/* General routines for the minimization of functions. All routines
   rely only on function evaluations; no derivatives are used. Based
   on code from _Numerical Recipes in C_, 2nd ed. */

#include <math.h>
#include <stdlib.h>
#include "supermodel.h"

/* -------------------------------------------------------------- */
/* Routine for initially bracketing a minimum (for a function of one
   variable). See NR in C p. 400. */

#define GOLD   1.618034  /* Default ratio by which successive
			    intervals are magnified */
#define GLIMIT 100.0     /* Max magnification allowed for a parabolic
			    fit step */
#define TINY   TSIL_EPSILON  /* A small number */

/* Various NR utilities: */
#define SHFT(a,b,c,d) (a)=(b);(b)=(c);(c)=(d);

static TSIL_REAL maxarg1, maxarg2;
#define FMAX(a,b) (maxarg1=(a),maxarg2=(b),(maxarg1) > (maxarg2) ?\
(maxarg1) : (maxarg2))

#define SIGN(a,b) ((b) > 0.0 ? TSIL_FABS(a) : -TSIL_FABS(a))


void BracketMin (TSIL_REAL *ax, TSIL_REAL *bx, TSIL_REAL *cx, 
		 TSIL_REAL *fa, TSIL_REAL *fb, TSIL_REAL *fc, 
		 TSIL_REAL (*func)(TSIL_REAL))
{
  TSIL_REAL ulim, u, r, q, fu, dum;

  *fa = (*func)(*ax);
  *fb = (*func)(*bx);
  if (*fb > *fa) {
    SHFT(dum,*ax,*bx,dum) ;
    SHFT(dum,*fb,*fa,dum) ;
  }
  *cx = (*bx) + GOLD*(*bx - *ax);
  *fc = (*func)(*cx);
  while (*fb > *fc) {
    r = (*bx - *ax)*(*fb - *fc);
    q = (*bx - *cx)*(*fb - *fa);
    u = (*bx) - ((*bx - *cx)*q - (*bx - *ax)*r)/
      (2.0L*SIGN(FMAX(TSIL_FABS(q-r),TINY), q-r));
    ulim = (*bx) + GLIMIT*(*cx - *bx);

    if ((*bx - u)*(u - *cx) > 0.0) {
      fu = (*func)(u);
      if (fu < *fc) {
	*ax = *bx;
	*bx = u;
	*fa = *fb;
	*fb = fu;
	return;
      }
      else if (fu > *fb) {
	*cx = u;
	*fc = fu;
	return;
      }
      u = (*cx) + GOLD*(*cx - *bx);
      fu = (*func)(u);
    }
    else if ((*cx - u)*(u - ulim) > 0.0) {
      fu = (*func)(u);
      if (fu < *fc) {
	SHFT(*bx,*cx,u,*cx + GOLD*(*cx - *bx)) ;
	SHFT(*fb,*fc,fu,(*func)(u)) ;
      }
    }
    else if ((u-ulim)*(ulim-*cx) >= 0.0) {
      u = ulim;
      fu = (*func)(u);
    }
    else {
      u = *cx + GOLD*(*cx - *bx);
      fu = (*func)(u);
    }
    SHFT(*ax,*bx,*cx,u) ;
    SHFT(*fa,*fb,*fc,fu) ;
  }
}

/* -------------------------------------------------------------- */
/* Implements Brent's method in one dimension. (ax,bx,cx) are a
   triplet of points known to bracket the minimum (generated by the
   above, e.g.). The routine locates the minimum to a fractional
   precision of roughly tol, returning the location of the minimum in
   *xmin.  The function returns the value of f at the minimum. */

#define ITMAX 100
#define CGOLD 0.3819660
#define ZEPS  1.0e-10

TSIL_REAL BrentMin (TSIL_REAL ax,
		    TSIL_REAL bx,
		    TSIL_REAL cx,
		    TSIL_REAL (*f)(TSIL_REAL),
		    TSIL_REAL tol,
		    TSIL_REAL *xmin)
{
  int iter;
  TSIL_REAL a,b,d,etemp,fu,fv,fw,fx,p,q,r,tol1,tol2,u,v,w,x,xm;
  TSIL_REAL e = 0.0;

  a = (ax < cx ? ax : cx);
  b = (ax > cx ? ax : cx);

  x = w = v = bx;
  fw = fv = fx = (*f)(x);
  for (iter=1; iter<=ITMAX; iter++) {
    xm = 0.5L*(a + b);
    tol2 = 2.0L*(tol1 = tol*TSIL_FABS(x) + ZEPS);
    if (TSIL_FABS(x - xm) <= (tol2 - 0.5*(b-a))) {
      *xmin = x;
/*       printf("Brent: %d evaluations\n", iter); */
      return fx;
    }
    if (TSIL_FABS(e) > tol1) {
      r = (x - w)*(fx - fv);
      q = (x - v)*(fx - fw);
      p = (x - v)*q - (x - w)*r;
      q = 2.0L*(q - r);
      if (q > 0.0) p = -p;
      q = TSIL_FABS(q);
      etemp = e;
      e = d;
      if (TSIL_FABS(p) >= TSIL_FABS(0.5L*q*etemp) ||
	  p <= q*(a - x) ||
	  p >= q*(b - x))
	d = CGOLD*(e = (x >= xm ? a-x : b-x));
      else {
	d = p/q;
	u = x + d;
	if (u-a < tol2 || b-u < tol2)
	  d = SIGN(tol1, xm-x);
      }
    }
    else {
      d = CGOLD*(e = (x >= xm ? a-x: b-x));
    }
    u = (TSIL_FABS(d) >= tol1 ? x+d : x + SIGN(tol1,d));
    fu = (*f)(u);
    if (fu <= fx) {
      if (u >= x) a = x; else b = x;
      SHFT(v,w,x,u) ;
      SHFT(fv,fw,fx,fu) ;
    }
    else {
      if (u < x) a = u; else b = u;
      if (fu <= fw || w == x) {
	v = w;
	w = u;
	fv = fw;
	fw = fu;
      }
      else if (fu <= fv || v == x || v == w) {
	v = u;
	fv = fu;
      }
    }
  }
  TSIL_Error ("Brent", "Too many iterations", 42);
  *xmin = x;
  return fx;
}

/* -------------------------------------------------------------- */
/* Used by the simplex routine below. Steps by a factor fac through
   the face of the simplex across from the high point, tries it, and
   replaces the high point if the new point is better. */

TSIL_REAL SimplexTry (TSIL_REAL **p,
		      TSIL_REAL y[],
		      TSIL_REAL psum[],
		      int ndim,
		      TSIL_REAL (*func)(TSIL_REAL []),
		      int ihi,
		      TSIL_REAL fac)
{
  int j;
  TSIL_REAL fac1, fac2, ytry, *ptry;

  ptry = (TSIL_REAL *) calloc (ndim, sizeof(TSIL_REAL));

  fac1 = (1.0L - fac)/ndim;
  fac2 = fac1 - fac;

  for (j=0; j<ndim; j++)
    ptry[j] = psum[j]*fac1 - p[ihi][j]*fac2;

  ytry = (*func)(ptry);

  if (ytry < y[ihi]) {
    y[ihi] = ytry;
    for (j=0; j<ndim; j++) {
      psum[j] += ptry[j] - p[ihi][j];
      p[ihi][j] = ptry[j];      
    }
  }
  free (ptry);

  return ytry;
}

/* -------------------------------------------------------------- */
/* Implements the downhill simplex method for multidimensional
   minimization.  Not very efficient but perhaps worth testing. */

#define MAXEVALS 10000
#define GET_PSUM for (j=0;j<ndim;j++) {\
                   for (sum=0.0,i=0; i<mpts; i++) \
                     sum += p[i][j]; psum[j] = sum;}

#define SWAP(a,b) {swap=(a);(a)=(b);(b)=swap;}

void SimplexMin (TSIL_REAL **p,
		 TSIL_REAL y[],
		 int       ndim,
		 TSIL_REAL ftol,
		 TSIL_REAL (*func)(TSIL_REAL []),
		 int       *nfunc)
{
  int i, ihi, ilo, inhi, j, mpts = ndim + 1;
  TSIL_REAL rtol, sum, swap, ysave, ytry, *psum;

  psum = (TSIL_REAL *) calloc (ndim, sizeof(TSIL_REAL));
  *nfunc = 0;

  GET_PSUM ;

  for (;;) {
    ilo = 0;
    ihi = y[1]>y[2] ? (inhi=2,1) : (inhi=1,2);

    for (i=0; i<mpts; i++) {
      if (y[i] <= y[ilo]) ilo = i;
      if (y[i] > y[ihi]) {
	inhi = ihi;
	ihi = i;
      }
      else if (y[i] > y[inhi] && i != ihi) inhi = i;
    }
    rtol = 2.0L*TSIL_FABS(y[ihi]-y[ilo])/
      (TSIL_FABS(y[ihi]) + TSIL_FABS(y[ilo]) + TINY);

    if (rtol < ftol) {
      SWAP(y[1],y[ilo]) ;
      for (i=0; i<ndim; i++) 
	SWAP(p[1][i],p[ilo][i]) ;
      break;
    }
    if (*nfunc >= MAXEVALS)
      TSIL_Error ("simplexMin", "MAXEVALS exceeded", 42);
    *nfunc += 2;

    ytry = SimplexTry (p,y,psum,ndim,func,ihi,-1.0L);
    
    if (ytry <= y[ilo])
      ytry = SimplexTry (p,y,psum,ndim,func,ihi,2.0L);

    else if (ytry >= y[inhi]) {
      ysave = y[ihi];
      ytry = SimplexTry (p,y,psum,ndim,func,ihi,0.5L);
      if (ytry >= ysave) {
	for (i=0; i<mpts; i++) {
	  if (i != ilo) {
	    for (j=0; j<ndim; j++)
	      p[i][j] = psum[j]=0.5L*(p[i][j] + p[ilo][j]);
	    y[i] = (*func)(psum);
	  }
	}
	*nfunc += ndim;
	GET_PSUM ;
      }
    }
    else --(*nfunc);
  }
  free (psum);

  return;
}

/* -------------------------------------------------------------- */
/* Utility used in Powell's method routine below. */

int ncom;
TSIL_REAL *pcom, *xicom, (*nrfunc)(TSIL_REAL []);

TSIL_REAL f1dim (TSIL_REAL x)
{
  int j;
  TSIL_REAL f, *xt;

  xt = (TSIL_REAL *) calloc (ncom, sizeof(TSIL_REAL));
  for (j=0; j<ncom; j++)
    xt[j] = pcom[j] + x*xicom[j];
  f = (*nrfunc)(xt);
  free (xt);
  return f;
}

/* -------------------------------------------------------------- */
/* Utility used in Powell's method routine below. */

#define LINMINTOL 1.0e-6

void linmin (TSIL_REAL p[],
	     TSIL_REAL xi[],
	     int n,
	     TSIL_REAL *fret,
	     TSIL_REAL (*func)(TSIL_REAL []))
{
  TSIL_REAL ax, bx, cx, tol, xmin;
  TSIL_REAL x, xx, fx;
  TSIL_REAL fa, fb, fc;
  int j;

  ncom = n;
  pcom = (TSIL_REAL *) calloc (n, sizeof(TSIL_REAL));
  xicom = (TSIL_REAL *) calloc (n, sizeof(TSIL_REAL));
  nrfunc = func;

  for (j=0; j<n; j++) {
    pcom[j] = p[j];
    xicom[j] = xi[j];
  }
  ax = 0.0;
  xx = 1.0;
  BracketMin (&ax, &xx, &bx, &fa, &fx, &fb, f1dim);
  *fret = BrentMin (ax, xx, bx, f1dim, LINMINTOL, &xmin);

  for (j=0; j<n; j++) {
    xi[j] *= xmin;
    p[j] += xi[j];
  }
  free (xicom);
  free (pcom);
}

/* -------------------------------------------------------------- */
/* Implements a variant of Powell's method for multidimensional
   function minimization. */

void PowellMin (TSIL_REAL p[],
		TSIL_REAL **xi,
		int n,
		TSIL_REAL ftol,
		int *iter,
		TSIL_REAL *fret,
		TSIL_REAL (*func)(TSIL_REAL []))
{
  int i, ibig, j;
  TSIL_REAL del, fp, fptt, t, *pt, *ptt, *xit;

  pt  = (TSIL_REAL *) calloc (n, sizeof(TSIL_REAL));
  ptt = (TSIL_REAL *) calloc (n, sizeof(TSIL_REAL));
  xit = (TSIL_REAL *) calloc (n, sizeof(TSIL_REAL));

  *fret = (*func)(p);
/*   printf("Initial fret = %Lf\n", *fret); */

  for (j=0; j<n; j++) pt[j] = p[j];

  for (*iter=1; ; ++(*iter)) {

    fp = *fret;
    ibig = 0;
    del = 0.0;
    for (i=0; i<n; i++) {
      for (j=0; j<n; j++) xit[j] = xi[j][i];
      fptt = *fret;
      linmin (p, xit, n, fret, func);
      if (fptt - *fret > del) {
	del = fptt - *fret;
	ibig = i;
      }
    }
    if (2.0L*(fp-(*fret)) <= ftol*(TSIL_FABS(fp)+TSIL_FABS(*fret))+TINY) {

/*       printf("Powell exiting...\n"); */
/*       printf("fp   = %Lf\n", fp); */
/*       printf("fret = %Lf\n", *fret); */

      free (xit);
      free (ptt);
      free (pt);
      return;
    }
    if (*iter == ITMAX)
      TSIL_Error ("PowellMin", "Max iterations exceeded", 42);

    for (j=0; j<n; j++) {
      ptt[j] = 2.0L*p[j] - pt[j];
      xit[j] = p[j] - pt[j];
      pt[j] = p[j];
    }
    fptt = (*func)(ptt);
    if (fptt < fp) {
      t = 2.0L*(fp - 2.0L*(*fret) + fptt)*TSIL_POW(fp - (*fret) - del, 2)
	- del*TSIL_POW(fp - fptt, 2);
      if (t < 0.0) {
	linmin (p, xit, n, fret, func);
	for (j=0; j<n; j++) {
	  xi[j][ibig] = xi[j][n-1];
	  xi[j][n-1] = xit[j];
	}
      }
    }
  }
}
