/** \file decays.cpp
   Project:     SOFTSUSY 
   Author:      Tom Cridge, Ben Allanach
   Manual:      hep-ph/0104145, Comp. Phys. Comm. 143 (2002) 305 
   Webpage:     http://hepforge.cedar.ac.uk/softsusy/

*/

#include "decays.h"
#include <iostream>
#include <cstring>
#include <stdlib.h>
#include <iomanip>
#include "main.h"
#include <complex>

using namespace std;

static double m1 = 0.,m2 = 0.,m3 = 0.,m4 = 0.,mq = 0.,m5 = 0.,m6 = 0., m7 = 0., m8 = 0., MZboson = 0., MWboson = 0., mh = 0., mH = 0., mA = 0., mphi = 0., g1 = 0., g2 = 0., alphamix = 0., betavac = 0.;
const int NeutMIXdim = 4;
static int neutralinoj = 0, neutralinoi = 0, AorhorH = 0;
static double accuracy = 0.01; ///Accuracy of numerical integration in 1->3 decays
static DoubleMatrix NeutMIX(NeutMIXdim,NeutMIXdim);


void calculateDecays(MssmSoftsusy * r) {
  //  cout << "In calculateDecays\n";
  /// see physpars.h and see softsusy.h
  ///Output the parameter values we use in Calculating the Decays
  
  ///for now just input parameters here by hand to be the same as in Susyhit
  // sPhysical changeparams = r->displayPhys();
  // ///changeparams.thetaL = 1.868; ///In Susyhit sinthetaL is given by aldo(1,1) and costhetaL by aldo(1,2), thetaL is gammaL in Tata and Baer
  // ///changeparams.thetaR = 1.77134; ///In Susyhit sinthetaR is given by alup(1,1), costhetaR by alup(1,2), thetaR is gammaR in Tata and Baer
  // changeparams.thetat = 1.13055325E+00;
  // changeparams.thetab = 2.77677470E-01;
  // changeparams.thetatau = -0.142466326;
  // changeparams.mu (1,1) = 1.05681025E+03;
  // changeparams.mu(2,1) = 1.02049360E+03; ///used in neutralino to squark calculations
  // ///changeparams.mu(2,1) = 997.648781; ///used in squark to neutralino calculations
  // changeparams.mu(1,2) = 1.05681025E+03;
  // changeparams.mu(2,2) = 1.02049360E+03;
  // changeparams.mu(1,3) = 8.15247294E+02; /// note this actually means the (1,3) element of mu is now mstop1 (may have been mstopL usually)
  // changeparams.mu(2,3) = 1.02309773E+03; /// note this actually means the (2,3) element of mu is now mstop2 (may have been mstopR usually)
  // changeparams.md(1,1) = 1.05970803E+03;
  // changeparams.md(2,1) = 1.01697262E+03;
  // changeparams.md(1,2) = 1.05970803E+03;
  // changeparams.md(2,2) = 1.01697262E+03;
  // changeparams.md(1,3) = 9.80846728E+02; /// note this actually means the (1,3) element of md is now msbottom1 (may have been msbottomL usually) 
  // changeparams.md(2,3) = 1.01465391E+03; /// note this actually means the (2,3) element of md is now msbottom2 (may have been msbottomL usually) 
  // changeparams.me(1,1) = 3.56763851E+02;
  // changeparams.me(2,1) = 2.26215350E+02;
  // ///changeparams.me(2,1) = 300; /// For testing neutralino 1->3 decays make it heavier than neutralinos to prevent 1->2 decays
  // changeparams.me(1,2) = 3.56763851E+02;
  // changeparams.me(2,2) = 2.26215350E+02;
  // ///changeparams.me(2,2) = 300; /// For testing neutralino 1->3 decays make it heavier than neutralinos to prevent 1->2 decays
  // changeparams.me(1,3) = 2.19362290E+02;
  // ///changeparams.me(1,3) = 290; /// For testing neutralino 1->3 decays make it heavier than neutralinos to prevent 1->2 decays
  // changeparams.me(2,3) = 3.58037026E+02;
  // changeparams.msnu(1) = 3.48188038E+02;
  // changeparams.msnu(2) = 3.48188038E+02;
  // changeparams.msnu(3) = 3.47170852E+02;

  // changeparams.mGluino = 1.15321247E+03;
  // changeparams.mch(1) = 3.85438334E+02;
  // changeparams.mch(2) = 6.40872171E+02;
  // changeparams.mixNeut(1,1) = 9.95658918E-01; changeparams.mixNeut(1,2) = -1.77631384E-02; changeparams.mixNeut(1,3) = 8.42900351E-02; changeparams.mixNeut(1,4) = -3.52559324E-02;
  // changeparams.mixNeut(2,1) = 3.95225009E-02; changeparams.mixNeut(2,2) = 9.68100754E-01; changeparams.mixNeut(2,3) = -2.04706466E-01; changeparams.mixNeut(2,4) = 1.38975409E-01;
  // changeparams.mixNeut(3,1) = 3.36184277E-02; changeparams.mixNeut(3,2) = -4.84726235E-02; changeparams.mixNeut(3,3) = -7.03543887E-01; changeparams.mixNeut(3,4) = -7.08199270E-01;
  // changeparams.mixNeut(4,1) = 7.72728484E-02; changeparams.mixNeut(4,2) = -2.45185247E-01; changeparams.mixNeut(4,3) = -6.75289902E-01; changeparams.mixNeut(4,4) = 6.91300694E-01;  
    

  r->runto(r->displayMsusy());
  double e = r->displayGaugeCoupling(2) * r->calcSinthdrbar();
  double sinth = r->calcSinthdrbar(); ///Is sinthetaW
  double gs = r->displayGaugeCoupling(3);
  double gp= r->displayGaugeCoupling(1); 
  double g = r->displayGaugeCoupling(2);
  

  r->runto(r->displayMz());
  // double e = r->displayGaugeCoupling(2) * r->calcSinthdrbar();
  // double sinth = r->calcSinthdrbar(); ///Is sinthetaW
  // double gs = r->displayGaugeCoupling(3);
  // double gp= r->displayGaugeCoupling(1); 
  // double g = r->displayGaugeCoupling(2);
  //  cout << "g= " << g << " sinth= " << sinth << " e= " << e << endl;
  //  cout << "From Softsusy at Msusy: g= " << g << " gp= " << gp << endl;
  double alphas = pow(gs,2)/(4*PI);
  double tanthetaW = gp/g;

  ///double gaugecoupling1 = r->displayGaugeCoupling(1);
  ///double gaugecoupling2 = r->displayGaugeCoupling(2);
  ///double gaugecoupling3 = r->displayGaugeCoupling(3);
  ///cout << "gaugecoupling1 = " << gaugecoupling1 << " gaugecoupling2 = " << gaugecoupling2 << " gaugecoupling3 = "<< gaugecoupling3 << endl;

  double alphaEm = pow(e,2)/(4*PI);
  //  cout << "alphaEm= " << alphaEm << endl;
  r->runto(r->displayMsusy());

  ///Switch on or off 1->3 decays
  int onetothree = 1; ///0 means 1->3 decays are off, 1 means 1->3 decays are on.
  /// See accuracy above for accuracy of 1->3 numerical integrals evaluated

  double mGluino = r->displayPhys().mGluino; DoubleVector mneut(r->displayPhys().mneut); DoubleMatrix mUpSquark(r->displayPhys().mu);  double thetaH = r->displayPhys().thetaH; double thetaA0 = r->displayPhys().thetaA0;  DoubleVector mch(r->displayPhys().mch); DoubleVector mh0(r->displayPhys().mh0); DoubleVector mA0(r->displayPhys().mA0);  double mHpm = r->displayPhys().mHpm; DoubleVector msnu(r->displayPhys().msnu); DoubleMatrix mixNeut(r->displayPhys().mixNeut);
 double thetaL = r->displayPhys().thetaL; double thetaR = r->displayPhys().thetaR; double thetat = r->displayPhys().thetat; double thetab = r->displayPhys().thetab; double thetatau = r->displayPhys().thetatau;  double thetamu = r->displayPhys().thetamu; DoubleMatrix mu(r->displayPhys().mu); DoubleMatrix md(r->displayPhys().md); DoubleMatrix me(r->displayPhys().me); DoubleMatrix mixh0(r->displayPhys().mixh0); double mwSoftSusy = r->displayMwRun(); double mz = r->displayMzRun(); double polemw = r->displayMw();
 //  cout << "mwSoftSusy=" << mwSoftSusy << endl; ///mwSoftSusy is basically the running mass - use it as such after testing finished against susyhit

    
 double tanbeta = r->displayTanb();
 double beta = atan(tanbeta);
 double alpha =r->displayDrBarPars().thetaH;
  
 // cout << "alpha= " << alpha <<  endl;
 double thetaL2 = -thetaL + PI/2;
 double thetaR2 = -thetaR + PI/2;
 double runmw = mwSoftSusy;

 ///For SPheno-decays.cpp comparison8 I generated the following spectrum from SPheno for comparison, good for +ve chargino mass to +ve neutralino mass decays tests
 /// mh0(1) = 1.19315484E+02; mh0(2) = 2.50008898E+03; mA0(1) = 2.50000000E+03; mHpm = 2.50167358E+03; md(1,1) = 3.64140215E+03; md(2,1) = 3.64005402E+03; mu(1,1) = 3.64068782E+03; mu(2,1) = 3.64053312E+03;  md(1,2) = 3.64141970E+03; md(2,2) = 3.64003730E+03; mu(1,2) = 3.64069087E+03; mu(2,2) = 3.64053137E+03; md(1,3) = 2.52147047E+03; md(2,3) = 2.54817360E+03; mu(1,3) = 2.54080722E+03; mu(2,3) = 2.55762580E+03; me(1,1) = 2.50275305E+03; me(2,1) = 2.50012299E+03; msnu(1) = 2.50114240E+03; me(1,2) = 2.50285055E+03; me(2,2) = 2.50002765E+03; msnu(2) = 2.50114262E+03; me(1,3) = 2.49277211E+03; me(2,3) = 2.51026851E+03; msnu(3) = 2.50120537E+03; mGluino = 3.56740536E+02; mneut(1) = 2.33158827E+03; mneut(2) = 2.49409892E+03; mneut(3) = -2.50992058E+03; mneut(4) = 2.56079166E+03; mch(1) = 2.33239475E+03; mch(2) = 2.53005164E+03; alpha = -1.03618490E-01; beta = atan(9.65109965E+00);  thetat = 0.506439382; thetab = 1.055081728; thetatau = 0.856042152; mixNeut(1,1) = 5.64791921E-02; mixNeut(1,2) = -9.44618090E-01; mixNeut(1,3) = 2.35558325E-01; mixNeut(1,4) = -2.21402440E-01; mixNeut(2,1) = 7.10061772E-01; mixNeut(2,2) = 2.65545663E-01; mixNeut(2,3) = 4.62105332E-01; mixNeut(2,4) = -4.60170015E-01; mixNeut(3,1) = 5.59875489E-03; mixNeut(3,2) = -1.02069150E-02; mixNeut(3,3) = -7.06946824E-01; mixNeut(3,4) = -7.07170886E-01; mixNeut(4,1) = -7.01848299E-01; mixNeut(4,2) = 1.92556443E-01; mixNeut(4,3) = 4.80829623E-01; mixNeut(4,4) = -4.89013145E-01; thetaL2 = 1.900124617; thetaR2 = 1.879710652;

 /*  cout << "g = " << g << endl;
  cout << "gp = " << gp << endl;
  cout << "gs = " << gs << endl;
  cout << "mh0(1) = " << mh0(1) << endl;
  cout << "mh0(2 = " << mh0(2) << endl;
  cout << "mA0(1) = " << mA0(1) << endl;
  cout << "mHpm = " << mHpm << endl;
  cout << "md(1,1) = " << md(1,1) << endl;
  cout << "md(2,1) = " << md(2,1) << endl;
  cout << "mu(1,1) = " << mu(1,1) << endl;
  cout << "mu(2,1) = " << mu(2,1) << endl;
  cout << "md(1,2) = " << md(1,2) << endl;
  cout << "md(2,2) = " << md(2,2) << endl;
  cout << "mu(1,2) = " << mu(1,2) << endl;
  cout << "mu(2,2) = " << mu(2,2) << endl;
  cout << "md(1,3) = " << md(1,3) << endl;
  cout << "md(2,3) = " << md(2,3) << endl;
  cout << "mu(1,3) = " << mu(1,3) << endl;
  cout << "mu(2,3) = " << mu(2,3) << endl;
  cout << "me(1,1) = " << me(1,1) << endl;
  cout << "me(2,1) = " << me(2,1) << endl;
  cout << "msnu(1) = " << msnu(1) << endl;
  cout << "me(1,2) = " << me(1,2) << endl;
  cout << "me(2,2) = " << me(2,2) << endl;
  cout << "msnu(2) = " << msnu(2) << endl;
  cout << "me(1,3) = " << me(1,3) << endl;
  cout << "me(2,3) = " << me(2,3) << endl;
  cout << "msnu(3) = " << msnu(3) << endl;
  cout << "mGluino = " << mGluino << endl;
  cout << "mneut(1) = " << mneut(1) << endl;
  cout << "mneut(2) = " << mneut(2) << endl;
  cout << "mneut(3) = " << mneut(3) << endl;
  cout << "mneut(4) = " << mneut(4) << endl;
  cout << "mch(1) = " << mch(1) << endl;
  cout << "mch(2) = " << mch(2) << endl;
  cout << "alpha = " << alpha << endl;
  cout << "beta = " << atan(tanbeta) << endl;
  cout << "thetat = " << thetat << endl;
  cout << "thetab = " << thetab << endl;
  cout << "thetatau = " << thetatau << endl;
  cout << "mixNeut(1,1) = " << mixNeut(1,1) << endl;
  cout << "mixNeut(1,2) = " << mixNeut(1,2) << endl;
  cout << "mixNeut(1,3) = " << mixNeut(1,3) << endl;
  cout << "mixNeut(1,4) = " << mixNeut(1,4) << endl;
  cout << "mixNeut(2,1) = " << mixNeut(2,1) << endl;
  cout << "mixNeut(2,2) = " << mixNeut(2,2) << endl;
  cout << "mixNeut(2,3) = " << mixNeut(2,3) << endl;
  cout << "mixNeut(2,4) = " << mixNeut(2,4) << endl;
  cout << "mixNeut(3,1) = " << mixNeut(3,1) << endl;
  cout << "mixNeut(3,2) = " << mixNeut(3,2) << endl;
  cout << "mixNeut(3,3) = " << mixNeut(3,3) << endl;
  cout << "mixNeut(3,4) = " << mixNeut(3,4) << endl;
  cout << "mixNeut(4,1) = " << mixNeut(4,1) << endl;
  cout << "mixNeut(4,2) = " << mixNeut(4,2) << endl;
  cout << "mixNeut(4,3) = " << mixNeut(4,3) << endl;
  cout << "mixNeut(4,4) = " << mixNeut(4,4) << endl;
  cout << "thetaL2 = " << -thetaL + PI/2 << endl;
  cout << "thetaR2 = " << -thetaR + PI/2 << endl;
 */


  ///Must ensure the masses of the stop1, stop2, sbottom1, sbottom2, stau1, stau2 are hierarchical:
  if (me(1,3) > me(2,3)) {
    double metemp = me(1,3);
    me(1,3) = me(2,3);
    me(2,3) = metemp;
  }
  if (mu(1,3) > mu(2,3)) {
    double mutemp = mu(1,3);
    mu(1,3) = mu(2,3);
    mu(2,3) = mutemp;
  }
  if (md(1,3) > md(2,3)) { 
    double mdtemp = md(1,3);
    md(1,3) = md(2,3);
    md(2,3) = mdtemp;
  }

  ///BR Tolerance
  double BRTol = 1e-15; ///BRs less than this are not output

  ///gravitino stuff
  double mgravitino = r->displayGravitino();
  // mgravitino = 5.92500000e-08; ///Doesn't affect functions lsp(m,posi,posj) or nlsp(m,posi,posj) therefore these will read out the lsp and nlsp incorrectly with these, just use to test gravitino decay formulae.
  int gravonoff = 0; ///a gravitino switch, by default it's off (0), it's turned on (1) a few lines below if the gravitino is the LSP as then decays to it are important, if it's not the LSP decays to it are unimportant as they are Planck suppressed.
  double MPlreduced = 2.4e18;
  ///double MPlreduced = MPLANCK/pow(8*PI,0.5);
  /*  cout << "MPlreduced = " << MPlreduced << endl;
      cout << "mgravitino = " << mgravitino << endl;*/
  int posi = 0, posj = 0;
  double m = mgravitino;
  double LSP = r->lsp(m, posi, posj); 
  LSP = -1; ///Temporary set to gravitino
  if (LSP == -1) {
    //    cout << "LSP IS A GRAVITINO" << endl;
    gravonoff = 1;
  }
    if( LSP == 0) {
      //    cout << "LSP is neutralino" << endl;
    gravonoff = 0;
  }
  else if (LSP == 1) {
    //    cout << "LSP is up squark" << endl;
    gravonoff = 0;
  }
  else if (LSP == 2) {
    //    cout << "LSP is down squark" << endl;
    gravonoff = 0;
  }
  else if (LSP == 3) {
    //    cout << "LSP is slepton" << endl;
    gravonoff = 0;
  }
  else if (LSP == 4) {
    //    cout << "LSP is chargino" << endl;
    gravonoff = 0;
  }
  else if (LSP == 5) {
    //    cout << "LSP is sneutrino" << endl;
    gravonoff = 0;
  }
  else if (LSP == 6) {
    //    cout << "LSP is gluino" << endl;
    gravonoff = 0;
  }
    //  cout << "mgravitino = " << mgravitino << endl;
  int NLSP = 0; /// default position
  int neutNLSP = 1, upsquNLSP= 1, downsquNLSP = 1, slepNLSP = 1, chargNLSP = 1, snuNLSP = 1, gluNLSP = 1; ///Default position is 1 so all SUSY dedcays to LSP gravitino considered unless you only want the NLSP decays to gravitino decays, then if below section uncommentedit sets all but NLSP switch to 0.
  
  ///Using the nlsp function from softsusy.cpp, Returns a label which says which particle is NLSP, 0 means NLSP is neutralino, 1=up squark, 2=down squark, 3=sleptons, 4=charginos, 5=sneutrinos, 6=gluino. Uncomment this if you only want the NLSP decays to the LSP gravitino to be considered, note one potential issue with this is particles only slightly heavier than the NLSP may still have only the decay to the LSPgravitino available and this function doesn't take account of this. If this section below is commented all SUSY decays to the LSP gravitino are considered and then they are not output if there BRs are less than 10^-15
  NLSP = r->nlsp(m, posi, posj); 
  NLSP = 0; ///Temporarily set to neutralino
  //  cout << "NLSP = " << NLSP << endl;
  if( NLSP == 0) {
    //    cout << "NLSP is neutralino" << endl;
    upsquNLSP= 0, downsquNLSP = 0, slepNLSP = 0, chargNLSP = 0, snuNLSP = 0, gluNLSP = 0;
  }
  else if (NLSP == 1) {
    //    cout << "NLSP is up squark" << endl;
    neutNLSP = 0, downsquNLSP = 0, slepNLSP = 0, chargNLSP = 0, snuNLSP = 0, gluNLSP = 0;
  }
  else if (NLSP == 2) {
    //    cout << "NLSP is down squark" << endl;
    neutNLSP = 0, upsquNLSP= 0, slepNLSP = 0, chargNLSP = 0, snuNLSP = 0, gluNLSP = 0;
  }
  else if (NLSP == 3) {
    //    cout << "NLSP is slepton" << endl;
    neutNLSP = 0, upsquNLSP= 0, downsquNLSP = 0, chargNLSP = 0, snuNLSP = 0, gluNLSP = 0;
  }
  else if (NLSP == 4) {
    //    cout << "NLSP is chargino - WARNING chargino NLSP decays to gravitino LSP not included in program!" << endl;
    neutNLSP = 0, upsquNLSP= 0, downsquNLSP = 0, slepNLSP = 0, snuNLSP = 0, gluNLSP = 0;
  }
  else if (NLSP == 5) {
    //    cout << "NLSP is sneutrino" << endl;
    neutNLSP = 0, upsquNLSP= 0, downsquNLSP = 0, slepNLSP = 0, chargNLSP = 0, gluNLSP = 0;
  }
  else if (NLSP == 6) {
    //    cout << "NLSP is gluino" << endl;
    neutNLSP = 0, upsquNLSP= 0, downsquNLSP = 0, slepNLSP = 0, chargNLSP = 0, snuNLSP = 0;
  }
  else { neutNLSP = 1, upsquNLSP= 1, downsquNLSP = 1, slepNLSP = 1, chargNLSP = 1, snuNLSP = 1, gluNLSP = 1;} ///Default position is to consdier all SUSY particle decays to LSP gravitino
  
  


 
 ///double beta = atan(tanbeta);
 // double beta = 1.46782279E+00; /// to set same as in SUSYHIT 
 // double runmw = 78.5877965; /// running mass for couplings
 // double polemw = 80.4666096; /// pole mass
 // double mz = 91.187; /// Just to make same as SUSYHIT in 3rd gen. squark to Z boson decays, normally revert  to displayMzRun a few lines up

 // cout << "thetaL2 = " << thetaL2 << endl;
 // cout << "thetaR2 = " << thetaR2 << endl;
 // thetaL2 = 1.868081124; /// To match susyhit
 // thetaR2 = 1.771344582; /// To match susyhit

 
 
 
 
 ///cout << alpha << " " << ALPHAMZ << " " << alphas << " " << ALPHASMZ << " " << ALPHASMZ2 << endl;
  /* cout << "beta=" << beta << endl;
 cout << "mup=" << MUP << " mdown=" << MDOWN << endl;
 cout << "melectron=" << MELECTRON << " mmuon=" << MMUON << endl;
  */
 
  ///Use Softsusy to run gs to different scales - can be used for h,H,A decays to gg.
  ///MssmSoftsusy copy(*r);
  ///MssmSoftsusy* copyref = &copy;
  ///copyref->runto(r->displayPhys().mh0(1));
  ///double g3atmh0 = copyref->displayGaugeCoupling(3);
  ///copyref->runto(r->displayPhys().mh0(2));
  ///double g3atmH0 = copyref->displayGaugeCoupling(3);
  ///copyref->runto(r->displayPhys().mA0(1));
  ///double g3atmA0 = copyref->displayGaugeCoupling(3);
  ///copyref->runto(r->displayMsusy());
  ///double g3atMsusy = copyref->displayGaugeCoupling(3);
  ///cout << "At mh= " << mh0(1) << ", g3atmh0= " << g3atmh0 << endl;
  ///cout << "At mH= " << mh0(2) << ", g3atmH0= " << g3atmH0 << endl;
  ///cout << "At mA= " << mA0(1) << ", g3atmA0= " << g3atmA0 << endl;
  ///cout << "At Msusy" <<  ", g3atMSusy= " << g3atMsusy << endl;

  ///Instead of using Softsusy to run gs to different scales (time inefficient) use the one-loop renormalisation group equations for gs directly to run to different scales, this is accurate enough for our purposes here:
 double alphasrun (double mu, double mu0, double alphasmu0); ///See later function definition
 double alphasatmz = 1.18900000e-01; ///use this as it's specified as this in the input block SMINPUTS
 double alphasatmh = alphasrun(mh0(1), mz, alphasatmz); 
 double alphasatmH = alphasrun(mh0(2), mz, alphasatmz);
 double alphasatmA = alphasrun(mA0(1), mz, alphasatmz);
 /* cout << "alphasatmh= " << alphasatmh << endl;
 cout << "alphasatmH= " << alphasatmH << endl;
 cout << "alphasatmA= " << alphasatmA << endl;*/
 double g3atmh0 = pow(4*PI*alphasatmh,0.5);
 double g3atmH0 = pow(4*PI*alphasatmH,0.5);
 double g3atmA0 = pow(4*PI*alphasatmA,0.5);


 
 ///For SPheno-decays.cpp comparison8 I generated the following spectrum from SPheno for comparison, good for +ve chargino mass to +ve neutralino mass decays tests
 // g = 6.33299172E-01; gp = 3.60876830E-01; gs = 1.06325656E+00; double alphasforsphcomp= pow(gs,2)/(4*PI); mh0(1) = 1.19315484E+02; mh0(2) = 2.50008898E+03; mA0(1) = 2.50000000E+03; mHpm = 2.50167358E+03; md(1,1) = 3.64140215E+03; md(2,1) = 3.64005402E+03; mu(1,1) = 3.64068782E+03; mu(2,1) = 3.64053312E+03;  md(1,2) = 3.64141970E+03; md(2,2) = 3.64003730E+03; mu(1,2) = 3.64069087E+03; mu(2,2) = 3.64053137E+03; md(1,3) = 2.52147047E+03; md(2,3) = 2.54817360E+03; mu(1,3) = 2.54080722E+03; mu(2,3) = 2.55762580E+03; me(1,1) = 2.50275305E+03; me(2,1) = 2.50012299E+03; msnu(1) = 2.50114240E+03; me(1,2) = 2.50285055E+03; me(2,2) = 2.50002765E+03; msnu(2) = 2.50114262E+03; me(1,3) = 2.49277211E+03; me(2,3) = 2.51026851E+03; msnu(3) = 2.50120537E+03; mGluino = 3.56740536E+02; mneut(1) = 2.33158827E+03; mneut(2) = 2.49409892E+03; mneut(3) = -2.50992058E+03; mneut(4) = 2.56079166E+03; mch(1) = 2.33239475E+03; mch(2) = 2.53005164E+03; alpha = -1.03618490E-01; beta = atan(9.65109965E+00);  thetat = 0.506439382; thetab = 1.055081728; thetatau = 0.856042152; mixNeut(1,1) = 5.64791921E-02; mixNeut(1,2) = -9.44618090E-01; mixNeut(1,3) = 2.35558325E-01; mixNeut(1,4) = -2.21402440E-01; mixNeut(2,1) = 7.10061772E-01; mixNeut(2,2) = 2.65545663E-01; mixNeut(2,3) = 4.62105332E-01; mixNeut(2,4) = -4.60170015E-01; mixNeut(3,1) = 5.59875489E-03; mixNeut(3,2) = -1.02069150E-02; mixNeut(3,3) = -7.06946824E-01; mixNeut(3,4) = -7.07170886E-01; mixNeut(4,1) = -7.01848299E-01; mixNeut(4,2) = 1.92556443E-01; mixNeut(4,3) = 4.80829623E-01; mixNeut(4,4) = -4.89013145E-01; thetaL2 = 1.900124617; thetaR2 = 1.879710652;




 

 
 ///Let's output the various values being used to help with debugging
 /* cout << "mg=" << mGluino << endl; cout << "mneut=" << mneut << endl;  cout << "mu=" << mUpSquark << endl;  cout << "thetaH="<< thetaH << endl;  cout << "thetaA0="<< thetaA0 << endl;  cout << "mch=" << mch << endl;
 /// DoubleVector mneut(r->displayPhys().mneut);
 cout << "mneut=" << mneut << endl;  cout << "mh0=" << mh0 << endl;  cout << "mA0=" << mA0 << endl;  cout << "mHpm=" << mHpm << endl;  cout << "msnu=" << msnu << endl;  cout << "mixNeut=" << mixNeut << endl;  cout << "thetaL=" << thetaL << endl;  cout << "thetaR=" << thetaR << endl;  cout << "thetat=" << thetat << endl;  cout << "thetab=" << thetab << endl;  cout << "thetatau=" << thetatau << endl;  cout << "thetamu=" << thetamu << endl;  cout << "mu=" << mu << endl;  cout << "md=" << md << endl;  cout << "me=" << me << endl;  cout << "mixh0=" << mixh0 << endl;  cout << "g=" << g << endl; cout << "gp=" << gp << endl; cout << "gs=" << gs << endl; cout << "mz=" << mz << endl;  cout << "runmw=" << runmw << endl; cout << "polemw=" << polemw << endl;   cout << "msupL=" << mu(1,1) << endl;  cout << "mup=" << MUP << endl;  cout << "MTOP=" << MTOP << " MBOTTOM=" << MBOTTOM << " MTAU= " << MTAU <<  endl; cout << "thetaL2= " << thetaL2 << endl; cout << "thetaR2= " << thetaR2 << endl;
 */
   
 ///Let's try to get the top and bottom running masses as these are used in SUSYHIT
  r->calcDrBarPars();
  double runmb = r->displayDrBarPars().mb;
  double runmt = r->displayDrBarPars().mt;
  double runmtau = r->displayDrBarPars().mtau;
 
  //  cout << "runmb = " << runmb << " runmt = " << runmt << " runmtau = " << runmtau << endl;
  
  double runmc = pow(2,0.5)*polemw*sin(beta)*r->displayYukawaMatrix(YU)(2,2)/g;
  double runms = pow(2,0.5)*polemw*cos(beta)*r->displayYukawaMatrix(YD)(2,2)/g;
  //  cout << "runmc = " << runmc << " runms = " << runms << endl; ///Useful in the 1->3 neuti -> neutj c/s cbar/sbar decays
  double runmd = pow(2,0.5)*polemw*cos(beta)*r->displayYukawaMatrix(YD)(1,1)/g;
  double runmu = pow(2,0.5)*polemw*sin(beta)*r->displayYukawaMatrix(YU)(1,1)/g;
  //  cout << "runmu = " << runmu << " runmd = " << runmd << endl;  ///Useful in the 1->3 neuti -> neutj u/d ubar/dbar decays
  
  ///Need trilinear couplings, these are in softpars.h
  ///DoubleMatrix aU, aD, aE; // as in softpars.h
  ///DoubleMatrix aU(r->displayPhys().aU); //DoubleMatrix & displayTrilinear(trilinears);
  
  double At = r->displaySoftA(UA, 3, 3), Ab = r->displaySoftA(DA, 3, 3), Atau = r->displaySoftA(EA, 3, 3), greekmu = r->displaySusyMu();
  double Au = r->displaySoftA(UA, 1, 1), Ad = r->displaySoftA(DA, 1, 1), Ac = r->displaySoftA(UA, 2, 2), As = r->displaySoftA(DA, 2, 2), Ae = r->displaySoftA(EA, 1, 1), Amu = r->displaySoftA(EA, 2, 2);

 
  ///double Au = 0, Ad = 0, Ac = 0, As = 0, Ae = 0; ///these are the values susyhit assumes I think!!!!!!!! CHECK THIS!
  /*  cout << " Au = " << Au << " Ad = " << Ad << " Ac = " << Ac << " As = " << As << " Ae = " << Ae <<  endl;
  cout << " At = " << At << " Ab= " << Ab << " Atau= " << Atau << " greekmu= " << greekmu << endl;

  cout << "mu=" << MUP << " md=" << MDOWN << " mc=" << MCHARM << " ms=" << MSTRANGE << " mt=" << MTOP << " mb=" << MBOTTOM << endl;
  cout << "msupL=" << mu(1,1) << " msupR=" <<mu(2,1) << " msdownL=" << md(1,1) << " msdownR=" << md(2,1) << endl;
  cout <<" mscharmL=" << mu(1,2) << " mscharmR=" << mu(2,2) << " mstrangeL=" << md(1,2) << " mstrangeR=" << md(2,2) << endl;
  cout << "mstop1=" << mu(1,3) << " mstop2=" <<mu(2,3) << " msbottom1=" << md(1,3) << " msbottom2=" << md(2,3) << endl;
  cout << "mGluino=" << mGluino << endl;
  cout << "GF= " << GMU << endl;
  */

  // r->calcDrBarPars();    ///calculates the DR bar couplings including rephased ones
  // r->displayDrBarPars().nBpmz; ///is the re-phased "N" matrix
  // r->displayDrBarPars().uBpmz; /// is rephased "U"
  // r->displayDrBarPars().vBpmz; ///- similarly for "V" (chargino mixing)
  // cout << "nBpmz = " << r->displayDrBarPars().nBpmz << endl;



 ///Obtaining the CKM Matrix from Yukawa Matrices:
 DoubleMatrix YUU(3,3), YDD(3,3), YEE(3,3);

 YUU = r->displayYukawaMatrix(YU); YDD = r->displayYukawaMatrix(YD); YEE = r->displayYukawaMatrix(YE);
 /* cout << "YUU= " << YUU << endl;
 cout << "YDD= " << YDD << endl;
 cout << "YEE= " << YEE << endl;*/

 DoubleMatrix u(3, 3), v(3, 3), vul(3,3), vur(3,3), vdl(3,3), vdr(3,3), vel(3,3), ver(3,3);
 DoubleVector ydDiag(3), yuDiag(3), yeDiag(3);
 r->displayYukawaMatrix(YU).diagonalise(u, v, yuDiag);
 vul = u.transpose(); vur = v.transpose();

 r->displayYukawaMatrix(YD).diagonalise(u, v, ydDiag);
 vdl = u.transpose(); vdr = v.transpose();

 r->displayYukawaMatrix(YE).diagonalise(u, v, yeDiag);
 vel = u.transpose(); ver = v.transpose();

 DoubleMatrix I3(3,3);
 for (int i=1; i<=3; i++) {
   for (int j=1; j<=3; j++) {
     if (i==j) {I3(i,j) = 1;}
     else {I3(i,j) = 0;}
   }
 }
 ///cout << "I3= " << I3 << endl;

 /* cout << "vul= " << vul << endl;
 cout << "vur= " << vur << endl;
 cout << "vdl= " << vdl << endl;
 cout << "vdr= " << vdr << endl;
 cout << "vel= " << vel << endl;
 cout << "ver= " << ver << endl;
 
 cout << "yuDiag= " << yuDiag << endl;
 cout << "ydDiag= " << ydDiag << endl;
 cout << "yeDiag= " << yeDiag << endl;
 */
 ///Form hermitian conjugate of vdl - only need to transpose as must be real as taken Yukawa matrices as real:
 DoubleMatrix vdlT = vdl.transpose();
 

 DoubleMatrix VCKM = vul*vdlT;

 /* cout << "CKM Matrix formed from the Yukawa matrices: " << endl;
    cout << VCKM << endl;*/

 DoubleMatrix Vu(3,3), Uu(3,3), yu(3,3), Vd(3,3), Ud(3,3), yd(3,3), Ve(3,3), Ue(3,3), ye(3,3);

 // r->displayYukawaMatrix(YU).diagonalise(Vu, Uu, yu);
 // cout << "Vu = " << Vu << endl;
 // cout << "Uu = " << Uu << endl;
 // cout << "yu = " << yu << endl;

 ///const ComplexMatrix FlavourMssmSoftsusy::displayComplexCkm() const {
 /// double d   = displayDelta();
 /// Complex eID(cos(d), sin(d));
 /// double s12 = sin(displayTheta12());
 /// double s13 = sin(displayTheta13());
 /// double s23 = sin(displayTheta23());
  
 /// double c12 = cos(displayTheta12());
 /// double c13 = cos(displayTheta13());
 /// double c23 = cos(displayTheta23());

 ///  ComplexMatrix ckmMatrix(3, 3);
 /// ckmMatrix(1, 1) = c12 * c13;      
 /// ckmMatrix(1, 2) = s12 * c13; 
 /// ckmMatrix(1, 3) = (s13 / eID);            
 /// ckmMatrix(2, 1) = (-s12 * c23 - c12 * s23 * s13 * eID);
 /// ckmMatrix(2, 2) = (c12 * c23 - s12 * s23 * s13 * eID);
 /// ckmMatrix(2, 3) = s23 * c13; 
 /// ckmMatrix(3, 1) = (s12 * s23 - c12 * c23 * s13 * eID); 
 /// ckmMatrix(3, 2) = (-c12 * s23 - s12 * c23 * s13 * eID); 
 /// ckmMatrix(3, 3) = c23 * c13; 

 /// return ckmMatrix;
 ///}

 /// Yukawas for cf with Yukawa matrices extracted (note in functions later I recalculate these and usually use runmw and for bottom and top will also usually use runmb and runmt
 // double mstrangeSpheno = 0.095; /// Use temporarily for neuti -> neutj f fbar decay
 double fu = g*MUP/(pow(2,0.5)*polemw*sin(beta));
 double fd = g*MDOWN/(pow(2,0.5)*polemw*cos(beta));
 double fc = g*MCHARM/(pow(2,0.5)*polemw*sin(beta));
 double fs = g*MSTRANGE/(pow(2,0.5)*polemw*cos(beta));
 
 double ft = g*runmt/(pow(2,0.5)*polemw*sin(beta));
 double fb = g*runmb/(pow(2,0.5)*polemw*cos(beta));
 double fe = g*MELECTRON/(pow(2,0.5)*polemw*cos(beta));
 double fmu = g*MMUON/(pow(2,0.5)*polemw*cos(beta));
 double ftau = g*MTAU/(pow(2,0.5)*polemw*cos(beta));
 /* cout << "fu= " << fu << "   fd= " << fd << "   fc= " << fc << "   fs= " << fs << "   ft= " << ft << endl;
 cout << "fb= " << fb << "   fe= " << fe << "   fmu= " << fmu << "   ftau= " << ftau << endl;
 */
  ///Define Particle PDG codes

  double PDGdown = 1, PDGup = 2, PDGstrange = 3, PDGcharm = 4, PDGbottom = 5, PDGtop = 6;
  double PDGelectron = 11, PDGnuelectron = 12, PDGmuon = 13, PDGnumuon = 14, PDGtau = 15, PDGnutau = 16, PDGgluon = 21, PDGphoton = 22, PDGZboson = 23, PDGWplus = 24, PDGh0 = 25, PDGH0 = 35, PDGA0 = 36, PDGHplus = 37;
  double PDGsdownL = 1000001, PDGsupL = 1000002, PDGsstrangeL = 1000003, PDGscharmL = 1000004, PDGsbottom1 = 1000005, PDGstop1 = 1000006;  double PDGselectronL = 1000011, PDGnuselectronL = 1000012, PDGsmuonL = 1000013, PDGnusmuonL = 1000014, PDGstau1 = 1000015, PDGnustauL = 1000016;
  double PDGgluino = 1000021, PDGneutralino1 = 1000022, PDGneutralino2 = 1000023, PDGchargino1 = 1000024, PDGneutralino3 = 1000025, PDGneutralino4 = 1000035, PDGchargino2 = 1000037;
  double PDGsdownR = 2000001, PDGsupR = 2000002, PDGsstrangeR = 2000003, PDGscharmR = 2000004, PDGsbottom2 = 2000005, PDGstop2 = 2000006;
  double PDGselectronR = 2000011, PDGsmuonR = 2000013, PDGstau2 = 2000015;
  /// double PDGnuselectronR = 2000012, PDGnusmuonR = 2000014, PDGnustauR = 2000016
  double PDGgravitino = 1000039;

  double MCH1=mch(1), MCH2=mch(2);

  

  /// Create object ParticleGluino of class Particle
  Particle ParticleGluino;
  ParticleGluino.name = "Gluino";
  ParticleGluino.PDG = PDGgluino;
  ParticleGluino.mass = mGluino;
  ParticleGluino.No_1to2_Decays = 24;
  ParticleGluino.No_1to3_Decays = 36;
  ParticleGluino.No_grav_Decays = 1;
  ParticleGluino.No_of_Decays = ParticleGluino.No_1to2_Decays + ParticleGluino.No_1to3_Decays + ParticleGluino.No_grav_Decays;
  ParticleGluino.Array_Decays.resize(ParticleGluino.No_of_Decays);
  for (int i = 0; i < ParticleGluino.No_of_Decays; i++)
    ParticleGluino.Array_Decays[i].resize(6); 
  ///for(int i=0; i<ParticleGluino.No_of_Decays; i++) {
  ///  for (int j =0; j<5; j++) {
  ///    ParticleGluino.Array_Decays[i][j] = 0.0;
  ///  }
  ///}
  ParticleGluino.Array_Comments.resize(ParticleGluino.No_of_Decays);
  ParticleGluino.total_width = 0.0; ///initialise to 0
  ParticleGluino.two_width = 0.0;
  ParticleGluino.three_width = 0.0;
  
  /// Create object ParticleSdownL
  Particle ParticleSdownL;
  ParticleSdownL.name = "SdownL";
  ParticleSdownL.PDG = PDGsdownL;
  ParticleSdownL.mass = md(1,1);
  ParticleSdownL.No_1to2_Decays = 7;
  ParticleSdownL.No_1to3_Decays = 0;
  ParticleSdownL.No_grav_Decays = 1;
  ParticleSdownL.No_of_Decays = ParticleSdownL.No_1to2_Decays + ParticleSdownL.No_1to3_Decays + ParticleSdownL.No_grav_Decays;
  ParticleSdownL.Array_Decays.resize(ParticleSdownL.No_of_Decays);
  for (int i = 0; i < ParticleSdownL.No_of_Decays; i++)
    ParticleSdownL.Array_Decays[i].resize(6); 
  ParticleSdownL.Array_Comments.resize(ParticleSdownL.No_of_Decays);
  ParticleSdownL.total_width = 0.0; ///initialise to 0
  ParticleSdownL.two_width = 0.0;
  ParticleSdownL.three_width = 0.0;
  
  ///Create object ParticleSdownR
  Particle ParticleSdownR;
  ParticleSdownR.name = "SdownR";
  ParticleSdownR.PDG = PDGsdownR;
  ParticleSdownR.mass = md(2,1);
  ParticleSdownR.No_1to2_Decays = 5;
  ParticleSdownR.No_1to3_Decays = 0;
  ParticleSdownR.No_grav_Decays = 1;
  ParticleSdownR.No_of_Decays = ParticleSdownR.No_1to2_Decays + ParticleSdownR.No_1to3_Decays + ParticleSdownR.No_grav_Decays;
  ParticleSdownR.Array_Decays.resize(ParticleSdownR.No_of_Decays);
  for (int i = 0; i < ParticleSdownR.No_of_Decays; i++)
    ParticleSdownR.Array_Decays[i].resize(6);
  ParticleSdownR.Array_Comments.resize(ParticleSdownR.No_of_Decays);
  ParticleSdownR.total_width = 0.0; ///initialise to 0
  ParticleSdownR.two_width = 0.0;
  ParticleSdownR.three_width = 0.0;

  ///Create object ParticleSupL
  Particle ParticleSupL;
  ParticleSupL.name = "SupL";
  ParticleSupL.PDG = PDGsupL;
  ParticleSupL.mass = mu(1,1);
  ParticleSupL.No_1to2_Decays = 7;
  ParticleSupL.No_1to3_Decays = 0;
  ParticleSupL.No_grav_Decays = 1;
  ParticleSupL.No_of_Decays = ParticleSupL.No_1to2_Decays + ParticleSupL.No_1to3_Decays + ParticleSupL.No_grav_Decays;
  ParticleSupL.Array_Decays.resize(ParticleSupL.No_of_Decays);
  for (int i = 0; i < ParticleSupL.No_of_Decays; i++)
    ParticleSupL.Array_Decays[i].resize(6);
  ParticleSupL.Array_Comments.resize(ParticleSupL.No_of_Decays);
  ParticleSupL.total_width = 0.0; ///initialise to 0
  ParticleSupL.two_width = 0.0;
  ParticleSupL.three_width = 0.0;

  ///Create object ParticleSupR
  Particle ParticleSupR;
  ParticleSupR.name = "SupR";
  ParticleSupR.PDG = PDGsupR;
  ParticleSupR.mass = mu(1,1);
  ParticleSupR.No_1to2_Decays = 5;
  ParticleSupR.No_1to3_Decays = 0;
  ParticleSupR.No_grav_Decays = 1;
  ParticleSupR.No_of_Decays = ParticleSupR.No_1to2_Decays + ParticleSupR.No_1to3_Decays + ParticleSupR.No_grav_Decays;
  ParticleSupR.Array_Decays.resize(ParticleSupR.No_of_Decays);
  for (int i = 0; i < ParticleSupR.No_of_Decays; i++)
    ParticleSupR.Array_Decays[i].resize(6);
  ParticleSupR.Array_Comments.resize(ParticleSupR.No_of_Decays);
  ParticleSupR.total_width = 0.0; ///initialise to 0
  ParticleSupR.two_width = 0.0;
  ParticleSupR.three_width = 0.0;

  ///Create object ParticleSstrangeL
  Particle ParticleSstrangeL;
  ParticleSstrangeL.name = "SstrangeL";
  ParticleSstrangeL.PDG = PDGsstrangeL;
  ParticleSstrangeL.mass = md(2,1);
  ParticleSstrangeL.No_1to2_Decays = 7;
  ParticleSstrangeL.No_1to3_Decays = 0;
  ParticleSstrangeL.No_grav_Decays = 1;
  ParticleSstrangeL.No_of_Decays = ParticleSstrangeL.No_1to2_Decays + ParticleSstrangeL.No_1to3_Decays + ParticleSstrangeL.No_grav_Decays;
  ParticleSstrangeL.Array_Decays.resize(ParticleSstrangeL.No_of_Decays);
  for (int i = 0; i < ParticleSstrangeL.No_of_Decays; i++)
    ParticleSstrangeL.Array_Decays[i].resize(6);
  ParticleSstrangeL.Array_Comments.resize(ParticleSstrangeL.No_of_Decays);
  ParticleSstrangeL.total_width = 0.0; //initialise to 0
  ParticleSstrangeL.two_width = 0.0;
  ParticleSstrangeL.three_width = 0.0;

  ///Create object ParticleSstrangeR
  Particle ParticleSstrangeR;
  ParticleSstrangeR.name = "SstrangeR";
  ParticleSstrangeR.PDG = PDGsstrangeR;
  ParticleSstrangeR.mass = md(2,2);
  ParticleSstrangeR.No_1to2_Decays = 5;
  ParticleSstrangeR.No_1to3_Decays = 0;
  ParticleSstrangeR.No_grav_Decays = 1;
  ParticleSstrangeR.No_of_Decays = ParticleSstrangeR.No_1to2_Decays + ParticleSstrangeR.No_1to3_Decays + ParticleSstrangeR.No_grav_Decays;
  ParticleSstrangeR.Array_Decays.resize(ParticleSstrangeR.No_of_Decays);
  for (int i = 0; i < ParticleSstrangeR.No_of_Decays; i++)
    ParticleSstrangeR.Array_Decays[i].resize(6); 
  ParticleSstrangeR.Array_Comments.resize(ParticleSstrangeR.No_of_Decays);
  ParticleSstrangeR.total_width = 0.0; //initialise to 0
  ParticleSstrangeR.two_width = 0.0;
  ParticleSstrangeR.three_width = 0.0;

  ///Create object ParticleScharmL
  Particle ParticleScharmL;
  ParticleScharmL.name = "ScharmL";
  ParticleScharmL.PDG = PDGscharmL;
  ParticleScharmL.mass = mu(1,2);
  ParticleScharmL.No_1to2_Decays = 7;
  ParticleScharmL.No_1to3_Decays = 0;
  ParticleScharmL.No_grav_Decays = 1;
  ParticleScharmL.No_of_Decays = ParticleScharmL.No_1to2_Decays + ParticleScharmL.No_1to3_Decays + ParticleScharmL.No_grav_Decays;
  ParticleScharmL.Array_Decays.resize(ParticleScharmL.No_of_Decays);
  for (int i = 0; i < ParticleScharmL.No_of_Decays; i++)
    ParticleScharmL.Array_Decays[i].resize(6);
  ParticleScharmL.Array_Comments.resize(ParticleScharmL.No_of_Decays);
  ParticleScharmL.total_width = 0.0; //initialise to 0
  ParticleScharmL.two_width = 0.0;
  ParticleScharmL.three_width = 0.0;

  ///Create object ParticleScharmR
  Particle ParticleScharmR;
  ParticleScharmR.name = "ScharmR";
  ParticleScharmR.PDG = PDGscharmR;
  ParticleScharmR.mass = mu(2,2);
  ParticleScharmR.No_1to2_Decays = 5;
  ParticleScharmR.No_1to3_Decays = 0;
  ParticleScharmR.No_grav_Decays = 1;
  ParticleScharmR.No_of_Decays = ParticleScharmR.No_1to2_Decays + ParticleScharmR.No_1to3_Decays + ParticleScharmR.No_grav_Decays;
  ParticleScharmR.Array_Decays.resize(ParticleScharmR.No_of_Decays);
  for (int i = 0; i < ParticleScharmR.No_of_Decays; i++)
    ParticleScharmR.Array_Decays[i].resize(6); 
  ParticleScharmR.Array_Comments.resize(ParticleScharmR.No_of_Decays);
  ParticleScharmR.total_width = 0.0; //initialise to 0
  ParticleScharmR.two_width = 0.0;
  ParticleScharmR.three_width = 0.0;

  ///Create object ParticleSbottom1
  Particle ParticleSbottom1;
  ParticleSbottom1.name = "Sbottom1";
  ParticleSbottom1.PDG = PDGsbottom1;
  ParticleSbottom1.mass = md(1,3);
  ParticleSbottom1.No_1to2_Decays = 11;
  ParticleSbottom1.No_1to3_Decays = 0;
  ParticleSbottom1.No_grav_Decays = 1;
  ParticleSbottom1.No_of_Decays = ParticleSbottom1.No_1to2_Decays + ParticleSbottom1.No_1to3_Decays + ParticleSbottom1.No_grav_Decays;
  ParticleSbottom1.Array_Decays.resize(ParticleSbottom1.No_of_Decays);
  for (int i = 0; i < ParticleSbottom1.No_of_Decays; i++)
    ParticleSbottom1.Array_Decays[i].resize(6);
  ParticleSbottom1.Array_Comments.resize(ParticleSbottom1.No_of_Decays);
  ParticleSbottom1.total_width = 0.0; //initialise to 0
  ParticleSbottom1.two_width = 0.0;
  ParticleSbottom1.three_width = 0.0;

  ///Create object ParticleSbottom2
  Particle ParticleSbottom2;
  ParticleSbottom2.name = "Sbottom2";
  ParticleSbottom2.PDG = PDGsbottom2;
  ParticleSbottom2.mass = md(2,3);
  ParticleSbottom2.No_1to2_Decays = 15;
  ParticleSbottom2.No_1to3_Decays = 0;
  ParticleSbottom2.No_grav_Decays = 1;
  ParticleSbottom2.No_of_Decays = ParticleSbottom2.No_1to2_Decays + ParticleSbottom2.No_1to3_Decays + ParticleSbottom2.No_grav_Decays;
  ParticleSbottom2.Array_Decays.resize(ParticleSbottom2.No_of_Decays);
  for (int i = 0; i < ParticleSbottom2.No_of_Decays; i++)
    ParticleSbottom2.Array_Decays[i].resize(6);
  ParticleSbottom2.Array_Comments.resize(ParticleSbottom2.No_of_Decays);
  ParticleSbottom2.total_width = 0.0; //initialise to 0
  ParticleSbottom2.two_width = 0.0;
  ParticleSbottom2.three_width = 0.0;

  ///Create object ParticleStop1
  Particle ParticleStop1;
  ParticleStop1.name = "Stop1";
  ParticleStop1.PDG = PDGstop1;
  ParticleStop1.mass = mu(1,3);
  ParticleStop1.No_1to2_Decays = 11;
  ParticleStop1.No_1to3_Decays = 0;
  ParticleStop1.No_grav_Decays = 1;
  ParticleStop1.No_of_Decays = ParticleStop1.No_1to2_Decays + ParticleStop1.No_1to3_Decays + ParticleStop1.No_grav_Decays;
  ParticleStop1.Array_Decays.resize(ParticleStop1.No_of_Decays);
  for (int i = 0; i < ParticleStop1.No_of_Decays; i++)
    ParticleStop1.Array_Decays[i].resize(6);
  ParticleStop1.Array_Comments.resize(ParticleStop1.No_of_Decays);
  ParticleStop1.total_width = 0.0; //initialise to 0
  ParticleStop1.two_width = 0.0;
  ParticleStop1.three_width = 0.0;

  ///Create object ParticleStop2
  Particle ParticleStop2;
  ParticleStop2.name = "Stop2";
  ParticleStop2.PDG = PDGstop2;
  ParticleStop2.mass = mu(2,3);
  ParticleStop2.No_1to2_Decays = 15;
  ParticleStop2.No_1to3_Decays = 0;
  ParticleStop2.No_grav_Decays = 1;
  ParticleStop2.No_of_Decays = ParticleStop2.No_1to2_Decays + ParticleStop2.No_1to3_Decays + ParticleStop2.No_grav_Decays;
  ParticleStop2.Array_Decays.resize(ParticleStop2.No_of_Decays);
  for (int i = 0; i < ParticleStop2.No_of_Decays; i++)
    ParticleStop2.Array_Decays[i].resize(6);
  ParticleStop2.Array_Comments.resize(ParticleStop2.No_of_Decays);
  ParticleStop2.total_width = 0.0; //initialise to 0
  ParticleStop2.two_width = 0.0;
  ParticleStop2.three_width = 0.0;

  ///Create object ParticleSelectonL
  Particle ParticleSelectronL;
  ParticleSelectronL.name = "SelectronL";
  ParticleSelectronL.PDG = PDGselectronL;
  ParticleSelectronL.mass = me(1,1);
  ParticleSelectronL.No_1to2_Decays = 6;
  ParticleSelectronL.No_1to3_Decays = 0;
  ParticleSelectronL.No_grav_Decays = 1;
  ParticleSelectronL.No_of_Decays = ParticleSelectronL.No_1to2_Decays + ParticleSelectronL.No_1to3_Decays + ParticleSelectronL.No_grav_Decays;
  ParticleSelectronL.Array_Decays.resize(ParticleSelectronL.No_of_Decays);
  for (int i = 0; i < ParticleSelectronL.No_of_Decays; i++)
    ParticleSelectronL.Array_Decays[i].resize(6);
  ParticleSelectronL.Array_Comments.resize(ParticleSelectronL.No_of_Decays);
  ParticleSelectronL.total_width = 0.0;
  ParticleSelectronL.two_width = 0.0;
  ParticleSelectronL.three_width = 0.0;

  ///Create object ParticleSelectronR
  Particle ParticleSelectronR;
  ParticleSelectronR.name = "SelectronR";
  ParticleSelectronR.PDG = PDGselectronR;
  ParticleSelectronR.mass = me(2,1);
  ParticleSelectronR.No_1to2_Decays = 4;
  ParticleSelectronR.No_1to3_Decays = 0;
  ParticleSelectronR.No_grav_Decays = 1;
  ParticleSelectronR.No_of_Decays = ParticleSelectronR.No_1to2_Decays + ParticleSelectronR.No_1to3_Decays + ParticleSelectronR.No_grav_Decays;
  ParticleSelectronR.Array_Decays.resize(ParticleSelectronR.No_of_Decays);
  for (int i = 0; i < ParticleSelectronR.No_of_Decays; i++)
    ParticleSelectronR.Array_Decays[i].resize(6);
  ParticleSelectronR.Array_Comments.resize(ParticleSelectronR.No_of_Decays);
  ParticleSelectronR.total_width = 0.0;
  ParticleSelectronR.two_width = 0.0;
  ParticleSelectronR.three_width = 0.0;

  ///Create object ParticleSmuonL
  Particle ParticleSmuonL;
  ParticleSmuonL.name = "SmuonL";
  ParticleSmuonL.PDG = PDGsmuonL;
  ParticleSmuonL.mass = me(1,2);
  ParticleSmuonL.No_1to2_Decays = 6;
  ParticleSmuonL.No_1to3_Decays = 0;
  ParticleSmuonL.No_grav_Decays = 1;
  ParticleSmuonL.No_of_Decays = ParticleSmuonL.No_1to2_Decays + ParticleSmuonL.No_1to3_Decays + ParticleSmuonL.No_grav_Decays;
  ParticleSmuonL.Array_Decays.resize(ParticleSmuonL.No_of_Decays);
  for (int i = 0; i < ParticleSmuonL.No_of_Decays; i++)
    ParticleSmuonL.Array_Decays[i].resize(6);
  ParticleSmuonL.Array_Comments.resize(ParticleSmuonL.No_of_Decays);
  ParticleSmuonL.total_width = 0.0;
  ParticleSmuonL.two_width = 0.0;
  ParticleSmuonL.three_width = 0.0;

  ///Create object ParticleSmuonR
  Particle ParticleSmuonR;
  ParticleSmuonR.name = "SmuonR";
  ParticleSmuonR.PDG = PDGsmuonR;
  ParticleSmuonR.mass = me(2,2);
  ParticleSmuonR.No_1to2_Decays = 4;
  ParticleSmuonR.No_1to3_Decays = 0;
  ParticleSmuonR.No_grav_Decays = 1;
  ParticleSmuonR.No_of_Decays = ParticleSmuonR.No_1to2_Decays + ParticleSmuonR.No_1to3_Decays + ParticleSmuonR.No_grav_Decays;
  ParticleSmuonR.Array_Decays.resize(ParticleSmuonR.No_of_Decays);
  for (int i = 0; i < ParticleSmuonR.No_of_Decays; i++)
    ParticleSmuonR.Array_Decays[i].resize(6);
  ParticleSmuonR.Array_Comments.resize(ParticleSmuonR.No_of_Decays);
  ParticleSmuonR.total_width = 0.0;
  ParticleSmuonR.two_width = 0.0;
  ParticleSmuonR.three_width = 0.0;

  ///Create object ParticleSnue
  Particle ParticleSnue;
  ParticleSnue.name = "Selectron sneutrino";
  ParticleSnue.PDG = PDGnuselectronL;
  ParticleSnue.mass = msnu(1);
  ParticleSnue.No_1to2_Decays = 6;
  ParticleSnue.No_1to3_Decays = 0;
  ParticleSnue.No_grav_Decays = 1;
  ParticleSnue.No_of_Decays = ParticleSnue.No_1to2_Decays + ParticleSnue.No_1to3_Decays + ParticleSnue.No_grav_Decays;
  ParticleSnue.Array_Decays.resize(ParticleSnue.No_of_Decays);
  for (int i = 0; i < ParticleSnue.No_of_Decays; i++)
    ParticleSnue.Array_Decays[i].resize(6);
  ParticleSnue.Array_Comments.resize(ParticleSnue.No_of_Decays);
  ParticleSnue.total_width = 0.0;
  ParticleSnue.two_width = 0.0;
  ParticleSnue.three_width = 0.0;

  ///Create object ParticleSnumu
  Particle ParticleSnumu;
  ParticleSnumu.name = "Smuon sneutrino";
  ParticleSnumu.PDG = PDGnusmuonL;
  ParticleSnumu.mass = msnu(2);
  ParticleSnumu.No_1to2_Decays = 6;
  ParticleSnumu.No_1to3_Decays = 0;
  ParticleSnumu.No_grav_Decays = 1;
  ParticleSnumu.No_of_Decays = ParticleSnumu.No_1to2_Decays + ParticleSnumu.No_1to3_Decays + ParticleSnumu.No_grav_Decays;
  ParticleSnumu.Array_Decays.resize(ParticleSnumu.No_of_Decays);
  for (int i = 0; i < ParticleSnumu.No_of_Decays; i++)
    ParticleSnumu.Array_Decays[i].resize(6);
  ParticleSnumu.Array_Comments.resize(ParticleSnumu.No_of_Decays);
  ParticleSnumu.total_width = 0.0;
  ParticleSnumu.two_width = 0.0;
  ParticleSnumu.three_width = 0.0;

  ///Create object ParticleStau1
  Particle ParticleStau1;
  ParticleStau1.name = "Stau1";
  ParticleStau1.PDG = PDGstau1;
  ParticleStau1.mass = me(1,3);
  ParticleStau1.No_1to2_Decays = 8;
  ParticleStau1.No_1to3_Decays = 0;
  ParticleStau1.No_grav_Decays = 1;
  ParticleStau1.No_of_Decays = ParticleStau1.No_1to2_Decays + ParticleStau1.No_1to3_Decays + ParticleStau1.No_grav_Decays;
  ParticleStau1.Array_Decays.resize(ParticleStau1.No_of_Decays);
  for (int i = 0; i < ParticleStau1.No_of_Decays; i++)
    ParticleStau1.Array_Decays[i].resize(6);
  ParticleStau1.Array_Comments.resize(ParticleStau1.No_of_Decays);
  ParticleStau1.total_width = 0.0;
  ParticleStau1.two_width = 0.0;
  ParticleStau1.three_width = 0.0;

  ///Create object ParticleStau2
  Particle ParticleStau2;
  ParticleStau2.name = "Stau2";
  ParticleStau2.PDG = PDGstau2;
  ParticleStau2.mass = me(2,3);
  ParticleStau2.No_1to2_Decays = 12;
  ParticleStau2.No_1to3_Decays = 0;
  ParticleStau2.No_grav_Decays = 1;
  ParticleStau2.No_of_Decays = ParticleStau2.No_1to2_Decays + ParticleStau2.No_1to3_Decays + ParticleStau2.No_grav_Decays;
  ParticleStau2.Array_Decays.resize(ParticleStau2.No_of_Decays);
  for (int i = 0; i < ParticleStau2.No_of_Decays; i++)
    ParticleStau2.Array_Decays[i].resize(6);
  ParticleStau2.Array_Comments.resize(ParticleStau2.No_of_Decays);
  ParticleStau2.total_width = 0.0;
  ParticleStau2.two_width = 0.0;
  ParticleStau2.three_width = 0.0;
  
  ///Create object ParticleSnutau
  Particle ParticleSnutau;
  ParticleSnutau.name = "Stau sneutrino";
  ParticleSnutau.PDG = PDGnustauL;
  ParticleSnutau.mass = msnu(3);
  ParticleSnutau.No_1to2_Decays = 10;
  ParticleSnutau.No_1to3_Decays = 0;
  ParticleSnutau.No_grav_Decays = 1;
  ParticleSnutau.No_of_Decays = ParticleSnutau.No_1to2_Decays + ParticleSnutau.No_1to3_Decays + ParticleSnutau.No_grav_Decays;
  ParticleSnutau.Array_Decays.resize(ParticleSnutau.No_of_Decays);
  for (int i = 0; i < ParticleSnutau.No_of_Decays; i++)
    ParticleSnutau.Array_Decays[i].resize(6);
  ParticleSnutau.Array_Comments.resize(ParticleSnutau.No_of_Decays);
  ParticleSnutau.total_width = 0.0;
  ParticleSnutau.two_width = 0.0;
  ParticleSnutau.three_width = 0.0;

  ///Create object ParticleChargino1
  Particle ParticleChargino1;
  ParticleChargino1.name = "Chargino 1+ (lightest)";
  ParticleChargino1.PDG = PDGchargino1;
  ParticleChargino1.mass = MCH1;
  ParticleChargino1.No_1to2_Decays = 23; ///We consider decays of the W1+, the W1- decays then just follow with the same amplitudes but often particles swapped for their anitparticles
  ParticleChargino1.No_1to3_Decays = 20;
  ParticleChargino1.No_grav_Decays = 0;
  ParticleChargino1.No_of_Decays = ParticleChargino1.No_1to2_Decays + ParticleChargino1.No_1to3_Decays + ParticleChargino1.No_grav_Decays; 
  ParticleChargino1.Array_Decays.resize(ParticleChargino1.No_of_Decays);
  for (int i = 0; i < ParticleChargino1.No_of_Decays; i++)
    ParticleChargino1.Array_Decays[i].resize(6);
  ParticleChargino1.Array_Comments.resize(ParticleChargino1.No_of_Decays);
  ParticleChargino1.total_width = 0.0;
  ParticleChargino1.two_width = 0.0;
  ParticleChargino1.three_width = 0.0;

  ///Create object ParticleChargino2
  Particle ParticleChargino2;
  ParticleChargino2.name = "Chargino 2+ (heaviest)";
  ParticleChargino2.PDG = PDGchargino2;
  ParticleChargino2.mass = MCH2;
  ParticleChargino2.No_1to2_Decays = 27; /// has 4 additional decays cf chargino 1 as chargino2 -> chargino1 + Z/h/H/A as well
  ParticleChargino2.No_1to3_Decays = 20;
  ParticleChargino2.No_grav_Decays = 0;
  ParticleChargino2.No_of_Decays = ParticleChargino2.No_1to2_Decays + ParticleChargino2.No_1to3_Decays + ParticleChargino2.No_grav_Decays;  
  ParticleChargino2.Array_Decays.resize(ParticleChargino2.No_of_Decays);
  for (int i = 0; i < ParticleChargino2.No_of_Decays; i++)
    ParticleChargino2.Array_Decays[i].resize(6);
  ParticleChargino2.Array_Comments.resize(ParticleChargino2.No_of_Decays);
  ParticleChargino2.total_width = 0.0;
  ParticleChargino2.two_width = 0.0;
  ParticleChargino2.three_width = 0.0;

  ///Create object ParticleNeutralino1
  Particle ParticleNeutralino1;
  ParticleNeutralino1.name = "Neutralino1";
  ParticleNeutralino1.PDG = PDGneutralino1;
  ParticleNeutralino1.mass = mneut(1);
  ParticleNeutralino1.No_1to2_Decays = 62;
  ParticleNeutralino1.No_1to3_Decays = 10;
  ParticleNeutralino1.No_grav_Decays = 5;
  ParticleNeutralino1.No_of_Decays = ParticleNeutralino1.No_1to2_Decays + ParticleNeutralino1.No_1to3_Decays + ParticleNeutralino1.No_grav_Decays;
  ParticleNeutralino1.Array_Decays.resize(ParticleNeutralino1.No_of_Decays);
  for (int i = 0; i < ParticleNeutralino1.No_of_Decays; i++)
    ParticleNeutralino1.Array_Decays[i].resize(6);
  ParticleNeutralino1.Array_Comments.resize(ParticleNeutralino1.No_of_Decays);
  ParticleNeutralino1.total_width = 0.0;
  ParticleNeutralino1.two_width = 0.0;
  ParticleNeutralino1.three_width = 0.0;

  ///Create object ParticleNeutralino2
  Particle ParticleNeutralino2;
  ParticleNeutralino2.name = "Neutralino2";
  ParticleNeutralino2.PDG = PDGneutralino2;
  ParticleNeutralino2.mass = mneut(2);
  ParticleNeutralino2.No_1to2_Decays = 62;
  ParticleNeutralino2.No_1to3_Decays = 12+10; ///12 neut -> neut f fbar decays + 10 neut -> char f fpbar decays
  ParticleNeutralino2.No_grav_Decays = 5;
  ParticleNeutralino2.No_of_Decays = ParticleNeutralino2.No_1to2_Decays + ParticleNeutralino2.No_1to3_Decays + ParticleNeutralino2.No_grav_Decays;
  ParticleNeutralino2.Array_Decays.resize(ParticleNeutralino2.No_of_Decays);
  ///for (int i = 0; i < ParticleNeutralino2.No_of_Decays; i++)
  ///  ParticleNeutralino2.Array_Decays[i].resize(5);
  for (int i = 0; i < ParticleNeutralino2.No_of_Decays; i++)
    ParticleNeutralino2.Array_Decays[i].resize(6); 
  ParticleNeutralino2.Array_Comments.resize(ParticleNeutralino2.No_of_Decays);
  ParticleNeutralino2.total_width = 0.0;
  ParticleNeutralino2.two_width = 0.0;
  ParticleNeutralino2.three_width = 0.0;

  ///Create object ParticleNeutralino3
  Particle ParticleNeutralino3;
  ParticleNeutralino3.name = "Neutralino3";
  ParticleNeutralino3.PDG = PDGneutralino3;
  ParticleNeutralino3.mass = mneut(3);
  ParticleNeutralino3.No_1to2_Decays = 62;
  ParticleNeutralino3.No_1to3_Decays = 24+10;
  ParticleNeutralino3.No_grav_Decays = 5;
  ParticleNeutralino3.No_of_Decays = ParticleNeutralino3.No_1to2_Decays + ParticleNeutralino3.No_1to3_Decays + ParticleNeutralino3.No_grav_Decays;
  ParticleNeutralino3.Array_Decays.resize(ParticleNeutralino3.No_of_Decays);
  ///for (int i = 0; i < ParticleNeutralino3.No_of_Decays; i++)
  ///  ParticleNeutralino3.Array_Decays[i].resize(5);
  for (int i = 0; i < ParticleNeutralino3.No_of_Decays; i++)
    ParticleNeutralino3.Array_Decays[i].resize(6);
  ParticleNeutralino3.Array_Comments.resize(ParticleNeutralino3.No_of_Decays);
  ParticleNeutralino3.total_width = 0.0;
  ParticleNeutralino3.two_width = 0.0;
  ParticleNeutralino3.three_width = 0.0;

  ///Create object ParticleNeutralino4
  Particle ParticleNeutralino4;
  ParticleNeutralino4.name = "Neutralino4";
  ParticleNeutralino4.PDG = PDGneutralino4;
  ParticleNeutralino4.mass = mneut(4);
  ParticleNeutralino4.No_1to2_Decays = 62;
  ParticleNeutralino4.No_1to3_Decays = 36+10;
  ParticleNeutralino4.No_grav_Decays = 5;
  ParticleNeutralino4.No_of_Decays = ParticleNeutralino4.No_1to2_Decays + ParticleNeutralino4.No_1to3_Decays + ParticleNeutralino4.No_grav_Decays;
  ParticleNeutralino4.Array_Decays.resize(ParticleNeutralino4.No_of_Decays);
  ///for (int i = 0; i < ParticleNeutralino4.No_of_Decays; i++)
  ///  ParticleNeutralino4.Array_Decays[i].resize(5);
  for (int i = 0; i < ParticleNeutralino4.No_of_Decays; i++)
    ParticleNeutralino4.Array_Decays[i].resize(6);
  ParticleNeutralino4.Array_Comments.resize(ParticleNeutralino4.No_of_Decays);
  ParticleNeutralino4.total_width = 0.0;
  ParticleNeutralino4.two_width = 0.0;
  ParticleNeutralino4.three_width = 0.0;

  ///Create object Particlehiggsl
  Particle Particlehiggsl;
  Particlehiggsl.name = "light higgs";
  Particlehiggsl.PDG = PDGh0;
  Particlehiggsl.mass = mh0(1);
  Particlehiggsl.No_1to2_Decays = 66;
  Particlehiggsl.No_1to3_Decays = 2;
  Particlehiggsl.No_grav_Decays = 0;
  Particlehiggsl.No_of_Decays = Particlehiggsl.No_1to2_Decays + Particlehiggsl.No_1to3_Decays + Particlehiggsl.No_grav_Decays;
  Particlehiggsl.Array_Decays.resize(Particlehiggsl.No_of_Decays);
  for (int i = 0; i < Particlehiggsl.No_of_Decays; i++)
    Particlehiggsl.Array_Decays[i].resize(6);
  Particlehiggsl.Array_Comments.resize(Particlehiggsl.No_of_Decays);
  Particlehiggsl.total_width = 0.0;
  Particlehiggsl.two_width = 0.0;
  Particlehiggsl.three_width = 0.0;

  ///Create object ParticleHiggsH
  Particle ParticleHiggsH;
  ParticleHiggsH.name = "heavy higgs";
  ParticleHiggsH.PDG = PDGH0;
  ParticleHiggsH.mass = mh0(2);
  ParticleHiggsH.No_1to2_Decays = 66;
  ParticleHiggsH.No_1to3_Decays = 2;
  ParticleHiggsH.No_grav_Decays = 0;
  ParticleHiggsH.No_of_Decays = ParticleHiggsH.No_1to2_Decays + ParticleHiggsH.No_1to3_Decays + ParticleHiggsH.No_grav_Decays;
  ParticleHiggsH.Array_Decays.resize(ParticleHiggsH.No_of_Decays);
  for (int i = 0; i < ParticleHiggsH.No_of_Decays; i++)
    ParticleHiggsH.Array_Decays[i].resize(6);
  ParticleHiggsH.Array_Comments.resize(ParticleHiggsH.No_of_Decays);
  ParticleHiggsH.total_width = 0.0;
  ParticleHiggsH.two_width = 0.0;
  ParticleHiggsH.three_width = 0.0;

  ///Create object ParticleHiggsA
  Particle ParticleHiggsA;
  ParticleHiggsA.name = "pseudoscalar higgs";
  ParticleHiggsA.PDG = PDGA0;
  ParticleHiggsA.mass = mA0(1);
  ParticleHiggsA.No_1to2_Decays = 46;///Note A cannot decay into alike sfermion antisfermion paris because of CP conservation
  ParticleHiggsA.No_1to3_Decays = 0;
  ParticleHiggsA.No_grav_Decays = 0;
  ParticleHiggsA.No_of_Decays = ParticleHiggsA.No_1to2_Decays + ParticleHiggsA.No_1to3_Decays + ParticleHiggsA.No_grav_Decays;
  ParticleHiggsA.Array_Decays.resize(ParticleHiggsA.No_of_Decays);
  for (int i = 0; i < ParticleHiggsA.No_of_Decays; i++)
    ParticleHiggsA.Array_Decays[i].resize(6);
  ParticleHiggsA.Array_Comments.resize(ParticleHiggsA.No_of_Decays);
  ParticleHiggsA.total_width = 0.0;
  ParticleHiggsA.two_width = 0.0;
  ParticleHiggsA.three_width = 0.0;

  ///Create object ParticleHiggsplus
  Particle ParticleHiggsplus;
  ParticleHiggsplus.name = "Charged higgs+";
  ParticleHiggsplus.PDG = PDGHplus;
  ParticleHiggsplus.mass = mHpm;
  ParticleHiggsplus.No_1to2_Decays = 39;
  ParticleHiggsplus.No_1to3_Decays = 0;
  ParticleHiggsplus.No_grav_Decays = 0;
  ParticleHiggsplus.No_of_Decays = ParticleHiggsplus.No_1to2_Decays + ParticleHiggsplus.No_1to3_Decays + ParticleHiggsplus.No_grav_Decays;
  ParticleHiggsplus.Array_Decays.resize(ParticleHiggsplus.No_of_Decays);
  for (int i = 0; i < ParticleHiggsplus.No_of_Decays; i++)
    ParticleHiggsplus.Array_Decays[i].resize(6);
  ParticleHiggsplus.Array_Comments.resize(ParticleHiggsplus.No_of_Decays);
  ParticleHiggsplus.total_width = 0.0;
  ParticleHiggsplus.two_width = 0.0;
  ParticleHiggsplus.three_width = 0.0;
  
 
  ///Function Declarations
  double gluinoamplitudedecay (double m1, double m2, double m3, double alphastrong);
  double gluinoamplitudedecaymix (double m1, double m2, double m3, double alphastrong, double squarkmix, double theta);
  double squarkamplitudedecaygluino (double m1, double m2, double m3, double alphastrong);
  double squarkamplitudedecaygluinomix (double m1, double m2, double m3, double alphastrong, double squarkmix, double theta);
  double squarkamplitudedecaycharginoW1 (double m1, double m2, double m3, double g, double gamma);
  double squarkamplitudedecaycharginoW2 (double m1, double m2, double m3, double g, double gamma);
  double squark1amplitudedecaycharginoW1mix (double m1, double m2, double m3, double g, double gammaL, double gammaR,  double theta, double beta, double mWboson, double runmt, double runmb, double torb);
  double squark1amplitudedecaycharginoW2mix (double m1, double m2, double m3, double g, double gammaL, double gammaR,  double theta, double beta, double mWboson, double runmt, double runmb, double torb);
  double squark2amplitudedecaycharginoW1mix (double m1, double m2, double m3, double g, double gammaL, double gammaR,  double theta, double beta, double mWboson, double mup, double mdown, double torb);
  double squark2amplitudedecaycharginoW2mix (double m1, double m2, double m3, double g, double gammaL, double gammaR,  double theta, double beta, double mWboson, double mup, double mdown, double torb);
  double squarkLamplitudedecayneutralino (double m1, double m2, double m3, double g, double gprime,  DoubleMatrix mixNeut, int neutralino, int uord ); 
  double squarkRamplitudedecayneutralino (double m1, double m2, double m3, double g, double gprime, DoubleMatrix mixNeut, int neutralino, int uord );
  ///double squark1amplitudedecayneutralinomix (double m1, double m2, double m3, double g, double gprime, double theta, double beta, double mWboson, DoubleMatrix mixNeut, double runmt, double runmb, int neutralino, int uord);
  ///double squark2amplitudedecayneutralinomix (double m1, double m2, double m3, double g, double gprime, double theta, double beta, double mWboson, DoubleMatrix mixNeut, double runmt, double runmb, int neutralino, int uord);
  ///double teststop1amplitudedecayneutralinomix (double m1, double m2, double m3, double mWboson, double theta, double beta, DoubleMatrix mixNeut, double g, double gp, double runmt, int neutralino);
  ///double testsbottom1amplitudedecayneutralinomix (double m1, double m2, double m3, double mWboson, double theta, double beta, DoubleMatrix mixNeut, double g, double gp, double runmb, int neutralino);
  ///double teststop2amplitudedecayneutralinomix (double m1, double m2, double m3, double mWboson, double theta, double beta, DoubleMatrix mixNeut, double g, double gp, double runmt, int neutralino);
  ///double testsbottom2amplitudedecayneutralinomix (double m1, double m2, double m3, double mWboson, double theta, double beta, DoubleMatrix mixNeut, double g, double gp, double runmb, int neutralino);
  ///double testmederivedstop1amplitudedecayneutralinomix (double m1, double m2, double m3, double mWboson, double theta, double beta, DoubleMatrix mixNeut, double g, double gp, double runmt, int neutralino);
  double testrealsquark3amplitudedecayneutralino (double m1, double m2, double m3, double mWboson, double theta, double beta, DoubleMatrix mixNeut, double g, double gp, double runmt, int squark , int oneortwo,  int neutralino);
  double squark3amplitudedecaysquark3Wboson (double m1, double m2, double m3, double g, double thetat, double thetab, int m1torb, int m1oneortwo, int m3torb, int m3oneortwo);
  double squark3amplitudedecaychargedHiggssquark3 (double m1, double m2, double m3, double g, double mWboson, double beta, double thetat, double thetab, double greekmu, double At, double Ab, double mt, double mb, int t1or2, int b1or2);
  double squark32amplitudedecayneutralHiggssquark3 (double m1, double m2, double m3, double g, double gp, double mWboson, double beta, double alpha, double thetat, double thetab, double greekmu, double At, double Ab, double mt, double mb, int torb, char phi);
  double squark32amplitudedecaysquark3Zboson (double m1, double m2, double m3, double g, double gp, double theta);
  double sleptonamplitudedecayleptonneutralino (double m1, double m2, double m3, double g, double gp, DoubleMatrix mixNeut, char LorR, int neutralino);
  double sneutrinoamplitudedecayneutrinoneutralino (double m1, double m2, double m3, double g, double gp, DoubleMatrix mixNeut, int neutralino);
  double sleptonamplitudedecaychargino (double m1, double m2, double m3, double g, double theta, int chargino);
  double stauamplitudedecaytauneutralino (double m1, double m2, double m3, double g, double gp, double mWboson, DoubleMatrix mixNeut, double theta, double beta, int oneortwo, int neutralino);
  double stausneutrinoamplitudedecaytauneutrinoneutralino (double m1, double m2, double m3, double g, double gp, DoubleMatrix mixNeut, int neutralino); 
  double stauamplitudedecaynutauchargino (double m1, double m2, double m3, double g, double mWboson, double theta, double thetaL, double beta, double mtau, int oneortwo, int chargino);
  double stausneutrinoamplitudedecaytauchargino (double m1, double m2, double m3, double g, double mWboson, double beta, double thetaL, double thetaR, int chargino);
  double stauamplitudedecaysnustauHminus (double m1, double m2, double m3, double g, double mWboson, double beta, double thetatau, double mtau, double mu, double Atau, int oneortwo);
  double stauamplitudedecaysnustauWboson (double m1, double m2, double m3, double g, double thetatau, int oneortwo);
  double stau2amplitudedecaystau1Zboson (double m1, double m2, double m3, double g, double gp, double thetatau);
  double stau2amplitudedecaystau1phi (double m1, double m2, double m3, double g, double gp, double thetatau, double beta, double alpha, double mWboson, double mtau, double greekmu, double Atau, char phi);
  double charginoamplitudedecayquarksquarkL (double m1, double m2, double m3, double g, double theta, int chargino);
  double charginoamplitudedecayquarksquarkmix (double m1, double m2, double m3, double g, double theta, double thetaL, double thetaR, double beta, double runmt, double runmb, double mWboson, int chargino, int upordowntypesquark, int oneortwo);
  double charginoamplitudedecayleptonsleptonL (double m1, double m2, double m3, double g, double thetaLorR, int chargino);
  double charginoamplitudedecaysnutautau (double m1, double m2, double m3, double g, double thetaL, double thetaR, double beta, double mWboson, int chargino);
  double charginoamplitudedecaystaunutau (double m1, double m2, double m3, double g, double thetaL, double thetaR, double thetatau, double beta, double mWboson, double mtau, int oneortwo, int chargino);
  double charginoamplitudedecayWbosonneutralino (double m1, double m2, double m3, double g, double thetaL, double thetaR, DoubleMatrix mixNeut, int chargino, int neutralino);
  double charginoamplitudedecayHminusneutralino (double m1, double m2, double m3, double g, double gp, double thetaL, double thetaR, double beta, DoubleMatrix mixNeut, int chargino, int neutralino);
  double chargino2amplitudedecaychargino1Zboson (double m1, double m2, double m3, double g, double gp, double thetaL, double thetaR);
  double chargino2amplitudedecaychargino1neutHiggs (double m1, double m2, double m3, double g, double gp, double thetaL, double thetaR, double beta, double alpha, char phi);
  double neutralinoamplitudedecayquarksquarkLorR (double m1, double m2, double m3, double g, double gp, DoubleMatrix mixNeut, int uordtype , char LorR, int neutralino);
  double neutralinoamplitudedecayleptonsleptonLorR (double m1, double m2, double m3, double g, double gp, DoubleMatrix mixNeut, char LorR, int neutralino);
  double neutralinoamplitudedecayneutrinosneutrinoL (double m1, double m2, double m3, double g, double gp, DoubleMatrix mixNeut, int neutralino);
  double neutralinoamplitudedecaysquark3quarkmix (double m1, double m2, double m3, double mWboson, double theta, double beta, DoubleMatrix mixNeut, double g, double gp, double runmq, int squark , int oneortwo,  int neutralino);
  double neutralinoamplitudedecaystautau (double m1, double m2, double m3, double mWboson, double theta, double beta, DoubleMatrix mixNeut, double g, double gp, int oneortwo,  int neutralino);
  double neutralinoamplitudedecaycharginoWboson (double m1, double m2, double m3, double g, double thetaL, double thetaR, DoubleMatrix mixNeut, int neutralino,  int chargino);
  double neutralinoamplitudedecaycharginoHplus (double m1, double m2, double m3, double g, double gp, double beta, double thetaL, double thetaR, DoubleMatrix mixNeut, int neutralino,  int chargino);
  double neutralinoamplitudedecayneutralinoZboson (double m1, double m2, double m3, double g, double gp, DoubleMatrix mixNeut, int ineutralino,  int fneutralino);
  double neutralinoamplitudedecayneutralinoneutHiggs (double m1, double m2, double m3, double g, double gp, DoubleMatrix mixNeut, double mixingangle, int ineutralino,  int fneutralino, char phi);
  double higgslorHamplitudedecayquarkantiquark (double m1, double m2, double g, double alpha, double beta, double mWboson, int uord, char lorH);
  double higgsAamplitudedecayquarkantiquark (double m1, double m2, double g, double beta, double mWboson, int uord); 
  double higgsphiamplitudedecayneutralinoneutralino (double m1, double m2, double m3, double g, double tanthetaW, double mixingangle, DoubleMatrix mixNeut, int ineutralino, int fneutralino, char phi);
  double higgsphiamplitudedecaysamechargino (double m1, double m2, double g, double thetaL, double thetaR, double alpha, double beta, int chargino, char phi); ///this function calls the function higgsphicharginocouplings to calculate the couplings for it
  double higgsphiamplitudedecaydifchargino (double m1, double m2, double m3, double g, double thetaL, double thetaR, double alpha, double beta, char phi);
  double higgshamplitudedecayAA (double m1, double m2, double g, double gp, double alpha, double beta, double mWboson);
  double higgsHamplitudedecayhh (double m1, double m2, double g, double gp, double alpha, double beta, double mWboson);
  double higgsHamplitudedecayAA (double m1, double m2, double g, double gp, double alpha, double beta, double mWboson);
  double higgsHamplitudedecayHplusHminus (double m1, double m2, double g, double gp, double alpha, double beta, double mWboson);
  double higgshamplitudedecayhiggsAZboson (double m1, double m2, double m3, double g, double gp, double alpha, double beta);
  double higgsHamplitudedecayhiggsAZboson (double m1, double m2, double m3, double g, double gp, double alpha, double beta);
  double higgsAamplitudedecayhiggshZboson (double m1, double m2, double m3, double g, double gp, double alpha, double beta);
  double higgsAamplitudedecayhiggsHZboson (double m1, double m2, double m3, double g, double gp, double alpha, double beta);
  double higgshamplitudedecay2squarksamehand (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson,double mupq, double mdownq, int sq);
  double higgshamplitudedecay2squarkdiffhand (double m1, double m2, double m3, double g, double alpha, double beta, double mWboson, double mupq, double mdownq, double greekmu, double Aup, double Adown, int sq);
  double higgsHamplitudedecay2squarksamehand (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson,double mupq, double mdownq, int sq);
  double higgsHamplitudedecay2squarkdiffhand (double m1, double m2, double m3, double g, double alpha, double beta, double mWboson, double mupq, double mdownq, double greekmu, double Aup, double Adown, int sq);
  double higgshamplitudedecay2sleptonsamehand (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mel, int sl);
  double higgshamplitudedecay2sleptondiffhand (double m1, double m2, double m3, double g, double alpha, double beta, double mWboson, double mel, double greekmu, double Aelectron, int sl);
  double higgsHamplitudedecay2sleptonsamehand (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mel, int sl);
  double higgsHamplitudedecay2sleptondiffhand (double m1, double m2, double m3, double g, double alpha, double beta, double mWboson, double mel, double greekmu, double Aelectron, int sl);
  double higgshamplitudedecaystop1stop1 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta);
  double higgshamplitudedecaystop2stop2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta);
  double higgshamplitudedecaystop1stop2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta);
  double higgshamplitudedecaysbottom1sbottom1 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta);
  double higgshamplitudedecaysbottom2sbottom2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta);
  double higgshamplitudedecaysbottom1sbottom2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta);
  double higgsHamplitudedecaystop1stop1 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta);
  double higgsHamplitudedecaystop2stop2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta);
  double higgsHamplitudedecaystop1stop2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta);
  double higgsHamplitudedecaysbottom1sbottom1 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta);
  double higgsHamplitudedecaysbottom2sbottom2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta);
  double higgsHamplitudedecaysbottom1sbottom2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta);
  double higgshamplitudedecaystau1stau1 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtau, double greekmu, double Atau, double theta);
  double higgshamplitudedecaystau2stau2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtau, double greekmu, double Atau, double theta);
  double higgshamplitudedecaystau1stau2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtau, double greekmu, double Atau, double theta);
  double higgshtestamplitudedecaystau1stau1 (double m1, double m2, double thetatau, double g, double gp, double mWboson, double alpha, double beta, double mtau, double greekmu, double Atau);
  double higgsHamplitudedecaystau1stau1 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtau, double greekmu, double Atau, double theta);
  double higgsHamplitudedecaystau2stau2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtau, double greekmu, double Atau, double theta);
  double higgsHamplitudedecaystau1stau2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtau, double greekmu, double Atau, double theta);
  double higgsAamplitudedecaysfermions (double m1, double m2, double m3, double g, double mWboson, double mf, double greekmu, double Asf, double beta, char uord);
  double higgsHplusamplitudedecayquarkantiquark (double m1, double m2, double m3, double g, double mWboson, double beta, DoubleMatrix VCKM, int quark, int antiquark);
  double higgsHplusamplitudedecayneutralinochargino (double m1, double m2, double m3, double g, double gp, double beta, double thetaL, double thetaR, DoubleMatrix mixNeut, int neutralino,  int chargino);
  double higgsHplusamplitudedecayneutralinocharginosusyhitway (double m1, double m2, double m3, double g, double gp, double beta, double thetaL, double thetaR, DoubleMatrix mixNeut, int neutralino,  int chargino);
  double higgsHplusamplitudedecayWbosonhiggsh (double m1, double m2, double m3, double g, double alpha, double beta);
  DoubleVector higgsHplusamplitudedecaysquarksquark (double m1, double m2, double m3, double g, double beta, double mWboson, double mup, double mdown, double greekmu, double Aup, double Adown);
  DoubleVector higgsHplusamplitudedecaysquarksquarkmix (double m1, double m2, double m3, double g, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double thetatop, double thetabottom);
  double higgsesamplitudedecaygammagammatotal(double m1, double g, double gprime, double mWboson, double polemw, double alpha, double beta, double mtop, double mbottom, double mcharm, double mtau, double mHpm, double mstop1, double mstop2, double msbottom1, double msbottom2, double mstau1, double mstau2, double mchargino1, double mchargino2, double thetaL, double thetaR, double thetat, double thetab, double thetatau, double greekmu, double Atop, double Abottom, double Atau, char higgstype);
  double higgsesamplitudedecaygluongluontotal(double m1, double g, double gs, double gprime, double mWboson, double alpha, double beta, double mtop, double mbottom, double mcharm, double mstop1, double mstop2, double msbottom1, double msbottom2, double thetaL, double thetaR, double thetat, double thetab, double greekmu, double Atop, double Abottom, char higgstype);
  ///double higgsamplitudedecayVVstar (double m1, double mboson, double g, double gp, double beta, double alpha, char Vtype);
  DoubleVector higgshamplitudedecayVV(double m1, double mWboson, double mZboson, double g, double gp, double alpha, double beta, char Vtype);
  DoubleVector higgsHamplitudedecayVV(double m1, double mWboson, double mZboson, double g, double gp, double alpha, double beta, char Vtype);
  double higgsesamplitudedecayZbosonphotontotal(double m1, double mZboson, double g, double gprime, double polemw, double runmw, double alpha, double beta, double mtop, double mbottom, double mcharm, double mstrange, double mstop1, double mstop2, double msbottom1, double msbottom2, double mHplus, double thetaL, double thetaR, double thetat, double thetab, double greekmu, double Atop, double Abottom, char higgstype);
  double gluinoamplitudedecay1to3neutfirsttwogen (double m1, double m2, double m3, double m4, double m5, double g, double gp, DoubleMatrix mixNeut, double alphas, char uord, int neut, int Nsteps, int adaptive, int onetothree, double approx);
  double gluinoamplitudedecay1to3charfirsttwogen (double m1, double m2, double m3, double m4, double m5, double m6, double g, double thetaL, double thetaR, double alphas, int charg, int Nsteps, int adaptive, int onetothree, double approx);
  double gluinoamplitudedecay1to3neutttbar (double m1, double m2, double m3, double m4, double m5, double mw, double g, double gp, double thetat, double beta,double alphas, DoubleMatrix mixNeut, double runmq, int neutralino, int Nsteps, int adaptive, int onetothree, double approx);
  double gluinoamplitudedecay1to3neutbbbar (double m1, double m2, double m3, double m4, double m5, double mw, double g, double gp, double thetab, double beta,double alphas, DoubleMatrix mixNeut, double runmq, int neutralino, int Nsteps, int adaptive, int onetothree, double approx);
  double gluinoamplitudedecaychartbbar (double m1, double m2, double m3, double m4, double m5, double m6, double m7, double m8, double alphas, double thetat, double thetab, double mw, double g, double gp, double gammaL, double gammaR, double beta, double runmt, double runmb, int chargino, int Nsteps, int adaptive, int onetothree, double approx);
  double neutralinoamplitudedecayneutffbar (double m1, double m2, double mf, double msf1, double msf2, double mz, double mh, double mH, double mA, double runmf, double mw, double thetaf, double beta, double alpha, double g, double gp, DoubleMatrix mixNeut, int neutralinoj, int neutralinoi, char qorl, char uord, int Nsteps, int adaptive, int onetothree, double approx);
  double gluinoamplitudedecaygravitino (double m1, double mgrav, double MPlreduced, int gravonoff, int gluNLSP);
  double squarkamplitudedecaygravitino(double m1, double mgrav, double mquark, double MPlreduced, int gravonoff, int squNLSP);
  double neutralinoamplitudedecayphotongravitino(double m1, double mgrav, double MPlreduced, DoubleMatrix mixNeut, double g, double gp, int neutralino, int gravonoff, int neutNLSP);
  double neutralinoamplitudedecayZgravitino(double m1, double mZ, double mgrav, double MPlreduced, DoubleMatrix mixNeut, double g, double gp, double beta, int neutralino, int gravonoff, int neutNLSP);
  double neutralinoamplitudedecayphigravitino(double m1, double mphi, double mgrav, double MPlreduced, DoubleMatrix mixNeut, double alpha, double beta, int neutralino, int gravonoff, char phi, int neutNLSP);

  
  DoubleVector squarkmixcharginocouplings (double g, double theta, double beta, double gammaL, double gammaR, double runmt, double runmb, double mWboson, int torb);
  DoubleVector higgsphisamecharginocouplings(double alpha, double beta, double thetaL, double thetaR);
  DoubleVector higgsphidifcharginocouplings (double alpha, double beta, double thetaL, double thetaR);
  DoubleVector higgshsquarksamehandcouplings (double mWboson, double g, double gp, double alpha, double beta, double mupq, double mdownq);
  DoubleVector higgshsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mupq, double mdownq, double greekmu, double Aup, double Adown);
  DoubleVector higgsHsquarksamehandcouplings (double mWboson, double g, double gp, double alpha, double beta, double mupq, double mdownq);
  DoubleVector higgsHsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mupq, double mdownq, double greekmu, double Aup, double Adown);
  DoubleVector higgshsleptonsamehandcouplings (double mWboson, double g, double gp, double alpha, double beta, double mel);
  DoubleVector higgshsleptondiffhandcouplings (double mWboson, double g, double alpha, double beta, double mel, double greekmu, double Ae);
  DoubleVector higgsHsleptonsamehandcouplings (double mWboson, double g, double gp, double alpha, double beta, double mel) ;
  DoubleVector higgsHsleptondiffhandcouplings (double mWboson, double g, double alpha, double beta, double mel, double greekmu, double Ae);
  DoubleVector higgsHplussquarkcouplings (double mWboson, double g, double beta, double mup, double mdown, double greekmu, double Au, double Ad);


  DoubleVector foftau(double mpart, double mcomp);  
  
  
  void printRowPDG(ostream & cout, double x);

  ///Integral calculating functions for 1->3 decays

  double compute_area7(double (*funcp)(double, double, double, double, double, double), double lo, double hi, double Nsteps, int adaptive, double approx, double m1, double m2, double msf, double mf, double mz);
  double compute_area6(double (*funcp)(double, double, double, double, double), double lo, double hi, double Nsteps, int adaptive, double approx, double m1, double m2, double m3, double m4);
  double compute_area8(double (*funcp)(double, double, double, double, double, double, double), double lo, double hi, double Nsteps, int adaptive, double approx, double m1, double m2, double m3, double m4, double m5, double m6);
  double compute_area71(double (*funcp)(double, double, double, double, double, double, int), double lo, double hi, double Nsteps, int adaptive, double approx, double m1, double m2, double m3, double m4, double m5, int AorhorH);

  double Zsfintegralsum(double m1, double m2, double msf, double mf, double mz, double min, double max, double Nsteps, int adaptive, double approx);
  double Aintegralsum(double m1, double m2, double mz, double mA, double mf, double min, double max, double Nsteps, int adaptive, double approx);
  double G3integralsum(double m1, double m2, double m3, double mt, double mb, double min, double max, double Nsteps, int adaptive, double approx);
  double G2integralsum(double m1, double m2, double m3, double mt, double mb, double min, double max, double Nsteps, int adaptive, double approx);
  double chiprimeintegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx);
  double Yintegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx);
  double Xintegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx);
  double zetaintegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx);
  double chiintegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx);
  double rhointegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx);
  double xsiintegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx);
  double phitildaintegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx);
  double psitildaintegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx);

  double Zintegralsum(double m1, double m2, double mz, double mf, double min, double max, double Nsteps, int adaptive, double approx);
  double G1integralsum(double m1, double m2, double m3, double mq, double min, double max, double Nsteps, int adaptive, double approx);
  
  double G4integralsum(double m1, double m2, double m3, double m4, double mt, double mb, double min, double max, double Nsteps, int adaptive, double approx);
  double G5integralsum(double m1, double m2, double m3, double m4, double mt, double mb, double min, double max, double Nsteps, int adaptive, double approx);
  double G6integralsum(double m1, double m2, double m3, double m4, double mt, double mb, double min, double max, double Nsteps, int adaptive, double approx);
  double G7integralsum(double m1, double m2, double m3, double m4, double mt, double mb, double min, double max, double Nsteps, int adaptive, double approx);
  double G8integralsum(double m1, double m2, double m3, double m4, double mt, double mb, double min, double max, double Nsteps, int adaptive, double approx);
  
  double Jintegralsum(double m1, double m2, double msf, double mphi, double mf, double min, double max, double Nsteps, double approx, int adaptive, int AorhorH);
 
  double hHintegral (double m1, double m2, double mf, double mh, double mH, double fromE, double toE, double stepE, double g, double gp, double alpha, DoubleMatrix mixNeut, int neutralinoi, int neutralinoj); ///hHintegral only done via usual method (not via a separate integrating function compute_areai) as can't pass a DoubleMatrix in a function pointer



  ///1 to 3 decay functions calling dgauss
  double gluinoamplitudedecaydgausscharginoqqpbarfirsttwogen (double mgluino, double mchargino, double mquark, double mquarkp, double msqL, double msqpL, double g, double thetaL, double thetaR, double alphas, int charg, int onetothree);
  double gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (double mgluino, double mneutralino, double msqL, double msqR, double mquark, double g, double gp, DoubleMatrix mixNeut, double alphas, char uord, int neut, int onetothree);
  double gluinoamplitudedecaydgaussneutralinottbar (double mgluino, double mst1, double mst2, double mneutralino, double mt, double mWboson, double g, double gp, double thetat, double beta, double alphas, DoubleMatrix mixNeut, double runmt, int neutralino, int onetothree, char torb);
  // double gluinoamplitudedecaydgaussneutralinobbbarorig(double mgluino, double msb1, double msb2, double mneutralino, double mb, double mWboson, double g, double gp, double thetab, double beta, double alphas, DoubleMatrix mixNeut, double runmb, int neutralino, int onetothree);
  double gluinoamplitudedecaydgausschartbbar (double mgluino, double mst1, double mst2, double msb1, double msb2, double mtop, double mbottom, double mchar, double alphas, double thetat, double thetab, double MWBoson, double g, double gp, double gammaL, double gammaR, double beta, double runmt, double runmb, int chargino, int onetothree);
  // double gluinoamplitudedecaydgausschartbbarorig (double mgluino, double mst1, double mst2, double msb1, double msb2, double mtop, double mbottom, double mchar, double alphas, double thetat, double thetab, double MWBoson, double g, double gp, double gammaL, double gammaR, double beta, double runmt, double runmb, int chargino, int onetothree);
  double neutralinoamplitudedecaydgaussneutralinoffbar (double mneutralinoi, double msf1, double msf2, double mZboson, double mhiggsl, double mhiggsH, double mhiggsA, double mneutralinoj, double mf, double alphas, double thetaq, double mWboson, double g, double gp, double alpha, double beta, double runmq, DoubleMatrix mixNeut, int ineutralino, int jneutralino, int onetothree, char uordornuorl);
  double neutralinoamplitudedecaycharginoffprimebar (double mneutralinoi, double msfp1, double msfp2, double msf1, double msf2, double mWboson, double mHP, double mcharginoj, double mfp, double mf, double thetaq, double thetaqp, double g, double gp, double alpha, double beta, double thetaL2, double thetaR2, double runmqp, double runmq, DoubleMatrix mixNeut, int ineutralino, int jchargino, int onetothree, char qorl, char norc); 



  double fdgauss(double x);
  double gpsitildadgauss(double Et);
  double gphitildadgauss(double Et);
  double gxsidgauss (double Et);
  double grhodgauss (double Et);
  double gchidgauss (double Et);
  double gzetadgauss (double Et);
  double gXdgauss (double Et);
  double gYdgauss (double Et);
  double gchiprimedgauss (double Et);
  double gG1dgauss (double Et);
  double gG4dgauss (double Et);
  double gG5dgauss(double Et);
  double gG6dgauss(double Et);
  double gG7dgauss(double Et);
  double gG8dgauss(double Et);
  double gG2dgauss(double Eb);
  double gG3dgauss(double Eb);
  double gZdgauss(double E);
  double ghHdgauss (double E);
  double gAdgauss (double E);
  double gZsfdgauss (double s);
  double gJdgauss(double s);

  double gneutineutjffZ1dgauss(double s);
  double gneutineutjffZ2dgauss(double s);
  double gneutineutjffZ3dgauss(double s);
  double gneutineutjffZ4dgauss(double s);

  double gintegralhdgauss(double E);
  double gintegralHdgauss(double E);
  double gintegralh1dgauss(double E);
  double gintegralh2dgauss(double E);
  double gintegralh3dgauss(double E);
  double gintegralh4dgauss(double E);  
  double gintegralH1dgauss(double E);
  double gintegralH2dgauss(double E);
  double gintegralH3dgauss(double E);
  double gintegralH4dgauss(double E);
  double gintegralhH1dgauss(double E);
  double gintegralhH2dgauss(double E);
  double gintegralhH3dgauss(double E);
  double gintegralhH4dgauss(double E);
  double gintegralA1dgauss(double E);
  double gintegralA2dgauss(double E);
  double gintegralA3dgauss(double E);
  double gintegralA4dgauss(double E);
  double gintegral1Zsfdgauss(double E);
  double gintegral2Zsfdgauss(double E);
  double gintegral3Zsfdgauss(double E);
  double gintegral4Zsfdgauss(double E);
  double gintegral5Zsfdgauss(double E);
  double gintegral6Zsfdgauss(double E);
  double gintegral7Zsfdgauss(double E);
  double gintegral8Zsfdgauss(double E);
  double gintegral1hsfdgauss(double E);
  double gintegral2hsfdgauss(double E);
  double gintegral3hsfdgauss(double E);
  double gintegral4hsfdgauss(double E);
  double gintegral5hsfdgauss(double E);
  double gintegral6hsfdgauss(double E);
  double gintegral7hsfdgauss(double E);
  double gintegral8hsfdgauss(double E);
  double gintegral1Hsfdgauss(double E);
  double gintegral2Hsfdgauss(double E);
  double gintegral3Hsfdgauss(double E);
  double gintegral4Hsfdgauss(double E);
  double gintegral5Hsfdgauss(double E);
  double gintegral6Hsfdgauss(double E);
  double gintegral7Hsfdgauss(double E);
  double gintegral8Hsfdgauss(double E);
  double gintegral1ZAdgauss(double E);
  double gintegral2ZAdgauss(double E);
  double gintegral3ZAdgauss(double E);
  double gintegral4ZAdgauss(double E);
  double gneutineutjffgA1dgauss(double E);
  double gneutineutjffgA2dgauss(double E);
  double gneutineutjffgA3dgauss(double E);
  double gneutineutjffgA4dgauss(double E);

  double gneuticharjffpW1dgauss(double E);
  double gneuticharjffpW2dgauss(double E);
  double gneuticharjffpHpm1dgauss(double E);
  double gneuticharjffpHpm2dgauss(double E);
  double gneuticharjffpHpm3dgauss(double E);
  double gneuticharjffpHpm4dgauss(double E);
  double gneuticharjffp1sf1sf2dgauss(double E);
  double gneuticharjffp2sf1sf2dgauss(double E);
  double gneuticharjffp3sf1sf2dgauss(double E);
  double gneuticharjffp4sf1sf2dgauss(double E);
  double gneuticharjffp1sfp1sf2dgauss(double E);
  double gneuticharjffp2sfp1sf2dgauss(double E);
  double gneuticharjffp3sfp1sf2dgauss(double E);
  double gneuticharjffp4sfp1sf2dgauss(double E);
  double gneuticharjffp5sfp1sf2dgauss(double E);
  double gneuticharjffp6sfp1sf2dgauss(double E);
  double gneuticharjffp7sfp1sf2dgauss(double E);
  double gneuticharjffp8sfp1sf2dgauss(double E);
  double gneuticharjffp1WHpmdgauss(double E);
  double gneuticharjffp2WHpmdgauss(double E);
  double gneuticharjffp3WHpmdgauss(double E);
  double gneuticharjffp4WHpmdgauss(double E);
  double gneuticharjffpW1Sfpdgauss(double E);
  double gneuticharjffpW2Sfpdgauss(double E);
  double gneuticharjffpW3Sfpdgauss(double E);
  double gneuticharjffpW4Sfpdgauss(double E);
  double gneuticharjffpW5Sfpdgauss(double E);
  double gneuticharjffpW6Sfpdgauss(double E);
  double gneuticharjffpW7Sfpdgauss(double E);
  double gneuticharjffpW8Sfpdgauss(double E);
  double gneuticharjffpHg1dgauss(double E);
  double gneuticharjffpHg2dgauss(double E);
  double gneuticharjffpHg3dgauss(double E);
  double gneuticharjffpHg4dgauss(double E);
  double gneuticharjffp1gsfpdgauss(double E);
  double gneuticharjffp2gsfpdgauss(double E);
  double gneuticharjffp3gsfpdgauss(double E);
  double gneuticharjffp4gsfpdgauss(double E);
  double gneuticharjffp5gsfpdgauss(double E);
  double gneuticharjffp6gsfpdgauss(double E);
  double gneuticharjffp7gsfpdgauss(double E);
  double gneuticharjffp8gsfpdgauss(double E);
  double gneuticharjffp1sfpsfpdgauss(double E);
  double gneuticharjffp21sfpsfpdgauss(double E);
  double gneuticharjffp31sfpsfpdgauss(double E);
  double gneuticharjffp41sfpsfpdgauss(double E);

  ///TEST OF DGAUSS

  double (*fp) (double);
  double area = 0;
  fp = fdgauss;
  area = dgauss(fp,0,1,0.01);
  //  cout << "area = " << area << endl;
  //cout << fdgauss(2) << endl;

  ///Initialise NeutMIX before using it in the integrals
  for (int i = 1; i<=NeutMIXdim; i++) {
    for (int j = 1; j<=NeutMIXdim; j++) {
      NeutMIX(i,j) = 0;
    }
  }

  //  cout << "NeutMIX: " << NeutMIX<< endl;

  NeutMIX = mixNeut;
  //  cout << "NeutMIX: " << NeutMIX << endl;
  g1 = g; g2 = gp; alphamix = alpha; betavac = beta;
  ///Calling gpsitilda with m1 =mGluino, m2 = muL, m3 = muL, m4 = mZ1, mq = mt
  //mGluino = 650; ///Reduce mGluino slightly as otherwise the 1->2 decay of mglu -> mst1 + mt is available
  //m1 = mGluino, m2 = mu(1,3), m3 = mu(2,3), m4 = mneut(1), mq = mtopSUSYHIT;
  // double upper = 0;
  // upper = (pow(m1,2)-2*mq*m4-pow(m4,2))/(2*m1);
  // double check = gpsitildadgauss(200);
  // cout << "gpsitildadgauss at Et = 200: " << check << endl;
  // fp = gpsitildadgauss;
  // area = dgauss(fp,mq,upper,0.01);
  // cout << "areagpsitildadgauss = " << area << endl;
  // fp = gphitildadgauss;
  // cout << "gphitildadgauss at Et = 200: " << gphitildadgauss(200) << endl;
  // area = dgauss(fp,mq,upper,0.01);
  // cout << "areagphitildadgauss = " << area << endl;
  // fp = gxsidgauss;
  // cout << "gxsidgauss at Et = 200: " << gxsidgauss(200) << endl;
  // area = dgauss(fp,mq,upper,0.01);
  // cout << "areagxsidgauss = " << area << endl;
  // fp = grhodgauss;
  // cout << "grhodgauss at Et = 200: " << grhodgauss(200) << endl;
  // area = dgauss(fp,mq,upper,0.01);
  // cout << "areagrhodgauss = " << area << endl;
  // fp = gchidgauss;
  // cout << "gchidgauss at Et = 200: " << gchidgauss(200) << endl;
  // area = dgauss(fp,mq,upper,0.01);
  // cout << "areagchidgauss = " << area << endl;
  // fp = gzetadgauss;
  // cout << "gzetadgauss at Et = 200: " << gzetadgauss(200) << endl;
  // area = dgauss(fp,mq,upper,0.01);
  // cout << "areagzetadgauss = " << area << endl;
  // fp = gXdgauss;
  // cout << "gXdgauss at Et = 200: " << gXdgauss(200) << endl;
  // area = dgauss(fp,mq,upper,0.01);
  // cout << "areagXdgauss = " << area << endl;
  // fp = gYdgauss;
  // cout << "gYdgauss at Et = 200: " << gYdgauss(200) << endl;
  // area = dgauss(fp,mq,upper,0.01);
  // cout << "areagYdgauss = " << area << endl;
  // cout << "Masses used in gchiprimedgauss: mst1 = " << m2 << " mst2 = " << m3 << " mgluino = " << m1 << " mneut(1) = " << m4 << " mtop = " << mq << endl;
  // fp = gchiprimedgauss;
  // cout << "gchiprimedgauss at Et = 250: " << gchiprimedgauss(250) << endl;
  // area = dgauss(fp,mq,upper,0.01);
  // cout << "areagchiprimedgauss = " << area << endl;


  // m1 = mGluino, m2 = mu(1,3), m3 = mu(2,3), m4 = md(1,3), m5 = md(2,3), m6 = MTOP, m7 = MBOTTOM, m8 = MCH1;
  // upper = (pow(m1,2)+pow(m6,2) - pow(m8+m7,2))/(2*m1);
  // cout << "upper" << upper << endl;
  // fp = gG4dgauss;
  // cout << "gG4dgauss at Et = 200: " << gG4dgauss(200) << endl;
  // area = dgauss(fp,m6,upper,0.01);
  // cout << "areagG4dgauss = " << area << endl;
  // fp = gG5dgauss;
  // cout << "gG5dgauss at Et = 200: " << gG5dgauss(200) << endl;
  // area = dgauss(fp,m6,upper,0.01);
  // cout << "areagG5dgauss = " << area << endl;
  // fp = gG6dgauss;
  // cout << "gG6dgauss at Et = 200: " << gG6dgauss(200) << endl;
  // area = dgauss(fp,m6,upper,0.01);
  // cout << "areagG6dgauss = " << area << endl;
  // fp = gG7dgauss;
  // cout << "gG7dgauss at Et = 200: " << gG7dgauss(200) << endl;
  // area = dgauss(fp,m6,upper,0.01);
  // cout << "areagG7dgauss = " << area << endl;
  // fp = gG8dgauss;
  // cout << "gG8dgauss at Et = 200: " << gG8dgauss(200) << endl;
  // area = dgauss(fp,m6,upper,0.01);
  // cout << "areagG8dgauss = " << area << endl;
  // fp = gG1dgauss;
  // cout << "gG1dgauss at Et = 200: " << gG1dgauss(200) << endl;
  // area = dgauss(fp,m6,upper,0.05);
  // cout << "areagG1dgauss = " << area << endl;

  // upper = (pow(m1,2)-pow(m6+m8,2))/(2*m1);
  // fp = gG2dgauss;
  // cout << "gG2dgauss at Et = 200: " << gG2dgauss(200) << endl;
  // area = dgauss(fp,m7,upper,0.01);
  // cout << "areagG2dgauss = " << area << endl;
  // fp = gG3dgauss;
  // cout << "gG3dgauss at Et = 200: " << gG3dgauss(200) << endl;
  // area = dgauss(fp,m7,upper,0.01);
  // cout << "areagG3dgauss = " << area << endl;


  // m1 = mneut(4), m2 = mu(1,3), m3 = mu(2,3), m4 = mneut(1), mq = MTOP, MZboson = mz;
  // upper = (pow(m1,2)+pow(m4,2)-4*pow(mq,2))/(2*m1);
  // fp = gZdgauss;
  // cout << "gZdgauss at E = 150: " << gZdgauss(150) << endl;
  // area = dgauss(fp,m4,upper,0.01);
  // cout << "areagZdgauss = " << area << endl;

  // neutralinoj = 2, neutralinoi = 1; ///Set depending on what is initial neutralinoj and what is final neutralinoi
  // m1 = mneut(neutralinoj), m4 = mneut(neutralinoi), mh = mh0(1), mH = mh0(2), mA = mA0(1), mq = MBOTTOM;
  // fp = ghHdgauss;
  // cout << "ghHdgauss at E = 110: " << ghHdgauss(110) << endl;
  // area = dgauss(fp,m4,upper,0.01);
  // cout << "areaghHdgauss = " << area << endl;
  // fp = gAdgauss;
  // cout << "gAdgauss at E = 110: " << gAdgauss(110) << endl;
  // area = dgauss(fp,m4,upper,0.01);
  // cout << "areagAdgauss = " << area << endl;

  // m2 = md(1,3); ///here considering sdown1 contribution
  // AorhorH = 0; /// h or H Jintegral indicated by setting this 0, A integral indicated by setting this 1
  // mphi = mh; // for h Jintegral
  // upper = pow(m1-m4,2);
  // fp = gZsfdgauss;
  // cout << "gZsfdgauss at s = 1000: " << gZsfdgauss(1000) << endl;
  // area = dgauss(fp,4*pow(mq,2),upper,0.01);
  // if (isinf(area)==1) {
  //   cout << "Infinity attained in numerical integration - error probably as 1->2 mode available" << endl;
  //   area = 0;
  // }
  // cout << "areagZsfdgauss = " << area << endl;
  // fp = gJdgauss;
  // cout << "gJdgauss at s = 1000: " << gJdgauss(1000) << endl;
  // area = dgauss(fp,4*pow(mq,2),upper,0.01);
  // cout << "areagJdgauss = " << area << endl;

  ///for (mGluino = 1000; mGluino <=2000; mGluino = mGluino + 50) {

  //    cout << "mGluino = " << mGluino << endl;
  
 /// Now need to calculate the partial decays of the gluino
  double gluinoamplitudeupantisupL = 0, gluinoamplitudeupantisupR = 0, gluinoamplitudeantiupsupL = 0, gluinoamplitudeantiupsupR = 0;
  gluinoamplitudeupantisupL = gluinoamplitudedecay(mGluino, MUP, mu(1,1), alphas);
  gluinoamplitudeupantisupR = gluinoamplitudedecay (mGluino, MUP, mu(2,1), alphas);
  gluinoamplitudeantiupsupL = gluinoamplitudedecay (mGluino, MUP, mu(1,1), alphas);
  gluinoamplitudeantiupsupR = gluinoamplitudedecay (mGluino, MUP, mu(2,1), alphas);
  
 double gluinoamplitudedownantisdownL = 0, gluinoamplitudedownantisdownR = 0, gluinoamplitudeantidownsdownL = 0, gluinoamplitudeantidownsdownR = 0;
 gluinoamplitudedownantisdownL = gluinoamplitudedecay(mGluino, MDOWN, md(1,1), alphas);
 gluinoamplitudedownantisdownR = gluinoamplitudedecay(mGluino, MDOWN, md(2,1), alphas);
 gluinoamplitudeantidownsdownL = gluinoamplitudedecay(mGluino, MDOWN, md(1,1), alphas);
 gluinoamplitudeantidownsdownR = gluinoamplitudedecay(mGluino, MDOWN, md(2,1), alphas);
 
 double gluinoamplitudecharmantischarmL = 0, gluinoamplitudecharmantischarmR = 0, gluinoamplitudeanticharmscharmL = 0, 	gluinoamplitudeanticharmscharmR = 0;
 gluinoamplitudecharmantischarmL = gluinoamplitudedecay(mGluino, MCHARM, mu(1,2), alphas);
 gluinoamplitudecharmantischarmR = gluinoamplitudedecay(mGluino, MCHARM, mu(2,2), alphas);
 gluinoamplitudeanticharmscharmL = gluinoamplitudedecay(mGluino, MCHARM, mu(1,2), alphas);
 gluinoamplitudeanticharmscharmR = gluinoamplitudedecay(mGluino, MCHARM, mu(2,2), alphas);
 
 double gluinoamplitudestrangeantisstrangeL = 0, gluinoamplitudestrangeantisstrangeR = 0, gluinoamplitudeantistrangesstrangeL = 0, 	gluinoamplitudeantistrangesstrangeR = 0;
 gluinoamplitudestrangeantisstrangeL = gluinoamplitudedecay(mGluino, MSTRANGE, md(1,2), alphas);
 gluinoamplitudestrangeantisstrangeR = gluinoamplitudedecay(mGluino, MSTRANGE, md(2,2), alphas);
 gluinoamplitudeantistrangesstrangeL = gluinoamplitudedecay(mGluino, MSTRANGE, md(1,2), alphas);
 gluinoamplitudeantistrangesstrangeR = gluinoamplitudedecay(mGluino, MSTRANGE, md(2,2), alphas); 
 gluinoamplitudecharmantischarmL = gluinoamplitudedecay(mGluino, MCHARM, mu(1,2), alphas);

 double gluinoamplitudetopantistop1 = 0, gluinoamplitudetopantistop2 = 0, gluinoamplitudeantitopstop1 = 0, 	gluinoamplitudeantitopstop2 = 0;
 gluinoamplitudetopantistop1 = gluinoamplitudedecaymix(mGluino, MTOP, mu(1,3), alphas, 1, thetat);
 gluinoamplitudetopantistop2 = gluinoamplitudedecaymix(mGluino, MTOP, mu(2,3), alphas, 2, thetat);
 gluinoamplitudeantitopstop1 = gluinoamplitudedecaymix(mGluino, MTOP, mu(1,3), alphas, 1, thetat);
 gluinoamplitudeantitopstop2 = gluinoamplitudedecaymix(mGluino, MTOP, mu(2,3), alphas, 2, thetat);

 double gluinoamplitudebottomantisbottom1 = 0, gluinoamplitudebottomantisbottom2 = 0, gluinoamplitudeantibottomsbottom1 = 0, 	gluinoamplitudeantibottomsbottom2 = 0;
 gluinoamplitudebottomantisbottom1 = gluinoamplitudedecaymix(mGluino, MBOTTOM, md(1,3), alphas, 1, thetab);
 gluinoamplitudebottomantisbottom2 = gluinoamplitudedecaymix(mGluino, MBOTTOM, md(2,3), alphas, 2, thetab);
 gluinoamplitudeantibottomsbottom1 = gluinoamplitudedecaymix(mGluino, MBOTTOM, md(1,3), alphas, 1, thetab);
 gluinoamplitudeantibottomsbottom2 = gluinoamplitudedecaymix(mGluino, MBOTTOM, md(2,3), alphas, 2, thetab); 

 double gluinoamplitudeneut1uubar = 0, gluinoamplitudeneut2uubar = 0, gluinoamplitudeneut3uubar = 0, gluinoamplitudeneut4uubar = 0, gluinoamplitudeneut1ddbar = 0, gluinoamplitudeneut2ddbar = 0, gluinoamplitudeneut3ddbar = 0, gluinoamplitudeneut4ddbar = 0, gluinoamplitudeneut1ccbar = 0, gluinoamplitudeneut2ccbar = 0, gluinoamplitudeneut3ccbar = 0, gluinoamplitudeneut4ccbar = 0, gluinoamplitudeneut1ssbar = 0, gluinoamplitudeneut2ssbar = 0, gluinoamplitudeneut3ssbar = 0, gluinoamplitudeneut4ssbar = 0, gluinoamplitudeneut1ttbar = 0, gluinoamplitudeneut2ttbar = 0, gluinoamplitudeneut3ttbar = 0, gluinoamplitudeneut4ttbar = 0, gluinoamplitudeneut1bbbar = 0, gluinoamplitudeneut2bbbar = 0, gluinoamplitudeneut3bbbar = 0, gluinoamplitudeneut4bbbar = 0, gluinoamplitudegravitinogluon = 0;

 // ///ALPHASMZ2 = alphasforsphcomp; ///used alphas here for comp with spheno, usually use ALPHASMZ2 for comp with susyhit if have usual slhaspectrum.in
 //gluinoamplitudeneut1uubar =  gluinoamplitudedecay1to3neutfirsttwogen (mGluino, mneut(1), mu(1,1), mu(2,1), MUP, g, gp, mixNeut, ALPHASMZ2, 'u', 1, Nsteps, adaptive, onetothree, approx); 
 // ///gluinoamplitudeneut1uubar =  gluinoamplitudedecay1to3neutttbar (mGluino, mu(1,1), mu(2,1), mneut(1), MUP, runmw, g, gp, 0, beta, ALPHASMZ2, mixNeut, MUP, 1, Nsteps, adaptive,  onetothree, approx);
 //gluinoamplitudeneut2uubar =  gluinoamplitudedecay1to3neutfirsttwogen (mGluino, mneut(2), mu(1,1), mu(2,1), MUP, g, gp, mixNeut, ALPHASMZ2, 'u', 2, Nsteps, adaptive, onetothree, approx);
 // ///gluinoamplitudeneut2uubar = gluinoamplitudedecay1to3neutttbar (mGluino, mu(1,1), mu(2,1), mneut(2), MUP, runmw, g, gp, 0, beta, ALPHASMZ2, mixNeut, MUP, 2, Nsteps, adaptive, onetothree, approx);
 //gluinoamplitudeneut3uubar =  gluinoamplitudedecay1to3neutfirsttwogen (mGluino, mneut(3), mu(1,1), mu(2,1), MUP, g, gp, mixNeut, ALPHASMZ2, 'u', 3, Nsteps, adaptive, onetothree, approx);
 // ///gluinoamplitudeneut3uubar = gluinoamplitudedecay1to3neutttbar (mGluino, mu(1,1), mu(2,1), mneut(3), MUP, runmw, g, gp, 0, beta, ALPHASMZ2, mixNeut, MUP, 3, Nsteps, adaptive, onetothree, approx);
 //gluinoamplitudeneut4uubar =  gluinoamplitudedecay1to3neutfirsttwogen (mGluino, mneut(4), mu(1,1), mu(2,1), MUP, g, gp, mixNeut, ALPHASMZ2, 'u', 4, Nsteps, adaptive, onetothree, approx);
 // ///gluinoamplitudeneut4uubar = gluinoamplitudedecay1to3neutttbar (mGluino, mu(1,1), mu(2,1), mneut(4), MUP, runmw, g, gp, 0, beta, ALPHASMZ2, mixNeut, MUP, 4, Nsteps, adaptive, onetothree, approx);
 //gluinoamplitudeneut1ddbar =  gluinoamplitudedecay1to3neutfirsttwogen (mGluino, mneut(1), md(1,1), md(2,1), MDOWN, g, gp, mixNeut, ALPHASMZ2, 'd', 1, Nsteps, adaptive, onetothree, approx);
 // ///gluinoamplitudeneut1ddbar = gluinoamplitudedecay1to3neutbbbar (mGluino, md(1,1), md(2,1), mneut(1), MDOWN, runmw, g, gp, 0, beta,ALPHASMZ2, mixNeut, MDOWN, 1, Nsteps, adaptive, onetothree, approx);
 //gluinoamplitudeneut2ddbar =  gluinoamplitudedecay1to3neutfirsttwogen (mGluino, mneut(2), md(1,1), md(2,1), MDOWN, g, gp, mixNeut, ALPHASMZ2, 'd', 2, Nsteps, adaptive, onetothree, approx);
 // ///gluinoamplitudeneut2ddbar = gluinoamplitudedecay1to3neutbbbar (mGluino, md(1,1), md(2,1), mneut(2), MDOWN, runmw, g, gp, 0, beta,ALPHASMZ2, mixNeut, MDOWN, 2, Nsteps, adaptive, onetothree, approx);
 //gluinoamplitudeneut3ddbar =  gluinoamplitudedecay1to3neutfirsttwogen (mGluino, mneut(3), md(1,1), md(2,1), MDOWN, g, gp, mixNeut, ALPHASMZ2, 'd', 3, Nsteps, adaptive, onetothree, approx);
 // ///gluinoamplitudeneut3ddbar = gluinoamplitudedecay1to3neutbbbar (mGluino, md(1,1), md(2,1), mneut(3), MDOWN, runmw, g, gp, 0, beta,ALPHASMZ2, mixNeut, MDOWN, 3, Nsteps, adaptive, onetothree, approx);
 //gluinoamplitudeneut4ddbar =  gluinoamplitudedecay1to3neutfirsttwogen (mGluino, mneut(4), md(1,1), md(2,1), MDOWN, g, gp, mixNeut, ALPHASMZ2, 'd', 4, Nsteps, adaptive, onetothree, approx);
 // ///gluinoamplitudeneut4ddbar = gluinoamplitudedecay1to3neutbbbar (mGluino, md(1,1), md(2,1), mneut(4), MDOWN, runmw, g, gp, 0, beta,ALPHASMZ2, mixNeut, MDOWN, 4, Nsteps, adaptive, onetothree, approx);
 //gluinoamplitudeneut1ccbar =  gluinoamplitudedecay1to3neutfirsttwogen (mGluino, mneut(1), mu(1,2), mu(2,2), MCHARM, g, gp, mixNeut, ALPHASMZ2, 'u', 1, Nsteps, adaptive, onetothree, approx);
 // ///gluinoamplitudeneut1ccbar = gluinoamplitudedecay1to3neutttbar (mGluino, mu(1,2), mu(2,2), mneut(1), MCHARM, runmw, g, gp, 0, beta , ALPHASMZ2, mixNeut, MCHARM, 1, Nsteps, adaptive, onetothree, approx);
 //gluinoamplitudeneut2ccbar =  gluinoamplitudedecay1to3neutfirsttwogen (mGluino, mneut(2), mu(1,2), mu(2,2), MCHARM, g, gp, mixNeut, ALPHASMZ2, 'u', 2, Nsteps, adaptive, onetothree, approx);
 // ///gluinoamplitudeneut2ccbar = gluinoamplitudedecay1to3neutttbar (mGluino, mu(1,2), mu(2,2), mneut(2), MCHARM, runmw, g, gp, 0, beta , ALPHASMZ2, mixNeut, MCHARM, 2, Nsteps, adaptive, onetothree, approx);
 ///gluinoamplitudeneut3ccbar =  gluinoamplitudedecay1to3neutfirsttwogen (mGluino, mneut(3), mu(1,2), mu(2,2), MCHARM, g, gp, mixNeut, ALPHASMZ2, 'u', 3, Nsteps, adaptive, onetothree, approx);
 //gluinoamplitudeneut3ccbar = gluinoamplitudedecay1to3neutttbar (mGluino, mu(1,2), mu(2,2), mneut(3), MCHARM, runmw, g, gp, 0, beta , ALPHASMZ2, mixNeut, MCHARM, 3, Nsteps, adaptive, onetothree, approx);
 //gluinoamplitudeneut4ccbar =  gluinoamplitudedecay1to3neutfirsttwogen (mGluino, mneut(4), mu(1,2), mu(2,2), MCHARM, g, gp, mixNeut, ALPHASMZ2, 'u', 4, Nsteps, adaptive, onetothree, approx);
 // ///gluinoamplitudeneut4ccbar = gluinoamplitudedecay1to3neutttbar (mGluino, mu(1,2), mu(2,2), mneut(4), MCHARM, runmw, g, gp, 0, beta , ALPHASMZ2, mixNeut, MCHARM, 4, Nsteps, adaptive, onetothree, approx);
 //gluinoamplitudeneut1ssbar =  gluinoamplitudedecay1to3neutfirsttwogen (mGluino, mneut(1), md(1,2), md(2,2), MSTRANGE, g, gp, mixNeut, ALPHASMZ2, 'd', 1, Nsteps, adaptive, onetothree, approx);
 // ///gluinoamplitudeneut1ssbar = gluinoamplitudedecay1to3neutbbbar (mGluino, md(1,2), md(2,2), mneut(1), MSTRANGE, runmw, g, gp, 0, beta , ALPHASMZ2, mixNeut, MSTRANGE, 1, Nsteps, adaptive, onetothree, approx);
 //gluinoamplitudeneut2ssbar =  gluinoamplitudedecay1to3neutfirsttwogen (mGluino, mneut(2), md(1,2), md(2,2), MSTRANGE, g, gp, mixNeut, ALPHASMZ2, 'd', 2, Nsteps, adaptive, onetothree, approx);
 // ///gluinoamplitudeneut2ssbar = gluinoamplitudedecay1to3neutbbbar (mGluino, md(1,2), md(2,2), mneut(2), MSTRANGE, runmw, g, gp, 0, beta , ALPHASMZ2, mixNeut, MSTRANGE, 2, Nsteps, adaptive, onetothree, approx);
 //gluinoamplitudeneut3ssbar =  gluinoamplitudedecay1to3neutfirsttwogen (mGluino, mneut(3), md(1,2), md(2,2), MSTRANGE, g, gp, mixNeut, ALPHASMZ2, 'd', 3, Nsteps, adaptive, onetothree, approx);
 // ///gluinoamplitudeneut3ssbar = gluinoamplitudedecay1to3neutbbbar (mGluino, md(1,2), md(2,2), mneut(3), MSTRANGE, runmw, g, gp, 0, beta , ALPHASMZ2, mixNeut, MSTRANGE, 3, Nsteps, onetothree, approx);
 //gluinoamplitudeneut4ssbar =  gluinoamplitudedecay1to3neutfirsttwogen (mGluino, mneut(4), md(1,2), md(2,2), MSTRANGE, g, gp, mixNeut, ALPHASMZ2, 'd', 4, Nsteps, adaptive, onetothree, approx);
 // ///gluinoamplitudeneut4ssbar = gluinoamplitudedecay1to3neutbbbar (mGluino, md(1,2), md(2,2), mneut(4), MSTRANGE, runmw, g, gp, 0, beta , ALPHASMZ2, mixNeut, MSTRANGE, 4, Nsteps, adaptive, onetothree, approx);
 
 // gluinoamplitudeneut1ttbar = gluinoamplitudedecay1to3neutttbar (mGluino, mu(1,3), mu(2,3), mneut(1), mtopSUSYHIT, runmw, g, gp, thetat, beta, ALPHASMZ2, mixNeut, runmt, 1, Nsteps, adaptive, onetothree, approx);
 // gluinoamplitudeneut2ttbar = gluinoamplitudedecay1to3neutttbar (mGluino, mu(1,3), mu(2,3), mneut(2), mtopSUSYHIT, runmw, g, gp, thetat, beta, ALPHASMZ2, mixNeut, runmt, 2, Nsteps, adaptive, onetothree, approx);
 // gluinoamplitudeneut3ttbar = gluinoamplitudedecay1to3neutttbar (mGluino, mu(1,3), mu(2,3), mneut(3), mtopSUSYHIT, runmw, g, gp, thetat, beta, ALPHASMZ2, mixNeut, runmt, 3, Nsteps, adaptive, onetothree, approx);
 // gluinoamplitudeneut4ttbar = gluinoamplitudedecay1to3neutttbar (mGluino, mu(1,3), mu(2,3), mneut(4), mtopSUSYHIT, runmw, g, gp, thetat, beta, ALPHASMZ2, mixNeut, runmt, 4, Nsteps, adaptive, onetothree, approx);
 //  gluinoamplitudeneut1bbbar = gluinoamplitudedecay1to3neutbbbar (mGluino, md(1,3), md(2,3), mneut(1), mbottomSUSYHIT, runmw, g, gp, thetab, beta,ALPHASMZ2, mixNeut, runmb, 1, Nsteps, adaptive, onetothree, approx);
 //  gluinoamplitudeneut2bbbar = gluinoamplitudedecay1to3neutbbbar (mGluino, md(1,3), md(2,3), mneut(2), mbottomSUSYHIT, runmw, g, gp, thetab, beta,ALPHASMZ2, mixNeut, runmb, 2, Nsteps, adaptive, onetothree, approx);
 //  gluinoamplitudeneut3bbbar = gluinoamplitudedecay1to3neutbbbar (mGluino, md(1,3), md(2,3), mneut(3), mbottomSUSYHIT, runmw, g, gp, thetab, beta,ALPHASMZ2, mixNeut, runmb, 3, Nsteps, adaptive, onetothree, approx);
 //  gluinoamplitudeneut4bbbar = gluinoamplitudedecay1to3neutbbbar (mGluino, md(1,3), md(2,3), mneut(4), mbottomSUSYHIT, runmw, g, gp, thetab, beta,ALPHASMZ2, mixNeut, runmb, 4, Nsteps, adaptive, onetothree, approx);



 ///1 to 3 decays of gluinos to neutralinos and first two gen quarks via dgauss method:
 gluinoamplitudeneut1uubar = gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (mGluino, mneut(1), mu(1,1), mu(2,1), MUP, g, gp, mixNeut, alphas, 'u', 1, onetothree);
 // cout << "g -> Z1 u ubar = " << gluinoamplitudeneut1uubar << endl;
 //gluinoamplitudeneut1uubar = gluinoamplitudedecaydgaussneutralinottbar (mGluino, mu(1,1), mu(2,1), mneut(1), MUP, runmw, g, gp, 0, beta, ALPHASMZ2, mixNeut, MUP, 1, onetothree);
 // cout << "g -> Z1 u ubar = " << gluinoamplitudeneut1uubar << endl;
 gluinoamplitudeneut2uubar = gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (mGluino, mneut(2), mu(1,1), mu(2,1), MUP, g, gp, mixNeut, alphas, 'u', 2, onetothree);
 gluinoamplitudeneut3uubar = gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (mGluino, mneut(3), mu(1,1), mu(2,1), MUP, g, gp, mixNeut, alphas, 'u', 3, onetothree);
 gluinoamplitudeneut4uubar = gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (mGluino, mneut(4), mu(1,1), mu(2,1), MUP, g, gp, mixNeut, alphas, 'u', 4, onetothree);
 gluinoamplitudeneut1ddbar = gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (mGluino, mneut(1), md(1,1), md(2,1), MDOWN, g, gp, mixNeut, alphas, 'd', 1, onetothree);
 gluinoamplitudeneut2ddbar = gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (mGluino, mneut(2), md(1,1), md(2,1), MDOWN, g, gp, mixNeut, alphas, 'd', 2, onetothree);
 gluinoamplitudeneut3ddbar = gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (mGluino, mneut(3), md(1,1), md(2,1), MDOWN, g, gp, mixNeut, alphas, 'd', 3, onetothree);
 gluinoamplitudeneut4ddbar = gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (mGluino, mneut(4), md(1,1), md(2,1), MDOWN, g, gp, mixNeut, alphas, 'd', 4, onetothree);
 gluinoamplitudeneut1ccbar = gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (mGluino, mneut(1), mu(1,2), mu(2,2), MCHARM, g, gp, mixNeut, alphas, 'u', 1, onetothree);
 gluinoamplitudeneut2ccbar = gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (mGluino, mneut(2), mu(1,2), mu(2,2), MCHARM, g, gp, mixNeut, alphas, 'u', 2, onetothree);
 gluinoamplitudeneut3ccbar = gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (mGluino, mneut(3), mu(1,2), mu(2,2), MCHARM, g, gp, mixNeut, alphas, 'u', 3, onetothree);
 gluinoamplitudeneut4ccbar = gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (mGluino, mneut(4), mu(1,2), mu(2,2), MCHARM, g, gp, mixNeut, alphas, 'u', 4, onetothree);
 gluinoamplitudeneut1ssbar = gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (mGluino, mneut(1), md(1,2), md(2,2), MSTRANGE, g, gp, mixNeut, alphas, 'd', 1, onetothree);
 gluinoamplitudeneut2ssbar = gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (mGluino, mneut(2), md(1,2), md(2,2), MSTRANGE, g, gp, mixNeut, alphas, 'd', 2, onetothree);
 gluinoamplitudeneut3ssbar = gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (mGluino, mneut(3), md(1,2), md(2,2), MSTRANGE, g, gp, mixNeut, alphas, 'd', 3, onetothree);
 gluinoamplitudeneut4ssbar = gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (mGluino, mneut(4), md(1,2), md(2,2), MSTRANGE, g, gp, mixNeut, alphas, 'd', 4, onetothree);
 

 gluinoamplitudeneut1ttbar = gluinoamplitudedecaydgaussneutralinottbar (mGluino, mu(1,3), mu(2,3), mneut(1), MTOP, runmw, g, gp, thetat, beta, alphas, mixNeut, runmt, 1, onetothree, 't');
 gluinoamplitudeneut2ttbar = gluinoamplitudedecaydgaussneutralinottbar (mGluino, mu(1,3), mu(2,3), mneut(2), MTOP, runmw, g, gp, thetat, beta, alphas, mixNeut, runmt, 2, onetothree, 't'); 
 gluinoamplitudeneut3ttbar = gluinoamplitudedecaydgaussneutralinottbar (mGluino, mu(1,3), mu(2,3), mneut(3), MTOP, runmw, g, gp, thetat, beta, alphas, mixNeut, runmt, 3, onetothree, 't');
 gluinoamplitudeneut4ttbar = gluinoamplitudedecaydgaussneutralinottbar (mGluino, mu(1,3), mu(2,3), mneut(4), MTOP, runmw, g, gp, thetat, beta, alphas, mixNeut, runmt, 4, onetothree, 't');
 gluinoamplitudeneut1bbbar = gluinoamplitudedecaydgaussneutralinottbar (mGluino, md(1,3), md(2,3), mneut(1), MBOTTOM, runmw, g, gp, thetab, beta, alphas, mixNeut, runmb, 1, onetothree, 'b');
 gluinoamplitudeneut2bbbar = gluinoamplitudedecaydgaussneutralinottbar (mGluino, md(1,3), md(2,3), mneut(2), MBOTTOM, runmw, g, gp, thetab, beta, alphas, mixNeut, runmb, 2, onetothree, 'b');
 gluinoamplitudeneut3bbbar = gluinoamplitudedecaydgaussneutralinottbar (mGluino, md(1,3), md(2,3), mneut(3), MBOTTOM, runmw, g, gp, thetab, beta, alphas, mixNeut, runmb, 3, onetothree, 'b'); 
 gluinoamplitudeneut4bbbar = gluinoamplitudedecaydgaussneutralinottbar (mGluino, md(1,3), md(2,3), mneut(4), MBOTTOM, runmw, g, gp, thetab, beta, alphas, mixNeut, runmb, 4, onetothree, 'b');


 gluinoamplitudegravitinogluon = gluinoamplitudedecaygravitino (mGluino, mgravitino, MPlreduced, gravonoff, gluNLSP);
  
 double gluinoamplitudechar1udbar = 0, gluinoamplitudechar2udbar = 0, gluinoamplitudechar1csbar = 0, gluinoamplitudechar2csbar = 0, gluinoamplitudechar1tbbar = 0, gluinoamplitudechar2tbbar = 0;

 ///1 to 3 decays of gluinos to charginos and q qpbar using dgauss method
 gluinoamplitudechar1udbar = gluinoamplitudedecaydgausscharginoqqpbarfirsttwogen (mGluino, MCH1, MUP, MDOWN, mu(1,1), md(1,1), g, thetaL2, thetaR2, alphas, 1, onetothree);
 gluinoamplitudechar2udbar = gluinoamplitudedecaydgausscharginoqqpbarfirsttwogen (mGluino, MCH2, MUP, MDOWN, mu(1,1), md(1,1), g, thetaL2, thetaR2, alphas, 2, onetothree);
 gluinoamplitudechar1csbar = gluinoamplitudedecaydgausscharginoqqpbarfirsttwogen (mGluino, MCH1, MCHARM, MSTRANGE, mu(1,2), md(1,2), g, thetaL2, thetaR2, alphas, 1, onetothree);
 gluinoamplitudechar2csbar = gluinoamplitudedecaydgausscharginoqqpbarfirsttwogen (mGluino, MCH2, MCHARM, MSTRANGE, mu(1,2), md(1,2), g, thetaL2, thetaR2, alphas, 2, onetothree);


  gluinoamplitudechar1tbbar = gluinoamplitudedecaydgausschartbbar (mGluino, mu(1,3), mu(2,3), md(1,3), md(2,3), MTOP, MBOTTOM, MCH1, alphas, thetat, thetab, runmw, g, gp, thetaL2, thetaR2, beta, runmt, runmb, 1, onetothree);
  gluinoamplitudechar2tbbar = gluinoamplitudedecaydgausschartbbar (mGluino, mu(1,3), mu(2,3), md(1,3), md(2,3), MTOP, MBOTTOM, MCH2, alphas, thetat, thetab, runmw, g, gp, thetaL2, thetaR2, beta, runmt, runmb, 2, onetothree);






 ///Now fill up Array_Decays for the Gluino
 ParticleGluino.Array_Decays[4][0] = PDGup; ParticleGluino.Array_Decays[4][1] = -PDGsupL; ParticleGluino.Array_Decays[4][2] =  gluinoamplitudeupantisupL; ParticleGluino.Array_Decays[4][3] = 2; ParticleGluino.Array_Comments[4] = "# ~g -> u ~u_L*"; 
 ParticleGluino.Array_Decays[5][0] = -PDGup; ParticleGluino.Array_Decays[5][1] = PDGsupL; ParticleGluino.Array_Decays[5][2] = gluinoamplitudeantiupsupL;ParticleGluino.Array_Decays[5][3] = 2; ParticleGluino.Array_Comments[5] = "# ~g -> ub ~u_L";
 ParticleGluino.Array_Decays[6][0] = PDGup;  ParticleGluino.Array_Decays[6][1] = -PDGsupR;  ParticleGluino.Array_Decays[6][2] = gluinoamplitudeupantisupR; ParticleGluino.Array_Decays[6][3] = 2; ParticleGluino.Array_Comments[6] = "# ~g -> u ~u_R*";
 ParticleGluino.Array_Decays[7][0] = -PDGup;  ParticleGluino.Array_Decays[7][1] = PDGsupR;  ParticleGluino.Array_Decays[7][2] = gluinoamplitudeantiupsupR; ParticleGluino.Array_Decays[7][3] = 2; ParticleGluino.Array_Comments[7] = "# ~g -> ub ~u_R";
 ParticleGluino.Array_Decays[0][0] = PDGdown;  ParticleGluino.Array_Decays[0][1] = -PDGsdownL;  ParticleGluino.Array_Decays[0][2] = gluinoamplitudedownantisdownL; ParticleGluino.Array_Decays[0][3] = 2; ParticleGluino.Array_Comments[0] = "# ~g -> d ~d_L*";
 ParticleGluino.Array_Decays[1][0] = -PDGdown;  ParticleGluino.Array_Decays[1][1] = PDGsdownL;  ParticleGluino.Array_Decays[1][2] = gluinoamplitudeantidownsdownL; ParticleGluino.Array_Decays[1][3] = 2; ParticleGluino.Array_Comments[1] = "# ~g -> db ~d_L";
 ParticleGluino.Array_Decays[2][0] = PDGdown;  ParticleGluino.Array_Decays[2][1] = -PDGsdownR;  ParticleGluino.Array_Decays[2][2] = gluinoamplitudedownantisdownR; ParticleGluino.Array_Decays[2][3] = 2; ParticleGluino.Array_Comments[2] = "# ~g -> d ~d_R*";
 ParticleGluino.Array_Decays[3][0] = -PDGdown;  ParticleGluino.Array_Decays[3][1] = PDGsdownR;  ParticleGluino.Array_Decays[3][2] = gluinoamplitudeantidownsdownR; ParticleGluino.Array_Decays[3][3] = 2; ParticleGluino.Array_Comments[3] = "# ~g -> db ~d_R";
 ParticleGluino.Array_Decays[12][0] = PDGcharm;  ParticleGluino.Array_Decays[12][1] = -PDGscharmL;  ParticleGluino.Array_Decays[12][2] = gluinoamplitudecharmantischarmL; ParticleGluino.Array_Decays[12][3] = 2; ParticleGluino.Array_Comments[12] = "# ~g -> c ~c_L*";
 ParticleGluino.Array_Decays[13][0] = -PDGcharm;  ParticleGluino.Array_Decays[13][1] = PDGscharmL;  ParticleGluino.Array_Decays[13][2] = gluinoamplitudeanticharmscharmL; ParticleGluino.Array_Decays[13][3] = 2; ParticleGluino.Array_Comments[13] = "# ~g -> cb ~c_L";
 ParticleGluino.Array_Decays[14][0] = PDGcharm;  ParticleGluino.Array_Decays[14][1] = -PDGscharmR;  ParticleGluino.Array_Decays[14][2] = gluinoamplitudecharmantischarmR; ParticleGluino.Array_Decays[14][3] = 2; ParticleGluino.Array_Comments[14] = "# ~g -> c ~c_R*";
 ParticleGluino.Array_Decays[15][0] = -PDGcharm;  ParticleGluino.Array_Decays[15][1] = PDGscharmR;  ParticleGluino.Array_Decays[15][2] = gluinoamplitudeanticharmscharmR; ParticleGluino.Array_Decays[15][3] = 2; ParticleGluino.Array_Comments[15] = "# ~g -> cb ~c_R";
 ParticleGluino.Array_Decays[8][0] = PDGstrange;  ParticleGluino.Array_Decays[8][1] = -PDGsstrangeL;  ParticleGluino.Array_Decays[8][2]=gluinoamplitudestrangeantisstrangeL; ParticleGluino.Array_Decays[8][3] = 2; ParticleGluino.Array_Comments[8] = "# ~g -> s ~s_L*";
 ParticleGluino.Array_Decays[9][0] = -PDGstrange;  ParticleGluino.Array_Decays[9][1] = PDGsstrangeL;  ParticleGluino.Array_Decays[9][2]=gluinoamplitudeantistrangesstrangeL; ParticleGluino.Array_Decays[9][3] = 2; ParticleGluino.Array_Comments[9] = "# ~g -> sb ~s_L";
 ParticleGluino.Array_Decays[10][0] = PDGstrange;  ParticleGluino.Array_Decays[10][1] = -PDGsstrangeR;  ParticleGluino.Array_Decays[10][2] = gluinoamplitudestrangeantisstrangeR; ParticleGluino.Array_Decays[10][3] = 2; ParticleGluino.Array_Comments[10] = "# ~g -> s ~s_R*";
 ParticleGluino.Array_Decays[11][0] = -PDGstrange;  ParticleGluino.Array_Decays[11][1] = PDGsstrangeR;  ParticleGluino.Array_Decays[11][2] = gluinoamplitudeantistrangesstrangeR; ParticleGluino.Array_Decays[11][3] = 2; ParticleGluino.Array_Comments[11] = "# ~g -> sb ~s_R";
 ParticleGluino.Array_Decays[20][0] = PDGtop;  ParticleGluino.Array_Decays[20][1] = -PDGstop1;  ParticleGluino.Array_Decays[20][2] = gluinoamplitudetopantistop1; ParticleGluino.Array_Decays[20][3] = 2; ParticleGluino.Array_Comments[20] = "# ~g -> t ~t_1*";
 ParticleGluino.Array_Decays[21][0] = -PDGtop;  ParticleGluino.Array_Decays[21][1] = PDGstop1;  ParticleGluino.Array_Decays[21][2] = gluinoamplitudeantitopstop1; ParticleGluino.Array_Decays[21][3] = 2; ParticleGluino.Array_Comments[21] = "# ~g -> tb ~t_1";
 ParticleGluino.Array_Decays[22][0] = PDGtop;  ParticleGluino.Array_Decays[22][1] = -PDGstop2;  ParticleGluino.Array_Decays[22][2] = gluinoamplitudetopantistop2; ParticleGluino.Array_Decays[22][3] = 2; ParticleGluino.Array_Comments[22] = "# ~g -> t ~t_2*";
 ParticleGluino.Array_Decays[23][0] = -PDGtop;  ParticleGluino.Array_Decays[23][1] = PDGstop2;  ParticleGluino.Array_Decays[23][2] = gluinoamplitudeantitopstop2; ParticleGluino.Array_Decays[23][3] = 2; ParticleGluino.Array_Comments[23] = "# ~g -> tb ~t_2";
 ParticleGluino.Array_Decays[16][0] = PDGbottom;  ParticleGluino.Array_Decays[16][1] = -PDGsbottom1;  ParticleGluino.Array_Decays[16][2] = gluinoamplitudebottomantisbottom1; ParticleGluino.Array_Decays[16][3] = 2; ParticleGluino.Array_Comments[16] = "# ~g -> b ~b_1*";
 ParticleGluino.Array_Decays[17][0] = -PDGbottom;  ParticleGluino.Array_Decays[17][1] = PDGsbottom1;  ParticleGluino.Array_Decays[17][2] = gluinoamplitudeantibottomsbottom1; ParticleGluino.Array_Decays[17][3] = 2; ParticleGluino.Array_Comments[17] = "# ~g -> bb ~b_1";
 ParticleGluino.Array_Decays[18][0] = PDGbottom;  ParticleGluino.Array_Decays[18][1] = -PDGsbottom2;  ParticleGluino.Array_Decays[18][2] = gluinoamplitudebottomantisbottom2; ParticleGluino.Array_Decays[18][3] = 2; ParticleGluino.Array_Comments[18] = "# ~g -> b ~b_2*";
 ParticleGluino.Array_Decays[19][0] = -PDGbottom;  ParticleGluino.Array_Decays[19][1] = PDGsbottom2;  ParticleGluino.Array_Decays[19][2] = gluinoamplitudeantibottomsbottom2; ParticleGluino.Array_Decays[19][3] = 2; ParticleGluino.Array_Comments[19] = "# ~g -> bb ~b_2";
 ParticleGluino.Array_Decays[24][0] = PDGgluon; ParticleGluino.Array_Decays[24][1] = PDGgravitino; ParticleGluino.Array_Decays[24][4] = 0; ParticleGluino.Array_Decays[24][2] =  gluinoamplitudegravitinogluon; ParticleGluino.Array_Decays[24][3] = 2; ParticleGluino.Array_Comments[24] = "# ~g -> g ~G";
 ParticleGluino.Array_Decays[25][0] = PDGneutralino1;ParticleGluino.Array_Decays[25][1] = PDGup; ParticleGluino.Array_Decays[25][4] = -PDGup; ParticleGluino.Array_Decays[25][2] = gluinoamplitudeneut1uubar; ParticleGluino.Array_Decays[25][3] = 3; ParticleGluino.Array_Comments[25] = "# ~g -> ~Z1 u ub";
 ParticleGluino.Array_Decays[26][0] = PDGneutralino2;ParticleGluino.Array_Decays[26][1] = PDGup; ParticleGluino.Array_Decays[26][4] = -PDGup; ParticleGluino.Array_Decays[26][2] = gluinoamplitudeneut2uubar; ParticleGluino.Array_Decays[26][3] = 3; ParticleGluino.Array_Comments[26] = "# ~g -> ~Z2 u ub";
 ParticleGluino.Array_Decays[27][0] = PDGneutralino3;ParticleGluino.Array_Decays[27][1] = PDGup; ParticleGluino.Array_Decays[27][4] = -PDGup; ParticleGluino.Array_Decays[27][2] = gluinoamplitudeneut3uubar; ParticleGluino.Array_Decays[27][3] = 3; ParticleGluino.Array_Comments[27] = "# ~g -> ~Z3 u ub";
 ParticleGluino.Array_Decays[28][0] = PDGneutralino4;ParticleGluino.Array_Decays[28][1] = PDGup; ParticleGluino.Array_Decays[28][4] = -PDGup; ParticleGluino.Array_Decays[28][2] = gluinoamplitudeneut4uubar; ParticleGluino.Array_Decays[28][3] = 3; ParticleGluino.Array_Comments[28] = "# ~g -> ~Z4 u ub";
 ParticleGluino.Array_Decays[29][0] = PDGneutralino1;ParticleGluino.Array_Decays[29][1] = PDGdown; ParticleGluino.Array_Decays[29][4] = -PDGdown; ParticleGluino.Array_Decays[29][2] = gluinoamplitudeneut1ddbar; ParticleGluino.Array_Decays[29][3] = 3; ParticleGluino.Array_Comments[29] = "# ~g -> ~Z1 d db";
 ParticleGluino.Array_Decays[30][0] = PDGneutralino2;ParticleGluino.Array_Decays[30][1] = PDGdown; ParticleGluino.Array_Decays[30][4] = -PDGdown; ParticleGluino.Array_Decays[30][2] = gluinoamplitudeneut2ddbar; ParticleGluino.Array_Decays[30][3] = 3; ParticleGluino.Array_Comments[30] = "# ~g -> ~Z2 d db";
 ParticleGluino.Array_Decays[31][0] = PDGneutralino3;ParticleGluino.Array_Decays[31][1] = PDGdown; ParticleGluino.Array_Decays[31][4] = -PDGdown; ParticleGluino.Array_Decays[31][2] = gluinoamplitudeneut3ddbar; ParticleGluino.Array_Decays[31][3] = 3; ParticleGluino.Array_Comments[31] = "# ~g -> ~Z3 d db"; 
 ParticleGluino.Array_Decays[32][0] = PDGneutralino4;ParticleGluino.Array_Decays[32][1] = PDGdown; ParticleGluino.Array_Decays[32][4] = -PDGdown; ParticleGluino.Array_Decays[32][2] = gluinoamplitudeneut4ddbar; ParticleGluino.Array_Decays[32][3] = 3; ParticleGluino.Array_Comments[32] = "# ~g -> ~Z4 d db";
 ParticleGluino.Array_Decays[33][0] = PDGneutralino1;ParticleGluino.Array_Decays[33][1] = PDGcharm; ParticleGluino.Array_Decays[33][4] = -PDGcharm; ParticleGluino.Array_Decays[33][2] = gluinoamplitudeneut1ccbar; ParticleGluino.Array_Decays[33][3] = 3; ParticleGluino.Array_Comments[33] = "# ~g -> ~Z1 c cb";
 ParticleGluino.Array_Decays[34][0] = PDGneutralino2;ParticleGluino.Array_Decays[34][1] = PDGcharm; ParticleGluino.Array_Decays[34][4] = -PDGcharm; ParticleGluino.Array_Decays[34][2] = gluinoamplitudeneut2ccbar; ParticleGluino.Array_Decays[34][3] = 3; ParticleGluino.Array_Comments[34] = "# ~g -> ~Z2 c cb";
 ParticleGluino.Array_Decays[35][0] = PDGneutralino3;ParticleGluino.Array_Decays[35][1] = PDGcharm; ParticleGluino.Array_Decays[35][4] = -PDGcharm; ParticleGluino.Array_Decays[35][2] = gluinoamplitudeneut3ccbar; ParticleGluino.Array_Decays[35][3] = 3; ParticleGluino.Array_Comments[35] = "# ~g -> ~Z3 c cb";
 ParticleGluino.Array_Decays[36][0] = PDGneutralino4;ParticleGluino.Array_Decays[36][1] = PDGcharm; ParticleGluino.Array_Decays[36][4] = -PDGcharm; ParticleGluino.Array_Decays[36][2] = gluinoamplitudeneut4ccbar; ParticleGluino.Array_Decays[36][3] = 3; ParticleGluino.Array_Comments[36] = "# ~g -> ~Z4 c cb";
 ParticleGluino.Array_Decays[37][0] = PDGneutralino1;ParticleGluino.Array_Decays[37][1] = PDGstrange; ParticleGluino.Array_Decays[37][4] = -PDGstrange; ParticleGluino.Array_Decays[37][2] = gluinoamplitudeneut1ssbar; ParticleGluino.Array_Decays[37][3] = 3; ParticleGluino.Array_Comments[37] = "# ~g -> ~Z1 s sb";
 ParticleGluino.Array_Decays[38][0] = PDGneutralino2;ParticleGluino.Array_Decays[38][1] = PDGstrange; ParticleGluino.Array_Decays[38][4] = -PDGstrange; ParticleGluino.Array_Decays[38][2] = gluinoamplitudeneut2ssbar; ParticleGluino.Array_Decays[38][3] = 3; ParticleGluino.Array_Comments[38] = "# ~g -> ~Z2 s sb";
 ParticleGluino.Array_Decays[39][0] = PDGneutralino3;ParticleGluino.Array_Decays[39][1] = PDGstrange; ParticleGluino.Array_Decays[39][4] = -PDGstrange; ParticleGluino.Array_Decays[39][2] = gluinoamplitudeneut3ssbar; ParticleGluino.Array_Decays[39][3] = 3; ParticleGluino.Array_Comments[39] = "# ~g -> ~Z3 s sb";
 ParticleGluino.Array_Decays[40][0] = PDGneutralino4;ParticleGluino.Array_Decays[40][1] = PDGstrange; ParticleGluino.Array_Decays[40][4] = -PDGstrange; ParticleGluino.Array_Decays[40][2] = gluinoamplitudeneut4ssbar; ParticleGluino.Array_Decays[40][3] = 3; ParticleGluino.Array_Comments[40] = "# ~g -> ~Z4 s sb";
 ParticleGluino.Array_Decays[41][0] = PDGchargino1;ParticleGluino.Array_Decays[41][1] = PDGup; ParticleGluino.Array_Decays[41][4] = -PDGdown; ParticleGluino.Array_Decays[41][2] = gluinoamplitudechar1udbar; ParticleGluino.Array_Decays[41][3] = 3; ParticleGluino.Array_Comments[41] = "# ~g -> ~W1+ u db";
 ParticleGluino.Array_Decays[42][0] = -PDGchargino1;ParticleGluino.Array_Decays[42][1] = PDGdown; ParticleGluino.Array_Decays[42][4] = -PDGup; ParticleGluino.Array_Decays[42][2] = gluinoamplitudechar1udbar; ParticleGluino.Array_Decays[42][3] = 3; ParticleGluino.Array_Comments[42] = "# ~g -> ~W1- ub d";
 ParticleGluino.Array_Decays[43][0] = PDGchargino1;ParticleGluino.Array_Decays[43][1] = PDGcharm; ParticleGluino.Array_Decays[43][4] = -PDGstrange; ParticleGluino.Array_Decays[43][2] = gluinoamplitudechar1csbar; ParticleGluino.Array_Decays[43][3] = 3; ParticleGluino.Array_Comments[43] = "# ~g -> ~W1+ c sb";
 ParticleGluino.Array_Decays[44][0] = -PDGchargino1;ParticleGluino.Array_Decays[44][1] = PDGstrange; ParticleGluino.Array_Decays[44][4] = -PDGcharm; ParticleGluino.Array_Decays[44][2] = gluinoamplitudechar1csbar; ParticleGluino.Array_Decays[44][3] = 3; ParticleGluino.Array_Comments[44] = "# ~g -> ~W1- cb s";
 ParticleGluino.Array_Decays[45][0] = PDGchargino2;ParticleGluino.Array_Decays[45][1] = PDGup; ParticleGluino.Array_Decays[45][4] = -PDGdown; ParticleGluino.Array_Decays[45][2] = gluinoamplitudechar2udbar; ParticleGluino.Array_Decays[45][3] = 3; ParticleGluino.Array_Comments[45] = "# ~g -> ~W2+ u db";
 ParticleGluino.Array_Decays[46][0] = -PDGchargino2;ParticleGluino.Array_Decays[46][1] = PDGdown; ParticleGluino.Array_Decays[46][4] = -PDGup; ParticleGluino.Array_Decays[46][2] = gluinoamplitudechar2udbar; ParticleGluino.Array_Decays[46][3] = 3; ParticleGluino.Array_Comments[46] = "# ~g -> ~W2- ub d";
 ParticleGluino.Array_Decays[47][0] = PDGchargino2;ParticleGluino.Array_Decays[47][1] = PDGcharm; ParticleGluino.Array_Decays[47][4] = -PDGstrange; ParticleGluino.Array_Decays[47][2] = gluinoamplitudechar2csbar; ParticleGluino.Array_Decays[47][3] = 3; ParticleGluino.Array_Comments[47] = "# ~g -> ~W2+ c sb";
 ParticleGluino.Array_Decays[48][0] = -PDGchargino2;ParticleGluino.Array_Decays[48][1] = PDGstrange; ParticleGluino.Array_Decays[48][4] = -PDGcharm; ParticleGluino.Array_Decays[48][2] = gluinoamplitudechar2csbar; ParticleGluino.Array_Decays[48][3] = 3; ParticleGluino.Array_Comments[48] = "# ~g -> ~W2- cb s";  
 ParticleGluino.Array_Decays[49][0] = PDGneutralino1; ParticleGluino.Array_Decays[49][1] = PDGtop; ParticleGluino.Array_Decays[49][4] = -PDGtop;  ParticleGluino.Array_Decays[49][2] = gluinoamplitudeneut1ttbar;  ParticleGluino.Array_Decays[49][3] = 3; ParticleGluino.Array_Comments[49] = "# ~g -> ~Z1 t tb";
 ParticleGluino.Array_Decays[50][0] = PDGneutralino2; ParticleGluino.Array_Decays[50][1] = PDGtop; ParticleGluino.Array_Decays[50][4] = -PDGtop;  ParticleGluino.Array_Decays[50][2] = gluinoamplitudeneut2ttbar;  ParticleGluino.Array_Decays[50][3] = 3; ParticleGluino.Array_Comments[50] = "# ~g -> ~Z2 t tb";
 ParticleGluino.Array_Decays[51][0] = PDGneutralino3; ParticleGluino.Array_Decays[51][1] = PDGtop; ParticleGluino.Array_Decays[51][4] = -PDGtop;  ParticleGluino.Array_Decays[51][2] = gluinoamplitudeneut3ttbar;  ParticleGluino.Array_Decays[51][3] = 3; ParticleGluino.Array_Comments[51] = "# ~g -> ~Z3 t tb";
 ParticleGluino.Array_Decays[52][0] = PDGneutralino4; ParticleGluino.Array_Decays[52][1] = PDGtop; ParticleGluino.Array_Decays[52][4] = -PDGtop;  ParticleGluino.Array_Decays[52][2] = gluinoamplitudeneut4ttbar;  ParticleGluino.Array_Decays[52][3] = 3; ParticleGluino.Array_Comments[52] = "# ~g -> ~Z4 t tb";
ParticleGluino.Array_Decays[53][0] = PDGneutralino1; ParticleGluino.Array_Decays[53][1] = PDGbottom; ParticleGluino.Array_Decays[53][4] = -PDGbottom;  ParticleGluino.Array_Decays[53][2] = gluinoamplitudeneut1bbbar;  ParticleGluino.Array_Decays[53][3] = 3; ParticleGluino.Array_Comments[53] = "# ~g -> ~Z1 b bb";
 ParticleGluino.Array_Decays[54][0] = PDGneutralino2; ParticleGluino.Array_Decays[54][1] = PDGbottom; ParticleGluino.Array_Decays[54][4] = -PDGbottom;  ParticleGluino.Array_Decays[54][2] = gluinoamplitudeneut2bbbar;  ParticleGluino.Array_Decays[54][3] = 3; ParticleGluino.Array_Comments[54] = "# ~g -> ~Z2 b bb";
 ParticleGluino.Array_Decays[55][0] = PDGneutralino3; ParticleGluino.Array_Decays[55][1] = PDGbottom; ParticleGluino.Array_Decays[55][4] = -PDGbottom;  ParticleGluino.Array_Decays[55][2] = gluinoamplitudeneut3bbbar;  ParticleGluino.Array_Decays[55][3] = 3; ParticleGluino.Array_Comments[55] = "# ~g -> ~Z3 b bb";
 ParticleGluino.Array_Decays[56][0] = PDGneutralino4; ParticleGluino.Array_Decays[56][1] = PDGbottom; ParticleGluino.Array_Decays[56][4] = -PDGbottom;  ParticleGluino.Array_Decays[56][2] = gluinoamplitudeneut4bbbar;  ParticleGluino.Array_Decays[56][3] = 3; ParticleGluino.Array_Comments[56] = "# ~g -> ~Z4 b bb";
 ParticleGluino.Array_Decays[57][0] = PDGchargino1; ParticleGluino.Array_Decays[57][1] = -PDGtop; ParticleGluino.Array_Decays[57][4] = PDGbottom; ParticleGluino.Array_Decays[57][2] =  gluinoamplitudechar1tbbar; ParticleGluino.Array_Decays[57][3] = 3; ParticleGluino.Array_Comments[57] = "# ~g -> ~W1+ tb b";
 ParticleGluino.Array_Decays[58][0] = -PDGchargino1; ParticleGluino.Array_Decays[58][1] = PDGtop; ParticleGluino.Array_Decays[58][4] = -PDGbottom; ParticleGluino.Array_Decays[58][2] =  gluinoamplitudechar1tbbar; ParticleGluino.Array_Decays[58][3] = 3; ParticleGluino.Array_Comments[58] = "# ~g -> ~W1- t bb";
 ParticleGluino.Array_Decays[59][0] = PDGchargino2; ParticleGluino.Array_Decays[59][1] = -PDGtop; ParticleGluino.Array_Decays[59][4] = PDGbottom; ParticleGluino.Array_Decays[59][2] =  gluinoamplitudechar2tbbar; ParticleGluino.Array_Decays[59][3] = 3; ParticleGluino.Array_Comments[59] = "# ~g -> ~W2+ tb b";
 ParticleGluino.Array_Decays[60][0] = -PDGchargino2; ParticleGluino.Array_Decays[60][1] = PDGtop; ParticleGluino.Array_Decays[60][4] = -PDGbottom; ParticleGluino.Array_Decays[60][2] =  gluinoamplitudechar2tbbar; ParticleGluino.Array_Decays[60][3] = 3; ParticleGluino.Array_Comments[60] = "# ~g -> ~W2- t bb";

 double Gluino_No_1to2_Decays = 0;
 ParticleGluino.two_width = 0;
 ParticleGluino.three_width = 0;

  if (gluNLSP == 1) { Gluino_No_1to2_Decays = ParticleGluino.No_1to2_Decays + ParticleGluino.No_grav_Decays;}
  else {Gluino_No_1to2_Decays = ParticleGluino.No_1to2_Decays;}
   
 for (int j = 0; j<Gluino_No_1to2_Decays; j++) {
   ParticleGluino.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
  }

 for (int j=0; j<Gluino_No_1to2_Decays; j++) {
    ParticleGluino.two_width = ParticleGluino.two_width + ParticleGluino.Array_Decays[j][2];
  }
 for (int j=Gluino_No_1to2_Decays; j<ParticleGluino.No_of_Decays; j++) {
   ParticleGluino.three_width = ParticleGluino.three_width + ParticleGluino.Array_Decays[j][2];
 }
  
  if ( ParticleGluino.three_width != ParticleGluino.three_width) /// Tests for a nan as only nans aren't equal to themselves
    {
      cout << "Three body decays give nan for gluino - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
      ParticleGluino.No_of_Decays = Gluino_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
      ParticleGluino.total_width = ParticleGluino.two_width;
    }
  else {
    ParticleGluino.total_width = ParticleGluino.two_width + ParticleGluino.three_width;
  }
   
  for (int i =0; i<ParticleGluino.No_of_Decays; i++) {
     ParticleGluino.Array_Decays[i][5]= ParticleGluino.Array_Decays[i][2]/ParticleGluino.total_width;
   }

 
 // cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 // cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleGluino.PDG << setw(12) << scientific << setprecision(8) <<  ParticleGluino.total_width << "   " << "# gluino decays" << endl;
 // cout.precision(7);
 // cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 // for (int k=0; k<ParticleGluino.No_of_Decays; k++) {
 //   if( ParticleGluino.Array_Decays[k][2] != 0 && ParticleGluino.Array_Decays[k][5] > BRTol) {
 //         cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleGluino.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleGluino.Array_Decays[k][3];  printRowPDG(cout, ParticleGluino.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleGluino.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleGluino.Array_Comments[k] << endl;
 //   }
 // }
 // cout << "#" << endl;

///Uncomment section below if want partial widths as well as branching ratios
  cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleGluino.PDG << setw(12) << scientific << setprecision(8) <<  ParticleGluino.total_width << "   " << "# gluino decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "PW" << setw(18) << "BR" << setw(8) << "NDA" << setw(12) << left << " PDG1" << setw(12) << " PDG2" << setw(12) << " PDG3 " << endl;
 for (int k=0; k<ParticleGluino.No_of_Decays; k++) {
   if( ParticleGluino.Array_Decays[k][2] != 0 && ParticleGluino.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleGluino.Array_Decays[k][2] << setprecision(8) << ParticleGluino.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << " " << ParticleGluino.Array_Decays[k][3] << setw(4) << " ";  printRowPDG(cout, ParticleGluino.Array_Decays[k][0]); cout << "    "; printRowPDG(cout,ParticleGluino.Array_Decays[k][1]); cout << "    "; printRowPDG(cout,ParticleGluino.Array_Decays[k][4]); cout << "   " << left << setprecision(0) << setw(15) << ParticleGluino.Array_Comments[k] << endl;
     }
 }
 cout << "#" << endl; 

 ///}
 
 ///Squark Decays

 ///SdownL Decays

 double sdownLamplitudegluinodown, sdownLamplitudedownneutralinoZ1, sdownLamplitudedownneutralinoZ2, sdownLamplitudedownneutralinoZ3,  sdownLamplitudedownneutralinoZ4, sdownLamplitudecharginoW1up, sdownLamplitudecharginoW2up, sdownLamplitudedowngravitino;

 sdownLamplitudegluinodown =  squarkamplitudedecaygluino (md(1,1), MDOWN, mGluino, alphas);
 sdownLamplitudecharginoW1up = squarkamplitudedecaycharginoW1 (md(1,1), MUP, MCH1, g, thetaL2);
 sdownLamplitudecharginoW2up = squarkamplitudedecaycharginoW2 (md(1,1), MUP, MCH2, g, thetaL2);
 sdownLamplitudedownneutralinoZ1 = squarkLamplitudedecayneutralino(md(1,1), MDOWN, mneut(1), g, gp, mixNeut, 1, -1);
 sdownLamplitudedownneutralinoZ2 = squarkLamplitudedecayneutralino(md(1,1), MDOWN, mneut(2), g, gp, mixNeut, 2, -1);
 sdownLamplitudedownneutralinoZ3 = squarkLamplitudedecayneutralino(md(1,1), MDOWN, mneut(3), g, gp, mixNeut, 3, -1);
 sdownLamplitudedownneutralinoZ4 = squarkLamplitudedecayneutralino(md(1,1), MDOWN, mneut(4), g, gp, mixNeut, 4, -1);
 sdownLamplitudedowngravitino = squarkamplitudedecaygravitino(md(1,1), mgravitino, MDOWN, MPlreduced, gravonoff, downsquNLSP);
 

 ParticleSdownL.Array_Decays[0][0] = PDGdown; ParticleSdownL.Array_Decays[0][1] = PDGgluino; ParticleSdownL.Array_Decays[0][2] = sdownLamplitudegluinodown; ParticleSdownL.Array_Decays[0][3] = 2; ParticleSdownL.Array_Comments[0] = "# ~d_L -> d ~g";
 ParticleSdownL.Array_Decays[1][0] = PDGup; ParticleSdownL.Array_Decays[1][1] = -PDGchargino1; ParticleSdownL.Array_Decays[1][2] = sdownLamplitudecharginoW1up; ParticleSdownL.Array_Decays[1][3] = 2; ParticleSdownL.Array_Comments[1] = "# ~d_L -> u ~chi_1-" ;
 ParticleSdownL.Array_Decays[2][0] = PDGup; ParticleSdownL.Array_Decays[2][1] = -PDGchargino2; ParticleSdownL.Array_Decays[2][2] = sdownLamplitudecharginoW2up; ParticleSdownL.Array_Decays[2][3] = 2; ParticleSdownL.Array_Comments[2] = "# ~d_L -> u ~chi_2-";
 ParticleSdownL.Array_Decays[3][0] = PDGdown; ParticleSdownL.Array_Decays[3][1] = PDGneutralino1; ParticleSdownL.Array_Decays[3][2] = sdownLamplitudedownneutralinoZ1; ParticleSdownL.Array_Decays[3][3] = 2; ParticleSdownL.Array_Comments[3] = "# ~d_L -> d ~chi_10";
 ParticleSdownL.Array_Decays[4][0] = PDGdown; ParticleSdownL.Array_Decays[4][1] = PDGneutralino2; ParticleSdownL.Array_Decays[4][2] = sdownLamplitudedownneutralinoZ2; ParticleSdownL.Array_Decays[4][3] = 2; ParticleSdownL.Array_Comments[4] = "# ~d_L -> d ~chi_20";
 ParticleSdownL.Array_Decays[5][0] = PDGdown; ParticleSdownL.Array_Decays[5][1] = PDGneutralino3; ParticleSdownL.Array_Decays[5][2] = sdownLamplitudedownneutralinoZ3; ParticleSdownL.Array_Decays[5][3] = 2; ParticleSdownL.Array_Comments[5] = "# ~d_L -> d ~chi_30";
 ParticleSdownL.Array_Decays[6][0] = PDGdown; ParticleSdownL.Array_Decays[6][1] = PDGneutralino4; ParticleSdownL.Array_Decays[6][2] = sdownLamplitudedownneutralinoZ4; ParticleSdownL.Array_Decays[6][3] = 2; ParticleSdownL.Array_Comments[6] = "# ~d_L -> d ~chi_40";
 ParticleSdownL.Array_Decays[7][0] = PDGdown; ParticleSdownL.Array_Decays[7][1] = PDGgravitino; ParticleSdownL.Array_Decays[7][2] = sdownLamplitudedowngravitino; ParticleSdownL.Array_Decays[7][3] = 2; ParticleSdownL.Array_Comments[7] = "# ~d_L -> d ~G";

 double SdownL_No_1to2_Decays = 0;

 if (downsquNLSP == 1) { SdownL_No_1to2_Decays = ParticleSdownL.No_1to2_Decays + ParticleSdownL.No_grav_Decays;}
 else {SdownL_No_1to2_Decays = ParticleSdownL.No_1to2_Decays;}
 
 for (int j = 0; j<SdownL_No_1to2_Decays; j++) {
   ParticleSdownL.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<SdownL_No_1to2_Decays; j++) {
   ParticleSdownL.two_width = ParticleSdownL.two_width + ParticleSdownL.Array_Decays[j][2];
 }
 for (int j=SdownL_No_1to2_Decays; j<ParticleSdownL.No_of_Decays; j++) {
   ParticleSdownL.three_width = ParticleSdownL.three_width + ParticleSdownL.Array_Decays[j][2];
 }
 
 if ( ParticleSdownL.three_width != ParticleSdownL.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for sdownL - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleSdownL.No_of_Decays = SdownL_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleSdownL.total_width = ParticleSdownL.two_width;
   }
 else {
   ParticleSdownL.total_width = ParticleSdownL.two_width + ParticleSdownL.three_width;
 }
 
 for (int i =0; i<ParticleSdownL.No_of_Decays; i++) {
   ParticleSdownL.Array_Decays[i][5]= ParticleSdownL.Array_Decays[i][2]/ParticleSdownL.total_width;
 }
 
 
 /// if (ParticleSdownL.total_width < 1.00e-300)
 ///    ParticleSdownL.total_width = 0.00;
  
  cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
  cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleSdownL.PDG << setw(12) << scientific << setprecision(8) <<  ParticleSdownL.total_width << "   " << "# sdown_L decays" << endl;
  cout.precision(7);
  cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
  for (int k=0; k<ParticleSdownL.No_of_Decays; k++) {
    if( ParticleSdownL.Array_Decays[k][2] != 0 && ParticleSdownL.Array_Decays[k][5] > BRTol) {
      cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleSdownL.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleSdownL.Array_Decays[k][3];  printRowPDG(cout, ParticleSdownL.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleSdownL.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleSdownL.Array_Comments[k] << endl;
    }
    else {}
  }
  cout << "#" << endl;
  
  ///SdownR Decays

  double sdownRamplitudegluinodown, sdownRamplitudedownneutralinoZ1, sdownRamplitudedownneutralinoZ2, sdownRamplitudedownneutralinoZ3, sdownRamplitudedownneutralinoZ4, sdownRamplitudedowngravitino;

 sdownRamplitudegluinodown = squarkamplitudedecaygluino (md(2,1), MDOWN, mGluino, alphas);
 sdownRamplitudedownneutralinoZ1 = squarkRamplitudedecayneutralino (md(2,1), MDOWN, mneut(1), g, gp, mixNeut, 1, -1);
 sdownRamplitudedownneutralinoZ2 = squarkRamplitudedecayneutralino (md(2,1), MDOWN, mneut(2), g, gp, mixNeut, 2, -1);
 sdownRamplitudedownneutralinoZ3 = squarkRamplitudedecayneutralino (md(2,1), MDOWN, mneut(3), g, gp, mixNeut, 3, -1);
 sdownRamplitudedownneutralinoZ4 = squarkRamplitudedecayneutralino (md(2,1), MDOWN, mneut(4), g, gp, mixNeut, 4, -1);
 sdownRamplitudedowngravitino = squarkamplitudedecaygravitino(md(2,1), mgravitino, MDOWN, MPlreduced, gravonoff, downsquNLSP);

 ParticleSdownR.Array_Decays[0][0] = PDGdown; ParticleSdownR.Array_Decays[0][1] = PDGgluino; ParticleSdownR.Array_Decays[0][2] = sdownRamplitudegluinodown; ParticleSdownR.Array_Decays[0][3] = 2; ParticleSdownR.Array_Comments[0] = "# ~d_R -> d ~g";
 ParticleSdownR.Array_Decays[1][0] = PDGdown; ParticleSdownR.Array_Decays[1][1] = PDGneutralino1; ParticleSdownR.Array_Decays[1][2] = sdownRamplitudedownneutralinoZ1; ParticleSdownR.Array_Decays[1][3] = 2; ParticleSdownR.Array_Comments[1] = "# ~d_R -> d ~chi_10";
 ParticleSdownR.Array_Decays[2][0] = PDGdown; ParticleSdownR.Array_Decays[2][1] = PDGneutralino2; ParticleSdownR.Array_Decays[2][2] = sdownRamplitudedownneutralinoZ2; ParticleSdownR.Array_Decays[2][3] = 2; ParticleSdownR.Array_Comments[2] = "# ~d_R -> d ~chi_20";
 ParticleSdownR.Array_Decays[3][0] = PDGdown; ParticleSdownR.Array_Decays[3][1] = PDGneutralino3; ParticleSdownR.Array_Decays[3][2] = sdownRamplitudedownneutralinoZ3; ParticleSdownR.Array_Decays[3][3] = 2; ParticleSdownR.Array_Comments[3] = "# ~d_R -> d ~chi_30";
 ParticleSdownR.Array_Decays[4][0] = PDGdown; ParticleSdownR.Array_Decays[4][1] = PDGneutralino4; ParticleSdownR.Array_Decays[4][2] = sdownRamplitudedownneutralinoZ4; ParticleSdownR.Array_Decays[4][3] = 2; ParticleSdownR.Array_Comments[4] = "# ~d_R -> d ~chi_40";

 ParticleSdownR.Array_Decays[5][0] = PDGdown; ParticleSdownR.Array_Decays[5][1] = PDGgravitino; ParticleSdownR.Array_Decays[5][2] = sdownRamplitudedowngravitino; ParticleSdownR.Array_Decays[5][3] = 2; ParticleSdownR.Array_Comments[5] = "# ~d_R -> d ~G";

 double SdownR_No_1to2_Decays = 0;

 if (downsquNLSP == 1) { SdownR_No_1to2_Decays = ParticleSdownR.No_1to2_Decays + ParticleSdownR.No_grav_Decays;}
 else {SdownR_No_1to2_Decays = ParticleSdownR.No_1to2_Decays;}
 
 for (int j = 0; j<SdownR_No_1to2_Decays; j++) {
   ParticleSdownR.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<SdownR_No_1to2_Decays; j++) {
   ParticleSdownR.two_width = ParticleSdownR.two_width + ParticleSdownR.Array_Decays[j][2];
 }
 for (int j=SdownR_No_1to2_Decays; j<ParticleSdownR.No_of_Decays; j++) {
   ParticleSdownR.three_width = ParticleSdownR.three_width + ParticleSdownR.Array_Decays[j][2];
 }
 
 if ( ParticleSdownR.three_width != ParticleSdownR.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for sdownR - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleSdownR.No_of_Decays = SdownR_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleSdownR.total_width = ParticleSdownR.two_width;
   }
 else {
   ParticleSdownR.total_width = ParticleSdownR.two_width + ParticleSdownR.three_width;
 }
 
 for (int i =0; i<ParticleSdownR.No_of_Decays; i++) {
   ParticleSdownR.Array_Decays[i][5]= ParticleSdownR.Array_Decays[i][2]/ParticleSdownR.total_width;
 }

  cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
  cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleSdownR.PDG << setw(12) << scientific << setprecision(8) <<  ParticleSdownR.total_width << "   " << "# sdown_R decays" << endl;
  cout.precision(7);
  cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
  for (int k=0; k<ParticleSdownR.No_of_Decays; k++) {
    if( ParticleSdownR.Array_Decays[k][2] != 0 && ParticleSdownR.Array_Decays[k][5] > BRTol) {
      cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleSdownR.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleSdownR.Array_Decays[k][3];  printRowPDG(cout, ParticleSdownR.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleSdownR.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleSdownR.Array_Comments[k] << endl;
    }
  }
  cout << "#" << endl; 

 ///SupL Decays
 
  double supLamplitudegluinoup, supLamplitudeupneutralinoZ1, supLamplitudeupneutralinoZ2,  supLamplitudeupneutralinoZ3,  supLamplitudeupneutralinoZ4, supLamplitudecharginoW1down, supLamplitudecharginoW2down, supLamplitudeupgravitino;

 supLamplitudegluinoup = squarkamplitudedecaygluino (mu(1,1), MUP, mGluino, alphas);
 supLamplitudecharginoW1down = squarkamplitudedecaycharginoW1 (mu(1,1), MDOWN, MCH1, g, thetaR2);
 supLamplitudecharginoW2down = squarkamplitudedecaycharginoW2 (mu(1,1), MDOWN, MCH2, g, thetaR2);
 supLamplitudeupneutralinoZ1 = squarkLamplitudedecayneutralino (mu(1,1), MUP, mneut(1), g, gp, mixNeut, 1, 1);
 supLamplitudeupneutralinoZ2 = squarkLamplitudedecayneutralino (mu(1,1), MUP, mneut(2), g, gp, mixNeut, 2, 1);
 supLamplitudeupneutralinoZ3 = squarkLamplitudedecayneutralino (mu(1,1), MUP, mneut(3), g, gp, mixNeut, 3, 1);
 supLamplitudeupneutralinoZ4 = squarkLamplitudedecayneutralino (mu(1,1), MUP, mneut(4), g, gp, mixNeut, 4, 1);
 ///supLamplitudeupneutralinoZ1 =  squark1amplitudedecayneutralinomix (mu(1,1), MUP, mneut(1), g, gp, 0, beta, mw, mixNeut, runmt, runmb, 1, 1);
 ///supLamplitudeupneutralinoZ2 =  squark1amplitudedecayneutralinomix (mu(1,1), MUP, mneut(2), g, gp, 0, beta, mw, mixNeut, runmt, runmb, 2, 1);
 ///supLamplitudeupneutralinoZ3 =  squark1amplitudedecayneutralinomix (mu(1,1), MUP, mneut(3), g, gp, 0, beta, mw, mixNeut, runmt, runmb, 3, 1);
 ///supLamplitudeupneutralinoZ4 =  squark1amplitudedecayneutralinomix (mu(1,1), MUP, mneut(4), g, gp, 0, beta, mw, mixNeut, runmt, runmb, 4, 1);

 supLamplitudeupgravitino = squarkamplitudedecaygravitino (mu(1,1), mgravitino, MUP, MPlreduced, gravonoff, upsquNLSP);

 ParticleSupL.Array_Decays[0][0] = PDGup; ParticleSupL.Array_Decays[0][1] = PDGgluino; ParticleSupL.Array_Decays[0][2] = supLamplitudegluinoup; ParticleSupL.Array_Decays[0][3] = 2; ParticleSupL.Array_Comments[0] = "# ~u_L -> u ~g";
 ParticleSupL.Array_Decays[1][0] = PDGdown; ParticleSupL.Array_Decays[1][1] = PDGchargino1; ParticleSupL.Array_Decays[1][2] = supLamplitudecharginoW1down; ParticleSupL.Array_Decays[1][3] = 2; ParticleSupL.Array_Comments[1] = "# ~u_L -> d ~chi_1+";
 ParticleSupL.Array_Decays[2][0] = PDGdown; ParticleSupL.Array_Decays[2][1] = PDGchargino2; ParticleSupL.Array_Decays[2][2] = supLamplitudecharginoW2down; ParticleSupL.Array_Decays[2][3] = 2; ParticleSupL.Array_Comments[2] = "# ~u_L -> d ~chi_2+";
 ParticleSupL.Array_Decays[3][0] = PDGup; ParticleSupL.Array_Decays[3][1] = PDGneutralino1; ParticleSupL.Array_Decays[3][2] = supLamplitudeupneutralinoZ1; ParticleSupL.Array_Decays[3][3] = 2; ParticleSupL.Array_Comments[3] = "# ~u_L -> u ~chi_10";
 ParticleSupL.Array_Decays[4][0] = PDGup; ParticleSupL.Array_Decays[4][1] = PDGneutralino2; ParticleSupL.Array_Decays[4][2] = supLamplitudeupneutralinoZ2; ParticleSupL.Array_Decays[4][3] = 2; ParticleSupL.Array_Comments[4] = "# ~u_L -> u ~chi_20";
 ParticleSupL.Array_Decays[5][0] = PDGup; ParticleSupL.Array_Decays[5][1] = PDGneutralino3; ParticleSupL.Array_Decays[5][2] = supLamplitudeupneutralinoZ3; ParticleSupL.Array_Decays[5][3] = 2; ParticleSupL.Array_Comments[5] = "# ~u_L -> u ~chi_30";
 ParticleSupL.Array_Decays[6][0] = PDGup; ParticleSupL.Array_Decays[6][1] = PDGneutralino4; ParticleSupL.Array_Decays[6][2] = supLamplitudeupneutralinoZ4; ParticleSupL.Array_Decays[6][3] = 2; ParticleSupL.Array_Comments[6] = "# ~u_L -> u ~chi_40";

 ParticleSupL.Array_Decays[7][0] = PDGup; ParticleSupL.Array_Decays[7][1] = PDGgravitino; ParticleSupL.Array_Decays[7][2] = supLamplitudeupgravitino; ParticleSupL.Array_Decays[7][3] = 2; ParticleSupL.Array_Comments[7] = "# ~u_L -> u ~G";

 double SupL_No_1to2_Decays = 0;

 if (upsquNLSP == 1) { SupL_No_1to2_Decays = ParticleSupL.No_1to2_Decays + ParticleSupL.No_grav_Decays;}
 else {SupL_No_1to2_Decays = ParticleSupL.No_1to2_Decays;}
 
 for (int j = 0; j<SupL_No_1to2_Decays; j++) {
   ParticleSupL.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<SupL_No_1to2_Decays; j++) {
   ParticleSupL.two_width = ParticleSupL.two_width + ParticleSupL.Array_Decays[j][2];
 }
 for (int j=SupL_No_1to2_Decays; j<ParticleSupL.No_of_Decays; j++) {
   ParticleSupL.three_width = ParticleSupL.three_width + ParticleSupL.Array_Decays[j][2];
 }
 
 if ( ParticleSupL.three_width != ParticleSupL.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for supL - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleSupL.No_of_Decays = SupL_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleSupL.total_width = ParticleSupL.two_width;
   }
 else {
   ParticleSupL.total_width = ParticleSupL.two_width + ParticleSupL.three_width;
 }
 
 for (int i =0; i<ParticleSupL.No_of_Decays; i++) {
   ParticleSupL.Array_Decays[i][5]= ParticleSupL.Array_Decays[i][2]/ParticleSupL.total_width;
 }


 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleSupL.PDG << setw(12) << scientific << setprecision(8) <<  ParticleSupL.total_width << "   " << "# sup_L decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleSupL.No_of_Decays; k++) {
   if( ParticleSupL.Array_Decays[k][2] != 0 && ParticleSupL.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleSupL.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleSupL.Array_Decays[k][3];  printRowPDG(cout, ParticleSupL.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleSupL.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleSupL.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;

 ///SupR Decays

 double supRamplitudegluinoup, supRamplitudeupneutralinoZ1, supRamplitudeupneutralinoZ2,  supRamplitudeupneutralinoZ3,  supRamplitudeupneutralinoZ4, supRamplitudeupgravitino;

 supRamplitudegluinoup = squarkamplitudedecaygluino (mu(2,1), MUP, mGluino, alphas);
 supRamplitudeupneutralinoZ1 = squarkRamplitudedecayneutralino (mu(2,1), MUP, mneut(1), g, gp, mixNeut, 1, 1);
 supRamplitudeupneutralinoZ2 = squarkRamplitudedecayneutralino (mu(2,1), MUP, mneut(2), g, gp, mixNeut, 2, 1);
 supRamplitudeupneutralinoZ3 = squarkRamplitudedecayneutralino (mu(2,1), MUP, mneut(3), g, gp, mixNeut, 3, 1);
 supRamplitudeupneutralinoZ4 = squarkRamplitudedecayneutralino (mu(2,1), MUP, mneut(4), g, gp, mixNeut, 4, 1);
 supRamplitudeupgravitino = squarkamplitudedecaygravitino(mu(2,1), mgravitino, MUP, MPlreduced, gravonoff, upsquNLSP);

 ParticleSupR.Array_Decays[0][0] = PDGup; ParticleSupR.Array_Decays[0][1] = PDGgluino; ParticleSupR.Array_Decays[0][2] = supRamplitudegluinoup; ParticleSupR.Array_Decays[0][3] = 2; ParticleSupR.Array_Comments[0] = "# ~u_R -> u ~g";
 ParticleSupR.Array_Decays[1][0] = PDGup; ParticleSupR.Array_Decays[1][1] = PDGneutralino1; ParticleSupR.Array_Decays[1][2] = supRamplitudeupneutralinoZ1; ParticleSupR.Array_Decays[1][3] = 2; ParticleSupR.Array_Comments[1] = "# ~u_R -> u ~chi_10";
 ParticleSupR.Array_Decays[2][0] = PDGup; ParticleSupR.Array_Decays[2][1] = PDGneutralino2; ParticleSupR.Array_Decays[2][2] = supRamplitudeupneutralinoZ2; ParticleSupR.Array_Decays[2][3] = 2; ParticleSupR.Array_Comments[2] = "# ~u_R -> u ~chi_20";
 ParticleSupR.Array_Decays[3][0] = PDGup; ParticleSupR.Array_Decays[3][1] = PDGneutralino3; ParticleSupR.Array_Decays[3][2] = supRamplitudeupneutralinoZ3; ParticleSupR.Array_Decays[3][3] = 2; ParticleSupR.Array_Comments[3] = "# ~u_R -> u ~chi_30";
 ParticleSupR.Array_Decays[4][0] = PDGup; ParticleSupR.Array_Decays[4][1] = PDGneutralino4; ParticleSupR.Array_Decays[4][2] = supRamplitudeupneutralinoZ4; ParticleSupR.Array_Decays[4][3] = 2; ParticleSupR.Array_Comments[4] = "# ~u_R -> u ~chi_40";

 ParticleSupR.Array_Decays[5][0] = PDGup; ParticleSupR.Array_Decays[5][1] = PDGgravitino; ParticleSupR.Array_Decays[5][2] = supRamplitudeupgravitino; ParticleSupR.Array_Decays[5][3] = 2; ParticleSupR.Array_Comments[5] = "# ~u_R -> u ~G";

 double SupR_No_1to2_Decays = 0;

 if (upsquNLSP == 1) { SupR_No_1to2_Decays = ParticleSupR.No_1to2_Decays + ParticleSupR.No_grav_Decays;}
 else {SupR_No_1to2_Decays = ParticleSupR.No_1to2_Decays;}
 
 for (int j = 0; j<SupR_No_1to2_Decays; j++) {
   ParticleSupR.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<SupR_No_1to2_Decays; j++) {
   ParticleSupR.two_width = ParticleSupR.two_width + ParticleSupR.Array_Decays[j][2];
 }
 for (int j=SupR_No_1to2_Decays; j<ParticleSupR.No_of_Decays; j++) {
   ParticleSupR.three_width = ParticleSupR.three_width + ParticleSupR.Array_Decays[j][2];
 }
 
 if ( ParticleSupR.three_width != ParticleSupR.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for supR - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleSupR.No_of_Decays = SupR_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleSupR.total_width = ParticleSupR.two_width;
   }
 else {
   ParticleSupR.total_width = ParticleSupR.two_width + ParticleSupR.three_width;
 }
 
 for (int i =0; i<ParticleSupR.No_of_Decays; i++) {
   ParticleSupR.Array_Decays[i][5]= ParticleSupR.Array_Decays[i][2]/ParticleSupR.total_width;
 }


 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleSupR.PDG << setw(12) << scientific << setprecision(8) <<  ParticleSupR.total_width << "   " << "# sup_R decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleSupR.No_of_Decays; k++) {
   if( ParticleSupR.Array_Decays[k][2] != 0 && ParticleSupR.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleSupR.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleSupR.Array_Decays[k][3];  printRowPDG(cout, ParticleSupR.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleSupR.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleSupR.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;

 ///SstrangeL Decays

 double sstrangeLamplitudegluinostrange, sstrangeLamplitudestrangeneutralinoZ1,  sstrangeLamplitudestrangeneutralinoZ2,  sstrangeLamplitudestrangeneutralinoZ3,  sstrangeLamplitudestrangeneutralinoZ4,  sstrangeLamplitudecharginoW1charm, sstrangeLamplitudecharginoW2charm, sstrangeLamplitudestrangegravitino;

 sstrangeLamplitudegluinostrange = squarkamplitudedecaygluino (md(1,2), MSTRANGE, mGluino, alphas);
 sstrangeLamplitudecharginoW1charm = squarkamplitudedecaycharginoW1 (md(1,2), MCHARM, MCH1, g, thetaL2);
 sstrangeLamplitudecharginoW2charm = squarkamplitudedecaycharginoW2 (md(1,2), MCHARM, MCH2, g, thetaL2);
 sstrangeLamplitudestrangeneutralinoZ1 = squarkLamplitudedecayneutralino (md(1,2), MSTRANGE, mneut(1), g, gp, mixNeut, 1, -1);
 sstrangeLamplitudestrangeneutralinoZ2 = squarkLamplitudedecayneutralino (md(1,2), MSTRANGE, mneut(2), g, gp, mixNeut, 2, -1);
 sstrangeLamplitudestrangeneutralinoZ3 = squarkLamplitudedecayneutralino (md(1,2), MSTRANGE, mneut(3), g, gp, mixNeut, 3, -1);
 sstrangeLamplitudestrangeneutralinoZ4 = squarkLamplitudedecayneutralino (md(1,2), MSTRANGE, mneut(4), g, gp, mixNeut, 4, -1);
 
 sstrangeLamplitudestrangegravitino = squarkamplitudedecaygravitino (md(1,2), mgravitino, MSTRANGE, MPlreduced, gravonoff, downsquNLSP);

 ParticleSstrangeL.Array_Decays[0][0] = PDGstrange; ParticleSstrangeL.Array_Decays[0][1] = PDGgluino; ParticleSstrangeL.Array_Decays[0][2] = sstrangeLamplitudegluinostrange; ParticleSstrangeL.Array_Decays[0][3] = 2; ParticleSstrangeL.Array_Comments[0] = "# ~s_L -> s ~g";
 ParticleSstrangeL.Array_Decays[1][0] = PDGcharm; ParticleSstrangeL.Array_Decays[1][1] = -PDGchargino1; ParticleSstrangeL.Array_Decays[1][2] = sstrangeLamplitudecharginoW1charm; ParticleSstrangeL.Array_Decays[1][3] = 2; ParticleSstrangeL.Array_Comments[1] = "# ~s_L -> c ~chi_1-" ;
 ParticleSstrangeL.Array_Decays[2][0] = PDGcharm; ParticleSstrangeL.Array_Decays[2][1] = -PDGchargino2; ParticleSstrangeL.Array_Decays[2][2] = sstrangeLamplitudecharginoW2charm; ParticleSstrangeL.Array_Decays[2][3] = 2; ParticleSstrangeL.Array_Comments[2] = "# ~s_L -> c ~chi_2-";
 ParticleSstrangeL.Array_Decays[3][0] = PDGstrange; ParticleSstrangeL.Array_Decays[3][1] = PDGneutralino1; ParticleSstrangeL.Array_Decays[3][2] = sstrangeLamplitudestrangeneutralinoZ1; ParticleSstrangeL.Array_Decays[3][3] = 2; ParticleSstrangeL.Array_Comments[3] = "# ~s_L -> s ~chi_10";
 ParticleSstrangeL.Array_Decays[4][0] = PDGstrange; ParticleSstrangeL.Array_Decays[4][1] = PDGneutralino2; ParticleSstrangeL.Array_Decays[4][2] = sstrangeLamplitudestrangeneutralinoZ2; ParticleSstrangeL.Array_Decays[4][3] = 2; ParticleSstrangeL.Array_Comments[4] = "# ~s_L -> s ~chi_20";
 ParticleSstrangeL.Array_Decays[5][0] = PDGstrange; ParticleSstrangeL.Array_Decays[5][1] = PDGneutralino3; ParticleSstrangeL.Array_Decays[5][2] = sstrangeLamplitudestrangeneutralinoZ3; ParticleSstrangeL.Array_Decays[5][3] = 2; ParticleSstrangeL.Array_Comments[5] = "# ~s_L -> s ~chi_30";
 ParticleSstrangeL.Array_Decays[6][0] = PDGstrange; ParticleSstrangeL.Array_Decays[6][1] = PDGneutralino4; ParticleSstrangeL.Array_Decays[6][2] = sstrangeLamplitudestrangeneutralinoZ4; ParticleSstrangeL.Array_Decays[6][3] = 2; ParticleSstrangeL.Array_Comments[6] = "# ~s_L -> s ~chi_40";

 ParticleSstrangeL.Array_Decays[7][0] = PDGstrange; ParticleSstrangeL.Array_Decays[7][1] = PDGgravitino; ParticleSstrangeL.Array_Decays[7][2] = sstrangeLamplitudestrangegravitino; ParticleSstrangeL.Array_Decays[7][3] = 2; ParticleSstrangeL.Array_Comments[7] = "# ~s_L -> s ~G";

double SstrangeL_No_1to2_Decays = 0;

 if (downsquNLSP == 1) { SstrangeL_No_1to2_Decays = ParticleSstrangeL.No_1to2_Decays + ParticleSstrangeL.No_grav_Decays;}
 else {SstrangeL_No_1to2_Decays = ParticleSstrangeL.No_1to2_Decays;}
 
 for (int j = 0; j<SstrangeL_No_1to2_Decays; j++) {
   ParticleSstrangeL.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<SstrangeL_No_1to2_Decays; j++) {
   ParticleSstrangeL.two_width = ParticleSstrangeL.two_width + ParticleSstrangeL.Array_Decays[j][2];
 }
 for (int j=SstrangeL_No_1to2_Decays; j<ParticleSstrangeL.No_of_Decays; j++) {
   ParticleSstrangeL.three_width = ParticleSstrangeL.three_width + ParticleSstrangeL.Array_Decays[j][2];
 }
 
 if ( ParticleSstrangeL.three_width != ParticleSstrangeL.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for sstrangeL - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleSstrangeL.No_of_Decays = SstrangeL_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleSstrangeL.total_width = ParticleSstrangeL.two_width;
   }
 else {
   ParticleSstrangeL.total_width = ParticleSstrangeL.two_width + ParticleSstrangeL.three_width;
 }
 
 for (int i =0; i<ParticleSstrangeL.No_of_Decays; i++) {
   ParticleSstrangeL.Array_Decays[i][5]= ParticleSstrangeL.Array_Decays[i][2]/ParticleSstrangeL.total_width;
 }


 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleSstrangeL.PDG << setw(12) << scientific << setprecision(8) <<  ParticleSstrangeL.total_width << "   " << "# sstrange_L decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleSstrangeL.No_of_Decays; k++) {
   if( ParticleSstrangeL.Array_Decays[k][2] != 0 && ParticleSstrangeL.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleSstrangeL.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleSstrangeL.Array_Decays[k][3];  printRowPDG(cout, ParticleSstrangeL.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleSstrangeL.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleSstrangeL.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;

 ///SstrangeR decays

 double sstrangeRamplitudegluinostrange, sstrangeRamplitudestrangeneutralinoZ1,  sstrangeRamplitudestrangeneutralinoZ2,  sstrangeRamplitudestrangeneutralinoZ3,  sstrangeRamplitudestrangeneutralinoZ4, sstrangeRamplitudestrangegravitino;

 sstrangeRamplitudegluinostrange = squarkamplitudedecaygluino (md(2,2), MSTRANGE, mGluino, alphas);
 sstrangeRamplitudestrangeneutralinoZ1 = squarkRamplitudedecayneutralino (md(2,2), MSTRANGE, mneut(1), g, gp, mixNeut, 1, -1);
 sstrangeRamplitudestrangeneutralinoZ2 = squarkRamplitudedecayneutralino (md(2,2), MSTRANGE, mneut(2), g, gp, mixNeut, 2, -1);
 sstrangeRamplitudestrangeneutralinoZ3 = squarkRamplitudedecayneutralino (md(2,2), MSTRANGE, mneut(3), g, gp, mixNeut, 3, -1);
 sstrangeRamplitudestrangeneutralinoZ4 = squarkRamplitudedecayneutralino (md(2,2), MSTRANGE, mneut(4), g, gp, mixNeut, 4, -1);

 sstrangeRamplitudestrangegravitino = squarkamplitudedecaygravitino(md(2,2), mgravitino, MSTRANGE, MPlreduced, gravonoff, downsquNLSP);

 ParticleSstrangeR.Array_Decays[0][0] = PDGstrange; ParticleSstrangeR.Array_Decays[0][1] = PDGgluino; ParticleSstrangeR.Array_Decays[0][2] = sstrangeRamplitudegluinostrange; ParticleSstrangeR.Array_Decays[0][3] = 2; ParticleSstrangeR.Array_Comments[0] = "# ~s_R -> s ~g";
 ParticleSstrangeR.Array_Decays[1][0] = PDGstrange; ParticleSstrangeR.Array_Decays[1][1] = PDGneutralino1; ParticleSstrangeR.Array_Decays[1][2] = sstrangeRamplitudestrangeneutralinoZ1; ParticleSstrangeR.Array_Decays[1][3] = 2; ParticleSstrangeR.Array_Comments[1] = "# ~s_R -> s ~chi_10";
 ParticleSstrangeR.Array_Decays[2][0] = PDGstrange; ParticleSstrangeR.Array_Decays[2][1] = PDGneutralino2; ParticleSstrangeR.Array_Decays[2][2] = sstrangeRamplitudestrangeneutralinoZ2; ParticleSstrangeR.Array_Decays[2][3] = 2; ParticleSstrangeR.Array_Comments[2] = "# ~s_R -> s ~chi_20";
 ParticleSstrangeR.Array_Decays[3][0] = PDGstrange; ParticleSstrangeR.Array_Decays[3][1] = PDGneutralino3; ParticleSstrangeR.Array_Decays[3][2] = sstrangeRamplitudestrangeneutralinoZ3; ParticleSstrangeR.Array_Decays[3][3] = 2; ParticleSstrangeR.Array_Comments[3] = "# ~s_R -> s ~chi_30";
 ParticleSstrangeR.Array_Decays[4][0] = PDGstrange; ParticleSstrangeR.Array_Decays[4][1] = PDGneutralino4; ParticleSstrangeR.Array_Decays[4][2] = sstrangeRamplitudestrangeneutralinoZ4; ParticleSstrangeR.Array_Decays[4][3] = 2; ParticleSstrangeR.Array_Comments[4] = "# ~s_R -> s ~chi_40";

 ParticleSstrangeR.Array_Decays[5][0] = PDGstrange; ParticleSstrangeR.Array_Decays[5][1] = PDGgravitino; ParticleSstrangeR.Array_Decays[5][2] = sstrangeRamplitudestrangegravitino; ParticleSstrangeR.Array_Decays[5][3] = 2; ParticleSstrangeR.Array_Comments[5] = "# ~s_R -> s ~G";

double SstrangeR_No_1to2_Decays = 0;

 if (downsquNLSP == 1) { SstrangeR_No_1to2_Decays = ParticleSstrangeR.No_1to2_Decays + ParticleSstrangeR.No_grav_Decays;}
 else {SstrangeR_No_1to2_Decays = ParticleSstrangeR.No_1to2_Decays;}
 
 for (int j = 0; j<SstrangeR_No_1to2_Decays; j++) {
   ParticleSstrangeR.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<SstrangeR_No_1to2_Decays; j++) {
   ParticleSstrangeR.two_width = ParticleSstrangeR.two_width + ParticleSstrangeR.Array_Decays[j][2];
 }
 for (int j=SstrangeR_No_1to2_Decays; j<ParticleSstrangeR.No_of_Decays; j++) {
   ParticleSstrangeR.three_width = ParticleSstrangeR.three_width + ParticleSstrangeR.Array_Decays[j][2];
 }
 
 if ( ParticleSstrangeR.three_width != ParticleSstrangeR.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for sstrangeR - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleSstrangeR.No_of_Decays = SstrangeR_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleSstrangeR.total_width = ParticleSstrangeR.two_width;
   }
 else {
   ParticleSstrangeR.total_width = ParticleSstrangeR.two_width + ParticleSstrangeR.three_width;
 }
 
 for (int i =0; i<ParticleSstrangeR.No_of_Decays; i++) {
   ParticleSstrangeR.Array_Decays[i][5]= ParticleSstrangeR.Array_Decays[i][2]/ParticleSstrangeR.total_width;
 }
 
 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleSstrangeR.PDG << setw(12) << scientific << setprecision(8) <<  ParticleSstrangeR.total_width << "   " << "# sstrange_R decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleSstrangeR.No_of_Decays; k++) {
   if( ParticleSstrangeR.Array_Decays[k][2] != 0 && ParticleSstrangeR.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleSstrangeR.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleSstrangeR.Array_Decays[k][3];  printRowPDG(cout, ParticleSstrangeR.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleSstrangeR.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleSstrangeR.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;

 ///ScharmL Decays

 double scharmLamplitudegluinocharm, scharmLamplitudecharmneutralinoZ1,  scharmLamplitudecharmneutralinoZ2,  scharmLamplitudecharmneutralinoZ3,  scharmLamplitudecharmneutralinoZ4,  scharmLamplitudecharginoW1strange, scharmLamplitudecharginoW2strange, scharmLamplitudecharmgravitino;

 scharmLamplitudegluinocharm = squarkamplitudedecaygluino (mu(1,2), MCHARM, mGluino, alphas);
 scharmLamplitudecharginoW1strange = squarkamplitudedecaycharginoW1 (mu(1,2), MSTRANGE, MCH1, g, thetaR2);
 scharmLamplitudecharginoW2strange = squarkamplitudedecaycharginoW2 (mu(1,2), MSTRANGE, MCH2, g, thetaR2);
 scharmLamplitudecharmneutralinoZ1 = squarkLamplitudedecayneutralino (mu(1,2), MCHARM, mneut(1), g, gp, mixNeut, 1, 1);
 scharmLamplitudecharmneutralinoZ2 = squarkLamplitudedecayneutralino (mu(1,2), MCHARM, mneut(2), g, gp, mixNeut, 2, 1);
 scharmLamplitudecharmneutralinoZ3 = squarkLamplitudedecayneutralino (mu(1,2), MCHARM, mneut(3), g, gp, mixNeut, 3, 1);
 scharmLamplitudecharmneutralinoZ4 = squarkLamplitudedecayneutralino (mu(1,2), MCHARM, mneut(4), g, gp, mixNeut, 4, 1);

 scharmLamplitudecharmgravitino = squarkamplitudedecaygravitino(mu(1,2), mgravitino, MCHARM, MPlreduced, gravonoff, upsquNLSP);

 ParticleScharmL.Array_Decays[0][0] = PDGcharm; ParticleScharmL.Array_Decays[0][1] = PDGgluino; ParticleScharmL.Array_Decays[0][2] = scharmLamplitudegluinocharm; ParticleScharmL.Array_Decays[0][3] = 2; ParticleScharmL.Array_Comments[0] = "# ~c_L -> c ~g";
 ParticleScharmL.Array_Decays[1][0] = PDGstrange; ParticleScharmL.Array_Decays[1][1] = PDGchargino1; ParticleScharmL.Array_Decays[1][2] = scharmLamplitudecharginoW1strange; ParticleScharmL.Array_Decays[1][3] = 2; ParticleScharmL.Array_Comments[1] = "# ~c_L -> s ~chi_1+";
 ParticleScharmL.Array_Decays[2][0] = PDGstrange; ParticleScharmL.Array_Decays[2][1] = PDGchargino2; ParticleScharmL.Array_Decays[2][2] = scharmLamplitudecharginoW2strange; ParticleScharmL.Array_Decays[2][3] = 2; ParticleScharmL.Array_Comments[2] = "# ~c_L -> s ~chi_2+";
 ParticleScharmL.Array_Decays[3][0] = PDGcharm; ParticleScharmL.Array_Decays[3][1] = PDGneutralino1; ParticleScharmL.Array_Decays[3][2] = scharmLamplitudecharmneutralinoZ1; ParticleScharmL.Array_Decays[3][3] = 2; ParticleScharmL.Array_Comments[3] = "# ~c_L -> c ~chi_10";
 ParticleScharmL.Array_Decays[4][0] = PDGcharm; ParticleScharmL.Array_Decays[4][1] = PDGneutralino2; ParticleScharmL.Array_Decays[4][2] = scharmLamplitudecharmneutralinoZ2; ParticleScharmL.Array_Decays[4][3] = 2; ParticleScharmL.Array_Comments[4] = "# ~c_L -> c ~chi_20";
 ParticleScharmL.Array_Decays[5][0] = PDGcharm; ParticleScharmL.Array_Decays[5][1] = PDGneutralino3; ParticleScharmL.Array_Decays[5][2] = scharmLamplitudecharmneutralinoZ3; ParticleScharmL.Array_Decays[5][3] = 2; ParticleScharmL.Array_Comments[5] = "# ~c_L -> c ~chi_30";
 ParticleScharmL.Array_Decays[6][0] = PDGcharm; ParticleScharmL.Array_Decays[6][1] = PDGneutralino4; ParticleScharmL.Array_Decays[6][2] = scharmLamplitudecharmneutralinoZ4; ParticleScharmL.Array_Decays[6][3] = 2; ParticleScharmL.Array_Comments[6] = "# ~c_L -> c ~chi_40";

 ParticleScharmL.Array_Decays[7][0] = PDGcharm; ParticleScharmL.Array_Decays[7][1] = PDGgravitino; ParticleScharmL.Array_Decays[7][2] = scharmLamplitudecharmgravitino; ParticleScharmL.Array_Decays[7][3] = 2; ParticleScharmL.Array_Comments[7] = "# ~c_L -> c ~G";

 double ScharmL_No_1to2_Decays = 0;

 if (upsquNLSP == 1) { ScharmL_No_1to2_Decays = ParticleScharmL.No_1to2_Decays + ParticleScharmL.No_grav_Decays;}
 else {ScharmL_No_1to2_Decays = ParticleScharmL.No_1to2_Decays;}
 
 for (int j = 0; j<ScharmL_No_1to2_Decays; j++) {
   ParticleScharmL.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<ScharmL_No_1to2_Decays; j++) {
   ParticleScharmL.two_width = ParticleScharmL.two_width + ParticleScharmL.Array_Decays[j][2];
 }
 for (int j=ScharmL_No_1to2_Decays; j<ParticleScharmL.No_of_Decays; j++) {
   ParticleScharmL.three_width = ParticleScharmL.three_width + ParticleScharmL.Array_Decays[j][2];
 }
 
 if ( ParticleScharmL.three_width != ParticleScharmL.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for scharmL - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleScharmL.No_of_Decays = ScharmL_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleScharmL.total_width = ParticleScharmL.two_width;
   }
 else {
   ParticleScharmL.total_width = ParticleScharmL.two_width + ParticleScharmL.three_width;
 }
 
 for (int i =0; i<ParticleScharmL.No_of_Decays; i++) {
   ParticleScharmL.Array_Decays[i][5]= ParticleScharmL.Array_Decays[i][2]/ParticleScharmL.total_width;
 }
 

 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleScharmL.PDG << setw(12) << scientific << setprecision(8) <<  ParticleScharmL.total_width << "   " << "# scharm_L decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleScharmL.No_of_Decays; k++) {
   if( ParticleScharmL.Array_Decays[k][2] != 0 && ParticleScharmL.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleScharmL.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleScharmL.Array_Decays[k][3];  printRowPDG(cout, ParticleScharmL.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleScharmL.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleScharmL.Array_Comments[k] << endl;
 }
 }
 cout << "#" << endl;

 ///ScharmR decays

 double scharmRamplitudegluinocharm, scharmRamplitudecharmneutralinoZ1,  scharmRamplitudecharmneutralinoZ2,  scharmRamplitudecharmneutralinoZ3,  scharmRamplitudecharmneutralinoZ4, scharmRamplitudecharmgravitino;

 scharmRamplitudegluinocharm = squarkamplitudedecaygluino (mu(2,2), MCHARM, mGluino, alphas);
 scharmRamplitudecharmneutralinoZ1 = squarkRamplitudedecayneutralino (mu(2,2), MCHARM, mneut(1), g, gp, mixNeut, 1, 1);
 scharmRamplitudecharmneutralinoZ2 = squarkRamplitudedecayneutralino (mu(2,2), MCHARM, mneut(2), g, gp, mixNeut, 2, 1);
 scharmRamplitudecharmneutralinoZ3 = squarkRamplitudedecayneutralino (mu(2,2), MCHARM, mneut(3), g, gp, mixNeut, 3, 1);
 scharmRamplitudecharmneutralinoZ4 = squarkRamplitudedecayneutralino (mu(2,2), MCHARM, mneut(4), g, gp, mixNeut, 4, 1);

 scharmRamplitudecharmgravitino = squarkamplitudedecaygravitino(mu(2,2), mgravitino,MCHARM, MPlreduced,gravonoff, upsquNLSP);

 ParticleScharmR.Array_Decays[0][0] = PDGcharm; ParticleScharmR.Array_Decays[0][1] = PDGgluino; ParticleScharmR.Array_Decays[0][2] = scharmRamplitudegluinocharm; ParticleScharmR.Array_Decays[0][3] = 2; ParticleScharmR.Array_Comments[0] = "# ~c_R -> c ~g";
 ParticleScharmR.Array_Decays[1][0] = PDGcharm; ParticleScharmR.Array_Decays[1][1] = PDGneutralino1; ParticleScharmR.Array_Decays[1][2] = scharmRamplitudecharmneutralinoZ1; ParticleScharmR.Array_Decays[1][3] = 2; ParticleScharmR.Array_Comments[1] = "# ~c_R -> c ~chi_10";
 ParticleScharmR.Array_Decays[2][0] = PDGcharm; ParticleScharmR.Array_Decays[2][1] = PDGneutralino2; ParticleScharmR.Array_Decays[2][2] = scharmRamplitudecharmneutralinoZ2; ParticleScharmR.Array_Decays[2][3] = 2; ParticleScharmR.Array_Comments[2] = "# ~c_R -> c ~chi_20";
 ParticleScharmR.Array_Decays[3][0] = PDGcharm; ParticleScharmR.Array_Decays[3][1] = PDGneutralino3; ParticleScharmR.Array_Decays[3][2] = scharmRamplitudecharmneutralinoZ3; ParticleScharmR.Array_Decays[3][3] = 2; ParticleScharmR.Array_Comments[3] = "# ~c_R -> c ~chi_30";
 ParticleScharmR.Array_Decays[4][0] = PDGcharm; ParticleScharmR.Array_Decays[4][1] = PDGneutralino4; ParticleScharmR.Array_Decays[4][2] = scharmRamplitudecharmneutralinoZ4; ParticleScharmR.Array_Decays[4][3] = 2; ParticleScharmR.Array_Comments[4] = "# ~c_R -> c ~chi_40";

 ParticleScharmR.Array_Decays[5][0] = PDGcharm; ParticleScharmR.Array_Decays[5][1] = PDGgravitino; ParticleScharmR.Array_Decays[5][2] = scharmRamplitudecharmgravitino; ParticleScharmR.Array_Decays[5][3] = 2; ParticleScharmR.Array_Comments[5] = "# ~c_R -> c ~G";

 double ScharmR_No_1to2_Decays = 0;

 if (upsquNLSP == 1) { ScharmR_No_1to2_Decays = ParticleScharmR.No_1to2_Decays + ParticleScharmR.No_grav_Decays;}
 else {ScharmR_No_1to2_Decays = ParticleScharmR.No_1to2_Decays;}
 
 for (int j = 0; j<ScharmR_No_1to2_Decays; j++) {
   ParticleScharmR.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<ScharmR_No_1to2_Decays; j++) {
   ParticleScharmR.two_width = ParticleScharmR.two_width + ParticleScharmR.Array_Decays[j][2];
 }
 for (int j=ScharmR_No_1to2_Decays; j<ParticleScharmR.No_of_Decays; j++) {
   ParticleScharmR.three_width = ParticleScharmR.three_width + ParticleScharmR.Array_Decays[j][2];
 }
 
 if ( ParticleScharmR.three_width != ParticleScharmR.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for scharmR - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleScharmR.No_of_Decays = ScharmR_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleScharmR.total_width = ParticleScharmR.two_width;
   }
 else {
   ParticleScharmR.total_width = ParticleScharmR.two_width + ParticleScharmL.three_width;
 }
 
 for (int i =0; i<ParticleScharmR.No_of_Decays; i++) {
   ParticleScharmR.Array_Decays[i][5]= ParticleScharmR.Array_Decays[i][2]/ParticleScharmR.total_width;
 }

  cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleScharmR.PDG << setw(12) << scientific << setprecision(8) <<  ParticleScharmR.total_width << "   " << "# scharm_R decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleScharmR.No_of_Decays; k++) {
   if( ParticleScharmR.Array_Decays[k][2] != 0 && ParticleScharmR.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleScharmR.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleScharmR.Array_Decays[k][3];  printRowPDG(cout, ParticleScharmR.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleScharmR.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleScharmR.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;

 ///Sbottom1 Decays

 double sbottom1amplitudegluinobottom, sbottom1amplitudebottomneutralinoZ1, sbottom1amplitudebottomneutralinoZ2, sbottom1amplitudebottomneutralinoZ3, sbottom1amplitudebottomneutralinoZ4, sbottom1amplitudetopcharginoW1, sbottom1amplitudetopcharginoW2, sbottom1amplitudeWbosonstop1, sbottom1amplitudeWbosonstop2, sbottom1amplitudeHminusstop1, sbottom1amplitudeHminusstop2, sbottom1amplitudebottomgravitino;

 sbottom1amplitudegluinobottom = squarkamplitudedecaygluinomix (md(1,3), MBOTTOM, mGluino, alphas, 1, thetab);
 sbottom1amplitudetopcharginoW1 = squark1amplitudedecaycharginoW1mix (md(1,3), MTOP, MCH1, g, thetaL2, thetaR2, thetab, beta, runmw, runmt, runmb, 2);
 sbottom1amplitudetopcharginoW2 = squark1amplitudedecaycharginoW2mix (md(1,3), MTOP, MCH2, g, thetaL2, thetaR2, thetab, beta, runmw, runmt, runmb, 2);
 sbottom1amplitudebottomneutralinoZ1 = testrealsquark3amplitudedecayneutralino (md(1,3), MBOTTOM, mneut(1), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 1, 1);
 sbottom1amplitudebottomneutralinoZ2 = testrealsquark3amplitudedecayneutralino (md(1,3), MBOTTOM, mneut(2), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 1, 2);
 sbottom1amplitudebottomneutralinoZ3 = testrealsquark3amplitudedecayneutralino (md(1,3), MBOTTOM, mneut(3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 1, 3);
 sbottom1amplitudebottomneutralinoZ4 = testrealsquark3amplitudedecayneutralino (md(1,3), MBOTTOM, mneut(4), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 1, 4);
 sbottom1amplitudeWbosonstop1 = squark3amplitudedecaysquark3Wboson (md(1,3), polemw, mu(1,3), g, thetat, thetab, 2, 1, 1, 1);
 sbottom1amplitudeWbosonstop2 = squark3amplitudedecaysquark3Wboson (md(1,3), polemw, mu(2,3), g, thetat, thetab, 2, 1, 1, 2);
 sbottom1amplitudeHminusstop1 = squark3amplitudedecaychargedHiggssquark3 (md(1,3), mHpm, mu(1,3), g, runmw, beta, thetat, thetab, greekmu, At, Ab, runmt, runmb, 1, 1);
 sbottom1amplitudeHminusstop2 = squark3amplitudedecaychargedHiggssquark3 (md(1,3), mHpm, mu(2,3), g, runmw, beta, thetat, thetab, greekmu, At, Ab, runmt, runmb, 2, 1);
 sbottom1amplitudebottomgravitino = squarkamplitudedecaygravitino(md(1,3), mgravitino, MBOTTOM, MPlreduced, gravonoff, downsquNLSP);
   

 ParticleSbottom1.Array_Decays[0][0] = PDGbottom; ParticleSbottom1.Array_Decays[0][1] = PDGgluino; ParticleSbottom1.Array_Decays[0][2] = sbottom1amplitudegluinobottom; ParticleSbottom1.Array_Decays[0][3] = 2; ParticleSbottom1.Array_Comments[0] = "# ~b_1 -> b ~g";
 ParticleSbottom1.Array_Decays[1][0] = PDGtop; ParticleSbottom1.Array_Decays[1][1] = -PDGchargino1; ParticleSbottom1.Array_Decays[1][2] = sbottom1amplitudetopcharginoW1; ParticleSbottom1.Array_Decays[1][3] = 2; ParticleSbottom1.Array_Comments[1] = "# ~b_1 -> t ~chi_1-"; 
 ParticleSbottom1.Array_Decays[2][0] = PDGtop; ParticleSbottom1.Array_Decays[2][1] = PDGchargino2; ParticleSbottom1.Array_Decays[2][2] = sbottom1amplitudetopcharginoW2; ParticleSbottom1.Array_Decays[2][3] = 2; ParticleSbottom1.Array_Comments[2] = "# ~b_1 -> t ~-chi_2-";
 ParticleSbottom1.Array_Decays[3][0] = PDGbottom; ParticleSbottom1.Array_Decays[3][1] = PDGneutralino1; ParticleSbottom1.Array_Decays[3][2] = sbottom1amplitudebottomneutralinoZ1; ParticleSbottom1.Array_Decays[3][3] = 2; ParticleSbottom1.Array_Comments[3] = "# ~b_1 -> b ~chi_10";
 ParticleSbottom1.Array_Decays[4][0] = PDGbottom; ParticleSbottom1.Array_Decays[4][1] = PDGneutralino2; ParticleSbottom1.Array_Decays[4][2] = sbottom1amplitudebottomneutralinoZ2; ParticleSbottom1.Array_Decays[4][3] = 2; ParticleSbottom1.Array_Comments[4] = "# ~b_1 -> b ~chi_20";
 ParticleSbottom1.Array_Decays[5][0] = PDGbottom; ParticleSbottom1.Array_Decays[5][1] = PDGneutralino3; ParticleSbottom1.Array_Decays[5][2] = sbottom1amplitudebottomneutralinoZ3; ParticleSbottom1.Array_Decays[5][3] = 2; ParticleSbottom1.Array_Comments[5] = "# ~b_1 -> b ~chi_30";
 ParticleSbottom1.Array_Decays[6][0] = PDGbottom; ParticleSbottom1.Array_Decays[6][1] = PDGneutralino4; ParticleSbottom1.Array_Decays[6][2] = sbottom1amplitudebottomneutralinoZ4; ParticleSbottom1.Array_Decays[6][3] = 2; ParticleSbottom1.Array_Comments[6] = "# ~b_1 -> b ~chi_40";
 ParticleSbottom1.Array_Decays[7][0] = -PDGWplus; ParticleSbottom1.Array_Decays[7][1] = PDGstop1 ; ParticleSbottom1.Array_Decays[7][2] = sbottom1amplitudeWbosonstop1; ParticleSbottom1.Array_Decays[7][3] = 2; ParticleSbottom1.Array_Comments[7] = "# ~b_1 -> W- ~t_1";
 ParticleSbottom1.Array_Decays[8][0] = -PDGWplus; ParticleSbottom1.Array_Decays[8][1] = PDGstop2 ; ParticleSbottom1.Array_Decays[8][2] = sbottom1amplitudeWbosonstop2; ParticleSbottom1.Array_Decays[8][3] = 2; ParticleSbottom1.Array_Comments[8] = "# ~b_1 -> W- ~t_2";
 ParticleSbottom1.Array_Decays[9][0] = -PDGHplus; ParticleSbottom1.Array_Decays[9][1] = PDGstop1; ParticleSbottom1.Array_Decays[9][2] = sbottom1amplitudeHminusstop1; ParticleSbottom1.Array_Decays[9][3] = 2; ParticleSbottom1.Array_Comments[9] = "# ~b_1 -> H- ~t_1";
 ParticleSbottom1.Array_Decays[10][0] = -PDGHplus; ParticleSbottom1.Array_Decays[10][1] = PDGstop2; ParticleSbottom1.Array_Decays[10][2] = sbottom1amplitudeHminusstop2; ParticleSbottom1.Array_Decays[10][3] = 2; ParticleSbottom1.Array_Comments[10] = "# ~b_1 -> H- ~t_2";

 ParticleSbottom1.Array_Decays[11][0] = PDGbottom; ParticleSbottom1.Array_Decays[11][1] = PDGgravitino; ParticleSbottom1.Array_Decays[11][2] = sbottom1amplitudebottomgravitino; ParticleSbottom1.Array_Decays[11][3] = 2; ParticleSbottom1.Array_Comments[11] = "# ~b_1 -> b ~G";

 double Sbottom1_No_1to2_Decays = 0;

 if (downsquNLSP == 1) { Sbottom1_No_1to2_Decays = ParticleSbottom1.No_1to2_Decays + ParticleSbottom1.No_grav_Decays;}
 else {Sbottom1_No_1to2_Decays = ParticleSbottom1.No_1to2_Decays;}
 
 for (int j = 0; j<Sbottom1_No_1to2_Decays; j++) {
   ParticleSbottom1.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<Sbottom1_No_1to2_Decays; j++) {
   ParticleSbottom1.two_width = ParticleSbottom1.two_width + ParticleSbottom1.Array_Decays[j][2];
 }
 for (int j=Sbottom1_No_1to2_Decays; j<ParticleSbottom1.No_of_Decays; j++) {
   ParticleSbottom1.three_width = ParticleSbottom1.three_width + ParticleSbottom1.Array_Decays[j][2];
 }
 
 if ( ParticleSbottom1.three_width != ParticleSbottom1.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for sbottom1 - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleSbottom1.No_of_Decays = Sbottom1_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleSbottom1.total_width = ParticleSbottom1.two_width;
   }
 else {
   ParticleSbottom1.total_width = ParticleSbottom1.two_width + ParticleSbottom1.three_width;
 }
 
 for (int i =0; i<ParticleSbottom1.No_of_Decays; i++) {
   ParticleSbottom1.Array_Decays[i][5]= ParticleSbottom1.Array_Decays[i][2]/ParticleSbottom1.total_width;
 }


 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleSbottom1.PDG << setw(12) << scientific << setprecision(8) <<  ParticleSbottom1.total_width << "   " << "# sbottom_1 decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleSbottom1.No_of_Decays; k++) {
   if( ParticleSbottom1.Array_Decays[k][2] != 0 && ParticleSbottom1.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleSbottom1.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleSbottom1.Array_Decays[k][3];  printRowPDG(cout, ParticleSbottom1.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleSbottom1.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleSbottom1.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;

 ///Sbottom2 Decays

 double sbottom2amplitudegluinobottom, sbottom2amplitudebottomneutralinoZ1, sbottom2amplitudebottomneutralinoZ2, sbottom2amplitudebottomneutralinoZ3, sbottom2amplitudebottomneutralinoZ4, sbottom2amplitudetopcharginoW1, sbottom2amplitudetopcharginoW2, sbottom2amplitudeWbosonstop1, sbottom2amplitudeWbosonstop2, sbottom2amplitudeHminusstop1, sbottom2amplitudeHminusstop2, sbottom2amplitudeZbosonsbottom1, sbottom2amplitudehsbottom1, sbottom2amplitudeAsbottom1, sbottom2amplitudeHsbottom1, sbottom2amplitudebottomgravitino;

 sbottom2amplitudegluinobottom =  squarkamplitudedecaygluinomix (md(2,3), MBOTTOM, mGluino, alphas, 2, thetab);
 sbottom2amplitudetopcharginoW1 = squark2amplitudedecaycharginoW1mix (md(2,3), MTOP, MCH1, g, thetaL2, thetaR2, thetab, beta, runmw, runmt, runmb,2);
 sbottom2amplitudetopcharginoW2 = squark2amplitudedecaycharginoW2mix (md(2,3), MTOP, MCH2, g, thetaL2, thetaR2, thetab, beta, runmw, runmt, runmb,2); 
 sbottom2amplitudebottomneutralinoZ1 = testrealsquark3amplitudedecayneutralino (md(2,3), MBOTTOM, mneut(1), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 2, 1);
 sbottom2amplitudebottomneutralinoZ2 = testrealsquark3amplitudedecayneutralino (md(2,3), MBOTTOM, mneut(2), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 2, 2);
 sbottom2amplitudebottomneutralinoZ3 = testrealsquark3amplitudedecayneutralino (md(2,3), MBOTTOM, mneut(3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 2, 3);
 sbottom2amplitudebottomneutralinoZ4 = testrealsquark3amplitudedecayneutralino (md(2,3), MBOTTOM, mneut(4), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 2, 4);
 sbottom2amplitudeWbosonstop1 = squark3amplitudedecaysquark3Wboson (md(2,3), polemw, mu(1,3), g, thetat, thetab, 2, 2, 1, 1);
 sbottom2amplitudeWbosonstop2 = squark3amplitudedecaysquark3Wboson (md(2,3), polemw, mu(2,3), g, thetat, thetab, 2, 2, 1, 2);
 sbottom2amplitudeHminusstop1 = squark3amplitudedecaychargedHiggssquark3 (md(2,3), mHpm, mu(1,3), g, runmw, beta, thetat, thetab, greekmu, At, Ab, runmt, runmb, 1, 2);
 sbottom2amplitudeHminusstop2 = squark3amplitudedecaychargedHiggssquark3 (md(2,3), mHpm, mu(2,3), g, runmw, beta, thetat, thetab, greekmu, At, Ab, runmt, runmb, 2, 2);
 sbottom2amplitudehsbottom1 = squark32amplitudedecayneutralHiggssquark3 (md(2,3), mh0(1), md(1,3), g, gp, runmw, beta, alpha, thetat, thetab, greekmu, At, Ab, runmt, runmb, 2, 'h');
 sbottom2amplitudeHsbottom1 = squark32amplitudedecayneutralHiggssquark3 (md(2,3), mh0(2), md(1,3), g, gp, runmw, beta, alpha, thetat, thetab, greekmu, At, Ab, runmt, runmb, 2, 'H');
 sbottom2amplitudeAsbottom1 = squark32amplitudedecayneutralHiggssquark3 (md(2,3), mA0(1), md(1,3), g, gp, runmw, beta, alpha, thetat, thetab, greekmu, At, Ab, runmt, runmb, 2, 'A');
 sbottom2amplitudeZbosonsbottom1 = squark32amplitudedecaysquark3Zboson (md(2,3), md(1,3), mz, g, gp, thetab); 

 sbottom2amplitudebottomgravitino = squarkamplitudedecaygravitino(md(2,3), mgravitino, MBOTTOM, MPlreduced, gravonoff, downsquNLSP);

 ParticleSbottom2.Array_Decays[0][0] = PDGbottom; ParticleSbottom2.Array_Decays[0][1] = PDGgluino; ParticleSbottom2.Array_Decays[0][2] = sbottom2amplitudegluinobottom; ParticleSbottom2.Array_Decays[0][3] = 2; ParticleSbottom2.Array_Comments[0] = "# ~b_2 -> b ~g";
 ParticleSbottom2.Array_Decays[1][0] = PDGtop; ParticleSbottom2.Array_Decays[1][1] = -PDGchargino1; ParticleSbottom2.Array_Decays[1][2] = sbottom2amplitudetopcharginoW1; ParticleSbottom2.Array_Decays[1][3] = 2; ParticleSbottom2.Array_Comments[1] = "# ~b_2 -> t ~chi_1-";
 ParticleSbottom2.Array_Decays[2][0] = PDGtop; ParticleSbottom2.Array_Decays[2][1] = -PDGchargino2; ParticleSbottom2.Array_Decays[2][2] = sbottom2amplitudetopcharginoW2; ParticleSbottom2.Array_Decays[2][3] = 2; ParticleSbottom2.Array_Comments[2] = "# ~b_2 -> t ~chi_2-";
 ParticleSbottom2.Array_Decays[3][0] = PDGbottom; ParticleSbottom2.Array_Decays[3][1] = PDGneutralino1; ParticleSbottom2.Array_Decays[3][2] = sbottom2amplitudebottomneutralinoZ1; ParticleSbottom2.Array_Decays[3][3] = 2; ParticleSbottom2.Array_Comments[3] = "# ~b_2 -> b ~chi_10";
 ParticleSbottom2.Array_Decays[4][0] = PDGbottom; ParticleSbottom2.Array_Decays[4][1] = PDGneutralino2; ParticleSbottom2.Array_Decays[4][2] = sbottom2amplitudebottomneutralinoZ2; ParticleSbottom2.Array_Decays[4][3] = 2; ParticleSbottom2.Array_Comments[4] = "# ~b_2 -> b ~chi_20";
 ParticleSbottom2.Array_Decays[5][0] = PDGbottom; ParticleSbottom2.Array_Decays[5][1] = PDGneutralino3; ParticleSbottom2.Array_Decays[5][2] = sbottom2amplitudebottomneutralinoZ3; ParticleSbottom2.Array_Decays[5][3] = 2; ParticleSbottom2.Array_Comments[5] = "# ~b_2 -> b ~chi_30";
 ParticleSbottom2.Array_Decays[6][0] = PDGbottom; ParticleSbottom2.Array_Decays[6][1] = PDGneutralino4; ParticleSbottom2.Array_Decays[6][2] = sbottom2amplitudebottomneutralinoZ4; ParticleSbottom2.Array_Decays[6][3] = 2; ParticleSbottom2.Array_Comments[6] = "# ~b_2 -> b ~chi_40";
 ParticleSbottom2.Array_Decays[7][0] = -PDGWplus; ParticleSbottom2.Array_Decays[7][1] = PDGstop1 ; ParticleSbottom2.Array_Decays[7][2] = sbottom2amplitudeWbosonstop1; ParticleSbottom2.Array_Decays[7][3] = 2; ParticleSbottom2.Array_Comments[7] = "# ~b_2 -> W- ~t_1";
 ParticleSbottom2.Array_Decays[8][0] = -PDGWplus; ParticleSbottom2.Array_Decays[8][1] = PDGstop2 ; ParticleSbottom2.Array_Decays[8][2] = sbottom2amplitudeWbosonstop2; ParticleSbottom2.Array_Decays[8][3] = 2; ParticleSbottom2.Array_Comments[8] = "# ~b_2 -> W- ~t_2";
 ParticleSbottom2.Array_Decays[9][0] = -PDGHplus; ParticleSbottom2.Array_Decays[9][1] = PDGstop1; ParticleSbottom2.Array_Decays[9][2] = sbottom2amplitudeHminusstop1; ParticleSbottom2.Array_Decays[9][3] = 2; ParticleSbottom2.Array_Comments[9] = "# ~b_2 -> H- ~t_1";
 ParticleSbottom2.Array_Decays[10][0] = -PDGHplus; ParticleSbottom2.Array_Decays[10][1] = PDGstop2; ParticleSbottom2.Array_Decays[10][2] = sbottom2amplitudeHminusstop2; ParticleSbottom2.Array_Decays[10][3] = 2; ParticleSbottom2.Array_Comments[10] = "# ~b_2 -> H- ~t_2";
 ParticleSbottom2.Array_Decays[11][0] = PDGh0; ParticleSbottom2.Array_Decays[11][1] = PDGsbottom1; ParticleSbottom2.Array_Decays[11][2] = sbottom2amplitudehsbottom1; ParticleSbottom2.Array_Decays[11][3] = 2; ParticleSbottom2.Array_Comments[11] = "# ~b_2 -> h ~b_1";
 ParticleSbottom2.Array_Decays[12][0] = PDGH0; ParticleSbottom2.Array_Decays[12][1] = PDGsbottom1; ParticleSbottom2.Array_Decays[12][2] = sbottom2amplitudeHsbottom1; ParticleSbottom2.Array_Decays[12][3] = 2; ParticleSbottom2.Array_Comments[12] = "# ~b_2 -> H ~b_1";
 ParticleSbottom2.Array_Decays[13][0] = PDGA0; ParticleSbottom2.Array_Decays[13][1] = PDGsbottom1; ParticleSbottom2.Array_Decays[13][2] = sbottom2amplitudeAsbottom1; ParticleSbottom2.Array_Decays[13][3] = 2; ParticleSbottom2.Array_Comments[13] = "# ~b_2 -> A ~b_1";
 ParticleSbottom2.Array_Decays[14][0] = PDGsbottom1; ParticleSbottom2.Array_Decays[14][1] = PDGZboson; ParticleSbottom2.Array_Decays[14][2] = sbottom2amplitudeZbosonsbottom1; ParticleSbottom2.Array_Decays[14][3] = 2; ParticleSbottom2.Array_Comments[14] = "# ~b_2 -> Z ~b_1";
 
 ParticleSbottom2.Array_Decays[15][0] = PDGbottom; ParticleSbottom2.Array_Decays[15][1] = PDGgravitino; ParticleSbottom2.Array_Decays[15][2] = sbottom2amplitudebottomgravitino; ParticleSbottom2.Array_Decays[15][3] = 2; ParticleSbottom2.Array_Comments[15] = "# ~b_2 -> b ~G";

 double Sbottom2_No_1to2_Decays = 0;

 if (downsquNLSP == 1) { Sbottom2_No_1to2_Decays = ParticleSbottom2.No_1to2_Decays + ParticleSbottom2.No_grav_Decays;}
 else {Sbottom2_No_1to2_Decays = ParticleSbottom2.No_1to2_Decays;}
 
 for (int j = 0; j<Sbottom2_No_1to2_Decays; j++) {
   ParticleSbottom2.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<Sbottom2_No_1to2_Decays; j++) {
   ParticleSbottom2.two_width = ParticleSbottom2.two_width + ParticleSbottom2.Array_Decays[j][2];
 }
 for (int j=Sbottom2_No_1to2_Decays; j<ParticleSbottom2.No_of_Decays; j++) {
   ParticleSbottom2.three_width = ParticleSbottom2.three_width + ParticleSbottom2.Array_Decays[j][2];
 }
 
 if ( ParticleSbottom2.three_width != ParticleSbottom2.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for sbottom2 - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleSbottom2.No_of_Decays = Sbottom2_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleSbottom2.total_width = ParticleSbottom2.two_width;
   }
 else {
   ParticleSbottom2.total_width = ParticleSbottom2.two_width + ParticleSbottom2.three_width;
 }
 
 for (int i =0; i<ParticleSbottom2.No_of_Decays; i++) {
   ParticleSbottom2.Array_Decays[i][5]= ParticleSbottom2.Array_Decays[i][2]/ParticleSbottom2.total_width;
 }

 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleSbottom2.PDG << setw(12) << scientific << setprecision(8) <<  ParticleSbottom2.total_width << "   " << "# sbottom_2 decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleSbottom2.No_of_Decays; k++) {
   if( ParticleSbottom2.Array_Decays[k][2] != 0 && ParticleSbottom2.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleSbottom2.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleSbottom2.Array_Decays[k][3];  printRowPDG(cout, ParticleSbottom2.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleSbottom2.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleSbottom2.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;

 ///Stop1 Decays

 double stop1amplitudegluinotop, stop1amplitudetopneutralinoZ1, stop1amplitudetopneutralinoZ2, stop1amplitudetopneutralinoZ3, stop1amplitudetopneutralinoZ4, stop1amplitudebottomcharginoW1, stop1amplitudebottomcharginoW2, stop1amplitudeWbosonsbottom1, stop1amplitudeWbosonsbottom2, stop1amplitudeHplussbottom1, stop1amplitudeHplussbottom2, stop1amplitudetopgravitino;

 stop1amplitudegluinotop = squarkamplitudedecaygluinomix (mu(1,3), MTOP, mGluino, alphas, 1, thetat);
 stop1amplitudebottomcharginoW1 = squark1amplitudedecaycharginoW1mix (mu(1,3), MBOTTOM, MCH1, g, thetaL2, thetaR2, thetat, beta, runmw, runmt, runmb, 1);
 stop1amplitudebottomcharginoW2 = squark1amplitudedecaycharginoW2mix (mu(1,3), MBOTTOM, MCH2, g, thetaL2, thetaR2, thetat, beta, runmw, runmt, runmb, 1);
 stop1amplitudetopneutralinoZ1 = testrealsquark3amplitudedecayneutralino (mu(1,3), MTOP, mneut(1), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 1, 1);
 stop1amplitudetopneutralinoZ2 = testrealsquark3amplitudedecayneutralino (mu(1,3), MTOP, mneut(2), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 1, 2);
 stop1amplitudetopneutralinoZ3 = testrealsquark3amplitudedecayneutralino (mu(1,3), MTOP, mneut(3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 1, 3);
 stop1amplitudetopneutralinoZ4 = testrealsquark3amplitudedecayneutralino (mu(1,3), MTOP, mneut(4), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 1, 4);
 stop1amplitudeWbosonsbottom1 = squark3amplitudedecaysquark3Wboson (mu(1,3), polemw, md(1,3), g, thetat, thetab, 1, 1, 2, 1);
 stop1amplitudeWbosonsbottom2 = squark3amplitudedecaysquark3Wboson (mu(1,3), polemw, md(2,3), g, thetat, thetab, 1, 1, 2, 2);
 stop1amplitudeHplussbottom1 = squark3amplitudedecaychargedHiggssquark3 (mu(1,3), mHpm, md(1,3), g, runmw, beta, thetat, thetab, greekmu, At, Ab, runmt, runmb, 1, 1);
 stop1amplitudeHplussbottom2 = squark3amplitudedecaychargedHiggssquark3 (mu(1,3), mHpm, md(2,3), g, runmw, beta, thetat, thetab, greekmu, At, Ab, runmt, runmb, 1, 2);
 
 stop1amplitudetopgravitino = squarkamplitudedecaygravitino(mu(1,3), mgravitino, MTOP, MPlreduced, gravonoff, upsquNLSP);
 


 ParticleStop1.Array_Decays[0][0] = PDGtop; ParticleStop1.Array_Decays[0][1] = PDGgluino; ParticleStop1.Array_Decays[0][2] = stop1amplitudegluinotop; ParticleStop1.Array_Decays[0][3] = 2; ParticleStop1.Array_Comments[0] = "# ~t_1 -> t ~g";
 ParticleStop1.Array_Decays[1][0] = PDGbottom; ParticleStop1.Array_Decays[1][1] = PDGchargino1; ParticleStop1.Array_Decays[1][2] = stop1amplitudebottomcharginoW1; ParticleStop1.Array_Decays[1][3] = 2; ParticleStop1.Array_Comments[1] = "# ~t_1 -> b ~chi_1+";
 ParticleStop1.Array_Decays[2][0] = PDGbottom; ParticleStop1.Array_Decays[2][1] = PDGchargino2; ParticleStop1.Array_Decays[2][2] = stop1amplitudebottomcharginoW2; ParticleStop1.Array_Decays[2][3] = 2; ParticleStop1.Array_Comments[2] = "# ~t_1 -> b ~chi_2+";
 ParticleStop1.Array_Decays[3][0] = PDGtop; ParticleStop1.Array_Decays[3][1] = PDGneutralino1; ParticleStop1.Array_Decays[3][2] = stop1amplitudetopneutralinoZ1; ParticleStop1.Array_Decays[3][3] = 2; ParticleStop1.Array_Comments[3] = "# ~t_1 -> t ~chi_10";
 ParticleStop1.Array_Decays[4][0] = PDGtop; ParticleStop1.Array_Decays[4][1] = PDGneutralino2; ParticleStop1.Array_Decays[4][2] = stop1amplitudetopneutralinoZ2; ParticleStop1.Array_Decays[4][3] = 2; ParticleStop1.Array_Comments[4] = "# ~t_1 -> t ~chi_20";
 ParticleStop1.Array_Decays[5][0] = PDGtop; ParticleStop1.Array_Decays[5][1] = PDGneutralino3; ParticleStop1.Array_Decays[5][2] = stop1amplitudetopneutralinoZ3; ParticleStop1.Array_Decays[5][3] = 2; ParticleStop1.Array_Comments[5] = "# ~t_1 -> t ~chi_30";
 ParticleStop1.Array_Decays[6][0] = PDGtop; ParticleStop1.Array_Decays[6][1] = PDGneutralino4; ParticleStop1.Array_Decays[6][2] = stop1amplitudetopneutralinoZ4; ParticleStop1.Array_Decays[6][3] = 2; ParticleStop1.Array_Comments[6] = "# ~t_1 -> t ~chi_40";
 ParticleStop1.Array_Decays[7][0] = PDGWplus; ParticleStop1.Array_Decays[7][1] = PDGsbottom1 ; ParticleStop1.Array_Decays[7][2] = stop1amplitudeWbosonsbottom1; ParticleStop1.Array_Decays[7][3] = 2; ParticleStop1.Array_Comments[7] = "# ~t_1 -> W+ ~b_1";
 ParticleStop1.Array_Decays[8][0] = PDGWplus; ParticleStop1.Array_Decays[8][1] = PDGsbottom2 ; ParticleStop1.Array_Decays[8][2] = stop1amplitudeWbosonsbottom2; ParticleStop1.Array_Decays[8][3] = 2; ParticleStop1.Array_Comments[8] = "# ~t_1 -> W+ ~b_2";
 ParticleStop1.Array_Decays[9][0] = PDGHplus; ParticleStop1.Array_Decays[9][1] = PDGsbottom1; ParticleStop1.Array_Decays[9][2] = stop1amplitudeHplussbottom1; ParticleStop1.Array_Decays[9][3] = 2; ParticleStop1.Array_Comments[9] = "# ~t_1 -> H+ ~b_1";
 ParticleStop1.Array_Decays[10][0] = PDGHplus; ParticleStop1.Array_Decays[10][1] = PDGsbottom2; ParticleStop1.Array_Decays[10][2] = stop1amplitudeHplussbottom2; ParticleStop1.Array_Decays[10][3] = 2; ParticleStop1.Array_Comments[10] = "# ~t_1 -> H+ ~b_2"; 

 ParticleStop1.Array_Decays[11][0] = PDGtop; ParticleStop1.Array_Decays[11][1] = PDGgravitino; ParticleStop1.Array_Decays[11][2] = stop1amplitudetopgravitino; ParticleStop1.Array_Decays[11][3] = 2; ParticleStop1.Array_Comments[11] = "# ~t_1 -> t ~G";

 double Stop1_No_1to2_Decays = 0;

 if (upsquNLSP == 1) { Stop1_No_1to2_Decays = ParticleStop1.No_1to2_Decays + ParticleStop1.No_grav_Decays;}
 else {Stop1_No_1to2_Decays = ParticleStop1.No_1to2_Decays;}
 
 for (int j = 0; j<Stop1_No_1to2_Decays; j++) {
   ParticleStop1.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<Stop1_No_1to2_Decays; j++) {
   ParticleStop1.two_width = ParticleStop1.two_width + ParticleStop1.Array_Decays[j][2];
 }
 for (int j=Stop1_No_1to2_Decays; j<ParticleStop1.No_of_Decays; j++) {
   ParticleStop1.three_width = ParticleStop1.three_width + ParticleStop1.Array_Decays[j][2];
 }
 
 if ( ParticleStop1.three_width != ParticleStop1.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for stop1 - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleStop1.No_of_Decays = Stop1_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleStop1.total_width = ParticleStop1.two_width;
   }
 else {
   ParticleStop1.total_width = ParticleStop1.two_width + ParticleStop1.three_width;
 }
 
 for (int i =0; i<ParticleStop1.No_of_Decays; i++) {
   ParticleStop1.Array_Decays[i][5]= ParticleStop1.Array_Decays[i][2]/ParticleStop1.total_width;
 }


cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleStop1.PDG << setw(12) << scientific << setprecision(8) <<  ParticleStop1.total_width << "   " << "# stop_1 decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleStop1.No_of_Decays; k++) {
   if( ParticleStop1.Array_Decays[k][2] != 0 && ParticleStop1.Array_Decays[k][5] > BRTol) {
      cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleStop1.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleStop1.Array_Decays[k][3];  printRowPDG(cout, ParticleStop1.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleStop1.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleStop1.Array_Comments[k] << endl;
     }
   }
 cout << "#" << endl;

 ///Stop2 Decays

 double stop2amplitudegluinotop, stop2amplitudetopneutralinoZ1, stop2amplitudetopneutralinoZ2, stop2amplitudetopneutralinoZ3, stop2amplitudetopneutralinoZ4, stop2amplitudebottomcharginoW1, stop2amplitudebottomcharginoW2, stop2amplitudeWbosonsbottom1, stop2amplitudeWbosonsbottom2, stop2amplitudeHplussbottom1, stop2amplitudeHplussbottom2, stop2amplitudeZbosonstop1, stop2amplitudehstop1, stop2amplitudeHstop1, stop2amplitudeAstop1, stop2amplitudetopgravitino;

 stop2amplitudegluinotop = squarkamplitudedecaygluinomix (mu(2,3), MTOP, mGluino, alphas, 2, thetat);
 stop2amplitudebottomcharginoW1 = squark2amplitudedecaycharginoW1mix (mu(2,3), MBOTTOM, MCH1, g, thetaL2, thetaR2, thetat, beta, runmw, runmt, runmb,1);
 stop2amplitudebottomcharginoW2 = squark2amplitudedecaycharginoW2mix (mu(2,3), MBOTTOM, MCH2, g, thetaL2, thetaR2, thetat, beta, runmw, runmt, runmb,1);
 stop2amplitudetopneutralinoZ1 = testrealsquark3amplitudedecayneutralino (mu(2,3), MTOP, mneut(1), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 2, 1);
 stop2amplitudetopneutralinoZ2 = testrealsquark3amplitudedecayneutralino (mu(2,3), MTOP, mneut(2), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 2, 2);
 stop2amplitudetopneutralinoZ3 = testrealsquark3amplitudedecayneutralino (mu(2,3), MTOP, mneut(3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 2, 3);
 stop2amplitudetopneutralinoZ4 = testrealsquark3amplitudedecayneutralino (mu(2,3), MTOP, mneut(4), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 2, 4);
 stop2amplitudeWbosonsbottom1 = squark3amplitudedecaysquark3Wboson (mu(2,3), polemw, md(1,3), g, thetat, thetab, 1, 2, 2, 1);
 stop2amplitudeWbosonsbottom2 = squark3amplitudedecaysquark3Wboson (mu(2,3), polemw, md(2,3), g, thetat, thetab, 1, 2, 2, 2);
 stop2amplitudeHplussbottom1 = squark3amplitudedecaychargedHiggssquark3 (mu(2,3), mHpm, md(1,3), g, runmw, beta, thetat, thetab, greekmu, At, Ab, runmt, runmb, 2, 1);
 stop2amplitudeHplussbottom2 = squark3amplitudedecaychargedHiggssquark3 (mu(2,3), mHpm, md(2,3), g, runmw, beta, thetat, thetab, greekmu, At, Ab, runmt, runmb, 2, 2);
 stop2amplitudehstop1 = squark32amplitudedecayneutralHiggssquark3 (mu(2,3), mh0(1), mu(1,3), g, gp, runmw, beta, alpha, thetat, thetab, greekmu, At, Ab, runmt, runmb, 1, 'h');
 stop2amplitudeHstop1 = squark32amplitudedecayneutralHiggssquark3 (mu(2,3), mh0(2), mu(1,3), g, gp, runmw, beta, alpha, thetat, thetab, greekmu, At, Ab, runmt, runmb, 1, 'H'); 
 stop2amplitudeAstop1 = squark32amplitudedecayneutralHiggssquark3 (mu(2,3), mA0(1), mu(1,3), g, gp, runmw, beta, alpha, thetat, thetab, greekmu, At, Ab, runmt, runmb, 1, 'A');
 stop2amplitudeZbosonstop1 = squark32amplitudedecaysquark3Zboson (mu(2,3), mu(1,3), mz, g, gp, thetat); 

 stop2amplitudetopgravitino =squarkamplitudedecaygravitino(mu(2,3), mgravitino, MTOP, MPlreduced, gravonoff, upsquNLSP);

 ParticleStop2.Array_Decays[0][0] = PDGtop; ParticleStop2.Array_Decays[0][1] = PDGgluino; ParticleStop2.Array_Decays[0][2] = stop2amplitudegluinotop; ParticleStop2.Array_Decays[0][3] = 2; ParticleStop2.Array_Comments[0] = "# ~t_2 -> t ~g";
 ParticleStop2.Array_Decays[1][0] = PDGbottom; ParticleStop2.Array_Decays[1][1] = PDGchargino1; ParticleStop2.Array_Decays[1][2] = stop2amplitudebottomcharginoW1; ParticleStop2.Array_Decays[1][3] = 2; ParticleStop2.Array_Comments[1] = "# ~t_2 -> b ~chi_1+";
 ParticleStop2.Array_Decays[2][0] = PDGbottom; ParticleStop2.Array_Decays[2][1]= PDGchargino2; ParticleStop2.Array_Decays[2][2] = stop2amplitudebottomcharginoW2; ParticleStop2.Array_Decays[2][3] = 2; ParticleStop2.Array_Comments[2] = "# ~t_2 -> b ~chi_2+";
 ParticleStop2.Array_Decays[3][0] = PDGtop; ParticleStop2.Array_Decays[3][1] = PDGneutralino1; ParticleStop2.Array_Decays[3][2] = stop2amplitudetopneutralinoZ1; ParticleStop2.Array_Decays[3][3] = 2; ParticleStop2.Array_Comments[3] = "# ~t_2 -> t ~chi_10";
 ParticleStop2.Array_Decays[4][0] = PDGtop; ParticleStop2.Array_Decays[4][1] = PDGneutralino2; ParticleStop2.Array_Decays[4][2] = stop2amplitudetopneutralinoZ2; ParticleStop2.Array_Decays[4][3] = 2; ParticleStop2.Array_Comments[4] = "# ~t_2 -> t ~chi_20";
 ParticleStop2.Array_Decays[5][0] = PDGtop; ParticleStop2.Array_Decays[5][1] = PDGneutralino3; ParticleStop2.Array_Decays[5][2] = stop2amplitudetopneutralinoZ3; ParticleStop2.Array_Decays[5][3] = 2; ParticleStop2.Array_Comments[5] = "# ~t_2 -> t ~chi_30";
 ParticleStop2.Array_Decays[6][0] = PDGtop; ParticleStop2.Array_Decays[6][1] = PDGneutralino4; ParticleStop2.Array_Decays[6][2] = stop2amplitudetopneutralinoZ4; ParticleStop2.Array_Decays[6][3] = 2; ParticleStop2.Array_Comments[6] = "# ~t_2 -> t ~chi_40";
 ParticleStop2.Array_Decays[7][0] = PDGWplus; ParticleStop2.Array_Decays[7][1] = PDGsbottom1 ; ParticleStop2.Array_Decays[7][2] = stop2amplitudeWbosonsbottom1; ParticleStop2.Array_Decays[7][3] = 2; ParticleStop2.Array_Comments[7] = "# ~t_2 -> W+ ~b_1";
 ParticleStop2.Array_Decays[8][0] = PDGWplus; ParticleStop2.Array_Decays[8][1] = PDGsbottom2 ; ParticleStop2.Array_Decays[8][2] = stop2amplitudeWbosonsbottom2; ParticleStop2.Array_Decays[8][3] = 2; ParticleStop2.Array_Comments[8] = "# ~t_2 -> W+ ~b_2";
 ParticleStop2.Array_Decays[9][0] = PDGHplus; ParticleStop2.Array_Decays[9][1] = PDGsbottom1; ParticleStop2.Array_Decays[9][2] = stop2amplitudeHplussbottom1; ParticleStop2.Array_Decays[9][3] = 2; ParticleStop2.Array_Comments[9] = "# ~t_2 -> H+ ~b_1";
 ParticleStop2.Array_Decays[10][0] = PDGHplus; ParticleStop2.Array_Decays[10][1] = PDGsbottom2; ParticleStop2.Array_Decays[10][2] = stop2amplitudeHplussbottom2; ParticleStop2.Array_Decays[10][3] = 2; ParticleStop2.Array_Comments[10] = "# ~t_2 -> H+ ~b_2";
 ParticleStop2.Array_Decays[11][0] = PDGh0; ParticleStop2.Array_Decays[11][1] = PDGstop1; ParticleStop2.Array_Decays[11][2] = stop2amplitudehstop1; ParticleStop2.Array_Decays[11][3] = 2; ParticleStop2.Array_Comments[11] = "# ~t_2 -> h ~t_1";
 ParticleStop2.Array_Decays[12][0] = PDGH0; ParticleStop2.Array_Decays[12][1] = PDGstop1; ParticleStop2.Array_Decays[12][2] = stop2amplitudeHstop1; ParticleStop2.Array_Decays[12][3] = 2; ParticleStop2.Array_Comments[12] = "# ~t_2 -> H ~t_1";
 ParticleStop2.Array_Decays[13][0] = PDGA0; ParticleStop2.Array_Decays[13][1] = PDGstop1; ParticleStop2.Array_Decays[13][2] = stop2amplitudeAstop1; ParticleStop2.Array_Decays[13][3] = 2; ParticleStop2.Array_Comments[13] = "# ~t_2 -> A ~t_1";
 ParticleStop2.Array_Decays[14][0] = PDGstop1; ParticleStop2.Array_Decays[14][1] = PDGZboson; ParticleStop2.Array_Decays[14][2] = stop2amplitudeZbosonstop1; ParticleStop2.Array_Decays[14][3] = 2; ParticleStop2.Array_Comments[14] = "# ~t_2 -> Z ~t_1";

 ParticleStop2.Array_Decays[15][0] = PDGtop; ParticleStop2.Array_Decays[15][1] = PDGgravitino; ParticleStop2.Array_Decays[15][2] = stop2amplitudetopgravitino; ParticleStop2.Array_Decays[15][3] = 2; ParticleStop2.Array_Comments[15] = "# ~t_2 -> t ~G";

 
 double Stop2_No_1to2_Decays = 0;

 if (upsquNLSP == 1) { Stop2_No_1to2_Decays = ParticleStop2.No_1to2_Decays + ParticleStop2.No_grav_Decays;}
 else {Stop2_No_1to2_Decays = ParticleStop2.No_1to2_Decays;}
 
 for (int j = 0; j<Stop2_No_1to2_Decays; j++) {
   ParticleStop2.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<Stop2_No_1to2_Decays; j++) {
   ParticleStop2.two_width = ParticleStop2.two_width + ParticleStop2.Array_Decays[j][2];
 }
 for (int j=Stop2_No_1to2_Decays; j<ParticleStop2.No_of_Decays; j++) {
   ParticleStop2.three_width = ParticleStop2.three_width + ParticleStop2.Array_Decays[j][2];
 }
 
 if ( ParticleStop2.three_width != ParticleStop2.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for stop2 - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleStop2.No_of_Decays = Stop2_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleStop2.total_width = ParticleStop2.two_width;
   }
 else {
   ParticleStop2.total_width = ParticleStop2.two_width + ParticleStop2.three_width;
 }
 
 for (int i =0; i<ParticleStop2.No_of_Decays; i++) {
   ParticleStop2.Array_Decays[i][5]= ParticleStop2.Array_Decays[i][2]/ParticleStop2.total_width;
 }


 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleStop2.PDG << setw(12) << scientific << setprecision(8) <<  ParticleStop2.total_width << "   " << "# stop_2 decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleStop2.No_of_Decays; k++) {
   if( ParticleStop2.Array_Decays[k][2] != 0 && ParticleStop2.Array_Decays[k][5] > BRTol) {
         cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleStop2.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleStop2.Array_Decays[k][3];  printRowPDG(cout, ParticleStop2.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleStop2.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleStop2.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;

 
/// Slepton Decays

///SelectonL decays

 double selectronLamplitudeeneutralinoZ1, selectronLamplitudeeneutralinoZ2, selectronLamplitudeeneutralinoZ3, selectronLamplitudeeneutralinoZ4, selectronLamplitudenuecharginoW1, selectronLamplitudenuecharginoW2, selectronLamplitudeelectrongravitino;

 selectronLamplitudeeneutralinoZ1 = sleptonamplitudedecayleptonneutralino(me(1,1), MELECTRON, mneut(1), g, gp, mixNeut, 'L', 1);
 selectronLamplitudeeneutralinoZ2 = sleptonamplitudedecayleptonneutralino(me(1,1), MELECTRON, mneut(2), g, gp, mixNeut, 'L', 2);
 selectronLamplitudeeneutralinoZ3 = sleptonamplitudedecayleptonneutralino(me(1,1), MELECTRON, mneut(3), g, gp, mixNeut, 'L', 3);
 selectronLamplitudeeneutralinoZ4 = sleptonamplitudedecayleptonneutralino(me(1,1), MELECTRON, mneut(4), g, gp, mixNeut, 'L', 4);
 selectronLamplitudenuecharginoW1 = sleptonamplitudedecaychargino (me(1,1), 0, MCH1, g, thetaL2, 1);
 selectronLamplitudenuecharginoW2 = sleptonamplitudedecaychargino (me(1,1), 0, MCH2, g, thetaL2, 2);

 selectronLamplitudeelectrongravitino = squarkamplitudedecaygravitino(me(1,1), mgravitino, MELECTRON, MPlreduced, gravonoff, slepNLSP);

 ParticleSelectronL.Array_Decays[0][0] = PDGelectron; ParticleSelectronL.Array_Decays[0][1] = PDGneutralino1; ParticleSelectronL.Array_Decays[0][2] = selectronLamplitudeeneutralinoZ1; ParticleSelectronL.Array_Decays[0][3] = 2; ParticleSelectronL.Array_Comments[0] = "# ~e_L -> e- ~chi_10";
 ParticleSelectronL.Array_Decays[1][0] = PDGelectron; ParticleSelectronL.Array_Decays[1][1] = PDGneutralino2; ParticleSelectronL.Array_Decays[1][2] = selectronLamplitudeeneutralinoZ2; ParticleSelectronL.Array_Decays[1][3] = 2; ParticleSelectronL.Array_Comments[1] = "# ~e_L -> e- ~chi_20";
 ParticleSelectronL.Array_Decays[2][0] = PDGelectron; ParticleSelectronL.Array_Decays[2][1] = PDGneutralino3; ParticleSelectronL.Array_Decays[2][2] = selectronLamplitudeeneutralinoZ3; ParticleSelectronL.Array_Decays[2][3] = 2; ParticleSelectronL.Array_Comments[2] = "# ~e_L -> e- ~chi_30";
 ParticleSelectronL.Array_Decays[3][0] = PDGelectron; ParticleSelectronL.Array_Decays[3][1] = PDGneutralino4; ParticleSelectronL.Array_Decays[3][2] = selectronLamplitudeeneutralinoZ4; ParticleSelectronL.Array_Decays[3][3] = 2; ParticleSelectronL.Array_Comments[3] = "# ~e_L -> e- ~chi_40";
 ParticleSelectronL.Array_Decays[4][0] = PDGnuelectron; ParticleSelectronL.Array_Decays[4][1] = -PDGchargino1; ParticleSelectronL.Array_Decays[4][2] = selectronLamplitudenuecharginoW1; ParticleSelectronL.Array_Decays[4][3] = 2; ParticleSelectronL.Array_Comments[4] = "# ~e_L -> nu_e ~chi_1-";
 ParticleSelectronL.Array_Decays[5][0] = PDGnuelectron; ParticleSelectronL.Array_Decays[5][1] = -PDGchargino2; ParticleSelectronL.Array_Decays[5][2] = selectronLamplitudenuecharginoW2; ParticleSelectronL.Array_Decays[5][3] = 2; ParticleSelectronL.Array_Comments[5] = "# ~e_L -> nu_e ~chi_2-";

 ParticleSelectronL.Array_Decays[6][0] = PDGelectron; ParticleSelectronL.Array_Decays[6][1] = PDGgravitino; ParticleSelectronL.Array_Decays[6][2] = selectronLamplitudeelectrongravitino; ParticleSelectronL.Array_Decays[6][3] = 2; ParticleSelectronL.Array_Comments[6] = "# ~e_L -> e- ~G";

 double SelectronL_No_1to2_Decays = 0;

 if (slepNLSP == 1) { SelectronL_No_1to2_Decays = ParticleSelectronL.No_1to2_Decays + ParticleSelectronL.No_grav_Decays;}
 else {SelectronL_No_1to2_Decays = ParticleSelectronL.No_1to2_Decays;}
 
 for (int j = 0; j<SelectronL_No_1to2_Decays; j++) {
   ParticleSelectronL.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<SelectronL_No_1to2_Decays; j++) {
   ParticleSelectronL.two_width = ParticleSelectronL.two_width + ParticleSelectronL.Array_Decays[j][2];
 }
 for (int j=SelectronL_No_1to2_Decays; j<ParticleSelectronL.No_of_Decays; j++) {
   ParticleSelectronL.three_width = ParticleSelectronL.three_width + ParticleSelectronL.Array_Decays[j][2];
 }
 
 if ( ParticleSelectronL.three_width != ParticleSelectronL.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for selectronL - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleSelectronL.No_of_Decays = SelectronL_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleSelectronL.total_width = ParticleSelectronL.two_width;
   }
 else {
   ParticleSelectronL.total_width = ParticleSelectronL.two_width + ParticleSelectronL.three_width;
 }
 
 for (int i =0; i<ParticleSelectronL.No_of_Decays; i++) {
   ParticleSelectronL.Array_Decays[i][5]= ParticleSelectronL.Array_Decays[i][2]/ParticleSelectronL.total_width;
 }


 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleSelectronL.PDG << setw(12) << scientific << setprecision(8) <<  ParticleSelectronL.total_width << "   " << "# selectron_L decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleSelectronL.No_of_Decays; k++) {
   if( ParticleSelectronL.Array_Decays[k][2] != 0 && ParticleSelectronL.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleSelectronL.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleSelectronL.Array_Decays[k][3];  printRowPDG(cout, ParticleSelectronL.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleSelectronL.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleSelectronL.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;


///SelectonR decays

 double selectronRamplitudeeneutralinoZ1, selectronRamplitudeeneutralinoZ2, selectronRamplitudeeneutralinoZ3, selectronRamplitudeeneutralinoZ4, selectronRamplitudeelectrongravitino;

 selectronRamplitudeeneutralinoZ1 = sleptonamplitudedecayleptonneutralino(me(2,1), MELECTRON, mneut(1), g, gp, mixNeut, 'R', 1);
 selectronRamplitudeeneutralinoZ2 = sleptonamplitudedecayleptonneutralino(me(2,1), MELECTRON, mneut(2), g, gp, mixNeut, 'R', 2);
 selectronRamplitudeeneutralinoZ3 = sleptonamplitudedecayleptonneutralino(me(2,1), MELECTRON, mneut(3), g, gp, mixNeut, 'R', 3);
 selectronRamplitudeeneutralinoZ4 = sleptonamplitudedecayleptonneutralino(me(2,1), MELECTRON, mneut(4), g, gp, mixNeut, 'R', 4);

 selectronRamplitudeelectrongravitino = squarkamplitudedecaygravitino(me(2,1), mgravitino, MELECTRON, MPlreduced, gravonoff, slepNLSP);

 ParticleSelectronR.Array_Decays[0][0] = PDGelectron; ParticleSelectronR.Array_Decays[0][1] = PDGneutralino1; ParticleSelectronR.Array_Decays[0][2] = selectronRamplitudeeneutralinoZ1; ParticleSelectronR.Array_Decays[0][3] = 2; ParticleSelectronR.Array_Comments[0] = "# ~e_R -> e- ~chi_10";
 ParticleSelectronR.Array_Decays[1][0] = PDGelectron; ParticleSelectronR.Array_Decays[1][1] = PDGneutralino2; ParticleSelectronR.Array_Decays[1][2] = selectronRamplitudeeneutralinoZ2; ParticleSelectronR.Array_Decays[1][3] = 2; ParticleSelectronR.Array_Comments[1] = "# ~e_R -> e- ~chi_20";
 ParticleSelectronR.Array_Decays[2][0] = PDGelectron; ParticleSelectronR.Array_Decays[2][1] = PDGneutralino3; ParticleSelectronR.Array_Decays[2][2] = selectronRamplitudeeneutralinoZ3; ParticleSelectronR.Array_Decays[2][3] = 2; ParticleSelectronR.Array_Comments[2] = "# ~e_R -> e- ~chi_30";
 ParticleSelectronR.Array_Decays[3][0] = PDGelectron; ParticleSelectronR.Array_Decays[3][1] = PDGneutralino4; ParticleSelectronR.Array_Decays[3][2] = selectronRamplitudeeneutralinoZ4; ParticleSelectronL.Array_Decays[3][3] = 2; ParticleSelectronR.Array_Comments[3] = "# ~e_R -> e- ~chi_40";

 ParticleSelectronR.Array_Decays[4][0] = PDGelectron; ParticleSelectronR.Array_Decays[4][1] = PDGgravitino; ParticleSelectronR.Array_Decays[4][2] = selectronRamplitudeelectrongravitino; ParticleSelectronL.Array_Decays[4][3] = 2; ParticleSelectronR.Array_Comments[4] = "# ~e_R -> e- ~G";

 double SelectronR_No_1to2_Decays = 0;

 if (slepNLSP == 1) { SelectronR_No_1to2_Decays = ParticleSelectronR.No_1to2_Decays + ParticleSelectronR.No_grav_Decays;}
 else {SelectronR_No_1to2_Decays = ParticleSelectronR.No_1to2_Decays;}
 
 for (int j = 0; j<SelectronR_No_1to2_Decays; j++) {
   ParticleSelectronR.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<SelectronR_No_1to2_Decays; j++) {
   ParticleSelectronR.two_width = ParticleSelectronR.two_width + ParticleSelectronR.Array_Decays[j][2];
 }
 for (int j=SelectronR_No_1to2_Decays; j<ParticleSelectronR.No_of_Decays; j++) {
   ParticleSelectronR.three_width = ParticleSelectronR.three_width + ParticleSelectronR.Array_Decays[j][2];
 }
 
 if ( ParticleSelectronR.three_width != ParticleSelectronR.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for selectronR - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleSelectronR.No_of_Decays = SelectronR_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleSelectronR.total_width = ParticleSelectronR.two_width;
   }
 else {
   ParticleSelectronR.total_width = ParticleSelectronR.two_width + ParticleSelectronR.three_width;
 }
 
 for (int i =0; i<ParticleSelectronR.No_of_Decays; i++) {
   ParticleSelectronR.Array_Decays[i][5]= ParticleSelectronR.Array_Decays[i][2]/ParticleSelectronR.total_width;
 }

 
 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleSelectronR.PDG << setw(12) << scientific << setprecision(8) <<  ParticleSelectronR.total_width << "   " << "# selectron_R decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleSelectronR.No_of_Decays; k++) {
   if( ParticleSelectronR.Array_Decays[k][2] != 0 && ParticleSelectronR.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleSelectronR.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleSelectronR.Array_Decays[k][3];  printRowPDG(cout, ParticleSelectronR.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleSelectronR.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleSelectronR.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;



///SmuonL decays

 double smuonLamplitudemuneutralinoZ1, smuonLamplitudemuneutralinoZ2, smuonLamplitudemuneutralinoZ3, smuonLamplitudemuneutralinoZ4, smuonLamplitudenumucharginoW1, smuonLamplitudenumucharginoW2, smuonLamplitudemuongravitino;

 smuonLamplitudemuneutralinoZ1 = sleptonamplitudedecayleptonneutralino(me(1,2), MMUON, mneut(1), g, gp, mixNeut, 'L', 1);
 smuonLamplitudemuneutralinoZ2 = sleptonamplitudedecayleptonneutralino(me(1,2), MMUON, mneut(2), g, gp, mixNeut, 'L', 2);
 smuonLamplitudemuneutralinoZ3 = sleptonamplitudedecayleptonneutralino(me(1,2), MMUON, mneut(3), g, gp, mixNeut, 'L', 3);
 smuonLamplitudemuneutralinoZ4 = sleptonamplitudedecayleptonneutralino(me(1,2), MMUON, mneut(4), g, gp, mixNeut, 'L', 4);
 smuonLamplitudenumucharginoW1 = sleptonamplitudedecaychargino (me(1,2), 0, MCH1, g, thetaL2, 1);
 smuonLamplitudenumucharginoW2 = sleptonamplitudedecaychargino (me(1,2), 0, MCH2, g, thetaL2, 2);

 smuonLamplitudemuongravitino = squarkamplitudedecaygravitino(me(1,2), mgravitino, MMUON, MPlreduced, gravonoff, slepNLSP);

 ParticleSmuonL.Array_Decays[0][0] = PDGmuon; ParticleSmuonL.Array_Decays[0][1] = PDGneutralino1; ParticleSmuonL.Array_Decays[0][2] = smuonLamplitudemuneutralinoZ1; ParticleSmuonL.Array_Decays[0][3] = 2; ParticleSmuonL.Array_Comments[0] = "# ~mu_L -> mu- ~chi_10";
 ParticleSmuonL.Array_Decays[1][0] = PDGmuon; ParticleSmuonL.Array_Decays[1][1] = PDGneutralino2; ParticleSmuonL.Array_Decays[1][2] = smuonLamplitudemuneutralinoZ2; ParticleSmuonL.Array_Decays[1][3] = 2; ParticleSmuonL.Array_Comments[1] = "# ~mu_L -> mu- ~chi_20";
 ParticleSmuonL.Array_Decays[2][0] = PDGmuon; ParticleSmuonL.Array_Decays[2][1] = PDGneutralino3; ParticleSmuonL.Array_Decays[2][2] = smuonLamplitudemuneutralinoZ3; ParticleSmuonL.Array_Decays[2][3] = 2; ParticleSmuonL.Array_Comments[2] = "# ~mu_L -> mu- ~chi_30";
 ParticleSmuonL.Array_Decays[3][0] = PDGmuon; ParticleSmuonL.Array_Decays[3][1] = PDGneutralino4; ParticleSmuonL.Array_Decays[3][2] = smuonLamplitudemuneutralinoZ4; ParticleSmuonL.Array_Decays[3][3] = 2; ParticleSmuonL.Array_Comments[3] = "# ~mu_L -> mu- ~chi_40";
 ParticleSmuonL.Array_Decays[4][0] = PDGnumuon; ParticleSmuonL.Array_Decays[4][1] = -PDGchargino1; ParticleSmuonL.Array_Decays[4][2] = smuonLamplitudenumucharginoW1; ParticleSmuonL.Array_Decays[4][3] = 2; ParticleSmuonL.Array_Comments[4] = "# ~mu_L -> nu_mu ~chi_1-";
 ParticleSmuonL.Array_Decays[5][0] = PDGnumuon; ParticleSmuonL.Array_Decays[5][1] = -PDGchargino2; ParticleSmuonL.Array_Decays[5][2] = smuonLamplitudenumucharginoW2; ParticleSmuonL.Array_Decays[5][3] = 2; ParticleSmuonL.Array_Comments[5] = "# ~mu_L -> nu_mu ~chi_2-";

ParticleSmuonL.Array_Decays[6][0] = PDGmuon; ParticleSmuonL.Array_Decays[6][1] = PDGgravitino; ParticleSmuonL.Array_Decays[6][2] = smuonLamplitudemuongravitino; ParticleSmuonL.Array_Decays[6][3] = 2; ParticleSmuonL.Array_Comments[6] = "# ~mu_L -> mu- ~G"; 


 double SmuonL_No_1to2_Decays = 0;

 if (slepNLSP == 1) { SmuonL_No_1to2_Decays = ParticleSmuonL.No_1to2_Decays + ParticleSmuonL.No_grav_Decays;}
 else {SmuonL_No_1to2_Decays = ParticleSmuonL.No_1to2_Decays;}
 
 for (int j = 0; j<SmuonL_No_1to2_Decays; j++) {
   ParticleSmuonL.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<SmuonL_No_1to2_Decays; j++) {
   ParticleSmuonL.two_width = ParticleSmuonL.two_width + ParticleSmuonL.Array_Decays[j][2];
 }
 for (int j=SmuonL_No_1to2_Decays; j<ParticleSmuonL.No_of_Decays; j++) {
   ParticleSmuonL.three_width = ParticleSmuonL.three_width + ParticleSmuonL.Array_Decays[j][2];
 }
 
 if ( ParticleSmuonL.three_width != ParticleSmuonL.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for smuonL - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleSmuonL.No_of_Decays = SmuonL_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleSmuonL.total_width = ParticleSmuonL.two_width;
   }
 else {
   ParticleSmuonL.total_width = ParticleSmuonL.two_width + ParticleSmuonL.three_width;
 }
 
 for (int i =0; i<ParticleSmuonL.No_of_Decays; i++) {
   ParticleSmuonL.Array_Decays[i][5]= ParticleSmuonL.Array_Decays[i][2]/ParticleSmuonL.total_width;
 }
 
 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleSmuonL.PDG << setw(12) << scientific << setprecision(8) <<  ParticleSmuonL.total_width << "   " << "# smuon_L decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleSmuonL.No_of_Decays; k++) {
   if( ParticleSmuonL.Array_Decays[k][2] != 0 && ParticleSmuonL.Array_Decays[k][5] > BRTol) {
         cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleSmuonL.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleSmuonL.Array_Decays[k][3];  printRowPDG(cout, ParticleSmuonL.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleSmuonL.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleSmuonL.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;


///SmuonR decays

 double smuonRamplitudemuneutralinoZ1, smuonRamplitudemuneutralinoZ2, smuonRamplitudemuneutralinoZ3, smuonRamplitudemuneutralinoZ4, smuonRamplitudemuongravitino;

 smuonRamplitudemuneutralinoZ1 = sleptonamplitudedecayleptonneutralino(me(2,2), MMUON, mneut(1), g, gp, mixNeut, 'R', 1);
 smuonRamplitudemuneutralinoZ2 = sleptonamplitudedecayleptonneutralino(me(2,2), MMUON, mneut(2), g, gp, mixNeut, 'R', 2);
 smuonRamplitudemuneutralinoZ3 = sleptonamplitudedecayleptonneutralino(me(2,2), MMUON, mneut(3), g, gp, mixNeut, 'R', 3);
 smuonRamplitudemuneutralinoZ4 = sleptonamplitudedecayleptonneutralino(me(2,2), MMUON, mneut(4), g, gp, mixNeut, 'R', 4);

 smuonRamplitudemuongravitino = squarkamplitudedecaygravitino (me(2,2), mgravitino, MMUON, MPlreduced, gravonoff, slepNLSP);

 ParticleSmuonR.Array_Decays[0][0] = PDGmuon; ParticleSmuonR.Array_Decays[0][1] = PDGneutralino1; ParticleSmuonR.Array_Decays[0][2] = smuonRamplitudemuneutralinoZ1; ParticleSmuonR.Array_Decays[0][3] = 2; ParticleSmuonR.Array_Comments[0] = "# ~mu_R -> mu- ~chi_10";
 ParticleSmuonR.Array_Decays[1][0] = PDGmuon; ParticleSmuonR.Array_Decays[1][1] = PDGneutralino2; ParticleSmuonR.Array_Decays[1][2] = smuonRamplitudemuneutralinoZ2; ParticleSmuonR.Array_Decays[1][3] = 2; ParticleSmuonR.Array_Comments[1] = "# ~mu_R -> mu- ~chi_20";
 ParticleSmuonR.Array_Decays[2][0] = PDGmuon; ParticleSmuonR.Array_Decays[2][1] = PDGneutralino3; ParticleSmuonR.Array_Decays[2][2] = smuonRamplitudemuneutralinoZ3; ParticleSmuonR.Array_Decays[2][3] = 2; ParticleSmuonR.Array_Comments[2] = "# ~mu_R -> mu- ~chi_30";
 ParticleSmuonR.Array_Decays[3][0] = PDGmuon; ParticleSmuonR.Array_Decays[3][1] = PDGneutralino4; ParticleSmuonR.Array_Decays[3][2] = smuonRamplitudemuneutralinoZ4; ParticleSmuonR.Array_Decays[3][3] = 2; ParticleSmuonR.Array_Comments[3] = "# ~mu_R -> mu- ~chi_40";
 
 ParticleSmuonR.Array_Decays[4][0] = PDGmuon; ParticleSmuonR.Array_Decays[4][1] = PDGgravitino; ParticleSmuonR.Array_Decays[4][2] = smuonRamplitudemuongravitino; ParticleSmuonR.Array_Decays[4][3] = 2; ParticleSmuonR.Array_Comments[4] = "# ~mu_R -> mu- ~G";
 
 double SmuonR_No_1to2_Decays = 0;

 if (slepNLSP == 1) { SmuonR_No_1to2_Decays = ParticleSmuonR.No_1to2_Decays + ParticleSmuonR.No_grav_Decays;}
 else {SmuonR_No_1to2_Decays = ParticleSmuonR.No_1to2_Decays;}
 
 for (int j = 0; j<SmuonR_No_1to2_Decays; j++) {
   ParticleSmuonR.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<SmuonR_No_1to2_Decays; j++) {
   ParticleSmuonR.two_width = ParticleSmuonR.two_width + ParticleSmuonR.Array_Decays[j][2];
 }
 for (int j=SmuonR_No_1to2_Decays; j<ParticleSmuonR.No_of_Decays; j++) {
   ParticleSmuonR.three_width = ParticleSmuonR.three_width + ParticleSmuonL.Array_Decays[j][2];
 }
 
 if ( ParticleSmuonR.three_width != ParticleSmuonR.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for smuonR - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleSmuonR.No_of_Decays = SmuonR_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleSmuonR.total_width = ParticleSmuonR.two_width;
   }
 else {
   ParticleSmuonR.total_width = ParticleSmuonR.two_width + ParticleSmuonR.three_width;
 }
 
 for (int i =0; i<ParticleSmuonR.No_of_Decays; i++) {
   ParticleSmuonR.Array_Decays[i][5]= ParticleSmuonR.Array_Decays[i][2]/ParticleSmuonR.total_width;
 }
 
 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleSmuonR.PDG << setw(12) << scientific << setprecision(8) <<  ParticleSmuonR.total_width << "   " << "# smuon_R decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleSmuonR.No_of_Decays; k++) {
   if( ParticleSmuonR.Array_Decays[k][2] != 0 && ParticleSmuonR.Array_Decays[k][5] > BRTol) {
         cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleSmuonR.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleSmuonR.Array_Decays[k][3];  printRowPDG(cout, ParticleSmuonR.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleSmuonR.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleSmuonR.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;


 ///Selectron sneutrino decays

 double snueamplitudenueneutralinoZ1, snueamplitudenueneutralinoZ2, snueamplitudenueneutralinoZ3, snueamplitudenueneutralinoZ4, snueamplitudeecharginoW1, snueamplitudeecharginoW2, snueamplitudenuegravitino;
 
 snueamplitudenueneutralinoZ1 = sneutrinoamplitudedecayneutrinoneutralino (msnu(1), 0, mneut(1), g, gp, mixNeut, 1);
 snueamplitudenueneutralinoZ2 = sneutrinoamplitudedecayneutrinoneutralino (msnu(1), 0, mneut(2), g, gp, mixNeut, 2);
 snueamplitudenueneutralinoZ3 = sneutrinoamplitudedecayneutrinoneutralino (msnu(1), 0, mneut(3), g, gp, mixNeut, 3);
 snueamplitudenueneutralinoZ4 = sneutrinoamplitudedecayneutrinoneutralino (msnu(1), 0, mneut(4), g, gp, mixNeut, 4);
 snueamplitudeecharginoW1 = sleptonamplitudedecaychargino (msnu(1), MELECTRON, MCH1, g, thetaR2, 1);
 snueamplitudeecharginoW2 = sleptonamplitudedecaychargino (msnu(1), MELECTRON, MCH2, g, thetaR2, 2);

 snueamplitudenuegravitino = squarkamplitudedecaygravitino(msnu(1),mgravitino, 0, MPlreduced, gravonoff, snuNLSP);

 ParticleSnue.Array_Decays[0][0] = PDGnuelectron; ParticleSnue.Array_Decays[0][1] = PDGneutralino1; ParticleSnue.Array_Decays[0][2] = snueamplitudenueneutralinoZ1; ParticleSnue.Array_Decays[0][3] = 2; ParticleSnue.Array_Comments[0] = "# ~nu_eL -> nu_e ~chi_10" ;
 ParticleSnue.Array_Decays[1][0] = PDGnuelectron; ParticleSnue.Array_Decays[1][1] = PDGneutralino2; ParticleSnue.Array_Decays[1][2] = snueamplitudenueneutralinoZ2; ParticleSnue.Array_Decays[1][3] = 2; ParticleSnue.Array_Comments[1] = "# ~nu_eL -> nu_e ~chi_20";
 ParticleSnue.Array_Decays[2][0] = PDGnuelectron; ParticleSnue.Array_Decays[2][1] = PDGneutralino3; ParticleSnue.Array_Decays[2][2] = snueamplitudenueneutralinoZ3; ParticleSnue.Array_Decays[2][3] = 2; ParticleSnue.Array_Comments[2] = "# ~nu_eL -> nu_e ~chi_30";
 ParticleSnue.Array_Decays[3][0] = PDGnuelectron; ParticleSnue.Array_Decays[3][1] = PDGneutralino4; ParticleSnue.Array_Decays[3][2] = snueamplitudenueneutralinoZ4; ParticleSnue.Array_Decays[3][3] = 2; ParticleSnue.Array_Comments[3] = "# ~nu_eL -> nu_e ~chi_40";
 ParticleSnue.Array_Decays[4][0] = PDGelectron; ParticleSnue.Array_Decays[4][1] = PDGchargino1; ParticleSnue.Array_Decays[4][2] = snueamplitudeecharginoW1; ParticleSnue.Array_Decays[4][3] = 2; ParticleSnue.Array_Comments[4] = "# ~nu_eL -> e- ~chi_1+";
 ParticleSnue.Array_Decays[5][0] = PDGelectron; ParticleSnue.Array_Decays[5][1] = PDGchargino2; ParticleSnue.Array_Decays[5][2] = snueamplitudeecharginoW2; ParticleSnue.Array_Decays[5][3] = 2; ParticleSnue.Array_Comments[5] = "# ~nu_eL -> e- ~chi_2+";


  ParticleSnue.Array_Decays[6][0] = PDGnuelectron; ParticleSnue.Array_Decays[6][1] = PDGgravitino; ParticleSnue.Array_Decays[6][2] = snueamplitudenuegravitino; ParticleSnue.Array_Decays[6][3] = 2; ParticleSnue.Array_Comments[6] = "# ~nu_eL -> nu_e ~G";

  double Snue_No_1to2_Decays = 0;

 if (snuNLSP == 1) { Snue_No_1to2_Decays = ParticleSnue.No_1to2_Decays + ParticleSnue.No_grav_Decays;}
 else {Snue_No_1to2_Decays = ParticleSnue.No_1to2_Decays;}
 
 for (int j = 0; j<Snue_No_1to2_Decays; j++) {
   ParticleSnue.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<Snue_No_1to2_Decays; j++) {
   ParticleSnue.two_width = ParticleSnue.two_width + ParticleSnue.Array_Decays[j][2];
 }
 for (int j=Snue_No_1to2_Decays; j<ParticleSnue.No_of_Decays; j++) {
   ParticleSnue.three_width = ParticleSnue.three_width + ParticleSnue.Array_Decays[j][2];
 }
 
 if ( ParticleSnue.three_width != ParticleSnue.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for snue - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleSnue.No_of_Decays = Snue_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleSnue.total_width = ParticleSnue.two_width;
   }
 else {
   ParticleSnue.total_width = ParticleSnue.two_width + ParticleSnue.three_width;
 }
 
 for (int i =0; i<ParticleSnue.No_of_Decays; i++) {
   ParticleSnue.Array_Decays[i][5]= ParticleSnue.Array_Decays[i][2]/ParticleSnue.total_width;
 }

 
 
 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleSnue.PDG << setw(12) << scientific << setprecision(8) <<  ParticleSnue.total_width << "   " << "# snu_eL decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleSnue.No_of_Decays; k++) {
   if( ParticleSnue.Array_Decays[k][2] != 0 && ParticleSnue.Array_Decays[k][5] > BRTol) {
         cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleSnue.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleSnue.Array_Decays[k][3];  printRowPDG(cout, ParticleSnue.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleSnue.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleSnue.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;

///Smuon sneutrino decays

 double snumuamplitudenumuneutralinoZ1, snumuamplitudenumuneutralinoZ2, snumuamplitudenumuneutralinoZ3, snumuamplitudenumuneutralinoZ4, snumuamplitudemucharginoW1, snumuamplitudemucharginoW2, snumuamplitudenumugravitino;
 
 snumuamplitudenumuneutralinoZ1 = sneutrinoamplitudedecayneutrinoneutralino (msnu(2), 0, mneut(1), g, gp, mixNeut, 1);
 snumuamplitudenumuneutralinoZ2 = sneutrinoamplitudedecayneutrinoneutralino (msnu(2), 0, mneut(2), g, gp, mixNeut, 2);
 snumuamplitudenumuneutralinoZ3 = sneutrinoamplitudedecayneutrinoneutralino (msnu(2), 0, mneut(3), g, gp, mixNeut, 3);
 snumuamplitudenumuneutralinoZ4 = sneutrinoamplitudedecayneutrinoneutralino (msnu(2), 0, mneut(4), g, gp, mixNeut, 4);
 snumuamplitudemucharginoW1 = sleptonamplitudedecaychargino (msnu(2), MMUON, MCH1, g, thetaR2, 1);
 snumuamplitudemucharginoW2 = sleptonamplitudedecaychargino (msnu(2), MMUON, MCH2, g, thetaR2, 2);

 snumuamplitudenumugravitino = squarkamplitudedecaygravitino (msnu(2), mgravitino, 0, MPlreduced, gravonoff, snuNLSP);

 ParticleSnumu.Array_Decays[0][0] = PDGnumuon; ParticleSnumu.Array_Decays[0][1] = PDGneutralino1; ParticleSnumu.Array_Decays[0][2] = snumuamplitudenumuneutralinoZ1; ParticleSnumu.Array_Decays[0][3] = 2; ParticleSnumu.Array_Comments[0] = "# ~nu_muL -> nu_mu ~chi_10";
 ParticleSnumu.Array_Decays[1][0] = PDGnumuon; ParticleSnumu.Array_Decays[1][1] = PDGneutralino2; ParticleSnumu.Array_Decays[1][2] = snumuamplitudenumuneutralinoZ2; ParticleSnumu.Array_Decays[1][3] = 2; ParticleSnumu.Array_Comments[1] = "# ~nu_muL -> nu_mu ~chi_20";
 ParticleSnumu.Array_Decays[2][0] = PDGnumuon; ParticleSnumu.Array_Decays[2][1] = PDGneutralino3; ParticleSnumu.Array_Decays[2][2] = snumuamplitudenumuneutralinoZ3; ParticleSnumu.Array_Decays[2][3] = 2; ParticleSnumu.Array_Comments[2] = "# ~nu_muL -> nu_mu ~chi_30";
 ParticleSnumu.Array_Decays[3][0] = PDGnumuon; ParticleSnumu.Array_Decays[3][1] = PDGneutralino4; ParticleSnumu.Array_Decays[3][2] = snumuamplitudenumuneutralinoZ4; ParticleSnumu.Array_Decays[3][3] = 2; ParticleSnumu.Array_Comments[3] = "# ~nu_muL -> nu_mu ~chi_40";
 ParticleSnumu.Array_Decays[4][0] = PDGmuon; ParticleSnumu.Array_Decays[4][1] = PDGchargino1; ParticleSnumu.Array_Decays[4][2] = snumuamplitudemucharginoW1; ParticleSnumu.Array_Decays[4][3] = 2; ParticleSnumu.Array_Comments[4] = "# ~nu_muL -> mu- ~chi_1+";
 ParticleSnumu.Array_Decays[5][0] = PDGmuon; ParticleSnumu.Array_Decays[5][1] = PDGchargino2; ParticleSnumu.Array_Decays[5][2] = snumuamplitudemucharginoW2; ParticleSnumu.Array_Decays[5][3] = 2; ParticleSnumu.Array_Comments[5] = "# ~nu_muL -> mu- ~chi_2+";

 ParticleSnumu.Array_Decays[6][0] = PDGnumuon; ParticleSnumu.Array_Decays[6][1] = PDGgravitino; ParticleSnumu.Array_Decays[6][2] = snumuamplitudenumugravitino; ParticleSnumu.Array_Decays[6][3] = 2; ParticleSnumu.Array_Comments[6] = "# ~nu_muL -> nu_mu ~G";

 double Snumu_No_1to2_Decays = 0;

 if (snuNLSP == 1) { Snumu_No_1to2_Decays = ParticleSnumu.No_1to2_Decays + ParticleSnumu.No_grav_Decays;}
 else {Snumu_No_1to2_Decays = ParticleSnumu.No_1to2_Decays;}
 
 for (int j = 0; j<Snumu_No_1to2_Decays; j++) {
   ParticleSnumu.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<Snumu_No_1to2_Decays; j++) {
   ParticleSnumu.two_width = ParticleSnumu.two_width + ParticleSnumu.Array_Decays[j][2];
 }
 for (int j=Snumu_No_1to2_Decays; j<ParticleSnumu.No_of_Decays; j++) {
   ParticleSnumu.three_width = ParticleSnumu.three_width + ParticleSnumu.Array_Decays[j][2];
 }
 
 if ( ParticleSnumu.three_width != ParticleSnumu.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for snumu - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleSnumu.No_of_Decays = Snumu_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleSnumu.total_width = ParticleSnumu.two_width;
   }
 else {
   ParticleSnumu.total_width = ParticleSnumu.two_width + ParticleSnumu.three_width;
 }
 
 for (int i =0; i<ParticleSnumu.No_of_Decays; i++) {
   ParticleSnumu.Array_Decays[i][5]= ParticleSnumu.Array_Decays[i][2]/ParticleSnumu.total_width;
 }

 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleSnumu.PDG << setw(12) << scientific << setprecision(8) <<  ParticleSnumu.total_width << "   " << "# snu_muL decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleSnumu.No_of_Decays; k++) {
   if( ParticleSnumu.Array_Decays[k][2] != 0 && ParticleSnumu.Array_Decays[k][5] > BRTol) {
         cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleSnumu.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleSnumu.Array_Decays[k][3];  printRowPDG(cout, ParticleSnumu.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleSnumu.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleSnumu.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;

 ///Stau1 decays

 double stau1amplitudetauneutralinoZ1, stau1amplitudetauneutralinoZ2, stau1amplitudetauneutralinoZ3, stau1amplitudetauneutralinoZ4, stau1amplitudetauneutrinocharginoW1, stau1amplitudetauneutrinocharginoW2, stau1amplitudetausneutrinoHminus, stau1amplitudesnustauWboson, stau1amplitudetaugravitino;
 // cout << "mstau1 = " << me(1,3) << endl;
 
 stau1amplitudetauneutralinoZ1 = stauamplitudedecaytauneutralino (me(1,3), MTAU, mneut(1), g, gp, runmw, mixNeut, thetatau, beta, 1, 1);
 stau1amplitudetauneutralinoZ2 = stauamplitudedecaytauneutralino (me(1,3), MTAU, mneut(2), g, gp, runmw, mixNeut, thetatau, beta, 1, 2);
 stau1amplitudetauneutralinoZ3 = stauamplitudedecaytauneutralino (me(1,3), MTAU, mneut(3), g, gp, runmw, mixNeut, thetatau, beta, 1, 3);
 stau1amplitudetauneutralinoZ4 = stauamplitudedecaytauneutralino (me(1,3), MTAU, mneut(4), g, gp, runmw, mixNeut, thetatau, beta, 1, 4);
 stau1amplitudetauneutrinocharginoW1 = stauamplitudedecaynutauchargino (me(1,3), 0, MCH1, g, runmw, thetatau, thetaL2, beta, MTAU, 1, 1);
 stau1amplitudetauneutrinocharginoW2 = stauamplitudedecaynutauchargino (me(1,3), 0, MCH2, g, runmw, thetatau, thetaL2, beta, MTAU, 1, 2);
 stau1amplitudetausneutrinoHminus = stauamplitudedecaysnustauHminus (me(1,3), msnu(3), mHpm, g, runmw, beta, thetatau, MTAU, greekmu, Atau, 1);
 stau1amplitudesnustauWboson = stauamplitudedecaysnustauWboson (me(1,3), msnu(3), polemw, g, thetatau, 1);
 stau1amplitudetaugravitino = squarkamplitudedecaygravitino(me(1,3), mgravitino, MTAU, MPlreduced, gravonoff, slepNLSP);

 ParticleStau1.Array_Decays[0][0] = PDGtau; ParticleStau1.Array_Decays[0][1] = PDGneutralino1; ParticleStau1.Array_Decays[0][2] = stau1amplitudetauneutralinoZ1; ParticleStau1.Array_Decays[0][3] = 2; ParticleStau1.Array_Comments[0] = "# ~tau_1- -> tau- ~chi_10";
 ParticleStau1.Array_Decays[1][0] = PDGtau; ParticleStau1.Array_Decays[1][1] = PDGneutralino2; ParticleStau1.Array_Decays[1][2] = stau1amplitudetauneutralinoZ2; ParticleStau1.Array_Decays[1][3] = 2; ParticleStau1.Array_Comments[1] = "# ~tau_1- -> tau- ~chi_20";
 ParticleStau1.Array_Decays[2][0] = PDGtau; ParticleStau1.Array_Decays[2][1] = PDGneutralino3; ParticleStau1.Array_Decays[2][2] = stau1amplitudetauneutralinoZ3; ParticleStau1.Array_Decays[2][3] = 2; ParticleStau1.Array_Comments[2] = "# ~tau_1- -> tau- ~chi_30";
 ParticleStau1.Array_Decays[3][0] = PDGtau; ParticleStau1.Array_Decays[3][1] = PDGneutralino4; ParticleStau1.Array_Decays[3][2] = stau1amplitudetauneutralinoZ4; ParticleStau1.Array_Decays[3][3] = 2; ParticleStau1.Array_Comments[3] = "# ~tau_1- -> tau- ~chi_40";
 ParticleStau1.Array_Decays[4][0] = PDGnutau; ParticleStau1.Array_Decays[4][1] = PDGchargino1; ParticleStau1.Array_Decays[4][2] = stau1amplitudetauneutrinocharginoW1; ParticleStau1.Array_Decays[4][3] = 2; ParticleStau1.Array_Comments[4] = "# ~tau_1- -> nu_tau ~chi_1-";
 ParticleStau1.Array_Decays[5][0] = PDGnutau; ParticleStau1.Array_Decays[5][1] = PDGchargino2; ParticleStau1.Array_Decays[5][2] = stau1amplitudetauneutrinocharginoW2; ParticleStau1.Array_Decays[5][3] = 2; ParticleStau1.Array_Comments[5] = "# ~tau_1- -> nu_tau ~chi_2-";
 ParticleStau1.Array_Decays[6][0] = PDGnustauL; ParticleStau1.Array_Decays[6][1] = -PDGHplus; ParticleStau1.Array_Decays[6][2] = stau1amplitudetausneutrinoHminus; ParticleStau1.Array_Decays[6][3] = 2; ParticleStau1.Array_Comments[6] = "# ~tau_1- -> H- ~nu_tauL";
 ParticleStau1.Array_Decays[7][0] = PDGnustauL; ParticleStau1.Array_Decays[7][1] = -PDGWplus; ParticleStau1.Array_Decays[7][2] = stau1amplitudesnustauWboson; ParticleStau1.Array_Decays[7][3] = 2; ParticleStau1.Array_Comments[7] = "# ~tau_1- -> W- ~nu_tauL";
 
ParticleStau1.Array_Decays[8][0] = PDGtau; ParticleStau1.Array_Decays[8][1] = PDGgravitino; ParticleStau1.Array_Decays[8][2] = stau1amplitudetaugravitino; ParticleStau1.Array_Decays[8][3] = 2; ParticleStau1.Array_Comments[8] = "# ~tau_1- -> tau- ~G";
 
 double Stau1_No_1to2_Decays = 0;

 if (slepNLSP == 1) { Stau1_No_1to2_Decays = ParticleStau1.No_1to2_Decays + ParticleStau1.No_grav_Decays;}
 else {Stau1_No_1to2_Decays = ParticleStau1.No_1to2_Decays;}
 
 for (int j = 0; j<Stau1_No_1to2_Decays; j++) {
   ParticleStau1.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<Stau1_No_1to2_Decays; j++) {
   ParticleStau1.two_width = ParticleStau1.two_width + ParticleStau1.Array_Decays[j][2];
 }
 for (int j=Stau1_No_1to2_Decays; j<ParticleStau1.No_of_Decays; j++) {
   ParticleStau1.three_width = ParticleStau1.three_width + ParticleStau1.Array_Decays[j][2];
 }
 
 if ( ParticleStau1.three_width != ParticleStau1.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for stau1 - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleStau1.No_of_Decays = Stau1_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleStau1.total_width = ParticleStau1.two_width;
   }
 else {
   ParticleStau1.total_width = ParticleStau1.two_width + ParticleStau1.three_width;
 }
 
 for (int i =0; i<ParticleStau1.No_of_Decays; i++) {
   ParticleStau1.Array_Decays[i][5]= ParticleStau1.Array_Decays[i][2]/ParticleStau1.total_width;
 }

 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleStau1.PDG << setw(12) << scientific << setprecision(8) <<  ParticleStau1.total_width << "   " << "# stau_1 decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleStau1.No_of_Decays; k++) {
   if( ParticleStau1.Array_Decays[k][2] != 0 && ParticleStau1.Array_Decays[k][5] > BRTol) {
         cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleStau1.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleStau1.Array_Decays[k][3];  printRowPDG(cout, ParticleStau1.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleStau1.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleStau1.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;

///Stau2 decays

 double stau2amplitudetauneutralinoZ1, stau2amplitudetauneutralinoZ2, stau2amplitudetauneutralinoZ3, stau2amplitudetauneutralinoZ4, stau2amplitudetauneutrinocharginoW1, stau2amplitudetauneutrinocharginoW2, stau2amplitudestausneutrinoHminus, stau2amplitudestausneutrinoWboson, stau2amplitudestau1Zboson, stau2amplitudestau1h, stau2amplitudestau1H, stau2amplitudestau1A, stau2amplitudetaugravitino;
 
 // cout << "mstau2 = " << me(2,3) << endl;
 
 stau2amplitudetauneutralinoZ1 = stauamplitudedecaytauneutralino (me(2,3), MTAU, mneut(1), g, gp, runmw, mixNeut, thetatau, beta, 2, 1);
 stau2amplitudetauneutralinoZ2 = stauamplitudedecaytauneutralino (me(2,3), MTAU, mneut(2), g, gp, runmw, mixNeut, thetatau, beta, 2, 2);
 stau2amplitudetauneutralinoZ3 = stauamplitudedecaytauneutralino (me(2,3), MTAU, mneut(3), g, gp, runmw, mixNeut, thetatau, beta, 2, 3);
 stau2amplitudetauneutralinoZ4 = stauamplitudedecaytauneutralino (me(2,3), MTAU, mneut(4), g, gp, runmw, mixNeut, thetatau, beta, 2, 4);
 stau2amplitudetauneutrinocharginoW1 = stauamplitudedecaynutauchargino (me(2,3), 0, MCH1, g, runmw, thetatau, thetaL2, beta, MTAU, 2, 1);
 stau2amplitudetauneutrinocharginoW2 = stauamplitudedecaynutauchargino (me(2,3), 0, MCH2, g, runmw, thetatau, thetaL2, beta, MTAU, 2, 2);
 stau2amplitudestausneutrinoHminus = stauamplitudedecaysnustauHminus (me(2,3), msnu(3), mHpm, g, runmw, beta, thetatau, MTAU, greekmu, Atau, 2);
 stau2amplitudestausneutrinoWboson = stauamplitudedecaysnustauWboson (me(2,3), msnu(3), polemw, g, thetatau, 2);
 stau2amplitudestau1Zboson = stau2amplitudedecaystau1Zboson (me(2,3), me(1,3), mz, g, gp, thetatau);
 stau2amplitudestau1h = stau2amplitudedecaystau1phi (me(2,3), me(1,3), mh0(1), g, gp, thetatau, beta, alpha, runmw, MTAU, greekmu, Atau, 'h');
 stau2amplitudestau1H = stau2amplitudedecaystau1phi (me(2,3), me(1,3), mh0(2), g, gp, thetatau, beta, alpha, runmw, MTAU, greekmu, Atau, 'H');
 stau2amplitudestau1A = stau2amplitudedecaystau1phi (me(2,3), me(1,3), mA0(1), g, gp, thetatau, beta, alpha, runmw, MTAU, greekmu, Atau, 'A');

 stau2amplitudetaugravitino = squarkamplitudedecaygravitino(me(2,3), mgravitino, MTAU, MPlreduced, gravonoff, slepNLSP);

 ParticleStau2.Array_Decays[0][0] = PDGtau; ParticleStau2.Array_Decays[0][1] = PDGneutralino1; ParticleStau2.Array_Decays[0][2] = stau2amplitudetauneutralinoZ1; ParticleStau2.Array_Decays[0][3] = 2; ParticleStau2.Array_Comments[0] = "# ~tau_2- -> tau- ~chi_10";
 ParticleStau2.Array_Decays[1][0] = PDGtau; ParticleStau2.Array_Decays[1][1] = PDGneutralino2; ParticleStau2.Array_Decays[1][2] = stau2amplitudetauneutralinoZ2; ParticleStau2.Array_Decays[1][3] = 2; ParticleStau2.Array_Comments[1] = "# ~tau_2- -> tau- ~chi_20";
 ParticleStau2.Array_Decays[2][0] = PDGtau; ParticleStau2.Array_Decays[2][1] = PDGneutralino3; ParticleStau2.Array_Decays[2][2] = stau2amplitudetauneutralinoZ3; ParticleStau2.Array_Decays[2][3] = 2; ParticleStau2.Array_Comments[2] = "# ~tau_2- -> tau- ~chi_30";
 ParticleStau2.Array_Decays[3][0] = PDGtau; ParticleStau2.Array_Decays[3][1] = PDGneutralino4; ParticleStau2.Array_Decays[3][2] = stau2amplitudetauneutralinoZ4; ParticleStau2.Array_Decays[3][3] = 2; ParticleStau2.Array_Comments[3] = "# ~tau_2- -> tau- ~chi_40";
 ParticleStau2.Array_Decays[4][0] = PDGnutau; ParticleStau2.Array_Decays[4][1] = PDGchargino1; ParticleStau2.Array_Decays[4][2] = stau2amplitudetauneutrinocharginoW1; ParticleStau2.Array_Decays[4][3] = 2; ParticleStau2.Array_Comments[4] = "# ~tau_2- -> nu_tau ~chi_1-";
 ParticleStau2.Array_Decays[5][0] = PDGnutau; ParticleStau2.Array_Decays[5][1] = PDGchargino2; ParticleStau2.Array_Decays[5][2] = stau2amplitudetauneutrinocharginoW2; ParticleStau2.Array_Decays[5][3] = 2; ParticleStau2.Array_Comments[5] = "# ~tau_2- -> nu_tau ~chi_2-";
 ParticleStau2.Array_Decays[6][0] = PDGnustauL; ParticleStau2.Array_Decays[6][1] = -PDGHplus; ParticleStau2.Array_Decays[6][2] = stau2amplitudestausneutrinoHminus; ParticleStau2.Array_Decays[6][3] = 2; ParticleStau2.Array_Comments[6] = "# ~tau_2- -> H- ~nu_tauL";
 ParticleStau2.Array_Decays[7][0] = PDGnustauL; ParticleStau2.Array_Decays[7][1] = -PDGWplus; ParticleStau2.Array_Decays[7][2] = stau2amplitudestausneutrinoWboson; ParticleStau2.Array_Decays[7][3] = 2; ParticleStau2.Array_Comments[7] = "# ~tau_2- -> W- ~nu_tauL";
 ParticleStau2.Array_Decays[8][0] = PDGstau1; ParticleStau2.Array_Decays[8][1] = PDGZboson; ParticleStau2.Array_Decays[8][2] = stau2amplitudestau1Zboson; ParticleStau2.Array_Decays[8][3] = 2; ParticleStau2.Array_Comments[8] = "# ~tau_2- -> Z ~tau_1-";
 ParticleStau2.Array_Decays[9][0] = PDGstau1; ParticleStau2.Array_Decays[9][1] = PDGh0; ParticleStau2.Array_Decays[9][2] = stau2amplitudestau1h; ParticleStau2.Array_Decays[9][3] = 2; ParticleStau2.Array_Comments[9] = "# ~tau_2- -> h ~tau_1-";
 ParticleStau2.Array_Decays[10][0] = PDGstau1; ParticleStau2.Array_Decays[10][1] = PDGH0; ParticleStau2.Array_Decays[10][2] = stau2amplitudestau1H; ParticleStau2.Array_Decays[10][3] = 2; ParticleStau2.Array_Comments[10] = "# ~tau_2- -> H ~tau_1-";
 ParticleStau2.Array_Decays[11][0] = PDGstau1; ParticleStau2.Array_Decays[11][1] = PDGA0; ParticleStau2.Array_Decays[11][2] = stau2amplitudestau1A; ParticleStau2.Array_Decays[11][3] = 2; ParticleStau2.Array_Comments[11] = "# ~tau_2- -> A ~tau_1-";

 ParticleStau2.Array_Decays[12][0] = PDGtau; ParticleStau2.Array_Decays[12][1] = PDGgravitino; ParticleStau2.Array_Decays[12][2] = stau2amplitudetaugravitino; ParticleStau2.Array_Decays[12][3] = 2; ParticleStau2.Array_Comments[12] = "# ~tau_2- -> tau- ~G";

 double Stau2_No_1to2_Decays = 0;

 if (slepNLSP == 1) { Stau2_No_1to2_Decays = ParticleStau2.No_1to2_Decays + ParticleStau2.No_grav_Decays;}
 else {Stau2_No_1to2_Decays = ParticleStau2.No_1to2_Decays;}
 
 for (int j = 0; j<Stau2_No_1to2_Decays; j++) {
   ParticleStau2.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<Stau2_No_1to2_Decays; j++) {
   ParticleStau2.two_width = ParticleStau2.two_width + ParticleStau2.Array_Decays[j][2];
 }
 for (int j=Stau2_No_1to2_Decays; j<ParticleStau2.No_of_Decays; j++) {
   ParticleStau2.three_width = ParticleStau2.three_width + ParticleStau2.Array_Decays[j][2];
 }
 
 if ( ParticleStau2.three_width != ParticleStau2.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for stau2 - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleStau2.No_of_Decays = Stau2_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleStau2.total_width = ParticleStau2.two_width;
   }
 else {
   ParticleStau2.total_width = ParticleStau2.two_width + ParticleStau2.three_width;
 }
 
 for (int i =0; i<ParticleStau2.No_of_Decays; i++) {
   ParticleStau2.Array_Decays[i][5]= ParticleStau2.Array_Decays[i][2]/ParticleStau2.total_width;
 }

 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleStau2.PDG << setw(12) << scientific << setprecision(8) <<  ParticleStau2.total_width << "   " << "# stau_2 decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleStau2.No_of_Decays; k++) {
   if( ParticleStau2.Array_Decays[k][2] != 0 && ParticleStau2.Array_Decays[k][5] > BRTol) {
         cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleStau2.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleStau2.Array_Decays[k][3];  printRowPDG(cout, ParticleStau2.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleStau2.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleStau2.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;

///Stau sneutrino decays

 double snutauamplitudenutauneutralinoZ1, snutauamplitudenutauneutralinoZ2, snutauamplitudenutauneutralinoZ3, snutauamplitudenutauneutralinoZ4, snutauamplitudetaucharginoW1, snutauamplitudetaucharginoW2, snutauamplitudeWbosonstau1, snutauamplitudeWbosonstau2, snutauamplitudeHplusstau1, snutauamplitudeHplusstau2, snutauamplitudenutaugravitino;
 
  snutauamplitudenutauneutralinoZ1 = stausneutrinoamplitudedecaytauneutrinoneutralino (msnu(3), 0, mneut(1), g, gp, mixNeut, 1);
  snutauamplitudenutauneutralinoZ2 = stausneutrinoamplitudedecaytauneutrinoneutralino (msnu(3), 0, mneut(2), g, gp, mixNeut, 2);
  snutauamplitudenutauneutralinoZ3 = stausneutrinoamplitudedecaytauneutrinoneutralino (msnu(3), 0, mneut(3), g, gp, mixNeut, 3);
  snutauamplitudenutauneutralinoZ4 = stausneutrinoamplitudedecaytauneutrinoneutralino (msnu(3), 0, mneut(4), g, gp, mixNeut, 4);
  snutauamplitudetaucharginoW1 = stausneutrinoamplitudedecaytauchargino (msnu(3), MTAU, MCH1, g, runmw, beta, thetaL2, thetaR2, 1);
  snutauamplitudetaucharginoW2 = stausneutrinoamplitudedecaytauchargino (msnu(3), MTAU, MCH2, g, runmw, beta, thetaL2, thetaR2, 2);
  snutauamplitudeHplusstau1 = stauamplitudedecaysnustauHminus (msnu(3), me(1,3), mHpm, g, runmw, beta, thetatau, MTAU, greekmu, Atau, 1);
  snutauamplitudeHplusstau2 = stauamplitudedecaysnustauHminus (msnu(3), me(2,3), mHpm, g, runmw, beta, thetatau, MTAU, greekmu, Atau, 2);
  snutauamplitudeWbosonstau1 = stauamplitudedecaysnustauWboson (msnu(3), me(1,3), polemw, g, thetatau, 1);
  snutauamplitudeWbosonstau2 = stauamplitudedecaysnustauWboson (msnu(3), me(2,3), polemw, g, thetatau, 2);

  snutauamplitudenutaugravitino = squarkamplitudedecaygravitino(msnu(3), mgravitino, 0, MPlreduced, gravonoff, snuNLSP);

  ParticleSnutau.Array_Decays[0][0] = PDGnutau; ParticleSnutau.Array_Decays[0][1] = PDGneutralino1; ParticleSnutau.Array_Decays[0][2] = snutauamplitudenutauneutralinoZ1; ParticleSnutau.Array_Decays[0][3] = 2; ParticleSnutau.Array_Comments[0] = "# ~nu_tauL -> nu_tau ~chi_10";
  ParticleSnutau.Array_Decays[1][0] = PDGnutau; ParticleSnutau.Array_Decays[1][1] = PDGneutralino2; ParticleSnutau.Array_Decays[1][2] = snutauamplitudenutauneutralinoZ2; ParticleSnutau.Array_Decays[1][3] = 2; ParticleSnutau.Array_Comments[1] = "# ~nu_tauL -> nu_tau ~chi_20";
  ParticleSnutau.Array_Decays[2][0] = PDGnutau; ParticleSnutau.Array_Decays[2][1] = PDGneutralino3; ParticleSnutau.Array_Decays[2][2] = snutauamplitudenutauneutralinoZ3; ParticleSnutau.Array_Decays[2][3] = 2; ParticleSnutau.Array_Comments[2] = "# ~nu_tauL -> nu_tau ~chi_30";
  ParticleSnutau.Array_Decays[3][0] = PDGnutau; ParticleSnutau.Array_Decays[3][1] = PDGneutralino4; ParticleSnutau.Array_Decays[3][2] = snutauamplitudenutauneutralinoZ4; ParticleSnutau.Array_Decays[3][3] = 2; ParticleSnutau.Array_Comments[3] = "# ~nu_tauL -> nu_tau ~chi_40";
  ParticleSnutau.Array_Decays[4][0] = PDGtau; ParticleSnutau.Array_Decays[4][1] = PDGchargino1; ParticleSnutau.Array_Decays[4][2] = snutauamplitudetaucharginoW1; ParticleSnutau.Array_Decays[4][3] = 2; ParticleSnutau.Array_Comments[4] = "# ~nu_tauL -> tau- ~chi_1+";
  ParticleSnutau.Array_Decays[5][0] = PDGtau; ParticleSnutau.Array_Decays[5][1] = PDGchargino2; ParticleSnutau.Array_Decays[5][2] = snutauamplitudetaucharginoW2; ParticleSnutau.Array_Decays[5][3] = 2; ParticleSnutau.Array_Comments[5] = "# ~nu_tauL -> tau- ~chi_2+";
  ParticleSnutau.Array_Decays[6][0] = PDGstau1; ParticleSnutau.Array_Decays[6][1] = PDGHplus; ParticleSnutau.Array_Decays[6][2] = snutauamplitudeHplusstau1; ParticleSnutau.Array_Decays[6][3] = 2; ParticleSnutau.Array_Comments[6] = "# ~nu_tauL -> H+ ~tau_1-";
  ParticleSnutau.Array_Decays[7][0] = PDGstau2; ParticleSnutau.Array_Decays[7][1] = PDGHplus; ParticleSnutau.Array_Decays[7][2] = snutauamplitudeHplusstau2; ParticleSnutau.Array_Decays[7][3] = 2; ParticleSnutau.Array_Comments[7] = "# ~nu_tauL -> H+ ~tau_2-";
  ParticleSnutau.Array_Decays[8][0] = PDGWplus; ParticleSnutau.Array_Decays[8][1] = PDGstau1; ParticleSnutau.Array_Decays[8][2] = snutauamplitudeWbosonstau1; ParticleSnutau.Array_Decays[8][3] = 2; ParticleSnutau.Array_Comments[8] = "# ~nu_tauL -> W+ ~tau_1-";
  ParticleSnutau.Array_Decays[9][0] = PDGWplus; ParticleSnutau.Array_Decays[9][1] = PDGstau2; ParticleSnutau.Array_Decays[9][2] = snutauamplitudeWbosonstau2; ParticleSnutau.Array_Decays[9][3] = 2; ParticleSnutau.Array_Comments[9] = "# ~nu_tauL -> W+ ~tau_2-";

  ParticleSnutau.Array_Decays[10][0] = PDGnutau; ParticleSnutau.Array_Decays[10][1] = PDGgravitino; ParticleSnutau.Array_Decays[10][2] = snutauamplitudenutaugravitino; ParticleSnutau.Array_Decays[10][3] = 2; ParticleSnutau.Array_Comments[10] = "# ~nu_tauL -> nu_tau ~G";

 double Snutau_No_1to2_Decays = 0;

 if (snuNLSP == 1) { Snutau_No_1to2_Decays = ParticleSnutau.No_1to2_Decays + ParticleSnutau.No_grav_Decays;}
 else {Snutau_No_1to2_Decays = ParticleSnutau.No_1to2_Decays;}
 
 for (int j = 0; j<Snutau_No_1to2_Decays; j++) {
   ParticleSnutau.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<Snutau_No_1to2_Decays; j++) {
   ParticleSnutau.two_width = ParticleSnutau.two_width + ParticleSnutau.Array_Decays[j][2];
 }
 for (int j=Snutau_No_1to2_Decays; j<ParticleSnutau.No_of_Decays; j++) {
   ParticleSnutau.three_width = ParticleSnutau.three_width + ParticleSnutau.Array_Decays[j][2];
 }
 
 if ( ParticleSnutau.three_width != ParticleSnutau.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for snutau - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleSnutau.No_of_Decays = Snutau_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleSnutau.total_width = ParticleSnutau.two_width;
   }
 else {
   ParticleSnutau.total_width = ParticleSnutau.two_width + ParticleSnutau.three_width;
 }
 
 for (int i =0; i<ParticleSnutau.No_of_Decays; i++) {
   ParticleSnutau.Array_Decays[i][5]= ParticleSnutau.Array_Decays[i][2]/ParticleSnutau.total_width;
 }


 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleSnutau.PDG << setw(12) << scientific << setprecision(8) <<  ParticleSnutau.total_width << "   " << "# snu_tauL decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleSnutau.No_of_Decays; k++) {
   if( ParticleSnutau.Array_Decays[k][2] != 0 && ParticleSnutau.Array_Decays[k][5] > BRTol) {
         cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleSnutau.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleSnutau.Array_Decays[k][3];  printRowPDG(cout, ParticleSnutau.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleSnutau.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleSnutau.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl;


 ///Chargino Decays

 ///Chargino1 Decays
 
 double chargino1amplitudeWbosonneutralinoZ1, chargino1amplitudeWbosonneutralinoZ2, chargino1amplitudeWbosonneutralinoZ3, chargino1amplitudeWbosonneutralinoZ4, chargino1amplitudeHminusneutralinoZ1, chargino1amplitudeHminusneutralinoZ2, chargino1amplitudeHminusneutralinoZ3, chargino1amplitudeHminusneutralinoZ4, chargino1amplitudesupLd, chargino1amplitudesdownLu, chargino1amplitudescharmLs, chargino1amplitudesstrangeLc, chargino1amplitudestop1b, chargino1amplitudestop2b, chargino1amplitudesbottom1t, chargino1amplitudesbottom2t, chargino1amplitudesnuee, chargino1amplitudeselectronLnue, chargino1amplitudesnumumu, chargino1amplitudesmuonLnumu, chargino1amplitudesnutautau, chargino1amplitudenutaustau1, chargino1amplitudenutaustau2, chargino1amplitudeneut1udbar, chargino1amplitudeneut1csbar, chargino1amplitudeneut1nueebar, chargino1amplitudeneut1numumubar, chargino1amplitudeneut1nutautaubar, chargino1amplitudeneut2udbar, chargino1amplitudeneut2csbar, chargino1amplitudeneut2nueebar, chargino1amplitudeneut2numumubar, chargino1amplitudeneut2nutautaubar, chargino1amplitudeneut3udbar, chargino1amplitudeneut3csbar, chargino1amplitudeneut3nueebar, chargino1amplitudeneut3numumubar, chargino1amplitudeneut3nutautaubar, chargino1amplitudeneut4udbar, chargino1amplitudeneut4csbar, chargino1amplitudeneut4nueebar, chargino1amplitudeneut4numumubar, chargino1amplitudeneut4nutautaubar;
 
 chargino1amplitudesupLd = charginoamplitudedecayquarksquarkL (MCH1, MDOWN, mu(1,1), g, thetaR2, 1);
 chargino1amplitudesdownLu = charginoamplitudedecayquarksquarkL (MCH1, MUP, md(1,1), g, thetaL2, 1);
 chargino1amplitudescharmLs = charginoamplitudedecayquarksquarkL (MCH1, MSTRANGE, mu(1,2), g , thetaR2, 1);
 chargino1amplitudesstrangeLc = charginoamplitudedecayquarksquarkL (MCH1, MCHARM, md(1,2), g, thetaL2, 1);
 chargino1amplitudestop1b = charginoamplitudedecayquarksquarkmix (MCH1, MBOTTOM, mu(1,3), g, thetat, thetaL2, thetaR2, beta, runmt, runmb, runmw, 1, 1, 1);
 chargino1amplitudestop2b = charginoamplitudedecayquarksquarkmix (MCH1, MBOTTOM, mu(2,3), g, thetat, thetaL2, thetaR2, beta, runmt, runmb,  runmw, 1, 1, 2); 
 chargino1amplitudesbottom1t = charginoamplitudedecayquarksquarkmix (MCH1, MTOP, md(1,3), g, thetab, thetaL2, thetaR2, beta, runmt, runmb, runmw, 1, 2, 1);
 chargino1amplitudesbottom2t = charginoamplitudedecayquarksquarkmix (MCH1, MTOP, md(2,3), g, thetab, thetaL2, thetaR2, beta, runmt, runmb, runmw, 1, 2, 2);
 chargino1amplitudesnuee = charginoamplitudedecayleptonsleptonL (MCH1, MELECTRON, msnu(1), g, thetaR2, 1);
 chargino1amplitudeselectronLnue = charginoamplitudedecayleptonsleptonL (MCH1, 0, me(1,1), g, thetaL2, 1);
 chargino1amplitudesnumumu = charginoamplitudedecayleptonsleptonL (MCH1, MMUON, msnu(2), g, thetaR2, 1);
 chargino1amplitudesmuonLnumu = charginoamplitudedecayleptonsleptonL (MCH1, 0, me(1,2), g, thetaL2, 1); 
 chargino1amplitudesnutautau = charginoamplitudedecaysnutautau (MCH1, MTAU, msnu(3), g, thetaL2, thetaR2, beta, runmw, 1);
 chargino1amplitudenutaustau1 = charginoamplitudedecaystaunutau (MCH1, 0, me(1,3), g, thetaL2, thetaR2, thetatau, beta, runmw, MTAU, 1, 1);
 chargino1amplitudenutaustau2 = charginoamplitudedecaystaunutau (MCH1, 0, me(2,3), g, thetaL2, thetaR2, thetatau, beta, runmw, MTAU, 2, 1);
 chargino1amplitudeWbosonneutralinoZ1 = charginoamplitudedecayWbosonneutralino (MCH1, runmw, mneut(1), g, thetaL2, thetaR2, mixNeut, 1, 1);
 chargino1amplitudeWbosonneutralinoZ2 = charginoamplitudedecayWbosonneutralino (MCH1, runmw, mneut(2), g, thetaL2, thetaR2, mixNeut, 1, 2);
 chargino1amplitudeWbosonneutralinoZ3 = charginoamplitudedecayWbosonneutralino (MCH1, runmw, mneut(3), g, thetaL2, thetaR2, mixNeut, 1, 3);
 chargino1amplitudeWbosonneutralinoZ4 = charginoamplitudedecayWbosonneutralino (MCH1, runmw, mneut(4), g, thetaL2, thetaR2, mixNeut, 1, 4);
 chargino1amplitudeHminusneutralinoZ1 = charginoamplitudedecayHminusneutralino (MCH1, mHpm, mneut(1), g, gp, thetaL2, thetaR2, beta, mixNeut, 1, 1);
 chargino1amplitudeHminusneutralinoZ2 = charginoamplitudedecayHminusneutralino (MCH1, mHpm, mneut(2), g, gp, thetaL2, thetaR2, beta, mixNeut, 1, 2);
 chargino1amplitudeHminusneutralinoZ3 = charginoamplitudedecayHminusneutralino (MCH1, mHpm, mneut(3), g, gp, thetaL2, thetaR2, beta, mixNeut, 1, 3);
 chargino1amplitudeHminusneutralinoZ4 = charginoamplitudedecayHminusneutralino (MCH1, mHpm, mneut(4), g, gp, thetaL2, thetaR2, beta, mixNeut, 1, 4); 
 
 chargino1amplitudeneut1udbar = neutralinoamplitudedecaycharginoffprimebar (MCH1, mu(1,1), mu(2,1), md(1,1), md(2,1), polemw, mHpm, mneut(1), MUP, MDOWN, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, runmu, runmd, mixNeut, 1, 1, onetothree, 'q', 'c');
 chargino1amplitudeneut1csbar = neutralinoamplitudedecaycharginoffprimebar (MCH1, mu(1,2), mu(2,2), md(1,2), md(2,2), polemw, mHpm, mneut(1), MCHARM, MSTRANGE, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, runmc, runms, mixNeut, 1, 1, onetothree, 'q', 'c');
 chargino1amplitudeneut1nueebar = neutralinoamplitudedecaycharginoffprimebar (MCH1, msnu(1), 10000000000, me(1,1), me(2,1), polemw, mHpm, mneut(1), 0, MELECTRON, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, 0, MELECTRON, mixNeut, 1, 1, onetothree, 'l', 'c');
 chargino1amplitudeneut1numumubar = neutralinoamplitudedecaycharginoffprimebar (MCH1, msnu(2), 10000000000, me(1,2), me(2,2), polemw, mHpm, mneut(1), 0, MMUON, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, 0, MMUON, mixNeut, 1, 1, onetothree, 'l', 'c');
 chargino1amplitudeneut1nutautaubar = neutralinoamplitudedecaycharginoffprimebar (MCH1, msnu(3), 10000000000, me(1,3), me(2,3), polemw, mHpm, mneut(1), 0, MTAU, 0, thetatau, g, gp, alpha, beta, thetaL2, thetaR2, 0, runmtau, mixNeut, 1, 1, onetothree, 'l', 'c');
 chargino1amplitudeneut2udbar = neutralinoamplitudedecaycharginoffprimebar (MCH1, mu(1,1), mu(2,1), md(1,1), md(2,1), polemw, mHpm, mneut(2), MUP, MDOWN, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, runmu, runmd, mixNeut, 2, 1, onetothree, 'q', 'c');
 chargino1amplitudeneut2csbar = neutralinoamplitudedecaycharginoffprimebar (MCH1, mu(1,2), mu(2,2), md(1,2), md(2,2), polemw, mHpm, mneut(2), MCHARM, MSTRANGE, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, runmc, runms, mixNeut, 2, 1, onetothree, 'q', 'c');
 chargino1amplitudeneut2nueebar = neutralinoamplitudedecaycharginoffprimebar (MCH1, msnu(1), 10000000000, me(1,1), me(2,1), polemw, mHpm, mneut(2), 0, MELECTRON, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, 0, MELECTRON, mixNeut, 2, 1, onetothree, 'l', 'c');
 chargino1amplitudeneut2numumubar = neutralinoamplitudedecaycharginoffprimebar (MCH1, msnu(2), 10000000000, me(1,2), me(2,2), polemw, mHpm, mneut(2), 0, MMUON, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, 0, MMUON, mixNeut, 2, 1, onetothree, 'l', 'c');
 chargino1amplitudeneut2nutautaubar = neutralinoamplitudedecaycharginoffprimebar (MCH1, msnu(3), 10000000000, me(1,3), me(2,3), polemw, mHpm, mneut(2), 0, MTAU, 0, thetatau, g, gp, alpha, beta, thetaL2, thetaR2, 0, runmtau, mixNeut, 2, 1, onetothree, 'l', 'c');
 chargino1amplitudeneut3udbar = neutralinoamplitudedecaycharginoffprimebar (MCH1, mu(1,1), mu(2,1), md(1,1), md(2,1), polemw, mHpm, mneut(3), MUP, MDOWN, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, runmu, runmd, mixNeut, 3, 1, onetothree, 'q', 'c');
 chargino1amplitudeneut3csbar = neutralinoamplitudedecaycharginoffprimebar (MCH1, mu(1,2), mu(2,2), md(1,2), md(2,2), polemw, mHpm, mneut(3), MCHARM, MSTRANGE, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, runmc, runms, mixNeut, 3, 1, onetothree, 'q', 'c');
 chargino1amplitudeneut3nueebar = neutralinoamplitudedecaycharginoffprimebar (MCH1, msnu(1), 10000000000, me(1,1), me(2,1), polemw, mHpm, mneut(3), 0, MELECTRON, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, 0, MELECTRON, mixNeut, 3, 1, onetothree, 'l', 'c');
 chargino1amplitudeneut3numumubar = neutralinoamplitudedecaycharginoffprimebar (MCH1, msnu(2), 10000000000, me(1,2), me(2,2), polemw, mHpm, mneut(3), 0, MMUON, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, 0, MMUON, mixNeut, 3, 1, onetothree, 'l', 'c');
 chargino1amplitudeneut3nutautaubar = neutralinoamplitudedecaycharginoffprimebar (MCH1, msnu(3), 10000000000, me(1,3), me(2,3), polemw, mHpm, mneut(3), 0, MTAU, 0, thetatau, g, gp, alpha, beta, thetaL2, thetaR2, 0, runmtau, mixNeut, 3, 1, onetothree, 'l', 'c');
 chargino1amplitudeneut4udbar = neutralinoamplitudedecaycharginoffprimebar (MCH1, mu(1,1), mu(2,1), md(1,1), md(2,1), polemw, mHpm, mneut(4), MUP, MDOWN, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, runmu, runmd, mixNeut, 4, 1, onetothree, 'q', 'c');
 chargino1amplitudeneut4csbar = neutralinoamplitudedecaycharginoffprimebar (MCH1, mu(1,2), mu(2,2), md(1,2), md(2,2), polemw, mHpm, mneut(4), MCHARM, MSTRANGE, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, runmc, runms, mixNeut, 4, 1, onetothree, 'q', 'c');
 chargino1amplitudeneut4nueebar = neutralinoamplitudedecaycharginoffprimebar (MCH1, msnu(1), 10000000000, me(1,1), me(2,1), polemw, mHpm, mneut(4), 0, MELECTRON, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, 0, MELECTRON, mixNeut, 4, 1, onetothree, 'l', 'c');
 chargino1amplitudeneut4numumubar = neutralinoamplitudedecaycharginoffprimebar (MCH1, msnu(2), 10000000000, me(1,2), me(2,2), polemw, mHpm, mneut(4), 0, MMUON, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, 0, MMUON, mixNeut, 4, 1, onetothree, 'l', 'c');
 chargino1amplitudeneut4nutautaubar = neutralinoamplitudedecaycharginoffprimebar (MCH1, msnu(3), 10000000000, me(1,3), me(2,3), polemw, mHpm, mneut(4), 0, MTAU, 0, thetatau, g, gp, alpha, beta, thetaL2, thetaR2, 0, runmtau, mixNeut, 4, 1, onetothree, 'l', 'c');

 
 ParticleChargino1.Array_Decays[0][0] = -PDGdown; ParticleChargino1.Array_Decays[0][1] = PDGsupL; ParticleChargino1.Array_Decays[0][2] = chargino1amplitudesupLd; ParticleChargino1.Array_Decays[0][3] = 2; ParticleChargino1.Array_Comments[0] = "# ~chi_1+ -> db ~u_L";
 ParticleChargino1.Array_Decays[1][0] = PDGup; ParticleChargino1.Array_Decays[1][1] = -PDGsdownL; ParticleChargino1.Array_Decays[1][2] = chargino1amplitudesdownLu; ParticleChargino1.Array_Decays[1][3] = 2; ParticleChargino1.Array_Comments[1] = "# ~chi_1+ -> u ~d_L*"; 
 ParticleChargino1.Array_Decays[2][0] = -PDGstrange; ParticleChargino1.Array_Decays[2][1] = PDGscharmL; ParticleChargino1.Array_Decays[2][2] = chargino1amplitudescharmLs; ParticleChargino1.Array_Decays[2][3] = 2; ParticleChargino1.Array_Comments[2] = "# ~chi_1+ -> sb ~s_L";
 ParticleChargino1.Array_Decays[3][0] = PDGcharm; ParticleChargino1.Array_Decays[3][1] = -PDGsstrangeL; ParticleChargino1.Array_Decays[3][2] = chargino1amplitudesstrangeLc; ParticleChargino1.Array_Decays[3][3] = 2; ParticleChargino1.Array_Comments[3] = "# ~chi_1+ -> c ~s_L*";
 ParticleChargino1.Array_Decays[4][0] = -PDGbottom; ParticleChargino1.Array_Decays[4][1] = PDGstop1; ParticleChargino1.Array_Decays[4][2] = chargino1amplitudestop1b; ParticleChargino1.Array_Decays[4][3] = 2; ParticleChargino1.Array_Comments[4] = "# ~chi_1+ -> bb ~t_1";
 ParticleChargino1.Array_Decays[5][0] = -PDGbottom; ParticleChargino1.Array_Decays[5][1] = PDGstop2; ParticleChargino1.Array_Decays[5][2] = chargino1amplitudestop2b; ParticleChargino1.Array_Decays[5][3] = 2; ParticleChargino1.Array_Comments[5] = "# ~chi_1+ -> bb ~t2";
 ParticleChargino1.Array_Decays[6][0] = PDGtop; ParticleChargino1.Array_Decays[6][1] = PDGsbottom1; ParticleChargino1.Array_Decays[6][2] = chargino1amplitudesbottom1t; ParticleChargino1.Array_Decays[6][3] = 2; ParticleChargino1.Array_Comments[6] = "# ~chi_1+ -> t ~b_1";
 ParticleChargino1.Array_Decays[7][0] = PDGtop; ParticleChargino1.Array_Decays[7][1] = PDGsbottom2; ParticleChargino1.Array_Decays[7][2] = chargino1amplitudesbottom2t; ParticleChargino1.Array_Decays[7][3] = 2; ParticleChargino1.Array_Comments[7] = "# ~chi_1+ -> t ~b_2";
 ParticleChargino1.Array_Decays[8][0] = PDGnuselectronL; ParticleChargino1.Array_Decays[8][1] = -PDGelectron; ParticleChargino1.Array_Decays[8][2] = chargino1amplitudesnuee; ParticleChargino1.Array_Decays[8][3] = 2; ParticleChargino1.Array_Comments[8] = "# ~chi_1+ -> e+ ~nu_eL";
 ParticleChargino1.Array_Decays[9][0] = -PDGselectronL; ParticleChargino1.Array_Decays[9][1] = PDGnuelectron; ParticleChargino1.Array_Decays[9][2] = chargino1amplitudeselectronLnue; ParticleChargino1.Array_Decays[9][3] = 2; ParticleChargino1.Array_Comments[9] = "# ~chi_1+ -> nu_e ~e_L+";
 ParticleChargino1.Array_Decays[10][0] = PDGnusmuonL; ParticleChargino1.Array_Decays[10][1] = -PDGmuon; ParticleChargino1.Array_Decays[10][2] = chargino1amplitudesnumumu; ParticleChargino1.Array_Decays[10][3] = 2; ParticleChargino1.Array_Comments[10] = "# ~chi_1+ -> mu+ ~nu_muL";
 ParticleChargino1.Array_Decays[11][0] = -PDGsmuonL; ParticleChargino1.Array_Decays[11][1] = PDGnumuon; ParticleChargino1.Array_Decays[11][2] = chargino1amplitudesmuonLnumu; ParticleChargino1.Array_Decays[11][3] = 2; ParticleChargino1.Array_Comments[11] = "# ~chi_1+ -> nu_mu ~muL+";
 ParticleChargino1.Array_Decays[12][0] = -PDGtau; ParticleChargino1.Array_Decays[12][1] = PDGnustauL; ParticleChargino1.Array_Decays[12][2] = chargino1amplitudesnutautau; ParticleChargino1.Array_Decays[12][3] = 2; ParticleChargino1.Array_Comments[12] = "# ~chi_1+ -> tau+ ~nu_tauL";
 ParticleChargino1.Array_Decays[13][0] = PDGnutau; ParticleChargino1.Array_Decays[13][1] = -PDGstau1; ParticleChargino1.Array_Decays[13][2] = chargino1amplitudenutaustau1; ParticleChargino1.Array_Decays[13][3] = 2; ParticleChargino1.Array_Comments[13] = "# ~chi_1+ -> nu_tau ~tau_1+";
 ParticleChargino1.Array_Decays[14][0] = PDGnutau; ParticleChargino1.Array_Decays[14][1] = -PDGstau2; ParticleChargino1.Array_Decays[14][2] = chargino1amplitudenutaustau2; ParticleChargino1.Array_Decays[14][3] = 2; ParticleChargino1.Array_Comments[14] = "# ~chi_1+ -> nu_tau ~tau_2+";
 ParticleChargino1.Array_Decays[15][0] = PDGWplus; ParticleChargino1.Array_Decays[15][1] = PDGneutralino1; ParticleChargino1.Array_Decays[15][2] = chargino1amplitudeWbosonneutralinoZ1; ParticleChargino1.Array_Decays[15][3] = 2; ParticleChargino1.Array_Comments[15] = "# ~chi_1+ -> W+ ~chi_10";
 ParticleChargino1.Array_Decays[16][0] = PDGWplus; ParticleChargino1.Array_Decays[16][1] = PDGneutralino2; ParticleChargino1.Array_Decays[16][2] = chargino1amplitudeWbosonneutralinoZ2; ParticleChargino1.Array_Decays[16][3] = 2; ParticleChargino1.Array_Comments[16] = "# ~chi_1+ -> W+ ~chi_20";
 ParticleChargino1.Array_Decays[17][0] = PDGWplus; ParticleChargino1.Array_Decays[17][1] = PDGneutralino3; ParticleChargino1.Array_Decays[17][2] = chargino1amplitudeWbosonneutralinoZ3; ParticleChargino1.Array_Decays[17][3] = 2; ParticleChargino1.Array_Comments[17] = "# ~chi_1+ -> W+ ~chi_30";
 ParticleChargino1.Array_Decays[18][0] = PDGWplus; ParticleChargino1.Array_Decays[18][1] = PDGneutralino4; ParticleChargino1.Array_Decays[18][2] = chargino1amplitudeWbosonneutralinoZ4; ParticleChargino1.Array_Decays[18][3] = 2; ParticleChargino1.Array_Comments[18] = "# ~chi_1+ -> W+ ~chi_40";
 ParticleChargino1.Array_Decays[19][0] = PDGHplus; ParticleChargino1.Array_Decays[19][1] = PDGneutralino1; ParticleChargino1.Array_Decays[19][2] = chargino1amplitudeHminusneutralinoZ1; ParticleChargino1.Array_Decays[19][3] = 2; ParticleChargino1.Array_Comments[19] = "# ~chi_1+ -> H+ ~chi_10";
 ParticleChargino1.Array_Decays[20][0] = PDGHplus; ParticleChargino1.Array_Decays[20][1] = PDGneutralino2; ParticleChargino1.Array_Decays[20][2] = chargino1amplitudeHminusneutralinoZ2; ParticleChargino1.Array_Decays[20][3] = 2; ParticleChargino1.Array_Comments[20] = "# ~chi_1+ -> H+ ~chi_20";
 ParticleChargino1.Array_Decays[21][0] = PDGHplus; ParticleChargino1.Array_Decays[21][1] = PDGneutralino3; ParticleChargino1.Array_Decays[21][2] = chargino1amplitudeHminusneutralinoZ3; ParticleChargino1.Array_Decays[21][3] = 2; ParticleChargino1.Array_Comments[21] = "# ~chi_1+ -> H+ ~chi_30";
 ParticleChargino1.Array_Decays[22][0] = PDGHplus; ParticleChargino1.Array_Decays[22][1] = PDGneutralino4; ParticleChargino1.Array_Decays[22][2] = chargino1amplitudeHminusneutralinoZ4; ParticleChargino1.Array_Decays[22][3] = 2; ParticleChargino1.Array_Comments[22] = "# ~chi_1+ -> H+ ~chi_40";

 ParticleChargino1.Array_Decays[23][0] = PDGneutralino1; ParticleChargino1.Array_Decays[23][1] = PDGup; ParticleChargino1.Array_Decays[23][4] = -PDGdown; ParticleChargino1.Array_Decays[23][2] = chargino1amplitudeneut1udbar; ParticleChargino1.Array_Decays[23][3] = 3; ParticleChargino1.Array_Comments[23] = "# ~chi_1+ -> chi_10 u dbar";
 ParticleChargino1.Array_Decays[24][0] = PDGneutralino1; ParticleChargino1.Array_Decays[24][1] = PDGcharm; ParticleChargino1.Array_Decays[24][4] = -PDGstrange; ParticleChargino1.Array_Decays[24][2] = chargino1amplitudeneut1csbar; ParticleChargino1.Array_Decays[24][3] = 3; ParticleChargino1.Array_Comments[24] = "# ~chi_1+ -> chi_10 c sbar";
 ParticleChargino1.Array_Decays[25][0] = PDGneutralino1; ParticleChargino1.Array_Decays[25][1] = PDGnuelectron; ParticleChargino1.Array_Decays[25][4] = -PDGelectron; ParticleChargino1.Array_Decays[25][2] = chargino1amplitudeneut1nueebar; ParticleChargino1.Array_Decays[25][3] = 3; ParticleChargino1.Array_Comments[25] = "# ~chi_1+ -> chi_10 nu_e e+";
 ParticleChargino1.Array_Decays[26][0] = PDGneutralino1; ParticleChargino1.Array_Decays[26][1] = PDGnumuon; ParticleChargino1.Array_Decays[26][4] = -PDGmuon; ParticleChargino1.Array_Decays[26][2] = chargino1amplitudeneut1numumubar; ParticleChargino1.Array_Decays[26][3] = 3; ParticleChargino1.Array_Comments[26] = "# ~chi_1+ -> chi_10 nu_mu mu+";
 ParticleChargino1.Array_Decays[27][0] = PDGneutralino1; ParticleChargino1.Array_Decays[27][1] = PDGnutau; ParticleChargino1.Array_Decays[27][4] = -PDGtau; ParticleChargino1.Array_Decays[27][2] = chargino1amplitudeneut1nutautaubar; ParticleChargino1.Array_Decays[27][3] = 3; ParticleChargino1.Array_Comments[27] = "# ~chi_1+ -> chi_10 nu_tau tau+";
 ParticleChargino1.Array_Decays[28][0] = PDGneutralino2; ParticleChargino1.Array_Decays[28][1] = PDGup; ParticleChargino1.Array_Decays[28][4] = -PDGdown; ParticleChargino1.Array_Decays[28][2] = chargino1amplitudeneut2udbar; ParticleChargino1.Array_Decays[28][3] = 3; ParticleChargino1.Array_Comments[28] = "# ~chi_1+ -> chi_20 u dbar";
 ParticleChargino1.Array_Decays[29][0] = PDGneutralino2; ParticleChargino1.Array_Decays[29][1] = PDGcharm; ParticleChargino1.Array_Decays[29][4] = -PDGstrange; ParticleChargino1.Array_Decays[29][2] = chargino1amplitudeneut2csbar; ParticleChargino1.Array_Decays[29][3] = 3; ParticleChargino1.Array_Comments[29] = "# ~chi_1+ -> chi_20 c sbar";
 ParticleChargino1.Array_Decays[30][0] = PDGneutralino2; ParticleChargino1.Array_Decays[30][1] = PDGnuelectron; ParticleChargino1.Array_Decays[30][4] = -PDGelectron; ParticleChargino1.Array_Decays[30][2] = chargino1amplitudeneut2nueebar; ParticleChargino1.Array_Decays[30][3] = 3; ParticleChargino1.Array_Comments[30] = "# ~chi_1+ -> chi_20 nu_e e+";
 ParticleChargino1.Array_Decays[31][0] = PDGneutralino2; ParticleChargino1.Array_Decays[31][1] = PDGnumuon; ParticleChargino1.Array_Decays[31][4] = -PDGmuon; ParticleChargino1.Array_Decays[31][2] = chargino1amplitudeneut2numumubar; ParticleChargino1.Array_Decays[31][3] = 3; ParticleChargino1.Array_Comments[31] = "# ~chi_1+ -> chi_20 nu_mu mu+";
 ParticleChargino1.Array_Decays[32][0] = PDGneutralino2; ParticleChargino1.Array_Decays[32][1] = PDGnutau; ParticleChargino1.Array_Decays[32][4] = -PDGtau; ParticleChargino1.Array_Decays[32][2] = chargino1amplitudeneut2nutautaubar; ParticleChargino1.Array_Decays[32][3] = 3; ParticleChargino1.Array_Comments[32] = "# ~chi_1+ -> chi_20 nu_tau tau+";
 ParticleChargino1.Array_Decays[33][0] = PDGneutralino3; ParticleChargino1.Array_Decays[33][1] = PDGup; ParticleChargino1.Array_Decays[33][4] = -PDGdown; ParticleChargino1.Array_Decays[33][2] = chargino1amplitudeneut3udbar; ParticleChargino1.Array_Decays[33][3] = 3; ParticleChargino1.Array_Comments[33] = "# ~chi_1+ -> chi_30 u dbar";
 ParticleChargino1.Array_Decays[34][0] = PDGneutralino3; ParticleChargino1.Array_Decays[34][1] = PDGcharm; ParticleChargino1.Array_Decays[34][4] = -PDGstrange; ParticleChargino1.Array_Decays[34][2] = chargino1amplitudeneut3csbar; ParticleChargino1.Array_Decays[34][3] = 3; ParticleChargino1.Array_Comments[34] = "# ~chi_1+ -> chi_30 c sbar";
 ParticleChargino1.Array_Decays[35][0] = PDGneutralino3; ParticleChargino1.Array_Decays[35][1] = PDGnuelectron; ParticleChargino1.Array_Decays[35][4] = -PDGelectron; ParticleChargino1.Array_Decays[35][2] = chargino1amplitudeneut3nueebar; ParticleChargino1.Array_Decays[35][3] = 3; ParticleChargino1.Array_Comments[35] = "# ~chi_1+ -> chi_30 nu_e e+";
 ParticleChargino1.Array_Decays[36][0] = PDGneutralino3; ParticleChargino1.Array_Decays[36][1] = PDGnumuon; ParticleChargino1.Array_Decays[36][4] = -PDGmuon; ParticleChargino1.Array_Decays[36][2] = chargino1amplitudeneut3numumubar; ParticleChargino1.Array_Decays[36][3] = 3; ParticleChargino1.Array_Comments[36] = "# ~chi_1+ -> chi_30 nu_mu mu+";
 ParticleChargino1.Array_Decays[37][0] = PDGneutralino3; ParticleChargino1.Array_Decays[37][1] = PDGnutau; ParticleChargino1.Array_Decays[37][4] = -PDGtau; ParticleChargino1.Array_Decays[37][2] = chargino1amplitudeneut3nutautaubar; ParticleChargino1.Array_Decays[37][3] = 3; ParticleChargino1.Array_Comments[37] = "# ~chi_1+ -> chi_30 nu_tau tau+";
 ParticleChargino1.Array_Decays[38][0] = PDGneutralino4; ParticleChargino1.Array_Decays[38][1] = PDGup; ParticleChargino1.Array_Decays[38][4] = -PDGdown; ParticleChargino1.Array_Decays[38][2] = chargino1amplitudeneut4udbar; ParticleChargino1.Array_Decays[38][3] = 3; ParticleChargino1.Array_Comments[38] = "# ~chi_1+ -> chi_40 u dbar";
 ParticleChargino1.Array_Decays[39][0] = PDGneutralino4; ParticleChargino1.Array_Decays[39][1] = PDGcharm; ParticleChargino1.Array_Decays[39][4] = -PDGstrange; ParticleChargino1.Array_Decays[39][2] = chargino1amplitudeneut4csbar; ParticleChargino1.Array_Decays[39][3] = 3; ParticleChargino1.Array_Comments[39] = "# ~chi_1+ -> chi_40 c sbar";
 ParticleChargino1.Array_Decays[40][0] = PDGneutralino4; ParticleChargino1.Array_Decays[40][1] = PDGnuelectron; ParticleChargino1.Array_Decays[40][4] = -PDGelectron; ParticleChargino1.Array_Decays[40][2] = chargino1amplitudeneut4nueebar; ParticleChargino1.Array_Decays[40][3] = 3; ParticleChargino1.Array_Comments[40] = "# ~chi_1+ -> chi_40 nu_e e+";
 ParticleChargino1.Array_Decays[41][0] = PDGneutralino4; ParticleChargino1.Array_Decays[41][1] = PDGnumuon; ParticleChargino1.Array_Decays[41][4] = -PDGmuon; ParticleChargino1.Array_Decays[41][2] = chargino1amplitudeneut4numumubar; ParticleChargino1.Array_Decays[41][3] = 3; ParticleChargino1.Array_Comments[41] = "# ~chi_1+ -> chi_40 nu_mu mu+";
 ParticleChargino1.Array_Decays[42][0] = PDGneutralino4; ParticleChargino1.Array_Decays[42][1] = PDGnutau; ParticleChargino1.Array_Decays[42][4] = -PDGtau; ParticleChargino1.Array_Decays[42][2] = chargino1amplitudeneut4nutautaubar; ParticleChargino1.Array_Decays[42][3] = 3; ParticleChargino1.Array_Comments[42] = "# ~chi_1+ -> chi_40 nu_tau tau+";
 
 double Chargino1_No_1to2_Decays = 0;

 if (chargNLSP == 1) { Chargino1_No_1to2_Decays = ParticleChargino1.No_1to2_Decays + ParticleChargino1.No_grav_Decays;}
 else {Chargino1_No_1to2_Decays = ParticleChargino1.No_1to2_Decays;}
 
 for (int j = 0; j<Chargino1_No_1to2_Decays; j++) {
   ParticleChargino1.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<Chargino1_No_1to2_Decays; j++) {
   ParticleChargino1.two_width = ParticleChargino1.two_width + ParticleChargino1.Array_Decays[j][2];
 }
 for (int j=Chargino1_No_1to2_Decays; j<ParticleChargino1.No_of_Decays; j++) {
   ParticleChargino1.three_width = ParticleChargino1.three_width + ParticleChargino1.Array_Decays[j][2];
 }
 
 if ( ParticleChargino1.three_width != ParticleChargino1.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for chargino1 - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleChargino1.No_of_Decays = Chargino1_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleChargino1.total_width = ParticleChargino1.two_width;
   }
 else {
   ParticleChargino1.total_width = ParticleChargino1.two_width + ParticleChargino1.three_width;
 }
 
 for (int i =0; i<ParticleChargino1.No_of_Decays; i++) {
   ParticleChargino1.Array_Decays[i][5]= ParticleChargino1.Array_Decays[i][2]/ParticleChargino1.total_width;
 }
 
 /// Uncomment section below if want just BRs
 // cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 // cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleChargino1.PDG << setw(12) << scientific << setprecision(8) <<  ParticleChargino1.total_width << "   " << "# chargino1+ decays" << endl;
 // cout.precision(7);
 // cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 // for (int k=0; k<ParticleChargino1.No_of_Decays; k++) {
 //   if( ParticleChargino1.Array_Decays[k][2] != 0 && ParticleChargino1.Array_Decays[k][5] > BRTol) {
 //         cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleChargino1.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleChargino1.Array_Decays[k][3];  printRowPDG(cout, ParticleChargino1.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleChargino1.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleChargino1.Array_Comments[k] << endl;
 //   }
 // }
 // cout << "#" << endl;

 ///Uncomment section below if want PWs as well as BRs
  cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleChargino1.PDG << setw(12) << scientific << setprecision(8) <<  ParticleChargino1.total_width << "   " << "# chargino1 decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "PW" << setw(18) << "BR" << setw(8) << "NDA" << setw(12) << left << " PDG1" << setw(12) << " PDG2" << setw(12) << " PDG3 " << endl;
 for (int k=0; k<ParticleChargino1.No_of_Decays; k++) {
   if( ParticleChargino1.Array_Decays[k][2] != 0 && ParticleChargino1.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleChargino1.Array_Decays[k][2] << setprecision(8) << ParticleChargino1.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << " " << ParticleChargino1.Array_Decays[k][3] << setw(4) << " ";  printRowPDG(cout, ParticleChargino1.Array_Decays[k][0]); cout << "    "; printRowPDG(cout,ParticleChargino1.Array_Decays[k][1]); cout << "    "; printRowPDG(cout,ParticleChargino1.Array_Decays[k][4]); cout << "   " << left << setprecision(0) << setw(15) << ParticleChargino1.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl; 

///Chargino2 Decays
 
 double chargino2amplitudeWbosonneutralinoZ1, chargino2amplitudeWbosonneutralinoZ2, chargino2amplitudeWbosonneutralinoZ3, chargino2amplitudeWbosonneutralinoZ4, chargino2amplitudeHminusneutralinoZ1, chargino2amplitudeHminusneutralinoZ2, chargino2amplitudeHminusneutralinoZ3, chargino2amplitudeHminusneutralinoZ4, chargino2amplitudesupLd, chargino2amplitudesdownLu, chargino2amplitudescharmLs, chargino2amplitudesstrangeLc, chargino2amplitudestop1b, chargino2amplitudestop2b, chargino2amplitudesbottom1t, chargino2amplitudesbottom2t, chargino2amplitudesnuee, chargino2amplitudeselectronLnue, chargino2amplitudesnumumu, chargino2amplitudesmuonLnumu, chargino2amplitudesnutautau, chargino2amplitudenutaustau1, chargino2amplitudenutaustau2, chargino2amplitudechargino1Zboson, chargino2amplitudechargino1h, chargino2amplitudechargino1H, chargino2amplitudechargino1A, chargino2amplitudeneut1udbar, chargino2amplitudeneut1csbar, chargino2amplitudeneut1nueebar, chargino2amplitudeneut1numumubar, chargino2amplitudeneut1nutautaubar, chargino2amplitudeneut2udbar, chargino2amplitudeneut2csbar, chargino2amplitudeneut2nueebar, chargino2amplitudeneut2numumubar, chargino2amplitudeneut2nutautaubar, chargino2amplitudeneut3udbar, chargino2amplitudeneut3csbar, chargino2amplitudeneut3nueebar, chargino2amplitudeneut3numumubar, chargino2amplitudeneut3nutautaubar, chargino2amplitudeneut4udbar, chargino2amplitudeneut4csbar, chargino2amplitudeneut4nueebar, chargino2amplitudeneut4numumubar, chargino2amplitudeneut4nutautaubar;
 
 chargino2amplitudesupLd = charginoamplitudedecayquarksquarkL (MCH2, MDOWN, mu(1,1), g, thetaR2, 2);
 chargino2amplitudesdownLu = charginoamplitudedecayquarksquarkL (MCH2, MUP, md(1,1), g, thetaL2, 2);
 chargino2amplitudescharmLs = charginoamplitudedecayquarksquarkL (MCH2, MSTRANGE, mu(1,2), g , thetaR2, 2);
 chargino2amplitudesstrangeLc = charginoamplitudedecayquarksquarkL (MCH2, MCHARM, md(1,2), g, thetaL2, 2);
 chargino2amplitudestop1b = charginoamplitudedecayquarksquarkmix (MCH2, MBOTTOM, mu(1,3), g, thetat, thetaL2, thetaR2, beta, runmt, runmb, runmw, 2, 1, 1);
 chargino2amplitudestop2b = charginoamplitudedecayquarksquarkmix (MCH2, MBOTTOM, mu(2,3), g, thetat, thetaL2, thetaR2, beta, runmt, runmb, runmw, 2, 1, 2);
 chargino2amplitudesbottom1t = charginoamplitudedecayquarksquarkmix (MCH2, MTOP, md(1,3), g, thetab, thetaL2, thetaR2, beta, runmt, runmb, runmw, 2, 2, 1);
 chargino2amplitudesbottom2t = charginoamplitudedecayquarksquarkmix (MCH2, MTOP, md(2,3), g, thetab, thetaL2, thetaR2, beta, runmt, runmb, runmw, 2, 2, 2);
 chargino2amplitudesnuee = charginoamplitudedecayleptonsleptonL (MCH2, MELECTRON, msnu(1), g, thetaR2, 2);
 chargino2amplitudeselectronLnue = charginoamplitudedecayleptonsleptonL (MCH2, 0, me(1,1), g, thetaL2, 2);
 chargino2amplitudesnumumu = charginoamplitudedecayleptonsleptonL (MCH2, MMUON, msnu(2), g, thetaR2, 2);
 chargino2amplitudesmuonLnumu = charginoamplitudedecayleptonsleptonL (MCH2, 0, me(1,2), g, thetaL2, 2); 
 chargino2amplitudesnutautau = charginoamplitudedecaysnutautau (MCH2, MTAU, msnu(3), g, thetaL2, thetaR2, beta, runmw, 2);
 chargino2amplitudenutaustau1 = charginoamplitudedecaystaunutau (MCH2, 0, me(1,3), g, thetaL2, thetaR2, thetatau, beta, runmw, MTAU, 1, 2);
 chargino2amplitudenutaustau2 = charginoamplitudedecaystaunutau (MCH2, 0, me(2,3), g, thetaL2, thetaR2, thetatau, beta, runmw, MTAU, 2, 2);
 chargino2amplitudeWbosonneutralinoZ1 = charginoamplitudedecayWbosonneutralino (MCH2, polemw, mneut(1), g, thetaL2, thetaR2, mixNeut, 2, 1);
 chargino2amplitudeWbosonneutralinoZ2 = charginoamplitudedecayWbosonneutralino (MCH2, polemw, mneut(2), g, thetaL2, thetaR2, mixNeut, 2, 2);
 chargino2amplitudeWbosonneutralinoZ3 = charginoamplitudedecayWbosonneutralino (MCH2, polemw, mneut(3), g, thetaL2, thetaR2, mixNeut, 2, 3);
 chargino2amplitudeWbosonneutralinoZ4 = charginoamplitudedecayWbosonneutralino (MCH2, polemw, mneut(4), g, thetaL2, thetaR2, mixNeut, 2, 4);
 chargino2amplitudeHminusneutralinoZ1 = charginoamplitudedecayHminusneutralino (MCH2, mHpm, mneut(1), g, gp, thetaL2, thetaR2, beta, mixNeut, 2, 1);
 chargino2amplitudeHminusneutralinoZ2 = charginoamplitudedecayHminusneutralino (MCH2, mHpm, mneut(2), g, gp, thetaL2, thetaR2, beta, mixNeut, 2, 2);
 chargino2amplitudeHminusneutralinoZ3 = charginoamplitudedecayHminusneutralino (MCH2, mHpm, mneut(3), g, gp, thetaL2, thetaR2, beta, mixNeut, 2, 3);
 chargino2amplitudeHminusneutralinoZ4 = charginoamplitudedecayHminusneutralino (MCH2, mHpm, mneut(4), g, gp, thetaL2, thetaR2, beta, mixNeut, 2, 4);
 chargino2amplitudechargino1Zboson = chargino2amplitudedecaychargino1Zboson (MCH2, mz, MCH1, g, gp, thetaL2, thetaR2);
 chargino2amplitudechargino1h = chargino2amplitudedecaychargino1neutHiggs (MCH2, mh0(1), MCH1, g, gp, thetaL2, thetaR2, beta, alpha, 'h');
 chargino2amplitudechargino1H = chargino2amplitudedecaychargino1neutHiggs (MCH2, mh0(2), MCH1, g, gp, thetaL2, thetaR2, beta, alpha, 'H');
 chargino2amplitudechargino1A = chargino2amplitudedecaychargino1neutHiggs (MCH2, mA0(1), MCH1, g, gp, thetaL2, thetaR2, beta, alpha, 'A');

 chargino2amplitudeneut1udbar = neutralinoamplitudedecaycharginoffprimebar (MCH2, mu(1,1), mu(2,1), md(1,1), md(2,1), polemw, mHpm, mneut(1), MUP, MDOWN, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, runmu, runmd, mixNeut, 1, 2, onetothree, 'q', 'c');
 chargino2amplitudeneut1csbar = neutralinoamplitudedecaycharginoffprimebar (MCH2, mu(1,2), mu(2,2), md(1,2), md(2,2), polemw, mHpm, mneut(1), MCHARM, MSTRANGE, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, runmc, runms, mixNeut, 1, 2, onetothree, 'q', 'c');
 chargino2amplitudeneut1nueebar = neutralinoamplitudedecaycharginoffprimebar (MCH2, msnu(1), 0, me(1,1), me(2,1), polemw, mHpm, mneut(1), 0, MELECTRON, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, 0, MELECTRON, mixNeut, 1, 2, onetothree, 'l', 'c');
 chargino2amplitudeneut1numumubar = neutralinoamplitudedecaycharginoffprimebar (MCH2, msnu(2), 0, me(1,2), me(2,2), polemw, mHpm, mneut(1), 0, MMUON, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, 0, MMUON, mixNeut, 1, 2, onetothree, 'l', 'c');
 chargino2amplitudeneut1nutautaubar = neutralinoamplitudedecaycharginoffprimebar (MCH2, msnu(3), 0, me(1,3), me(2,3), polemw, mHpm, mneut(1), 0, MTAU, 0, thetatau, g, gp, alpha, beta, thetaL2, thetaR2, 0, runmtau, mixNeut, 1, 2, onetothree, 'l', 'c');
 chargino2amplitudeneut2udbar = neutralinoamplitudedecaycharginoffprimebar (MCH2, mu(1,1), mu(2,1), md(1,1), md(2,1), polemw, mHpm, mneut(2), MUP, MDOWN, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, runmu, runmd, mixNeut, 2, 2, onetothree, 'q', 'c');
 chargino2amplitudeneut2csbar = neutralinoamplitudedecaycharginoffprimebar (MCH2, mu(1,2), mu(2,2), md(1,2), md(2,2), polemw, mHpm, mneut(2), MCHARM, MSTRANGE, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, runmc, runms, mixNeut, 2, 2, onetothree, 'q', 'c');
 chargino2amplitudeneut2nueebar = neutralinoamplitudedecaycharginoffprimebar (MCH2, msnu(1), 0, me(1,1), me(2,1), polemw, mHpm, mneut(2), 0, MELECTRON, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, 0, MELECTRON, mixNeut, 2, 2, onetothree, 'l', 'c');
 chargino2amplitudeneut2numumubar = neutralinoamplitudedecaycharginoffprimebar (MCH2, msnu(2), 0, me(1,2), me(2,2), polemw, mHpm, mneut(2), 0, MMUON, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, 0, MMUON, mixNeut, 2, 2, onetothree, 'l', 'c');
 chargino2amplitudeneut2nutautaubar = neutralinoamplitudedecaycharginoffprimebar (MCH2, msnu(3), 0, me(1,3), me(2,3), polemw, mHpm, mneut(2), 0, MTAU, 0, thetatau, g, gp, alpha, beta, thetaL2, thetaR2, 0, runmtau, mixNeut, 2, 2, onetothree, 'l', 'c');
 chargino2amplitudeneut3udbar = neutralinoamplitudedecaycharginoffprimebar (MCH2, mu(1,1), mu(2,1), md(1,1), md(2,1), polemw, mHpm, mneut(3), MUP, MDOWN, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, runmu, runmd, mixNeut, 3, 2, onetothree, 'q', 'c');
 chargino2amplitudeneut3csbar = neutralinoamplitudedecaycharginoffprimebar (MCH2, mu(1,2), mu(2,2), md(1,2), md(2,2), polemw, mHpm, mneut(3), MCHARM, MSTRANGE, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, runmc, runms, mixNeut, 3, 2, onetothree, 'q', 'c');
 chargino2amplitudeneut3nueebar = neutralinoamplitudedecaycharginoffprimebar (MCH2, msnu(1), 0, me(1,1), me(2,1), polemw, mHpm, mneut(3), 0, MELECTRON, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, 0, MELECTRON, mixNeut, 3, 2, onetothree, 'l', 'c');
 chargino2amplitudeneut3numumubar = neutralinoamplitudedecaycharginoffprimebar (MCH2, msnu(2), 0, me(1,2), me(2,2), polemw, mHpm, mneut(3), 0, MMUON, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, 0, MMUON, mixNeut, 3, 2, onetothree, 'l', 'c');
 chargino2amplitudeneut3nutautaubar = neutralinoamplitudedecaycharginoffprimebar (MCH2, msnu(3), 0, me(1,3), me(2,3), polemw, mHpm, mneut(3), 0, MTAU, 0, thetatau, g, gp, alpha, beta, thetaL2, thetaR2, 0, runmtau, mixNeut, 3, 2, onetothree, 'l', 'c');
 chargino2amplitudeneut4udbar = neutralinoamplitudedecaycharginoffprimebar (MCH2, mu(1,1), mu(2,1), md(1,1), md(2,1), polemw, mHpm, mneut(4), MUP, MDOWN, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, runmu, runmd, mixNeut, 4, 2, onetothree, 'q', 'c');
 chargino2amplitudeneut4csbar = neutralinoamplitudedecaycharginoffprimebar (MCH2, mu(1,2), mu(2,2), md(1,2), md(2,2), polemw, mHpm, mneut(4), MCHARM, MSTRANGE, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, runmc, runms, mixNeut, 4, 2, onetothree, 'q', 'c');
 chargino2amplitudeneut4nueebar = neutralinoamplitudedecaycharginoffprimebar (MCH2, msnu(1), 0, me(1,1), me(2,1), polemw, mHpm, mneut(4), 0, MELECTRON, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, 0, MELECTRON, mixNeut, 4, 2, onetothree, 'l', 'c');
 chargino2amplitudeneut4numumubar = neutralinoamplitudedecaycharginoffprimebar (MCH2, msnu(2), 0, me(1,2), me(2,2), polemw, mHpm, mneut(4), 0, MMUON, 0, 0, g, gp, alpha, beta, thetaL2, thetaR2, 0, MMUON, mixNeut, 4, 2, onetothree, 'l', 'c');
 chargino2amplitudeneut4nutautaubar = neutralinoamplitudedecaycharginoffprimebar (MCH2, msnu(3), 0, me(1,3), me(2,3), polemw, mHpm, mneut(4), 0, MTAU, 0, thetatau, g, gp, alpha, beta, thetaL2, thetaR2, 0, runmtau, mixNeut, 4, 2, onetothree, 'l', 'c');
 
 ParticleChargino2.Array_Decays[0][0] = -PDGdown; ParticleChargino2.Array_Decays[0][1] = PDGsupL; ParticleChargino2.Array_Decays[0][2] = chargino2amplitudesupLd; ParticleChargino2.Array_Decays[0][3] = 2; ParticleChargino2.Array_Comments[0] = "# ~chi_2+ -> db ~u_L";
 ParticleChargino2.Array_Decays[1][0] = PDGup; ParticleChargino2.Array_Decays[1][1] = -PDGsdownL; ParticleChargino2.Array_Decays[1][2] = chargino2amplitudesdownLu; ParticleChargino2.Array_Decays[1][3] = 2; ParticleChargino2.Array_Comments[1] = "# ~chi_2+ -> u ~d_L*";
 ParticleChargino2.Array_Decays[2][0] = -PDGstrange; ParticleChargino2.Array_Decays[2][1] = PDGscharmL; ParticleChargino2.Array_Decays[2][2] = chargino2amplitudescharmLs; ParticleChargino2.Array_Decays[2][3] = 2; ParticleChargino2.Array_Comments[2] = "# ~chi_2+ -> sb ~c_L";
 ParticleChargino2.Array_Decays[3][0] = PDGcharm; ParticleChargino2.Array_Decays[3][1] = -PDGsstrangeL; ParticleChargino2.Array_Decays[3][2] = chargino2amplitudesstrangeLc; ParticleChargino2.Array_Decays[3][3] = 2; ParticleChargino2.Array_Comments[3] = "# ~chi_2+ -> c ~s_L*";
 ParticleChargino2.Array_Decays[4][0] = -PDGbottom; ParticleChargino2.Array_Decays[4][1] = PDGstop1; ParticleChargino2.Array_Decays[4][2] = chargino2amplitudestop1b; ParticleChargino2.Array_Decays[4][3] = 2; ParticleChargino2.Array_Comments[4] = "# ~chi_2+ -> bb ~t_1";
 ParticleChargino2.Array_Decays[5][0] = -PDGbottom; ParticleChargino2.Array_Decays[5][1] = PDGstop2; ParticleChargino2.Array_Decays[5][2] = chargino2amplitudestop2b; ParticleChargino2.Array_Decays[5][3] = 2; ParticleChargino2.Array_Comments[5] = "# ~chi_2+ -> bb ~t_2";
 ParticleChargino2.Array_Decays[6][0] = PDGtop; ParticleChargino2.Array_Decays[6][1] = -PDGsbottom1; ParticleChargino2.Array_Decays[6][2] = chargino2amplitudesbottom1t; ParticleChargino2.Array_Decays[6][3] = 2; ParticleChargino2.Array_Comments[6] = "# ~chi_2+ -> t ~b_1*";
 ParticleChargino2.Array_Decays[7][0] = PDGtop; ParticleChargino2.Array_Decays[7][1] = -PDGsbottom2; ParticleChargino2.Array_Decays[7][2] = chargino2amplitudesbottom2t; ParticleChargino2.Array_Decays[7][3] = 2; ParticleChargino2.Array_Comments[7] = "# ~chi_2+ -> t ~b_2*";
 ParticleChargino2.Array_Decays[8][0] = PDGnuselectronL; ParticleChargino2.Array_Decays[8][1] = -PDGelectron; ParticleChargino2.Array_Decays[8][2] = chargino2amplitudesnuee; ParticleChargino2.Array_Decays[8][3] = 2; ParticleChargino2.Array_Comments[8] = "# ~chi_2+ -> e+ ~nu_eL";
 ParticleChargino2.Array_Decays[9][0] = -PDGselectronL; ParticleChargino2.Array_Decays[9][1] = PDGnuelectron; ParticleChargino2.Array_Decays[9][2] = chargino2amplitudeselectronLnue; ParticleChargino2.Array_Decays[9][3] = 2; ParticleChargino2.Array_Comments[9] = "# ~chi_2+ -> nu_e ~e_L+";
 ParticleChargino2.Array_Decays[10][0] = PDGnusmuonL; ParticleChargino2.Array_Decays[10][1] = -PDGmuon; ParticleChargino2.Array_Decays[10][2] = chargino2amplitudesnumumu; ParticleChargino2.Array_Decays[10][3] = 2; ParticleChargino2.Array_Comments[10] = "# ~chi_2+ -> mu+ ~nu_muL";
 ParticleChargino2.Array_Decays[11][0] = -PDGsmuonL; ParticleChargino2.Array_Decays[11][1] = PDGnumuon; ParticleChargino2.Array_Decays[11][2] = chargino2amplitudesmuonLnumu; ParticleChargino2.Array_Decays[11][3] = 2; ParticleChargino2.Array_Comments[11] = "# ~chi_2+ -> nu_mu ~muL+";
 ParticleChargino2.Array_Decays[12][0] = -PDGtau; ParticleChargino2.Array_Decays[12][1] = PDGnustauL; ParticleChargino2.Array_Decays[12][2] = chargino2amplitudesnutautau; ParticleChargino2.Array_Decays[12][3] = 2; ParticleChargino2.Array_Comments[12] = "# ~chi_2+ -> tau+ ~nu_tauL";
 ParticleChargino2.Array_Decays[13][0] = PDGnutau; ParticleChargino2.Array_Decays[13][1] = -PDGstau1; ParticleChargino2.Array_Decays[13][2] = chargino2amplitudenutaustau1; ParticleChargino2.Array_Decays[13][3] = 2; ParticleChargino2.Array_Comments[13] = "# ~chi_2+ -> nu_tau ~tau_1+";
 ParticleChargino2.Array_Decays[14][0] = PDGnutau; ParticleChargino2.Array_Decays[14][1] = -PDGstau2; ParticleChargino2.Array_Decays[14][2] = chargino2amplitudenutaustau2; ParticleChargino2.Array_Decays[14][3] = 2; ParticleChargino2.Array_Comments[14] = "# ~chi_2+ -> nu_tau ~tau_2+";
 ParticleChargino2.Array_Decays[15][0] = PDGWplus; ParticleChargino2.Array_Decays[15][1] = PDGneutralino1; ParticleChargino2.Array_Decays[15][2] = chargino2amplitudeWbosonneutralinoZ1; ParticleChargino2.Array_Decays[15][3] = 2; ParticleChargino2.Array_Comments[15] = "# ~chi_2+ -> W+ ~chi_10";
 ParticleChargino2.Array_Decays[16][0] = PDGWplus; ParticleChargino2.Array_Decays[16][1] = PDGneutralino2; ParticleChargino2.Array_Decays[16][2] = chargino2amplitudeWbosonneutralinoZ2; ParticleChargino2.Array_Decays[16][3] = 2; ParticleChargino2.Array_Comments[16] = "# ~chi_2+ -> W+ ~chi_20";
 ParticleChargino2.Array_Decays[17][0] = PDGWplus; ParticleChargino2.Array_Decays[17][1] = PDGneutralino3; ParticleChargino2.Array_Decays[17][2] = chargino2amplitudeWbosonneutralinoZ3; ParticleChargino2.Array_Decays[17][3] = 2; ParticleChargino2.Array_Comments[17] = "# ~chi_2+ -> W+ ~chi_30";
 ParticleChargino2.Array_Decays[18][0] = PDGWplus; ParticleChargino2.Array_Decays[18][1] = PDGneutralino4; ParticleChargino2.Array_Decays[18][2] = chargino2amplitudeWbosonneutralinoZ4; ParticleChargino2.Array_Decays[18][3] = 2; ParticleChargino2.Array_Comments[18] = "# ~chi_2+ -> W+ ~chi_40";
 ParticleChargino2.Array_Decays[19][0] = PDGHplus; ParticleChargino2.Array_Decays[19][1] = PDGneutralino1; ParticleChargino2.Array_Decays[19][2] = chargino2amplitudeHminusneutralinoZ1; ParticleChargino2.Array_Decays[19][3] = 2; ParticleChargino2.Array_Comments[19] = "# ~chi_2+ -> H+ ~chi_10";
 ParticleChargino2.Array_Decays[20][0] = PDGHplus; ParticleChargino2.Array_Decays[20][1] = PDGneutralino2; ParticleChargino2.Array_Decays[20][2] = chargino2amplitudeHminusneutralinoZ2; ParticleChargino2.Array_Decays[20][3] = 2; ParticleChargino2.Array_Comments[20] = "# ~chi_2+ -> H+ ~chi_20";
 ParticleChargino2.Array_Decays[21][0] = PDGHplus; ParticleChargino2.Array_Decays[21][1] = PDGneutralino3; ParticleChargino2.Array_Decays[21][2] = chargino2amplitudeHminusneutralinoZ3; ParticleChargino2.Array_Decays[21][3] = 2; ParticleChargino2.Array_Comments[21] = "# ~chi_2+ -> H+ ~chi_30";
 ParticleChargino2.Array_Decays[22][0] = PDGHplus; ParticleChargino2.Array_Decays[22][1] = PDGneutralino4; ParticleChargino2.Array_Decays[22][2] = chargino2amplitudeHminusneutralinoZ4; ParticleChargino2.Array_Decays[22][3] = 2; ParticleChargino2.Array_Comments[22] = "# ~chi_2+ -> H+ ~chi_40";
 ParticleChargino2.Array_Decays[23][0] = PDGchargino1; ParticleChargino2.Array_Decays[23][1] = PDGZboson; ParticleChargino2.Array_Decays[23][2] = chargino2amplitudechargino1Zboson; ParticleChargino2.Array_Decays[23][3] = 2; ParticleChargino2.Array_Comments[23] = "# ~chi_2+ -> Z ~chi_1+";
 ParticleChargino2.Array_Decays[24][0] = PDGchargino1; ParticleChargino2.Array_Decays[24][1] = PDGh0; ParticleChargino2.Array_Decays[24][2] = chargino2amplitudechargino1h; ParticleChargino2.Array_Decays[24][3] = 2; ParticleChargino2.Array_Comments[24] = "# ~chi_2+ -> h ~chi_1+";
 ParticleChargino2.Array_Decays[25][0] = PDGchargino1; ParticleChargino2.Array_Decays[25][1] = PDGH0; ParticleChargino2.Array_Decays[25][2] = chargino2amplitudechargino1H; ParticleChargino2.Array_Decays[25][3] = 2; ParticleChargino2.Array_Comments[25] = "# ~chi_2+ -> H ~chi_1+";
 ParticleChargino2.Array_Decays[26][0] = PDGchargino1; ParticleChargino2.Array_Decays[26][1] = PDGA0; ParticleChargino2.Array_Decays[26][2] = chargino2amplitudechargino1A; ParticleChargino2.Array_Decays[26][3] = 2; ParticleChargino2.Array_Comments[26] = "# ~chi_2+ -> A ~chi_1+";
 
 ParticleChargino2.Array_Decays[27][0] = PDGneutralino1; ParticleChargino2.Array_Decays[27][1] = PDGup; ParticleChargino2.Array_Decays[27][4] = -PDGdown; ParticleChargino2.Array_Decays[27][2] = chargino2amplitudeneut1udbar; ParticleChargino2.Array_Decays[27][3] = 3; ParticleChargino2.Array_Comments[27] = "# ~chi_2+ -> chi_10 u dbar";
 ParticleChargino2.Array_Decays[28][0] = PDGneutralino1; ParticleChargino2.Array_Decays[28][1] = PDGcharm; ParticleChargino2.Array_Decays[28][4] = -PDGstrange; ParticleChargino2.Array_Decays[28][2] = chargino2amplitudeneut1csbar; ParticleChargino2.Array_Decays[28][3] = 3; ParticleChargino2.Array_Comments[28] = "# ~chi_2+ -> chi_10 c sbar";
 ParticleChargino2.Array_Decays[29][0] = PDGneutralino1; ParticleChargino2.Array_Decays[29][1] = PDGnuelectron; ParticleChargino2.Array_Decays[29][4] = -PDGelectron; ParticleChargino2.Array_Decays[29][2] = chargino2amplitudeneut1nueebar; ParticleChargino2.Array_Decays[29][3] = 3; ParticleChargino2.Array_Comments[29] = "# ~chi_2+ -> chi_10 nu_e e+";
 ParticleChargino2.Array_Decays[30][0] = PDGneutralino1; ParticleChargino2.Array_Decays[30][1] = PDGnumuon; ParticleChargino2.Array_Decays[30][4] = -PDGmuon; ParticleChargino2.Array_Decays[30][2] = chargino2amplitudeneut1numumubar; ParticleChargino2.Array_Decays[30][3] = 3; ParticleChargino2.Array_Comments[30] = "# ~chi_2+ -> chi_10 nu_mu mu+";
 ParticleChargino2.Array_Decays[31][0] = PDGneutralino1; ParticleChargino2.Array_Decays[31][1] = PDGnutau; ParticleChargino2.Array_Decays[31][4] = -PDGtau; ParticleChargino2.Array_Decays[31][2] = chargino2amplitudeneut1nutautaubar; ParticleChargino2.Array_Decays[31][3] = 3; ParticleChargino2.Array_Comments[31] = "# ~chi_2+ -> chi_10 nu_tau tau+";
 ParticleChargino2.Array_Decays[32][0] = PDGneutralino2; ParticleChargino2.Array_Decays[32][1] = PDGup; ParticleChargino2.Array_Decays[32][4] = -PDGdown; ParticleChargino2.Array_Decays[32][2] = chargino2amplitudeneut2udbar; ParticleChargino2.Array_Decays[32][3] = 3; ParticleChargino2.Array_Comments[32] = "# ~chi_2+ -> chi_20 u dbar";
 ParticleChargino2.Array_Decays[33][0] = PDGneutralino2; ParticleChargino2.Array_Decays[33][1] = PDGcharm; ParticleChargino2.Array_Decays[33][4] = -PDGstrange; ParticleChargino2.Array_Decays[33][2] = chargino2amplitudeneut2csbar; ParticleChargino2.Array_Decays[33][3] = 3; ParticleChargino2.Array_Comments[33] = "# ~chi_2+ -> chi_20 c sbar";
 ParticleChargino2.Array_Decays[34][0] = PDGneutralino2; ParticleChargino2.Array_Decays[34][1] = PDGnuelectron; ParticleChargino2.Array_Decays[34][4] = -PDGelectron; ParticleChargino2.Array_Decays[34][2] = chargino2amplitudeneut2nueebar; ParticleChargino2.Array_Decays[34][3] = 3; ParticleChargino2.Array_Comments[34] = "# ~chi_2+ -> chi_20 nu_e e+";
 ParticleChargino2.Array_Decays[35][0] = PDGneutralino2; ParticleChargino2.Array_Decays[35][1] = PDGnumuon; ParticleChargino2.Array_Decays[35][4] = -PDGmuon; ParticleChargino2.Array_Decays[35][2] = chargino2amplitudeneut2numumubar; ParticleChargino2.Array_Decays[35][3] = 3; ParticleChargino2.Array_Comments[35] = "# ~chi_2+ -> chi_20 nu_mu mu+";
 ParticleChargino2.Array_Decays[36][0] = PDGneutralino2; ParticleChargino2.Array_Decays[36][1] = PDGnutau; ParticleChargino2.Array_Decays[36][4] = -PDGtau; ParticleChargino2.Array_Decays[36][2] = chargino2amplitudeneut2nutautaubar; ParticleChargino2.Array_Decays[36][3] = 3; ParticleChargino2.Array_Comments[36] = "# ~chi_2+ -> chi_20 nu_tau tau+";
 ParticleChargino2.Array_Decays[37][0] = PDGneutralino3; ParticleChargino2.Array_Decays[37][1] = PDGup; ParticleChargino2.Array_Decays[37][4] = -PDGdown; ParticleChargino2.Array_Decays[37][2] = chargino2amplitudeneut3udbar; ParticleChargino2.Array_Decays[37][3] = 3; ParticleChargino2.Array_Comments[37] = "# ~chi_2+ -> chi_30 u dbar";
 ParticleChargino2.Array_Decays[38][0] = PDGneutralino3; ParticleChargino2.Array_Decays[38][1] = PDGcharm; ParticleChargino2.Array_Decays[38][4] = -PDGstrange; ParticleChargino2.Array_Decays[38][2] = chargino2amplitudeneut3csbar; ParticleChargino2.Array_Decays[38][3] = 3; ParticleChargino2.Array_Comments[38] = "# ~chi_2+ -> chi_30 c sbar";
 ParticleChargino2.Array_Decays[39][0] = PDGneutralino3; ParticleChargino2.Array_Decays[39][1] = PDGnuelectron; ParticleChargino2.Array_Decays[39][4] = -PDGelectron; ParticleChargino2.Array_Decays[39][2] = chargino2amplitudeneut3nueebar; ParticleChargino2.Array_Decays[39][3] = 3; ParticleChargino2.Array_Comments[39] = "# ~chi_2+ -> chi_30 nu_e e+";
 ParticleChargino2.Array_Decays[40][0] = PDGneutralino3; ParticleChargino2.Array_Decays[40][1] = PDGnumuon; ParticleChargino2.Array_Decays[40][4] = -PDGmuon; ParticleChargino2.Array_Decays[40][2] = chargino2amplitudeneut3numumubar; ParticleChargino2.Array_Decays[40][3] = 3; ParticleChargino2.Array_Comments[40] = "# ~chi_2+ -> chi_30 nu_mu mu+";
 ParticleChargino2.Array_Decays[41][0] = PDGneutralino3; ParticleChargino2.Array_Decays[41][1] = PDGnutau; ParticleChargino2.Array_Decays[41][4] = -PDGtau; ParticleChargino2.Array_Decays[41][2] = chargino2amplitudeneut3nutautaubar; ParticleChargino2.Array_Decays[41][3] = 3; ParticleChargino2.Array_Comments[41] = "# ~chi_2+ -> chi_30 nu_tau tau+";
 ParticleChargino2.Array_Decays[42][0] = PDGneutralino4; ParticleChargino2.Array_Decays[42][1] = PDGup; ParticleChargino2.Array_Decays[42][4] = -PDGdown; ParticleChargino2.Array_Decays[42][2] = chargino2amplitudeneut4udbar; ParticleChargino2.Array_Decays[42][3] = 3; ParticleChargino2.Array_Comments[42] = "# ~chi_2+ -> chi_40 u dbar";
 ParticleChargino2.Array_Decays[43][0] = PDGneutralino4; ParticleChargino2.Array_Decays[43][1] = PDGcharm; ParticleChargino2.Array_Decays[43][4] = -PDGstrange; ParticleChargino2.Array_Decays[43][2] = chargino2amplitudeneut4csbar; ParticleChargino2.Array_Decays[43][3] = 3; ParticleChargino2.Array_Comments[43] = "# ~chi_2+ -> chi_40 c sbar";
 ParticleChargino2.Array_Decays[44][0] = PDGneutralino4; ParticleChargino2.Array_Decays[44][1] = PDGnuelectron; ParticleChargino2.Array_Decays[44][4] = -PDGelectron; ParticleChargino2.Array_Decays[44][2] = chargino2amplitudeneut4nueebar; ParticleChargino2.Array_Decays[44][3] = 3; ParticleChargino2.Array_Comments[44] = "# ~chi_2+ -> chi_40 nu_e e+";
 ParticleChargino2.Array_Decays[45][0] = PDGneutralino4; ParticleChargino2.Array_Decays[45][1] = PDGnumuon; ParticleChargino2.Array_Decays[45][4] = -PDGmuon; ParticleChargino2.Array_Decays[45][2] = chargino2amplitudeneut4numumubar; ParticleChargino2.Array_Decays[45][3] = 3; ParticleChargino2.Array_Comments[45] = "# ~chi_2+ -> chi_40 nu_mu mu+";
 ParticleChargino2.Array_Decays[46][0] = PDGneutralino4; ParticleChargino2.Array_Decays[46][1] = PDGnutau; ParticleChargino2.Array_Decays[46][4] = -PDGtau; ParticleChargino2.Array_Decays[46][2] = chargino2amplitudeneut4nutautaubar; ParticleChargino2.Array_Decays[46][3] = 3; ParticleChargino2.Array_Comments[46] = "# ~chi_2+ -> chi_40 nu_tau tau+";


 double Chargino2_No_1to2_Decays = 0;

 if (chargNLSP == 1) { Chargino2_No_1to2_Decays = ParticleChargino2.No_1to2_Decays + ParticleChargino2.No_grav_Decays;}
 else {Chargino2_No_1to2_Decays = ParticleChargino2.No_1to2_Decays;}
 
 for (int j = 0; j<Chargino2_No_1to2_Decays; j++) {
   ParticleChargino2.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
 }
 
 for (int j=0; j<Chargino2_No_1to2_Decays; j++) {
   ParticleChargino2.two_width = ParticleChargino2.two_width + ParticleChargino2.Array_Decays[j][2];
 }
 for (int j=Chargino2_No_1to2_Decays; j<ParticleChargino2.No_of_Decays; j++) {
   ParticleChargino2.three_width = ParticleChargino2.three_width + ParticleChargino2.Array_Decays[j][2];
 }
 
 if ( ParticleChargino2.three_width != ParticleChargino2.three_width) /// Tests for a nan as only nans aren't equal to themselves
   {
     cout << "Three body decays give nan for chargino2 - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
     ParticleChargino2.No_of_Decays = Chargino2_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
     ParticleChargino2.total_width = ParticleChargino2.two_width;
   }
 else {
   ParticleChargino2.total_width = ParticleChargino2.two_width + ParticleChargino2.three_width;
 }
 
 for (int i =0; i<ParticleChargino2.No_of_Decays; i++) {
   ParticleChargino2.Array_Decays[i][5]= ParticleChargino2.Array_Decays[i][2]/ParticleChargino2.total_width;
 }
 
 ///Uncomment this section if you want just BRs output
 /// cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 /// cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleChargino2.PDG << setw(12) << scientific << setprecision(8) <<  ParticleChargino2.total_width << "   " << "# chargino2+ decays" << endl;
 /// cout.precision(7);
 /// cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 /// for (int k=0; k<ParticleChargino2.No_of_Decays; k++) {
 ///   if( ParticleChargino2.Array_Decays[k][2] != 0 && ParticleChargino2.Array_Decays[k][5] > BRTol) {
 ///         cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleChargino2.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleChargino2.Array_Decays[k][3];  printRowPDG(cout, ParticleChargino2.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleChargino2.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleChargino2.Array_Comments[k] << endl;
 ///   }
 /// }
 /// cout << "#" << endl;

 ///Uncomment section below if want PWs as well as BRs
  cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleChargino2.PDG << setw(12) << scientific << setprecision(8) <<  ParticleChargino2.total_width << "   " << "# chargino2 decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "PW" << setw(18) << "BR" << setw(8) << "NDA" << setw(12) << left << " PDG1" << setw(12) << " PDG2" << setw(12) << " PDG3 " << endl;
 for (int k=0; k<ParticleChargino2.No_of_Decays; k++) {
   if( ParticleChargino2.Array_Decays[k][2] != 0 && ParticleChargino2.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleChargino2.Array_Decays[k][2] << setprecision(8) << ParticleChargino2.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << " " << ParticleChargino2.Array_Decays[k][3] << setw(4) << " ";  printRowPDG(cout, ParticleChargino2.Array_Decays[k][0]); cout << "    "; printRowPDG(cout,ParticleChargino2.Array_Decays[k][1]); cout << "    "; printRowPDG(cout,ParticleChargino2.Array_Decays[k][4]); cout << "   " << left << setprecision(0) << setw(15) << ParticleChargino2.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl; 

 ///Neutralino Decays


 ///Neutralino1 Decays
 
 double neutralino1amplitudeuLubar, neutralino1amplitudeuRubar, neutralino1amplitudeuLbaru, neutralino1amplitudeuRbaru, neutralino1amplitudedLdbar, neutralino1amplitudedRdbar, neutralino1amplitudedLbard, neutralino1amplitudedRbard, neutralino1amplitudecLcbar, neutralino1amplitudecRcbar, neutralino1amplitudecLbarc, neutralino1amplitudecRbarc, neutralino1amplitudesLsbar, neutralino1amplitudesRsbar, neutralino1amplitudesLbars, neutralino1amplitudesRbars, neutralino1amplitudeeLebar, neutralino1amplitudeeRebar, neutralino1amplitudeeLbare, neutralino1amplitudeeRbare, neutralino1amplitudemuLmubar, neutralino1amplitudemuRmubar, neutralino1amplitudemuLbarmu, neutralino1amplitudemuRbarmu, neutralino1amplitudesnuenuebar, neutralino1amplitudesnuebarnue, neutralino1amplitudesnumunumubar, neutralino1amplitudesnumubarnumu, neutralino1amplitudetopstop1bar, neutralino1amplitudetopstop2bar, neutralino1amplitudetopbarstop1, neutralino1amplitudetopbarstop2, neutralino1amplitudebottomsbottom1bar, neutralino1amplitudebottomsbottom2bar, neutralino1amplitudebottombarsbottom1, neutralino1amplitudebottombarsbottom2, neutralino1amplitudetaustau1bar, neutralino1amplitudetaustau2bar, neutralino1amplitudetaubarstau1, neutralino1amplitudetaubarstau2, neutralino1amplitudenutausnutaubar, neutralino1amplitudenutaubarsnutau, neutralino1amplitudeWbosonpluscharginoW1, neutralino1amplitudeWbosonpluscharginoW2, neutralino1amplitudeWbosonminuscharginoW1, neutralino1amplitudeWbosonminuscharginoW2, neutralino1amplitudeHpluscharginoW1, neutralino1amplitudeHpluscharginoW2, neutralino1amplitudeHminuscharginoW1, neutralino1amplitudeHminuscharginoW2, neutralino1amplitudeZbosonneutralino2, neutralino1amplitudeZbosonneutralino3, neutralino1amplitudeZbosonneutralino4, neutralino1amplitudehneutralino2, neutralino1amplitudehneutralino3, neutralino1amplitudehneutralino4, neutralino1amplitudeHneutralino2, neutralino1amplitudeHneutralino3, neutralino1amplitudeHneutralino4, neutralino1amplitudeAneutralino2, neutralino1amplitudeAneutralino3, neutralino1amplitudeAneutralino4, neutralino1amplitudephotongravitino, neutralino1amplitudeZgravitino, neutralino1amplitudehgravitino, neutralino1amplitudeHgravitino, neutralino1amplitudeAgravitino;

 double neutralino1amplitudechargino1udbar, neutralino1amplitudechargino1csbar, neutralino1amplitudechargino1enuebar, neutralino1amplitudechargino1munumubar, neutralino1amplitudechargino1taunutaubar, neutralino1amplitudechargino2udbar, neutralino1amplitudechargino2csbar, neutralino1amplitudechargino2enuebar, neutralino1amplitudechargino2munumubar, neutralino1amplitudechargino2taunutaubar;

 // for (mgravitino = 1e-15; mgravitino <= 100; mgravitino = mgravitino*10) {
 //   cout.scientific;
 //   cout.precision(8);
 //   cout << "mgravitino = " << scientific << mgravitino << endl;
 //   BRTol = 1e-50;
  
 neutralino1amplitudeuLubar = neutralinoamplitudedecayquarksquarkLorR (mneut(1), MUP, mu(1,1), g, gp, mixNeut, 1, 'L', 1);
 neutralino1amplitudeuRubar = neutralinoamplitudedecayquarksquarkLorR (mneut(1), MUP, mu(2,1), g, gp, mixNeut, 1, 'R', 1);
 neutralino1amplitudeuLbaru = neutralinoamplitudedecayquarksquarkLorR (mneut(1), MUP, mu(1,1), g, gp, mixNeut, 1, 'L', 1); 
 neutralino1amplitudeuRbaru = neutralinoamplitudedecayquarksquarkLorR (mneut(1), MUP, mu(2,1), g, gp, mixNeut, 1, 'R', 1);
 neutralino1amplitudedLdbar = neutralinoamplitudedecayquarksquarkLorR (mneut(1), MDOWN, md(1,1), g, gp, mixNeut, 2, 'L', 1);
 neutralino1amplitudedRdbar = neutralinoamplitudedecayquarksquarkLorR (mneut(1), MDOWN, md(2,1), g, gp, mixNeut, 2, 'R', 1);
 neutralino1amplitudedLbard = neutralinoamplitudedecayquarksquarkLorR (mneut(1), MDOWN, md(1,1), g, gp, mixNeut, 2, 'L', 1);
 neutralino1amplitudedRbard = neutralinoamplitudedecayquarksquarkLorR (mneut(1), MDOWN, md(2,1), g, gp, mixNeut, 2, 'R', 1);
 neutralino1amplitudecLcbar = neutralinoamplitudedecayquarksquarkLorR (mneut(1), MCHARM, mu(1,2), g, gp, mixNeut, 1, 'L', 1);
 neutralino1amplitudecRcbar = neutralinoamplitudedecayquarksquarkLorR (mneut(1), MCHARM, mu(2,2), g, gp, mixNeut, 1, 'R', 1);
 neutralino1amplitudecLbarc = neutralinoamplitudedecayquarksquarkLorR (mneut(1), MCHARM, mu(1,2), g, gp, mixNeut, 1, 'L', 1);
 neutralino1amplitudecRbarc = neutralinoamplitudedecayquarksquarkLorR (mneut(1), MCHARM, mu(2,2), g, gp, mixNeut, 1, 'R', 1);
 neutralino1amplitudesLsbar = neutralinoamplitudedecayquarksquarkLorR (mneut(1), MSTRANGE, md(1,2), g, gp, mixNeut, 2, 'L', 1);
 neutralino1amplitudesRsbar = neutralinoamplitudedecayquarksquarkLorR (mneut(1), MSTRANGE, md(2,2), g, gp, mixNeut, 2, 'R', 1);
 neutralino1amplitudesLbars = neutralinoamplitudedecayquarksquarkLorR (mneut(1), MSTRANGE, md(1,2), g, gp, mixNeut, 2, 'L', 1);
 neutralino1amplitudesRbars = neutralinoamplitudedecayquarksquarkLorR (mneut(1), MSTRANGE, md(2,2), g, gp, mixNeut, 2, 'R', 1);
 neutralino1amplitudeeLebar = neutralinoamplitudedecayleptonsleptonLorR (mneut(1), MELECTRON, me(1,1), g, gp, mixNeut, 'L', 1);
 neutralino1amplitudeeRebar = neutralinoamplitudedecayleptonsleptonLorR (mneut(1), MELECTRON, me(2,1), g, gp, mixNeut, 'R', 1);
 neutralino1amplitudeeLbare = neutralinoamplitudedecayleptonsleptonLorR (mneut(1), MELECTRON, me(1,1), g, gp, mixNeut, 'L', 1);
 neutralino1amplitudeeRbare = neutralinoamplitudedecayleptonsleptonLorR (mneut(1), MELECTRON, me(2,1), g, gp, mixNeut, 'R', 1);
 neutralino1amplitudemuLmubar = neutralinoamplitudedecayleptonsleptonLorR (mneut(1), MMUON, me(1,2), g, gp, mixNeut, 'L', 1);
 neutralino1amplitudemuRmubar = neutralinoamplitudedecayleptonsleptonLorR (mneut(1), MMUON, me(2,2), g, gp, mixNeut, 'R', 1);
 neutralino1amplitudemuLbarmu = neutralinoamplitudedecayleptonsleptonLorR (mneut(1), MMUON, me(1,2), g, gp, mixNeut, 'L', 1);
 neutralino1amplitudemuRbarmu = neutralinoamplitudedecayleptonsleptonLorR (mneut(1), MMUON, me(2,2), g, gp, mixNeut, 'R', 1);
 neutralino1amplitudesnuenuebar = neutralinoamplitudedecayneutrinosneutrinoL (mneut(1), 0, msnu(1), g, gp, mixNeut, 1);
 neutralino1amplitudesnuebarnue = neutralinoamplitudedecayneutrinosneutrinoL (mneut(1), 0, msnu(1), g, gp, mixNeut, 1);
 neutralino1amplitudesnumunumubar = neutralinoamplitudedecayneutrinosneutrinoL (mneut(1), 0, msnu(2), g, gp, mixNeut, 1);
 neutralino1amplitudesnumubarnumu = neutralinoamplitudedecayneutrinosneutrinoL (mneut(1), 0, msnu(2), g, gp, mixNeut, 1);
 neutralino1amplitudetopstop1bar = neutralinoamplitudedecaysquark3quarkmix (mneut(1), MTOP, mu(1,3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 1, 1);
 neutralino1amplitudetopstop2bar = neutralinoamplitudedecaysquark3quarkmix (mneut(1), MTOP, mu(2,3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 2, 1);
 neutralino1amplitudetopbarstop1 = neutralinoamplitudedecaysquark3quarkmix (mneut(1), MTOP, mu(1,3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 1, 1);
 neutralino1amplitudetopbarstop2 = neutralinoamplitudedecaysquark3quarkmix (mneut(1), MTOP, mu(2,3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 2, 1);
 neutralino1amplitudebottomsbottom1bar = neutralinoamplitudedecaysquark3quarkmix (mneut(1), MTOP, md(1,3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 1, 1);
 neutralino1amplitudebottomsbottom2bar = neutralinoamplitudedecaysquark3quarkmix (mneut(1), MBOTTOM, md(2,3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 2, 1);
 neutralino1amplitudebottombarsbottom1 = neutralinoamplitudedecaysquark3quarkmix (mneut(1), MBOTTOM, md(1,3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 1, 1);
 neutralino1amplitudebottombarsbottom2 = neutralinoamplitudedecaysquark3quarkmix (mneut(1), MBOTTOM, md(2,3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 2, 1);
 neutralino1amplitudetaustau1bar = neutralinoamplitudedecaystautau (mneut(1), MTAU, me(1,3), runmw, thetatau, beta, mixNeut, g, gp, 1, 1);
 neutralino1amplitudetaustau2bar = neutralinoamplitudedecaystautau (mneut(1), MTAU, me(2,3), runmw, thetatau, beta, mixNeut, g, gp, 2, 1);
 neutralino1amplitudetaubarstau1 = neutralinoamplitudedecaystautau (mneut(1), MTAU, me(1,3), runmw, thetatau, beta, mixNeut, g, gp, 1, 1);
 neutralino1amplitudetaubarstau2 = neutralinoamplitudedecaystautau (mneut(1), MTAU, me(2,3), runmw, thetatau, beta, mixNeut, g, gp, 2, 1);
 neutralino1amplitudenutausnutaubar = neutralinoamplitudedecayneutrinosneutrinoL (mneut(1), 0, msnu(3), g, gp, mixNeut, 1);
 neutralino1amplitudenutaubarsnutau = neutralinoamplitudedecayneutrinosneutrinoL (mneut(1), 0, msnu(3), g, gp, mixNeut, 1);
 neutralino1amplitudeWbosonpluscharginoW1 = neutralinoamplitudedecaycharginoWboson (mneut(1), polemw, MCH1, g, thetaL2, thetaR2, mixNeut, 1, 1);
 neutralino1amplitudeWbosonpluscharginoW2 = neutralinoamplitudedecaycharginoWboson (mneut(1), polemw, MCH2, g, thetaL2, thetaR2, mixNeut, 1, 2);
 neutralino1amplitudeWbosonminuscharginoW1 = neutralinoamplitudedecaycharginoWboson (mneut(1), polemw, MCH1, g, thetaL2, thetaR2, mixNeut, 1, 1);
 neutralino1amplitudeWbosonminuscharginoW2 = neutralinoamplitudedecaycharginoWboson (mneut(1), polemw, MCH2, g, thetaL2, thetaR2, mixNeut, 1, 2);
 neutralino1amplitudeHpluscharginoW1 = neutralinoamplitudedecaycharginoHplus (mneut(1), mHpm, MCH1, g, gp, beta, thetaL2, thetaR2, mixNeut, 1, 1);
 neutralino1amplitudeHpluscharginoW2 = neutralinoamplitudedecaycharginoHplus (mneut(1), mHpm, MCH2, g, gp, beta, thetaL2, thetaR2, mixNeut, 1, 2);
 neutralino1amplitudeHminuscharginoW1 = neutralinoamplitudedecaycharginoHplus (mneut(1), mHpm, MCH1, g, gp, beta, thetaL2, thetaR2, mixNeut, 1, 1);
 neutralino1amplitudeHminuscharginoW2 = neutralinoamplitudedecaycharginoHplus (mneut(1), mHpm, MCH2, g, gp, beta, thetaL2, thetaR2, mixNeut, 1, 2);
 neutralino1amplitudeZbosonneutralino2 = neutralinoamplitudedecayneutralinoZboson (mneut(1), mz, mneut(2), g, gp, mixNeut, 1, 2);
 neutralino1amplitudeZbosonneutralino3 = neutralinoamplitudedecayneutralinoZboson (mneut(1), mz, mneut(3), g, gp, mixNeut, 1, 3);
 neutralino1amplitudeZbosonneutralino4 = neutralinoamplitudedecayneutralinoZboson (mneut(1), mz, mneut(4), g, gp, mixNeut, 1, 4);
 neutralino1amplitudehneutralino2 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(1), mh0(1), mneut(2), g, gp, mixNeut, alpha, 1, 2, 'h');
 neutralino1amplitudehneutralino3 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(1), mh0(1), mneut(3), g, gp, mixNeut, alpha, 1, 3, 'h');
 neutralino1amplitudehneutralino4 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(1), mh0(1), mneut(4), g, gp, mixNeut, alpha, 1, 4, 'h');
 neutralino1amplitudeHneutralino2 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(1), mh0(2), mneut(2), g, gp, mixNeut, alpha, 1, 2, 'H');
 neutralino1amplitudeHneutralino3 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(1), mh0(2), mneut(3), g, gp, mixNeut, alpha, 1, 3, 'H');
 neutralino1amplitudeHneutralino4 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(1), mh0(2), mneut(4), g, gp, mixNeut, alpha, 1, 4, 'H');
 neutralino1amplitudeAneutralino2 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(1), mA0(1), mneut(2), g, gp, mixNeut, beta, 1, 2, 'A');
 neutralino1amplitudeAneutralino3 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(1), mA0(1), mneut(3), g, gp, mixNeut, beta, 1, 3, 'A');
 neutralino1amplitudeAneutralino4 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(1), mA0(1), mneut(4), g, gp, mixNeut, beta, 1, 4, 'A');
 
 
 neutralino1amplitudechargino1udbar = neutralinoamplitudedecaycharginoffprimebar (mneut(1), mu(1,1), mu(2,1), md(1,1), md(2,1), polemw, mHpm, mch(1), MUP, MDOWN, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, runmu, runmd, mixNeut, 1, 1, onetothree, 'q', 'n');
 neutralino1amplitudechargino1csbar = neutralinoamplitudedecaycharginoffprimebar (mneut(1), mu(1,2), mu(2,2), md(1,2), md(2,2), polemw, mHpm, mch(1), MCHARM, MSTRANGE, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, runmc, runms, mixNeut, 1, 1, onetothree, 'q', 'n');
 neutralino1amplitudechargino1enuebar = neutralinoamplitudedecaycharginoffprimebar (mneut(1), me(1,1), me(2,1), msnu(1), 100000000000, polemw, mHpm, mch(1), 0, MELECTRON, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, 0, MELECTRON, mixNeut, 1, 1, onetothree, 'l', 'n');
 neutralino1amplitudechargino1munumubar = neutralinoamplitudedecaycharginoffprimebar (mneut(1), me(1,2), me(2,2), msnu(2), 100000000000, polemw, mHpm, mch(1), 0, MMUON, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, 0, MMUON, mixNeut, 1, 1, onetothree, 'l', 'n');
 neutralino1amplitudechargino1taunutaubar = neutralinoamplitudedecaycharginoffprimebar (mneut(1), me(1,3), me(2,3), msnu(3), 100000000000, polemw, mHpm, mch(1), 0, MTAU, 0, thetatau, g, gp, alphas, beta, thetaL2, thetaR2, 0, runmtau, mixNeut, 1, 1, onetothree, 'l', 'n');
 neutralino1amplitudechargino2udbar = neutralinoamplitudedecaycharginoffprimebar (mneut(1), mu(1,1), mu(2,1), md(1,1), md(2,1), polemw, mHpm, mch(2), MUP, MDOWN, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, runmu, runmd, mixNeut, 1, 2, onetothree, 'q', 'n');
 neutralino1amplitudechargino2csbar = neutralinoamplitudedecaycharginoffprimebar (mneut(1), mu(1,2), mu(2,2), md(1,2), md(2,2), polemw, mHpm, mch(2), MCHARM, MSTRANGE, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, runmc, runms, mixNeut, 1, 2, onetothree, 'q', 'n');
 neutralino1amplitudechargino2enuebar = neutralinoamplitudedecaycharginoffprimebar (mneut(1), me(1,1), me(2,1), msnu(1), 100000000000, polemw, mHpm, mch(2), 0, MELECTRON, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, 0, MELECTRON, mixNeut, 1, 2, onetothree, 'l', 'n');
 neutralino1amplitudechargino2munumubar = neutralinoamplitudedecaycharginoffprimebar (mneut(1), me(1,2), me(2,2), msnu(2), 100000000000, polemw, mHpm, mch(2), 0, MMUON, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, 0, MMUON, mixNeut, 1, 2, onetothree, 'l', 'n');
 neutralino1amplitudechargino2taunutaubar = neutralinoamplitudedecaycharginoffprimebar (mneut(1), me(1,3), me(2,3), msnu(3), 100000000000, polemw, mHpm, mch(2), 0, MTAU, 0, thetatau, g, gp, alphas, beta, thetaL2, thetaR2, 0, runmtau, mixNeut, 1, 2, onetothree, 'l', 'n');

 
 neutralino1amplitudephotongravitino = neutralinoamplitudedecayphotongravitino(mneut(1), mgravitino, MPlreduced, mixNeut, g, gp, 1, gravonoff, neutNLSP);
 cout.precision(22);
 cout << "neutralino1amplitudephotongravitino = " << neutralino1amplitudephotongravitino << endl;
 neutralino1amplitudeZgravitino = neutralinoamplitudedecayZgravitino(mneut(1), mz, mgravitino, MPlreduced, mixNeut, g, gp, beta, 1, gravonoff, neutNLSP);
 cout << "neutralino1amplitudeZgravitino = " << neutralino1amplitudeZgravitino << endl;
 neutralino1amplitudehgravitino = neutralinoamplitudedecayphigravitino(mneut(1), mh0(1), mgravitino, MPlreduced, mixNeut, alpha, beta, 1, gravonoff, 'h', neutNLSP);
 cout << "neutralino1amplitudehgravitino = " << neutralino1amplitudehgravitino << endl;
 neutralino1amplitudeHgravitino = neutralinoamplitudedecayphigravitino(mneut(1), mh0(2), mgravitino, MPlreduced, mixNeut, alpha, beta, 1, gravonoff, 'H', neutNLSP);
 neutralino1amplitudeAgravitino = neutralinoamplitudedecayphigravitino(mneut(1), mA0(1), mgravitino, MPlreduced, mixNeut, alpha, beta, 1, gravonoff, 'A', neutNLSP);

   ParticleNeutralino1.Array_Decays[0][0] = -PDGup; ParticleNeutralino1.Array_Decays[0][1] = PDGsupL; ParticleNeutralino1.Array_Decays[0][2] = neutralino1amplitudeuLubar; ParticleNeutralino1.Array_Decays[0][3] = 2; ParticleNeutralino1.Array_Comments[0] = "# ~chi_10 -> ub ~u_L";
   ParticleNeutralino1.Array_Decays[1][0] = -PDGup; ParticleNeutralino1.Array_Decays[1][1] = PDGsupR; ParticleNeutralino1.Array_Decays[1][2] = neutralino1amplitudeuRubar; ParticleNeutralino1.Array_Decays[1][3] = 2; ParticleNeutralino1.Array_Comments[1] = "# ~chi_10 -> ub ~u_R"; 
   ParticleNeutralino1.Array_Decays[2][0] = PDGup; ParticleNeutralino1.Array_Decays[2][1] = -PDGsupL; ParticleNeutralino1.Array_Decays[2][2] = neutralino1amplitudeuLbaru; ParticleNeutralino1.Array_Decays[2][3] = 2; ParticleNeutralino1.Array_Comments[2] = "# ~chi_10 -> u ~u_L*";
   ParticleNeutralino1.Array_Decays[3][0] = PDGup; ParticleNeutralino1.Array_Decays[3][1] = -PDGsupR; ParticleNeutralino1.Array_Decays[3][2] = neutralino1amplitudeuRbaru; ParticleNeutralino1.Array_Decays[3][3] = 2; ParticleNeutralino1.Array_Comments[3] = "# ~chi_10 -> u ~u_R*";
   ParticleNeutralino1.Array_Decays[4][0] = -PDGdown; ParticleNeutralino1.Array_Decays[4][1] = PDGsdownL; ParticleNeutralino1.Array_Decays[4][2] = neutralino1amplitudedLdbar; ParticleNeutralino1.Array_Decays[4][3] = 2; ParticleNeutralino1.Array_Comments[4] = "# ~chi_10 -> db ~d_L";
   ParticleNeutralino1.Array_Decays[5][0] = -PDGdown; ParticleNeutralino1.Array_Decays[5][1] = PDGsdownR; ParticleNeutralino1.Array_Decays[5][2] = neutralino1amplitudedRdbar; ParticleNeutralino1.Array_Decays[5][3] = 2; ParticleNeutralino1.Array_Comments[5] = "# ~chi_10 -> db ~d_R";
   ParticleNeutralino1.Array_Decays[6][0] = PDGdown; ParticleNeutralino1.Array_Decays[6][1] = -PDGsdownL; ParticleNeutralino1.Array_Decays[6][2] = neutralino1amplitudedLbard; ParticleNeutralino1.Array_Decays[6][3] = 2; ParticleNeutralino1.Array_Comments[6] = "# ~chi_10 -> d ~d_L*";
   ParticleNeutralino1.Array_Decays[7][0] = PDGdown; ParticleNeutralino1.Array_Decays[7][1] = -PDGsdownR; ParticleNeutralino1.Array_Decays[7][2] = neutralino1amplitudedRbard; ParticleNeutralino1.Array_Decays[7][3] = 2; ParticleNeutralino1.Array_Comments[7] = "# ~chi_10 -> d ~d_R*";
   ParticleNeutralino1.Array_Decays[8][0] = -PDGcharm; ParticleNeutralino1.Array_Decays[8][1] = PDGscharmL; ParticleNeutralino1.Array_Decays[8][2] = neutralino1amplitudecLcbar; ParticleNeutralino1.Array_Decays[8][3] = 2; ParticleNeutralino1.Array_Comments[8] = "# ~chi_10 -> cb ~c_L";
   ParticleNeutralino1.Array_Decays[9][0] = -PDGcharm; ParticleNeutralino1.Array_Decays[9][1] = PDGscharmR; ParticleNeutralino1.Array_Decays[9][2] = neutralino1amplitudecRcbar; ParticleNeutralino1.Array_Decays[9][3] = 2; ParticleNeutralino1.Array_Comments[9] = "# ~chi_10 -> cb ~c_R";
   ParticleNeutralino1.Array_Decays[10][0] = PDGcharm; ParticleNeutralino1.Array_Decays[10][1] = -PDGscharmL; ParticleNeutralino1.Array_Decays[10][2] = neutralino1amplitudecLbarc; ParticleNeutralino1.Array_Decays[10][3] = 2; ParticleNeutralino1.Array_Comments[10] = "# ~chi_10 -> c ~c_L*";
   ParticleNeutralino1.Array_Decays[11][0] = PDGcharm; ParticleNeutralino1.Array_Decays[11][1] = -PDGscharmR; ParticleNeutralino1.Array_Decays[11][2] = neutralino1amplitudecRbarc; ParticleNeutralino1.Array_Decays[11][3] = 2; ParticleNeutralino1.Array_Comments[11] = "# ~chi_10 -> c ~c_R*";
   ParticleNeutralino1.Array_Decays[12][0] = -PDGstrange; ParticleNeutralino1.Array_Decays[12][1] = PDGsstrangeL; ParticleNeutralino1.Array_Decays[12][2] = neutralino1amplitudesLsbar; ParticleNeutralino1.Array_Decays[12][3] = 2; ParticleNeutralino1.Array_Comments[12] = "# ~chi_10 -> sb ~s_L";
   ParticleNeutralino1.Array_Decays[13][0] = -PDGstrange; ParticleNeutralino1.Array_Decays[13][1] = PDGsstrangeR; ParticleNeutralino1.Array_Decays[13][2] = neutralino1amplitudesRsbar; ParticleNeutralino1.Array_Decays[13][3] = 2; ParticleNeutralino1.Array_Comments[13] = "# ~chi_10 -> sb ~s_R";
   ParticleNeutralino1.Array_Decays[14][0] = PDGstrange; ParticleNeutralino1.Array_Decays[14][1] = -PDGsstrangeL; ParticleNeutralino1.Array_Decays[14][2] = neutralino1amplitudesLbars; ParticleNeutralino1.Array_Decays[14][3] = 2; ParticleNeutralino1.Array_Comments[14] = "# ~chi_10 -> s ~s_L*";
   ParticleNeutralino1.Array_Decays[15][0] = PDGstrange; ParticleNeutralino1.Array_Decays[15][1] = -PDGsstrangeR; ParticleNeutralino1.Array_Decays[15][2] = neutralino1amplitudesRbars; ParticleNeutralino1.Array_Decays[15][3] = 2; ParticleNeutralino1.Array_Comments[15] = "# ~chi_10 -> s ~s_R*";
   ParticleNeutralino1.Array_Decays[16][0] = -PDGelectron; ParticleNeutralino1.Array_Decays[16][1] = PDGselectronL; ParticleNeutralino1.Array_Decays[16][2] = neutralino1amplitudeeLebar; ParticleNeutralino1.Array_Decays[16][3] = 2; ParticleNeutralino1.Array_Comments[16] = "# ~chi_10 -> e+ ~e_L-";
   ParticleNeutralino1.Array_Decays[17][0] = -PDGelectron; ParticleNeutralino1.Array_Decays[17][1] = PDGselectronR; ParticleNeutralino1.Array_Decays[17][2] = neutralino1amplitudeeRebar; ParticleNeutralino1.Array_Decays[17][3] = 2; ParticleNeutralino1.Array_Comments[17] = "# ~chi_10 -> e+ ~e_R-";
   ParticleNeutralino1.Array_Decays[18][0] = PDGelectron; ParticleNeutralino1.Array_Decays[18][1] = -PDGselectronL; ParticleNeutralino1.Array_Decays[18][2] = neutralino1amplitudeeLbare; ParticleNeutralino1.Array_Decays[18][3] = 2; ParticleNeutralino1.Array_Comments[18] = "# ~chi_10 -> e- ~e_L+";
   ParticleNeutralino1.Array_Decays[19][0] = PDGelectron; ParticleNeutralino1.Array_Decays[19][1] = -PDGselectronR; ParticleNeutralino1.Array_Decays[19][2] = neutralino1amplitudeeRbare; ParticleNeutralino1.Array_Decays[19][3] = 2; ParticleNeutralino1.Array_Comments[19] = "# ~chi_10 -> e- ~e_R+";
   ParticleNeutralino1.Array_Decays[20][0] = -PDGmuon; ParticleNeutralino1.Array_Decays[20][1] = PDGsmuonL; ParticleNeutralino1.Array_Decays[20][2] = neutralino1amplitudemuLmubar; ParticleNeutralino1.Array_Decays[20][3] = 2; ParticleNeutralino1.Array_Comments[20] = "# ~chi_10 -> mu+ ~mu_L-";
   ParticleNeutralino1.Array_Decays[21][0] = -PDGmuon; ParticleNeutralino1.Array_Decays[21][1] = PDGsmuonR; ParticleNeutralino1.Array_Decays[21][2] = neutralino1amplitudemuRmubar; ParticleNeutralino1.Array_Decays[21][3] = 2; ParticleNeutralino1.Array_Comments[21] = "# ~chi_10 -> mu+ ~mu_R-";
   ParticleNeutralino1.Array_Decays[22][0] = PDGmuon; ParticleNeutralino1.Array_Decays[22][1] = -PDGsmuonL; ParticleNeutralino1.Array_Decays[22][2] = neutralino1amplitudemuLbarmu; ParticleNeutralino1.Array_Decays[22][3] = 2; ParticleNeutralino1.Array_Comments[22] = "# ~chi_10 -> mu- ~mu_L+";
   ParticleNeutralino1.Array_Decays[23][0] = PDGmuon; ParticleNeutralino1.Array_Decays[23][1] = -PDGsmuonR; ParticleNeutralino1.Array_Decays[23][2] = neutralino1amplitudemuRbarmu; ParticleNeutralino1.Array_Decays[23][3] = 2; ParticleNeutralino1.Array_Comments[23] = "# ~chi_10 -> mu- ~mu_R+";
   ParticleNeutralino1.Array_Decays[24][0] = PDGnuelectron; ParticleNeutralino1.Array_Decays[24][1] = -PDGnuselectronL; ParticleNeutralino1.Array_Decays[24][2] = neutralino1amplitudesnuebarnue; ParticleNeutralino1.Array_Decays[24][3] = 2; ParticleNeutralino1.Array_Comments[24] = "# ~chi_10 -> nu_e ~nu_eL*";
   ParticleNeutralino1.Array_Decays[25][0] = -PDGnuelectron; ParticleNeutralino1.Array_Decays[25][1] = PDGnuselectronL; ParticleNeutralino1.Array_Decays[25][2] = neutralino1amplitudesnuenuebar; ParticleNeutralino1.Array_Decays[25][3] = 2; ParticleNeutralino1.Array_Comments[25] = "# ~chi_10 -> nu_eb ~nu_eL";
   ParticleNeutralino1.Array_Decays[26][0] = PDGnumuon; ParticleNeutralino1.Array_Decays[26][1] = -PDGnusmuonL; ParticleNeutralino1.Array_Decays[26][2] = neutralino1amplitudesnumubarnumu; ParticleNeutralino1.Array_Decays[26][3] = 2; ParticleNeutralino1.Array_Comments[26] = "# ~chi_10 -> nu_mu ~nu_muL*";
   ParticleNeutralino1.Array_Decays[27][0] = -PDGnumuon; ParticleNeutralino1.Array_Decays[27][1] = PDGnusmuonL; ParticleNeutralino1.Array_Decays[27][2] = neutralino1amplitudesnumunumubar; ParticleNeutralino1.Array_Decays[27][3] = 2; ParticleNeutralino1.Array_Comments[27] = "# ~chi_10 -> nu_mub ~nu_muL";
   ParticleNeutralino1.Array_Decays[28][0] = PDGtop; ParticleNeutralino1.Array_Decays[28][1] = -PDGstop1; ParticleNeutralino1.Array_Decays[28][2] = neutralino1amplitudetopstop1bar; ParticleNeutralino1.Array_Decays[28][3] = 2; ParticleNeutralino1.Array_Comments[28] = "# ~chi_10 -> t ~t_1*";
   ParticleNeutralino1.Array_Decays[29][0] = PDGtop; ParticleNeutralino1.Array_Decays[29][1] = -PDGstop2; ParticleNeutralino1.Array_Decays[29][2] = neutralino1amplitudetopstop2bar; ParticleNeutralino1.Array_Decays[29][3] = 2; ParticleNeutralino1.Array_Comments[29] = "# ~chi_10 -> t ~t_2*";
   ParticleNeutralino1.Array_Decays[30][0] = -PDGtop; ParticleNeutralino1.Array_Decays[30][1] = PDGstop1; ParticleNeutralino1.Array_Decays[30][2] = neutralino1amplitudetopbarstop1; ParticleNeutralino1.Array_Decays[30][3] = 2; ParticleNeutralino1.Array_Comments[30] = "# ~chi_10 -> tb ~t_1";
   ParticleNeutralino1.Array_Decays[31][0] = -PDGtop; ParticleNeutralino1.Array_Decays[31][1] = PDGstop2; ParticleNeutralino1.Array_Decays[31][2] = neutralino1amplitudetopbarstop2; ParticleNeutralino1.Array_Decays[31][3] = 2; ParticleNeutralino1.Array_Comments[31] = "# ~chi_10 -> tb ~t_2";
   ParticleNeutralino1.Array_Decays[32][0] = PDGbottom; ParticleNeutralino1.Array_Decays[32][1] = -PDGsbottom1; ParticleNeutralino1.Array_Decays[32][2] = neutralino1amplitudebottomsbottom1bar; ParticleNeutralino1.Array_Decays[32][3] = 2; ParticleNeutralino1.Array_Comments[32] = "# ~chi_10 -> b ~b_1*";
   ParticleNeutralino1.Array_Decays[33][0] = PDGbottom; ParticleNeutralino1.Array_Decays[33][1] = -PDGsbottom2; ParticleNeutralino1.Array_Decays[33][2] = neutralino1amplitudebottomsbottom2bar; ParticleNeutralino1.Array_Decays[33][3] = 2; ParticleNeutralino1.Array_Comments[33] = "# ~chi_10 -> b ~b_2*";
   ParticleNeutralino1.Array_Decays[34][0] = -PDGbottom; ParticleNeutralino1.Array_Decays[34][1] = PDGsbottom1; ParticleNeutralino1.Array_Decays[34][2] = neutralino1amplitudebottombarsbottom1; ParticleNeutralino1.Array_Decays[34][3] = 2; ParticleNeutralino1.Array_Comments[34] = "# ~chi_10 -> bb ~b_1";
   ParticleNeutralino1.Array_Decays[35][0] = -PDGbottom; ParticleNeutralino1.Array_Decays[35][1] = PDGsbottom2; ParticleNeutralino1.Array_Decays[35][2] = neutralino1amplitudebottombarsbottom2; ParticleNeutralino1.Array_Decays[35][3] = 2; ParticleNeutralino1.Array_Comments[35] = "# ~chi_10 -> bb ~b_2";
   ParticleNeutralino1.Array_Decays[36][0] = -PDGstau1; ParticleNeutralino1.Array_Decays[36][1] = PDGtau; ParticleNeutralino1.Array_Decays[36][2] = neutralino1amplitudetaustau1bar; ParticleNeutralino1.Array_Decays[36][3] = 2; ParticleNeutralino1.Array_Comments[36] = "# ~chi_10 -> tau- ~tau_1+";
   ParticleNeutralino1.Array_Decays[37][0] = -PDGstau2; ParticleNeutralino1.Array_Decays[37][1] = PDGtau; ParticleNeutralino1.Array_Decays[37][2] = neutralino1amplitudetaustau2bar; ParticleNeutralino1.Array_Decays[37][3] = 2; ParticleNeutralino1.Array_Comments[37] = "# ~chi_10 -> tau- ~tau_2+";
   ParticleNeutralino1.Array_Decays[38][0] = PDGstau1; ParticleNeutralino1.Array_Decays[38][1] = -PDGtau; ParticleNeutralino1.Array_Decays[38][2] = neutralino1amplitudetaubarstau1; ParticleNeutralino1.Array_Decays[38][3] = 2; ParticleNeutralino1.Array_Comments[38] = "# ~chi_10 -> tau+ ~tau_1-";
   ParticleNeutralino1.Array_Decays[39][0] = PDGstau2; ParticleNeutralino1.Array_Decays[39][1] = -PDGtau; ParticleNeutralino1.Array_Decays[39][2] = neutralino1amplitudetaubarstau2; ParticleNeutralino1.Array_Decays[39][3] = 2; ParticleNeutralino1.Array_Comments[39] = "# ~chi_10 -> tau+ ~tau_2-";
   ParticleNeutralino1.Array_Decays[40][0] = PDGnutau; ParticleNeutralino1.Array_Decays[40][1] = -PDGnustauL; ParticleNeutralino1.Array_Decays[40][2] = neutralino1amplitudenutausnutaubar; ParticleNeutralino1.Array_Decays[40][3] = 2; ParticleNeutralino1.Array_Comments[40] = "# ~chi_10 -> nu_tau ~nu_tauL*";
   ParticleNeutralino1.Array_Decays[41][0] = -PDGnutau; ParticleNeutralino1.Array_Decays[41][1] = PDGnustauL; ParticleNeutralino1.Array_Decays[41][2] = neutralino1amplitudenutaubarsnutau; ParticleNeutralino1.Array_Decays[41][3] = 2; ParticleNeutralino1.Array_Comments[41] = "# ~chi_10 -> nu_taub ~nu_tauL";
   ParticleNeutralino1.Array_Decays[42][0] = PDGWplus; ParticleNeutralino1.Array_Decays[42][1] = -PDGchargino1; ParticleNeutralino1.Array_Decays[42][2] = neutralino1amplitudeWbosonpluscharginoW1; ParticleNeutralino1.Array_Decays[42][3] = 2; ParticleNeutralino1.Array_Comments[42] = "# ~chi_10 -> W+ ~chi_1-";
   ParticleNeutralino1.Array_Decays[43][0] = PDGWplus; ParticleNeutralino1.Array_Decays[43][1] = -PDGchargino2; ParticleNeutralino1.Array_Decays[43][2] = neutralino1amplitudeWbosonpluscharginoW2; ParticleNeutralino1.Array_Decays[43][3] = 2; ParticleNeutralino1.Array_Comments[43] = "# ~chi_10 -> W+ ~chi_2-*";
   ParticleNeutralino1.Array_Decays[44][0] = -PDGWplus; ParticleNeutralino1.Array_Decays[44][1] = PDGchargino1; ParticleNeutralino1.Array_Decays[44][2] = neutralino1amplitudeWbosonminuscharginoW1; ParticleNeutralino1.Array_Decays[44][3] = 2; ParticleNeutralino1.Array_Comments[44] = "# ~chi_10 -> W- ~chi1+";
   ParticleNeutralino1.Array_Decays[45][0] = -PDGWplus; ParticleNeutralino1.Array_Decays[45][1] = PDGchargino2; ParticleNeutralino1.Array_Decays[45][2] = neutralino1amplitudeWbosonminuscharginoW2; ParticleNeutralino1.Array_Decays[45][3] = 2; ParticleNeutralino1.Array_Comments[45] = "# ~chi_10 -> W- ~chi_2+";
   ParticleNeutralino1.Array_Decays[46][0] = PDGHplus; ParticleNeutralino1.Array_Decays[46][1] = -PDGchargino1; ParticleNeutralino1.Array_Decays[46][2] = neutralino1amplitudeHpluscharginoW1; ParticleNeutralino1.Array_Decays[46][3] = 2; ParticleNeutralino1.Array_Comments[46] = "# ~chi_10 -> H+ ~chi_1-";
   ParticleNeutralino1.Array_Decays[47][0] = PDGHplus; ParticleNeutralino1.Array_Decays[47][1] = -PDGchargino2; ParticleNeutralino1.Array_Decays[47][2] = neutralino1amplitudeHpluscharginoW2; ParticleNeutralino1.Array_Decays[47][3] = 2; ParticleNeutralino1.Array_Comments[47] = "# ~chi_10 -> H+ ~chi_2-";
   ParticleNeutralino1.Array_Decays[48][0] = -PDGHplus; ParticleNeutralino1.Array_Decays[48][1] = PDGchargino1; ParticleNeutralino1.Array_Decays[48][2] = neutralino1amplitudeHminuscharginoW1; ParticleNeutralino1.Array_Decays[48][3] = 2; ParticleNeutralino1.Array_Comments[48] = "# ~chi_10 -> H- ~chi_1+";
   ParticleNeutralino1.Array_Decays[49][0] = -PDGHplus; ParticleNeutralino1.Array_Decays[49][1] = PDGchargino2; ParticleNeutralino1.Array_Decays[49][2] = neutralino1amplitudeHminuscharginoW2; ParticleNeutralino1.Array_Decays[49][3] = 2; ParticleNeutralino1.Array_Comments[49] = "# ~chi_10 -> H- ~chi_2+";
   ParticleNeutralino1.Array_Decays[50][0] = PDGZboson; ParticleNeutralino1.Array_Decays[50][1] = PDGneutralino2; ParticleNeutralino1.Array_Decays[50][2] = neutralino1amplitudeZbosonneutralino2; ParticleNeutralino1.Array_Decays[50][3] = 2; ParticleNeutralino1.Array_Comments[50] = "# ~chi_10 -> Z ~chi_20";
   ParticleNeutralino1.Array_Decays[51][0] = PDGZboson; ParticleNeutralino1.Array_Decays[51][1] = PDGneutralino3; ParticleNeutralino1.Array_Decays[51][2] = neutralino1amplitudeZbosonneutralino3; ParticleNeutralino1.Array_Decays[51][3] = 2; ParticleNeutralino1.Array_Comments[51] = "# ~chi_10 -> Z ~chi_30";
   ParticleNeutralino1.Array_Decays[52][0] = PDGZboson; ParticleNeutralino1.Array_Decays[52][1] = PDGneutralino4; ParticleNeutralino1.Array_Decays[52][2] = neutralino1amplitudeZbosonneutralino4; ParticleNeutralino1.Array_Decays[52][3] = 2; ParticleNeutralino1.Array_Comments[52] = "# ~chi_10 -> Z ~chi_40";
   ParticleNeutralino1.Array_Decays[53][0] = PDGh0; ParticleNeutralino1.Array_Decays[53][1] = PDGneutralino2; ParticleNeutralino1.Array_Decays[53][2] = neutralino1amplitudehneutralino2; ParticleNeutralino1.Array_Decays[53][3] = 2; ParticleNeutralino1.Array_Comments[53] = "# ~chi_10 -> h ~chi_20";
   ParticleNeutralino1.Array_Decays[54][0] = PDGh0; ParticleNeutralino1.Array_Decays[54][1] = PDGneutralino3; ParticleNeutralino1.Array_Decays[54][2] = neutralino1amplitudehneutralino3;  ParticleNeutralino1.Array_Decays[54][3] = 2; ParticleNeutralino1.Array_Comments[54] = "# ~chi_10 -> h ~chi_30";
   ParticleNeutralino1.Array_Decays[55][0] = PDGh0; ParticleNeutralino1.Array_Decays[55][1] = PDGneutralino4; ParticleNeutralino1.Array_Decays[55][2] = neutralino1amplitudehneutralino4; ParticleNeutralino1.Array_Decays[55][3] = 2; ParticleNeutralino1.Array_Comments[55] = "# ~chi_10 -> h ~chi_40";
   ParticleNeutralino1.Array_Decays[56][0] = PDGH0; ParticleNeutralino1.Array_Decays[56][1] = PDGneutralino2; ParticleNeutralino1.Array_Decays[56][2] = neutralino1amplitudeHneutralino2; ParticleNeutralino1.Array_Decays[56][3] = 2; ParticleNeutralino1.Array_Comments[56] = "# ~chi_10 -> H ~chi_20";
   ParticleNeutralino1.Array_Decays[57][0] = PDGH0; ParticleNeutralino1.Array_Decays[57][1] = PDGneutralino3; ParticleNeutralino1.Array_Decays[57][2] = neutralino1amplitudeHneutralino3; ParticleNeutralino1.Array_Decays[57][3] = 2; ParticleNeutralino1.Array_Comments[57] = "# ~chi_10 -> H ~chi_30";
   ParticleNeutralino1.Array_Decays[58][0] = PDGH0; ParticleNeutralino1.Array_Decays[58][1] = PDGneutralino4; ParticleNeutralino1.Array_Decays[58][2] = neutralino1amplitudeHneutralino4; ParticleNeutralino1.Array_Decays[58][3] = 2; ParticleNeutralino1.Array_Comments[58] = "# ~chi_10 -> H ~chi_40";
   ParticleNeutralino1.Array_Decays[59][0] = PDGA0; ParticleNeutralino1.Array_Decays[59][1] = PDGneutralino2; ParticleNeutralino1.Array_Decays[59][2] = neutralino1amplitudeAneutralino2; ParticleNeutralino1.Array_Decays[59][3] = 2; ParticleNeutralino1.Array_Comments[59] = "# ~chi_10 -> A ~chi_20";
   ParticleNeutralino1.Array_Decays[60][0] = PDGA0; ParticleNeutralino1.Array_Decays[60][1] = PDGneutralino3; ParticleNeutralino1.Array_Decays[60][2] = neutralino1amplitudeAneutralino3; ParticleNeutralino1.Array_Decays[60][3] = 2; ParticleNeutralino1.Array_Comments[60] = "# ~chi_10 -> A ~chi_30";
   ParticleNeutralino1.Array_Decays[61][0] = PDGA0; ParticleNeutralino1.Array_Decays[61][1] = PDGneutralino4; ParticleNeutralino1.Array_Decays[61][2] = neutralino1amplitudeAneutralino4; ParticleNeutralino1.Array_Decays[61][3] = 2; ParticleNeutralino1.Array_Comments[61] = "# ~chi_10 -> A ~chi_40";

   ParticleNeutralino1.Array_Decays[62][0] = PDGphoton; ParticleNeutralino1.Array_Decays[62][1] = PDGgravitino; ParticleNeutralino1.Array_Decays[62][2] = neutralino1amplitudephotongravitino; ParticleNeutralino1.Array_Decays[62][3] = 2; ParticleNeutralino1.Array_Comments[62] = "# ~chi_10 -> gamma ~G";
   ParticleNeutralino1.Array_Decays[63][0] = PDGZboson; ParticleNeutralino1.Array_Decays[63][1] = PDGgravitino; ParticleNeutralino1.Array_Decays[63][2] = neutralino1amplitudeZgravitino; ParticleNeutralino1.Array_Decays[63][3] = 2; ParticleNeutralino1.Array_Comments[63] = "# ~chi_10 -> Z ~G";
   ParticleNeutralino1.Array_Decays[64][0] = PDGh0; ParticleNeutralino1.Array_Decays[64][1] = PDGgravitino; ParticleNeutralino1.Array_Decays[64][2] = neutralino1amplitudehgravitino; ParticleNeutralino1.Array_Decays[64][3] = 2; ParticleNeutralino1.Array_Comments[64] = "# ~chi_10 -> h ~G";
   ParticleNeutralino1.Array_Decays[65][0] = PDGH0; ParticleNeutralino1.Array_Decays[65][1] = PDGgravitino; ParticleNeutralino1.Array_Decays[65][2] = neutralino1amplitudeHgravitino; ParticleNeutralino1.Array_Decays[65][3] = 2; ParticleNeutralino1.Array_Comments[65] = "# ~chi_10 -> H ~G";
   ParticleNeutralino1.Array_Decays[66][0] = PDGA0; ParticleNeutralino1.Array_Decays[66][1] = PDGgravitino; ParticleNeutralino1.Array_Decays[66][2] = neutralino1amplitudeAgravitino; ParticleNeutralino1.Array_Decays[66][3] = 2; ParticleNeutralino1.Array_Comments[66] = "# ~chi_10 -> A ~G";

   ParticleNeutralino1.Array_Decays[67][0] = PDGchargino1; ParticleNeutralino1.Array_Decays[67][1] = PDGup; ParticleNeutralino1.Array_Decays[67][4] = -PDGdown; ParticleNeutralino1.Array_Decays[67][2] = neutralino1amplitudechargino1udbar; ParticleNeutralino1.Array_Decays[67][3] = 3; ParticleNeutralino1.Array_Comments[67] = "# ~chi_10 -> chi_1- u db";
   ParticleNeutralino1.Array_Decays[68][0] = PDGchargino1; ParticleNeutralino1.Array_Decays[68][1] = PDGcharm; ParticleNeutralino1.Array_Decays[68][4] = -PDGstrange; ParticleNeutralino1.Array_Decays[68][2] = neutralino1amplitudechargino1csbar; ParticleNeutralino1.Array_Decays[68][3] = 3; ParticleNeutralino1.Array_Comments[68] = "# ~chi_10 -> chi_1- c sb";
   ParticleNeutralino1.Array_Decays[69][0] = PDGchargino1; ParticleNeutralino1.Array_Decays[69][1] = PDGnuelectron; ParticleNeutralino1.Array_Decays[69][4] = -PDGelectron; ParticleNeutralino1.Array_Decays[69][2] = neutralino1amplitudechargino1enuebar; ParticleNeutralino1.Array_Decays[69][3] = 3; ParticleNeutralino1.Array_Comments[69] = "# ~chi_10 -> chi_1- nu_e eb";
   ParticleNeutralino1.Array_Decays[70][0] = PDGchargino1; ParticleNeutralino1.Array_Decays[70][1] = PDGnumuon; ParticleNeutralino1.Array_Decays[70][4] = -PDGmuon; ParticleNeutralino1.Array_Decays[70][2] = neutralino1amplitudechargino1munumubar; ParticleNeutralino1.Array_Decays[70][3] = 3; ParticleNeutralino1.Array_Comments[70] = "# ~chi_10 -> chi_1- nu_mu mub";
   ParticleNeutralino1.Array_Decays[71][0] = PDGchargino1; ParticleNeutralino1.Array_Decays[71][1] = PDGnutau; ParticleNeutralino1.Array_Decays[71][4] = -PDGtau; ParticleNeutralino1.Array_Decays[71][2] = neutralino1amplitudechargino1taunutaubar; ParticleNeutralino1.Array_Decays[71][3] = 3; ParticleNeutralino1.Array_Comments[71] = "# ~chi_10 -> chi_1- nu_tau taub";
   ParticleNeutralino1.Array_Decays[72][0] = PDGchargino2; ParticleNeutralino1.Array_Decays[72][1] = PDGup; ParticleNeutralino1.Array_Decays[72][4] = -PDGdown; ParticleNeutralino1.Array_Decays[72][2] = neutralino1amplitudechargino2udbar; ParticleNeutralino1.Array_Decays[72][3] = 3; ParticleNeutralino1.Array_Comments[72] = "# ~chi_10 -> chi_2- u dbar";
   ParticleNeutralino1.Array_Decays[73][0] = PDGchargino2; ParticleNeutralino1.Array_Decays[73][1] = PDGcharm; ParticleNeutralino1.Array_Decays[73][4] = -PDGstrange; ParticleNeutralino1.Array_Decays[73][2] = neutralino1amplitudechargino2csbar; ParticleNeutralino1.Array_Decays[73][3] = 3; ParticleNeutralino1.Array_Comments[73] = "# ~chi_10 -> chi_2- c sbar";
   ParticleNeutralino1.Array_Decays[74][0] = PDGchargino2; ParticleNeutralino1.Array_Decays[74][1] = PDGnuelectron; ParticleNeutralino1.Array_Decays[74][4] = -PDGelectron; ParticleNeutralino1.Array_Decays[74][2] = neutralino1amplitudechargino2enuebar; ParticleNeutralino1.Array_Decays[74][3] = 3; ParticleNeutralino1.Array_Comments[74] = "# ~chi_10 -> chi_2- nu_e eb";
   ParticleNeutralino1.Array_Decays[75][0] = PDGchargino2; ParticleNeutralino1.Array_Decays[75][1] = PDGnumuon; ParticleNeutralino1.Array_Decays[75][4] = -PDGmuon; ParticleNeutralino1.Array_Decays[75][2] = neutralino1amplitudechargino2munumubar; ParticleNeutralino1.Array_Decays[75][3] = 3; ParticleNeutralino1.Array_Comments[75] = "# ~chi_10 -> chi_2- nu_mu mub";
   ParticleNeutralino1.Array_Decays[76][0] = PDGchargino2; ParticleNeutralino1.Array_Decays[76][1] = PDGnutau; ParticleNeutralino1.Array_Decays[67][4] = -PDGtau; ParticleNeutralino1.Array_Decays[76][2] = neutralino1amplitudechargino2taunutaubar; ParticleNeutralino1.Array_Decays[76][3] = 3; ParticleNeutralino1.Array_Comments[76] = "# ~chi_10 -> chi_2- nu_tau taubar";

   double Neut1_No_1to2_Decays = 0;

  if (neutNLSP == 1) { Neut1_No_1to2_Decays = ParticleNeutralino1.No_1to2_Decays + ParticleNeutralino1.No_grav_Decays;}
  else { Neut1_No_1to2_Decays = ParticleNeutralino1.No_1to2_Decays;}
   
 for (int j = 0; j<Neut1_No_1to2_Decays; j++) {
   ParticleNeutralino1.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
  }

 for (int j=0; j<Neut1_No_1to2_Decays; j++) {
    ParticleNeutralino1.two_width = ParticleNeutralino1.two_width + ParticleNeutralino1.Array_Decays[j][2];
  }
 for (int j=Neut1_No_1to2_Decays; j<ParticleNeutralino1.No_of_Decays; j++) {
   ParticleNeutralino1.three_width = ParticleNeutralino1.three_width + ParticleNeutralino1.Array_Decays[j][2];
 }
  
  if ( ParticleNeutralino1.three_width != ParticleNeutralino1.three_width) /// Tests for a nan as only nans aren't equal to themselves
    {
      cout << "Three body decays give nan for neutralino 1 - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
      ParticleNeutralino1.No_of_Decays = Neut1_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
      ParticleNeutralino1.total_width = ParticleNeutralino1.two_width;
    }
  else {
    ParticleNeutralino1.total_width = ParticleNeutralino1.two_width + ParticleNeutralino1.three_width;
  }
   
  for (int i =0; i<ParticleNeutralino1.No_of_Decays; i++) {
     ParticleNeutralino1.Array_Decays[i][5]= ParticleNeutralino1.Array_Decays[i][2]/ParticleNeutralino1.total_width;
   }


 /// cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 /// cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleNeutralino1.PDG << setw(12) << scientific << setprecision(8) <<  ParticleNeutralino1.total_width << "   " << "# neutralino1 decays" << endl;
 /// cout.precision(7);
 /// cout << left << setw(6) << "#" << setw(18) << "BR" << setw(8) << "NDA" << setw(12) << left << " PDG1" << setw(12) << " PDG2" << setw(12) << " PDG3 " << endl;
 /// for (int k=0; k<ParticleNeutralino1.No_of_Decays; k++) {
 ///   if( ParticleNeutralino1.Array_Decays[k][2] != 0 && ParticleNeutralino1.Array_Decays[k][5] > BRTol) {
 ///         cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleNeutralino1.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleNeutralino1.Array_Decays[k][3];  printRowPDG(cout, ParticleNeutralino1.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleNeutralino1.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleNeutralino1.Array_Comments[k] << endl;
 ///   }
 /// }
 /// cout << "#" << endl;

///Uncomment section below if want partial widths as well as branching ratios
 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleNeutralino1.PDG << setw(12) << scientific << setprecision(8) <<  ParticleNeutralino1.total_width << "   " << "# neutralino1 decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "PW" << setw(18) << "BR" << setw(8) << "NDA" << setw(12) << left << " PDG1" << setw(12) << " PDG2" << setw(12) << " PDG3 " << endl;
 for (int k=0; k<ParticleNeutralino1.No_of_Decays; k++) {
   if( ParticleNeutralino1.Array_Decays[k][2] != 0 && ParticleNeutralino1.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleNeutralino1.Array_Decays[k][2] << setprecision(8) << ParticleNeutralino1.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << " " << ParticleNeutralino1.Array_Decays[k][3] << setw(4) << " ";  printRowPDG(cout, ParticleNeutralino1.Array_Decays[k][0]); cout << "    "; printRowPDG(cout,ParticleNeutralino1.Array_Decays[k][1]); cout << "    "; printRowPDG(cout,ParticleNeutralino1.Array_Decays[k][4]); cout << "   " << left << setprecision(0) << setw(15) << ParticleNeutralino1.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl; 

 //}

///Neutralino2 Decays
 
 double neutralino2amplitudeuLubar, neutralino2amplitudeuRubar, neutralino2amplitudeuLbaru, neutralino2amplitudeuRbaru, neutralino2amplitudedLdbar, neutralino2amplitudedRdbar, neutralino2amplitudedLbard, neutralino2amplitudedRbard, neutralino2amplitudecLcbar, neutralino2amplitudecRcbar, neutralino2amplitudecLbarc, neutralino2amplitudecRbarc, neutralino2amplitudesLsbar, neutralino2amplitudesRsbar, neutralino2amplitudesLbars, neutralino2amplitudesRbars, neutralino2amplitudeeLebar, neutralino2amplitudeeRebar, neutralino2amplitudeeLbare, neutralino2amplitudeeRbare, neutralino2amplitudemuLmubar, neutralino2amplitudemuRmubar, neutralino2amplitudemuLbarmu, neutralino2amplitudemuRbarmu, neutralino2amplitudesnuenuebar, neutralino2amplitudesnuebarnue, neutralino2amplitudesnumunumubar, neutralino2amplitudesnumubarnumu, neutralino2amplitudetopstop1bar, neutralino2amplitudetopstop2bar, neutralino2amplitudetopbarstop1, neutralino2amplitudetopbarstop2, neutralino2amplitudebottomsbottom1bar, neutralino2amplitudebottomsbottom2bar, neutralino2amplitudebottombarsbottom1, neutralino2amplitudebottombarsbottom2, neutralino2amplitudetaustau1bar, neutralino2amplitudetaustau2bar, neutralino2amplitudetaubarstau1, neutralino2amplitudetaubarstau2, neutralino2amplitudenutausnutaubar, neutralino2amplitudenutaubarsnutau, neutralino2amplitudeWbosonpluscharginoW1, neutralino2amplitudeWbosonpluscharginoW2, neutralino2amplitudeWbosonminuscharginoW1, neutralino2amplitudeWbosonminuscharginoW2, neutralino2amplitudeHpluscharginoW1, neutralino2amplitudeHpluscharginoW2, neutralino2amplitudeHminuscharginoW1, neutralino2amplitudeHminuscharginoW2, neutralino2amplitudeZbosonneutralino1, neutralino2amplitudeZbosonneutralino3, neutralino2amplitudeZbosonneutralino4, neutralino2amplitudehneutralino1, neutralino2amplitudehneutralino3, neutralino2amplitudehneutralino4, neutralino2amplitudeHneutralino1, neutralino2amplitudeHneutralino3, neutralino2amplitudeHneutralino4, neutralino2amplitudeAneutralino1, neutralino2amplitudeAneutralino3, neutralino2amplitudeAneutralino4, neutralino2amplitudephotongravitino, neutralino2amplitudeZgravitino, neutralino2amplitudehgravitino, neutralino2amplitudeHgravitino, neutralino2amplitudeAgravitino;

 double neutralino2amplitudeneut1uubar, neutralino2amplitudeneut1ddbar, neutralino2amplitudeneut1ccbar, neutralino2amplitudeneut1ssbar, neutralino2amplitudeneut1ttbar, neutralino2amplitudeneut1bbbar, neutralino2amplitudeneut1eebar, neutralino2amplitudeneut1mumubar, neutralino2amplitudeneut1tautaubar, neutralino2amplitudeneut1nuenuebar, neutralino2amplitudeneut1numunumubar, neutralino2amplitudeneut1nutaunutaubar, neutralino2amplitudechargino1udbar, neutralino2amplitudechargino1csbar, neutralino2amplitudechargino1enuebar, neutralino2amplitudechargino1munumubar, neutralino2amplitudechargino1taunutaubar, neutralino2amplitudechargino2udbar, neutralino2amplitudechargino2csbar, neutralino2amplitudechargino2enuebar, neutralino2amplitudechargino2munumubar, neutralino2amplitudechargino2taunutaubar;
 
 neutralino2amplitudeuLubar = neutralinoamplitudedecayquarksquarkLorR (mneut(2), MUP, mu(1,1), g, gp, mixNeut, 1, 'L', 2);
 neutralino2amplitudeuRubar = neutralinoamplitudedecayquarksquarkLorR (mneut(2), MUP, mu(2,1), g, gp, mixNeut, 1, 'R', 2);
 neutralino2amplitudeuLbaru = neutralinoamplitudedecayquarksquarkLorR (mneut(2), MUP, mu(1,1), g, gp, mixNeut, 1, 'L', 2); 
 neutralino2amplitudeuRbaru = neutralinoamplitudedecayquarksquarkLorR (mneut(2), MUP, mu(2,1), g, gp, mixNeut, 1, 'R', 2);
 neutralino2amplitudedLdbar = neutralinoamplitudedecayquarksquarkLorR (mneut(2), MDOWN, md(1,1), g, gp, mixNeut, 2, 'L', 2);
 neutralino2amplitudedRdbar = neutralinoamplitudedecayquarksquarkLorR (mneut(2), MDOWN, md(2,1), g, gp, mixNeut, 2, 'R', 2);
 neutralino2amplitudedLbard = neutralinoamplitudedecayquarksquarkLorR (mneut(2), MDOWN, md(1,1), g, gp, mixNeut, 2, 'L', 2);
 neutralino2amplitudedRbard = neutralinoamplitudedecayquarksquarkLorR (mneut(2), MDOWN, md(2,1), g, gp, mixNeut, 2, 'R', 2);
 neutralino2amplitudecLcbar = neutralinoamplitudedecayquarksquarkLorR (mneut(2), MCHARM, mu(1,2), g, gp, mixNeut, 1, 'L', 2);
 neutralino2amplitudecRcbar = neutralinoamplitudedecayquarksquarkLorR (mneut(2), MCHARM, mu(2,2), g, gp, mixNeut, 1, 'R', 2);
 neutralino2amplitudecLbarc = neutralinoamplitudedecayquarksquarkLorR (mneut(2), MCHARM, mu(1,2), g, gp, mixNeut, 1, 'L', 2);
 neutralino2amplitudecRbarc = neutralinoamplitudedecayquarksquarkLorR (mneut(2), MCHARM, mu(2,2), g, gp, mixNeut, 1, 'R', 2);
 neutralino2amplitudesLsbar = neutralinoamplitudedecayquarksquarkLorR (mneut(2), MSTRANGE, md(1,2), g, gp, mixNeut, 2, 'L', 2);
 neutralino2amplitudesRsbar = neutralinoamplitudedecayquarksquarkLorR (mneut(2), MSTRANGE, md(2,2), g, gp, mixNeut, 2, 'R', 2);
 neutralino2amplitudesLbars = neutralinoamplitudedecayquarksquarkLorR (mneut(2), MSTRANGE, md(1,2), g, gp, mixNeut, 2, 'L', 2);
 neutralino2amplitudesRbars = neutralinoamplitudedecayquarksquarkLorR (mneut(2), MSTRANGE, md(2,2), g, gp, mixNeut, 2, 'R', 2);
 neutralino2amplitudeeLebar = neutralinoamplitudedecayleptonsleptonLorR (mneut(2), MELECTRON, me(1,1), g, gp, mixNeut, 'L', 2);
 neutralino2amplitudeeRebar = neutralinoamplitudedecayleptonsleptonLorR (mneut(2), MELECTRON, me(2,1), g, gp, mixNeut, 'R', 2);
 neutralino2amplitudeeLbare = neutralinoamplitudedecayleptonsleptonLorR (mneut(2), MELECTRON, me(1,1), g, gp, mixNeut, 'L', 2);
 neutralino2amplitudeeRbare = neutralinoamplitudedecayleptonsleptonLorR (mneut(2), MELECTRON, me(2,1), g, gp, mixNeut, 'R', 2);
 neutralino2amplitudemuLmubar = neutralinoamplitudedecayleptonsleptonLorR (mneut(2), MMUON, me(1,2), g, gp, mixNeut, 'L', 2);
 neutralino2amplitudemuRmubar = neutralinoamplitudedecayleptonsleptonLorR (mneut(2), MMUON, me(2,2), g, gp, mixNeut, 'R', 2);
 neutralino2amplitudemuLbarmu = neutralinoamplitudedecayleptonsleptonLorR (mneut(2), MMUON, me(1,2), g, gp, mixNeut, 'L', 2);
 neutralino2amplitudemuRbarmu = neutralinoamplitudedecayleptonsleptonLorR (mneut(2), MMUON, me(2,2), g, gp, mixNeut, 'R', 2);
 neutralino2amplitudesnuenuebar = neutralinoamplitudedecayneutrinosneutrinoL (mneut(2), 0, msnu(1), g, gp, mixNeut, 2);
 neutralino2amplitudesnuebarnue = neutralinoamplitudedecayneutrinosneutrinoL (mneut(2), 0, msnu(1), g, gp, mixNeut, 2);
 neutralino2amplitudesnumunumubar = neutralinoamplitudedecayneutrinosneutrinoL (mneut(2), 0, msnu(2), g, gp, mixNeut, 2);
 neutralino2amplitudesnumubarnumu = neutralinoamplitudedecayneutrinosneutrinoL (mneut(2), 0, msnu(2), g, gp, mixNeut, 2);
 neutralino2amplitudetopstop1bar = neutralinoamplitudedecaysquark3quarkmix (mneut(2), MTOP, mu(1,3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 1, 2);
 neutralino2amplitudetopstop2bar = neutralinoamplitudedecaysquark3quarkmix (mneut(2), MTOP, mu(2,3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 2, 2);
 neutralino2amplitudetopbarstop1 = neutralinoamplitudedecaysquark3quarkmix (mneut(2), MTOP, mu(1,3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 1, 2);
 neutralino2amplitudetopbarstop2 = neutralinoamplitudedecaysquark3quarkmix (mneut(2), MTOP, mu(2,3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 2, 2);
 neutralino2amplitudebottomsbottom1bar = neutralinoamplitudedecaysquark3quarkmix (mneut(2), MBOTTOM, md(1,3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 1, 2);
 neutralino2amplitudebottomsbottom2bar = neutralinoamplitudedecaysquark3quarkmix (mneut(2), MBOTTOM, md(2,3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 2, 2);
 neutralino2amplitudebottombarsbottom1 = neutralinoamplitudedecaysquark3quarkmix (mneut(2), MBOTTOM, md(1,3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 1, 2);
 neutralino2amplitudebottombarsbottom2 = neutralinoamplitudedecaysquark3quarkmix (mneut(2), MBOTTOM, md(2,3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 2, 2);
 neutralino2amplitudetaustau1bar = neutralinoamplitudedecaystautau (mneut(2), MTAU, me(1,3), runmw, thetatau, beta, mixNeut, g, gp, 1, 2);
 neutralino2amplitudetaustau2bar = neutralinoamplitudedecaystautau (mneut(2), MTAU, me(2,3), runmw, thetatau, beta, mixNeut, g, gp, 2, 2);
 neutralino2amplitudetaubarstau1 = neutralinoamplitudedecaystautau (mneut(2), MTAU, me(1,3), runmw, thetatau, beta, mixNeut, g, gp, 1, 2);
 neutralino2amplitudetaubarstau2 = neutralinoamplitudedecaystautau (mneut(2), MTAU, me(2,3), runmw, thetatau, beta, mixNeut, g, gp, 2, 2);
 neutralino2amplitudenutausnutaubar = neutralinoamplitudedecayneutrinosneutrinoL (mneut(2), 0, msnu(3), g, gp, mixNeut, 2);
 neutralino2amplitudenutaubarsnutau = neutralinoamplitudedecayneutrinosneutrinoL (mneut(2), 0, msnu(3), g, gp, mixNeut, 2);
 neutralino2amplitudeWbosonpluscharginoW1 = neutralinoamplitudedecaycharginoWboson (mneut(2), polemw, MCH1, g, thetaL2, thetaR2, mixNeut, 2, 1);
 neutralino2amplitudeWbosonpluscharginoW2 = neutralinoamplitudedecaycharginoWboson (mneut(2), polemw, MCH2, g, thetaL2, thetaR2, mixNeut, 2, 2);
 neutralino2amplitudeWbosonminuscharginoW1 = neutralinoamplitudedecaycharginoWboson (mneut(2), polemw, MCH1, g, thetaL2, thetaR2, mixNeut, 2, 1);
 neutralino2amplitudeWbosonminuscharginoW2 = neutralinoamplitudedecaycharginoWboson (mneut(2), polemw, MCH2, g, thetaL2, thetaR2, mixNeut, 2, 2);
 neutralino2amplitudeHpluscharginoW1 = neutralinoamplitudedecaycharginoHplus (mneut(2), mHpm, MCH1, g, gp, beta, thetaL2, thetaR2, mixNeut, 2, 1);
 neutralino2amplitudeHpluscharginoW2 = neutralinoamplitudedecaycharginoHplus (mneut(2), mHpm, MCH2, g, gp, beta, thetaL2, thetaR2, mixNeut, 2, 2);
 neutralino2amplitudeHminuscharginoW1 = neutralinoamplitudedecaycharginoHplus (mneut(2), mHpm, MCH1, g, gp, beta, thetaL2, thetaR2, mixNeut, 2, 1);
 neutralino2amplitudeHminuscharginoW2 = neutralinoamplitudedecaycharginoHplus (mneut(2), mHpm, MCH2, g, gp, beta, thetaL2, thetaR2, mixNeut, 2, 2);
 neutralino2amplitudeZbosonneutralino1 = neutralinoamplitudedecayneutralinoZboson (mneut(2), mz, mneut(1), g, gp, mixNeut, 2, 1);
 neutralino2amplitudeZbosonneutralino3 = neutralinoamplitudedecayneutralinoZboson (mneut(2), mz, mneut(3), g, gp, mixNeut, 2, 3);
 neutralino2amplitudeZbosonneutralino4 = neutralinoamplitudedecayneutralinoZboson (mneut(2), mz, mneut(4), g, gp, mixNeut, 2, 4);
 neutralino2amplitudehneutralino1 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(2), mh0(1), mneut(1), g, gp, mixNeut, alpha, 2, 1, 'h');
 neutralino2amplitudehneutralino3 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(2), mh0(1), mneut(3), g, gp, mixNeut, alpha, 2, 3, 'h');
 neutralino2amplitudehneutralino4 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(2), mh0(1), mneut(4), g, gp, mixNeut, alpha, 2, 4, 'h');
 neutralino2amplitudeHneutralino1 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(2), mh0(2), mneut(1), g, gp, mixNeut, alpha, 2, 1, 'H');
 neutralino2amplitudeHneutralino3 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(2), mh0(2), mneut(3), g, gp, mixNeut, alpha, 2, 3, 'H');
 neutralino2amplitudeHneutralino4 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(2), mh0(2), mneut(4), g, gp, mixNeut, alpha, 2, 4, 'H');
 neutralino2amplitudeAneutralino1 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(2), mA0(1), mneut(1), g, gp, mixNeut, beta, 2, 1, 'A');
 neutralino2amplitudeAneutralino3 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(2), mA0(1), mneut(3), g, gp, mixNeut, beta, 2, 3, 'A');
 neutralino2amplitudeAneutralino4 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(2), mA0(1), mneut(4), g, gp, mixNeut, beta, 2, 4, 'A');

 neutralino2amplitudephotongravitino = neutralinoamplitudedecayphotongravitino(mneut(2), mgravitino, MPlreduced, mixNeut, g, gp, 2, gravonoff, neutNLSP);
 neutralino2amplitudeZgravitino = neutralinoamplitudedecayZgravitino(mneut(2), mz, mgravitino, MPlreduced, mixNeut, g, gp, beta, 2, gravonoff, neutNLSP);
 neutralino2amplitudehgravitino = neutralinoamplitudedecayphigravitino(mneut(2), mh0(1), mgravitino, MPlreduced, mixNeut, alpha, beta, 2, gravonoff, 'h', neutNLSP);
 neutralino2amplitudeHgravitino = neutralinoamplitudedecayphigravitino(mneut(2), mh0(2), mgravitino, MPlreduced, mixNeut, alpha, beta, 2, gravonoff, 'H', neutNLSP);
 neutralino2amplitudeAgravitino = neutralinoamplitudedecayphigravitino(mneut(2), mA0(1), mgravitino, MPlreduced, mixNeut, alpha, beta, 2, gravonoff, 'A', neutNLSP);

 

 neutralino2amplitudeneut1uubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(2), mu(1,1), mu(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(1), MUP, alphas, 0, runmw, g, gp, alpha, beta, MUP, mixNeut, 2, 1, onetothree, 'u');
 neutralino2amplitudeneut1ddbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(2), md(1,1), md(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(1), MDOWN, alphas, 0, runmw, g, gp, alpha, beta, MDOWN, mixNeut, 2, 1, onetothree, 'd');
 neutralino2amplitudeneut1ccbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(2), mu(1,2), mu(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(1), MCHARM, alphas, 0, runmw, g, gp, alpha, beta, MCHARM, mixNeut, 2, 1, onetothree, 'u');
 neutralino2amplitudeneut1ssbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(2), md(1,2), md(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(1), MSTRANGE, alphas, 0, runmw, g, gp, alpha, beta, MSTRANGE, mixNeut, 2, 1, onetothree, 'd');
 neutralino2amplitudeneut1ttbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(2), mu(1,3), mu(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(1), MTOP, alphas, thetat, runmw, g, gp, alpha, beta, runmt, mixNeut, 2, 1, onetothree, 'u');
 neutralino2amplitudeneut1bbbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(2), md(1,3), md(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(1), MBOTTOM, alphas, thetab, runmw, g, gp, alpha, beta, runmb, mixNeut, 2, 1, onetothree, 'd');
 neutralino2amplitudeneut1eebar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(2), me(1,1), me(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(1), MELECTRON, alphas, 0, runmw, g, gp, alpha, beta, MELECTRON, mixNeut, 2, 1, onetothree, 'l');
 neutralino2amplitudeneut1mumubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(2), me(1,2), me(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(1), MMUON, alphas, 0, runmw, g, gp, alpha, beta, MMUON, mixNeut, 2, 1, onetothree, 'l');
 neutralino2amplitudeneut1tautaubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(2), me(1,3), me(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(1), MTAU, alphas, thetatau-PI/2, runmw, g, gp, alpha, beta, runmtau, mixNeut, 2, 1, onetothree, 'l');
 neutralino2amplitudeneut1nuenuebar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(2), msnu(1), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(1), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 2, 1, onetothree, 'n');
 neutralino2amplitudeneut1numunumubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(2), msnu(2), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(1), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 2, 1, onetothree, 'n');
 neutralino2amplitudeneut1nutaunutaubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(2), msnu(3), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(1), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 2, 1, onetothree, 'n'); ///Note set msf(2) very large as there is no msnuR so need this intermediate to decouple and not be present

 neutralino2amplitudechargino1udbar = neutralinoamplitudedecaycharginoffprimebar (mneut(2), mu(1,1), mu(2,1), md(1,1), md(2,1), polemw, mHpm, mch(1), MUP, MDOWN, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, runmu, runmd, mixNeut, 2, 1, onetothree, 'q', 'n');
 neutralino2amplitudechargino1csbar = neutralinoamplitudedecaycharginoffprimebar (mneut(2), mu(1,2), mu(2,2), md(1,2), md(2,2), polemw, mHpm, mch(1), MCHARM, MSTRANGE, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, runmc, runms, mixNeut, 2, 1, onetothree, 'q', 'n');
 neutralino2amplitudechargino1enuebar = neutralinoamplitudedecaycharginoffprimebar (mneut(2), me(1,1), me(2,1), msnu(1), 100000000000, polemw, mHpm, mch(1), 0, MELECTRON, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, 0, MELECTRON, mixNeut, 2, 1, onetothree, 'l', 'n');
 neutralino2amplitudechargino1munumubar = neutralinoamplitudedecaycharginoffprimebar (mneut(2), me(1,2), me(2,2), msnu(2), 100000000000, polemw, mHpm, mch(1), 0, MMUON, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, 0, MMUON, mixNeut, 2, 1, onetothree, 'l', 'n');
 neutralino2amplitudechargino1taunutaubar = neutralinoamplitudedecaycharginoffprimebar (mneut(2), me(1,3), me(2,3), msnu(3), 100000000000, polemw, mHpm, mch(1), 0, MTAU, 0, thetatau, g, gp, alphas, beta, thetaL2, thetaR2, 0, runmtau, mixNeut, 2, 1, onetothree, 'l', 'n');
 neutralino2amplitudechargino2udbar = neutralinoamplitudedecaycharginoffprimebar (mneut(2), mu(1,1), mu(2,1), md(1,1), md(2,1), polemw, mHpm, mch(2), MUP, MDOWN, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, runmu, runmd, mixNeut, 2, 2, onetothree, 'q', 'n');
 neutralino2amplitudechargino2csbar = neutralinoamplitudedecaycharginoffprimebar (mneut(2), mu(1,2), mu(2,2), md(1,2), md(2,2), polemw, mHpm, mch(2), MCHARM, MSTRANGE, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, runmc, runms, mixNeut, 2, 2, onetothree, 'q', 'n');
 neutralino2amplitudechargino2enuebar = neutralinoamplitudedecaycharginoffprimebar (mneut(2), me(1,1), me(2,1), msnu(1), 100000000000, polemw, mHpm, mch(2), 0, MELECTRON, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, 0, MELECTRON, mixNeut, 2, 2, onetothree, 'l', 'n');
 neutralino2amplitudechargino2munumubar = neutralinoamplitudedecaycharginoffprimebar (mneut(2), me(1,2), me(2,2), msnu(2), 100000000000, polemw, mHpm, mch(2), 0, MMUON, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, 0, MMUON, mixNeut, 2, 2, onetothree, 'l', 'n');
 neutralino2amplitudechargino2taunutaubar = neutralinoamplitudedecaycharginoffprimebar (mneut(2), me(1,3), me(2,3), msnu(3), 100000000000, polemw, mHpm, mch(2), 0, MTAU, 0, thetatau, g, gp, alphas, beta, thetaL2, thetaR2, 0, runmtau, mixNeut, 2, 2, onetothree, 'l', 'n');



 
   ParticleNeutralino2.Array_Decays[0][0] = -PDGup; ParticleNeutralino2.Array_Decays[0][1] = PDGsupL; ParticleNeutralino2.Array_Decays[0][2] = neutralino2amplitudeuLubar; ParticleNeutralino2.Array_Decays[0][3] = 2; ParticleNeutralino2.Array_Comments[0] = "# ~chi_20 -> ub ~u_L";
   ParticleNeutralino2.Array_Decays[1][0] = -PDGup; ParticleNeutralino2.Array_Decays[1][1] = PDGsupR; ParticleNeutralino2.Array_Decays[1][2] = neutralino2amplitudeuRubar; ParticleNeutralino2.Array_Decays[1][3] = 2; ParticleNeutralino2.Array_Comments[1] = "# ~chi_20 -> ub ~u_R";
   ParticleNeutralino2.Array_Decays[2][0] = PDGup; ParticleNeutralino2.Array_Decays[2][1] = -PDGsupL; ParticleNeutralino2.Array_Decays[2][2] = neutralino2amplitudeuLbaru; ParticleNeutralino2.Array_Decays[2][3] = 2; ParticleNeutralino2.Array_Comments[2] = "# ~chi_20 -> u ~u_L*";
   ParticleNeutralino2.Array_Decays[3][0] = PDGup; ParticleNeutralino2.Array_Decays[3][1] = -PDGsupR; ParticleNeutralino2.Array_Decays[3][2] = neutralino2amplitudeuRbaru; ParticleNeutralino2.Array_Decays[3][3] = 2; ParticleNeutralino2.Array_Comments[3] = "# ~chi_20 -> u ~u_R*";
   ParticleNeutralino2.Array_Decays[4][0] = -PDGdown; ParticleNeutralino2.Array_Decays[4][1] = PDGsdownL; ParticleNeutralino2.Array_Decays[4][2] = neutralino2amplitudedLdbar; ParticleNeutralino2.Array_Decays[4][3] = 2; ParticleNeutralino2.Array_Comments[4] = "# ~chi_20 -> db ~d_L";
   ParticleNeutralino2.Array_Decays[5][0] = -PDGdown; ParticleNeutralino2.Array_Decays[5][1] = PDGsdownR; ParticleNeutralino2.Array_Decays[5][2] = neutralino2amplitudedRdbar; ParticleNeutralino2.Array_Decays[5][3] = 2; ParticleNeutralino2.Array_Comments[5] = "# ~chi_20 -> db ~d_R";
   ParticleNeutralino2.Array_Decays[6][0] = PDGdown; ParticleNeutralino2.Array_Decays[6][1] = -PDGsdownL; ParticleNeutralino2.Array_Decays[6][2] = neutralino2amplitudedLbard; ParticleNeutralino2.Array_Decays[6][3] = 2; ParticleNeutralino2.Array_Comments[6] = "# ~chi_20 -> d ~d_L*";
   ParticleNeutralino2.Array_Decays[7][0] = PDGdown; ParticleNeutralino2.Array_Decays[7][1] = -PDGsdownR; ParticleNeutralino2.Array_Decays[7][2] = neutralino2amplitudedRbard; ParticleNeutralino2.Array_Decays[7][3] = 2; ParticleNeutralino2.Array_Comments[7] = "# ~chi_20 -> d ~d_R*";
   ParticleNeutralino2.Array_Decays[8][0] = -PDGcharm; ParticleNeutralino2.Array_Decays[8][1] = PDGscharmL; ParticleNeutralino2.Array_Decays[8][2] = neutralino2amplitudecLcbar; ParticleNeutralino2.Array_Decays[8][3] = 2; ParticleNeutralino2.Array_Comments[8] = "# ~chi_20 -> cb ~c_L";
   ParticleNeutralino2.Array_Decays[9][0] = -PDGcharm; ParticleNeutralino2.Array_Decays[9][1] = PDGscharmR; ParticleNeutralino2.Array_Decays[9][2] = neutralino2amplitudecRcbar; ParticleNeutralino2.Array_Decays[9][3] = 2; ParticleNeutralino2.Array_Comments[9] = "# ~chi_20 -> cb ~c_R";
   ParticleNeutralino2.Array_Decays[10][0] = PDGcharm; ParticleNeutralino2.Array_Decays[10][1] = -PDGscharmL; ParticleNeutralino2.Array_Decays[10][2] = neutralino2amplitudecLbarc; ParticleNeutralino2.Array_Decays[10][3] = 2; ParticleNeutralino2.Array_Comments[10] = "# ~chi_20 -> c ~c_L*";
   ParticleNeutralino2.Array_Decays[11][0] = PDGcharm; ParticleNeutralino2.Array_Decays[11][1] = -PDGscharmR; ParticleNeutralino2.Array_Decays[11][2] = neutralino2amplitudecRbarc; ParticleNeutralino2.Array_Decays[11][3] = 2; ParticleNeutralino2.Array_Comments[11] = "# ~chi_20 -> c ~c_R*";
   ParticleNeutralino2.Array_Decays[12][0] = -PDGstrange; ParticleNeutralino2.Array_Decays[12][1] = PDGsstrangeL; ParticleNeutralino2.Array_Decays[12][2] = neutralino2amplitudesLsbar; ParticleNeutralino2.Array_Decays[12][3] = 2; ParticleNeutralino2.Array_Comments[12] = "# ~chi_20 -> sb ~s_L";
   ParticleNeutralino2.Array_Decays[13][0] = -PDGstrange; ParticleNeutralino2.Array_Decays[13][1] = PDGsstrangeR; ParticleNeutralino2.Array_Decays[13][2] = neutralino2amplitudesRsbar; ParticleNeutralino2.Array_Decays[13][3] = 2; ParticleNeutralino2.Array_Comments[13] = "# ~chi_20 -> sb ~s_R";
   ParticleNeutralino2.Array_Decays[14][0] = PDGstrange; ParticleNeutralino2.Array_Decays[14][1] = -PDGsstrangeL; ParticleNeutralino2.Array_Decays[14][2] = neutralino2amplitudesLbars; ParticleNeutralino2.Array_Decays[14][3] = 2; ParticleNeutralino2.Array_Comments[14] = "# ~chi_20 -> s ~s_L*";
   ParticleNeutralino2.Array_Decays[15][0] = PDGstrange; ParticleNeutralino2.Array_Decays[15][1] = -PDGsstrangeR; ParticleNeutralino2.Array_Decays[15][2] = neutralino2amplitudesRbars; ParticleNeutralino2.Array_Decays[15][3] = 2; ParticleNeutralino2.Array_Comments[15] = "# ~chi_20 -> s ~s_R*";
   ParticleNeutralino2.Array_Decays[16][0] = -PDGelectron; ParticleNeutralino2.Array_Decays[16][1] = PDGselectronL; ParticleNeutralino2.Array_Decays[16][2] = neutralino2amplitudeeLebar; ParticleNeutralino2.Array_Decays[16][3] = 2; ParticleNeutralino2.Array_Comments[16] = "# ~chi_20 -> e+ ~e_L-";
   ParticleNeutralino2.Array_Decays[17][0] = -PDGelectron; ParticleNeutralino2.Array_Decays[17][1] = PDGselectronR; ParticleNeutralino2.Array_Decays[17][2] = neutralino2amplitudeeRebar; ParticleNeutralino2.Array_Decays[17][3] = 2; ParticleNeutralino2.Array_Comments[17] = "# ~chi_20 -> e+ ~e_R-";
   ParticleNeutralino2.Array_Decays[18][0] = PDGelectron; ParticleNeutralino2.Array_Decays[18][1] = -PDGselectronL; ParticleNeutralino2.Array_Decays[18][2] = neutralino2amplitudeeLbare; ParticleNeutralino2.Array_Decays[18][3] = 2; ParticleNeutralino2.Array_Comments[18] = "# ~chi_20 -> e- ~e_L+";
   ParticleNeutralino2.Array_Decays[19][0] = PDGelectron; ParticleNeutralino2.Array_Decays[19][1] = -PDGselectronR; ParticleNeutralino2.Array_Decays[19][2] = neutralino2amplitudeeRbare; ParticleNeutralino2.Array_Decays[19][3] = 2; ParticleNeutralino2.Array_Comments[19] = "# ~chi_20 -> e- ~e_R+";   
   ParticleNeutralino2.Array_Decays[20][0] = -PDGmuon; ParticleNeutralino2.Array_Decays[20][1] = PDGsmuonL; ParticleNeutralino2.Array_Decays[20][2] = neutralino2amplitudemuLmubar; ParticleNeutralino2.Array_Decays[20][3] = 2; ParticleNeutralino2.Array_Comments[20] = "# ~chi_20 -> mu+ ~mu_L-";
   ParticleNeutralino2.Array_Decays[21][0] = -PDGmuon; ParticleNeutralino2.Array_Decays[21][1] = PDGsmuonR; ParticleNeutralino2.Array_Decays[21][2] = neutralino2amplitudemuRmubar; ParticleNeutralino2.Array_Decays[21][3] = 2; ParticleNeutralino2.Array_Comments[21] = "# ~chi_20 -> mu+ ~mu_R-";
   ParticleNeutralino2.Array_Decays[22][0] = PDGmuon; ParticleNeutralino2.Array_Decays[22][1] = -PDGsmuonL; ParticleNeutralino2.Array_Decays[22][2] = neutralino2amplitudemuLbarmu; ParticleNeutralino2.Array_Decays[22][3] = 2; ParticleNeutralino2.Array_Comments[22] = "# ~chi_20 -> mu- ~mu_L+";
   ParticleNeutralino2.Array_Decays[23][0] = PDGmuon; ParticleNeutralino2.Array_Decays[23][1] = -PDGsmuonR; ParticleNeutralino2.Array_Decays[23][2] = neutralino2amplitudemuRbarmu; ParticleNeutralino2.Array_Decays[23][3] = 2; ParticleNeutralino2.Array_Comments[23] = "# ~chi_20 -> mu- ~mu_R+";
   ParticleNeutralino2.Array_Decays[24][0] = PDGnuelectron; ParticleNeutralino2.Array_Decays[24][1] = -PDGnuselectronL; ParticleNeutralino2.Array_Decays[24][2] = neutralino2amplitudesnuebarnue; ParticleNeutralino2.Array_Decays[24][3] = 2; ParticleNeutralino2.Array_Comments[24] = "# ~chi_20 -> nu_e ~nu_eL*";
   ParticleNeutralino2.Array_Decays[25][0] = -PDGnuelectron; ParticleNeutralino2.Array_Decays[25][1] = PDGnuselectronL; ParticleNeutralino2.Array_Decays[25][2] = neutralino2amplitudesnuenuebar; ParticleNeutralino2.Array_Decays[25][3] = 2; ParticleNeutralino2.Array_Comments[25] = "# ~chi_20 -> nu_eb ~nu_eL";
   ParticleNeutralino2.Array_Decays[26][0] = PDGnumuon; ParticleNeutralino2.Array_Decays[26][1] = -PDGnusmuonL; ParticleNeutralino2.Array_Decays[26][2] = neutralino2amplitudesnumubarnumu; ParticleNeutralino2.Array_Decays[26][3] = 2; ParticleNeutralino2.Array_Comments[26] = "# ~chi_20 -> nu_mu ~nu_muL*";
   ParticleNeutralino2.Array_Decays[27][0] = -PDGnumuon; ParticleNeutralino2.Array_Decays[27][1] = PDGnusmuonL; ParticleNeutralino2.Array_Decays[27][2] = neutralino2amplitudesnumunumubar; ParticleNeutralino2.Array_Decays[27][3] = 2; ParticleNeutralino2.Array_Comments[27] = "# ~chi_20 -> nu_mub ~numu_L";
   ParticleNeutralino2.Array_Decays[28][0] = PDGtop; ParticleNeutralino2.Array_Decays[28][1] = -PDGstop1; ParticleNeutralino2.Array_Decays[28][2] = neutralino2amplitudetopstop1bar; ParticleNeutralino2.Array_Decays[28][3] = 2; ParticleNeutralino2.Array_Comments[28] = "# ~chi_20 -> t ~t_1*";
   ParticleNeutralino2.Array_Decays[29][0] = PDGtop; ParticleNeutralino2.Array_Decays[29][1] = -PDGstop2; ParticleNeutralino2.Array_Decays[29][2] = neutralino2amplitudetopstop2bar; ParticleNeutralino2.Array_Decays[29][3] = 2; ParticleNeutralino2.Array_Comments[29] = "# ~chi_20 -> t ~t_2*";
   ParticleNeutralino2.Array_Decays[30][0] = -PDGtop; ParticleNeutralino2.Array_Decays[30][1] = PDGstop1; ParticleNeutralino2.Array_Decays[30][2] = neutralino2amplitudetopbarstop1; ParticleNeutralino2.Array_Decays[30][3] = 2; ParticleNeutralino2.Array_Comments[30] = "# ~chi_20 -> tb ~t_1";
   ParticleNeutralino2.Array_Decays[31][0] = -PDGtop; ParticleNeutralino2.Array_Decays[31][1] = PDGstop2; ParticleNeutralino2.Array_Decays[31][2] = neutralino2amplitudetopbarstop2; ParticleNeutralino2.Array_Decays[31][3] = 2; ParticleNeutralino2.Array_Comments[31] = "# ~chi_20 -> tb ~t_2";
   ParticleNeutralino2.Array_Decays[32][0] = PDGbottom; ParticleNeutralino2.Array_Decays[32][1] = -PDGsbottom1; ParticleNeutralino2.Array_Decays[32][2] = neutralino2amplitudebottomsbottom1bar; ParticleNeutralino2.Array_Decays[32][3] = 2; ParticleNeutralino2.Array_Comments[32] = "# ~chi_20 -> b ~b_1*";
   ParticleNeutralino2.Array_Decays[33][0] = PDGbottom; ParticleNeutralino2.Array_Decays[33][1] = -PDGsbottom2; ParticleNeutralino2.Array_Decays[33][2] = neutralino2amplitudebottomsbottom2bar; ParticleNeutralino2.Array_Decays[33][3] = 2; ParticleNeutralino2.Array_Comments[33] = "# ~chi_20 -> b ~b_2*";
   ParticleNeutralino2.Array_Decays[34][0] = -PDGbottom; ParticleNeutralino2.Array_Decays[34][1] = PDGsbottom1; ParticleNeutralino2.Array_Decays[34][2] = neutralino2amplitudebottombarsbottom1; ParticleNeutralino2.Array_Decays[34][3] = 2; ParticleNeutralino2.Array_Comments[34] = "# ~chi_20 -> bb ~b_1";
   ParticleNeutralino2.Array_Decays[35][0] = -PDGbottom; ParticleNeutralino2.Array_Decays[35][1] = PDGsbottom2; ParticleNeutralino2.Array_Decays[35][2] = neutralino2amplitudebottombarsbottom2; ParticleNeutralino2.Array_Decays[35][3] = 2; ParticleNeutralino2.Array_Comments[35] = "# ~chi_20 -> bb ~b_2";
   ParticleNeutralino2.Array_Decays[36][0] = -PDGstau1; ParticleNeutralino2.Array_Decays[36][1] = PDGtau; ParticleNeutralino2.Array_Decays[36][2] = neutralino2amplitudetaustau1bar; ParticleNeutralino2.Array_Decays[36][3] = 2; ParticleNeutralino2.Array_Comments[36] = "# ~chi_20 -> tau- ~tau_1+";
   ParticleNeutralino2.Array_Decays[37][0] = -PDGstau2; ParticleNeutralino2.Array_Decays[37][1] = PDGtau; ParticleNeutralino2.Array_Decays[37][2] = neutralino2amplitudetaustau2bar; ParticleNeutralino2.Array_Decays[37][3] = 2; ParticleNeutralino2.Array_Comments[37] = "# ~chi_20 -> tau- ~tau_2+";
   ParticleNeutralino2.Array_Decays[38][0] = PDGstau1; ParticleNeutralino2.Array_Decays[38][1] = -PDGtau; ParticleNeutralino2.Array_Decays[38][2] = neutralino2amplitudetaubarstau1; ParticleNeutralino2.Array_Decays[38][3] = 2; ParticleNeutralino2.Array_Comments[38] = "# ~chi_20 -> tau+ ~tau_1-";
   ParticleNeutralino2.Array_Decays[39][0] = PDGstau2; ParticleNeutralino2.Array_Decays[39][1] = -PDGtau; ParticleNeutralino2.Array_Decays[39][2] = neutralino2amplitudetaubarstau2; ParticleNeutralino2.Array_Decays[39][3] = 2; ParticleNeutralino2.Array_Comments[39] = "# ~chi_20 -> tau+ ~tau_2-";
  ParticleNeutralino2.Array_Decays[40][0] = PDGnutau; ParticleNeutralino2.Array_Decays[40][1] = -PDGnustauL; ParticleNeutralino2.Array_Decays[40][2] = neutralino2amplitudenutausnutaubar; ParticleNeutralino2.Array_Decays[40][3] = 2; ParticleNeutralino2.Array_Comments[40] = "# ~chi_20 -> nu_tau ~nu_tauL*";
  ParticleNeutralino2.Array_Decays[41][0] = -PDGnutau; ParticleNeutralino2.Array_Decays[41][1] = PDGnustauL; ParticleNeutralino2.Array_Decays[41][2] = neutralino2amplitudenutaubarsnutau; ParticleNeutralino2.Array_Decays[41][3] = 2; ParticleNeutralino2.Array_Comments[41] = "# ~chi_20 -> nu_taub ~nu_tauL";
  ParticleNeutralino2.Array_Decays[42][0] = PDGWplus; ParticleNeutralino2.Array_Decays[42][1] = -PDGchargino1; ParticleNeutralino2.Array_Decays[42][2] = neutralino2amplitudeWbosonpluscharginoW1; ParticleNeutralino2.Array_Decays[42][3] = 2; ParticleNeutralino2.Array_Comments[42] = "# ~chi_20 -> W+ ~chi_1-";
  ParticleNeutralino2.Array_Decays[43][0] = PDGWplus; ParticleNeutralino2.Array_Decays[43][1] = -PDGchargino2; ParticleNeutralino2.Array_Decays[43][2] = neutralino2amplitudeWbosonpluscharginoW2; ParticleNeutralino2.Array_Decays[43][3] = 2; ParticleNeutralino2.Array_Comments[43] = "# ~chi_20 -> W+ ~chi_2-";
  ParticleNeutralino2.Array_Decays[44][0] = -PDGWplus; ParticleNeutralino2.Array_Decays[44][1] = PDGchargino1; ParticleNeutralino2.Array_Decays[44][2] = neutralino2amplitudeWbosonminuscharginoW1; ParticleNeutralino2.Array_Decays[44][3] = 2; ParticleNeutralino2.Array_Comments[44] = "# ~chi_20 -> W- ~chi_1+";
  ParticleNeutralino2.Array_Decays[45][0] = -PDGWplus; ParticleNeutralino2.Array_Decays[45][1] = PDGchargino2; ParticleNeutralino2.Array_Decays[45][2] = neutralino2amplitudeWbosonminuscharginoW2; ParticleNeutralino2.Array_Decays[45][3] = 2; ParticleNeutralino2.Array_Comments[45] = "# ~chi_20 -> W- ~chi_2+";
  ParticleNeutralino2.Array_Decays[46][0] = PDGHplus; ParticleNeutralino2.Array_Decays[46][1] = -PDGchargino1; ParticleNeutralino2.Array_Decays[46][2] = neutralino2amplitudeHpluscharginoW1; ParticleNeutralino2.Array_Decays[46][3] = 2; ParticleNeutralino2.Array_Comments[46] = "# ~chi_20 -> H+ ~chi_1-";
  ParticleNeutralino2.Array_Decays[47][0] = PDGHplus; ParticleNeutralino2.Array_Decays[47][1] = -PDGchargino2; ParticleNeutralino2.Array_Decays[47][2] = neutralino2amplitudeHpluscharginoW2; ParticleNeutralino2.Array_Decays[47][3] = 2; ParticleNeutralino2.Array_Comments[47] = "# ~chi_20 -> H+ ~chi_2-";
  ParticleNeutralino2.Array_Decays[48][0] = -PDGHplus; ParticleNeutralino2.Array_Decays[48][1] = PDGchargino1; ParticleNeutralino2.Array_Decays[48][2] = neutralino2amplitudeHminuscharginoW1; ParticleNeutralino2.Array_Decays[48][3] = 2; ParticleNeutralino2.Array_Comments[48] = "# ~chi_20 -> H- ~chi1+";
  ParticleNeutralino2.Array_Decays[49][0] = -PDGHplus; ParticleNeutralino2.Array_Decays[49][1] = PDGchargino2; ParticleNeutralino2.Array_Decays[49][2] = neutralino2amplitudeHminuscharginoW2; ParticleNeutralino2.Array_Decays[49][3] = 2; ParticleNeutralino2.Array_Comments[49] = "# ~chi_20 -> H- ~chi_2+";
  ParticleNeutralino2.Array_Decays[50][0] = PDGZboson; ParticleNeutralino2.Array_Decays[50][1] = PDGneutralino1; ParticleNeutralino2.Array_Decays[50][2] = neutralino2amplitudeZbosonneutralino1; ParticleNeutralino2.Array_Decays[50][3] = 2; ParticleNeutralino2.Array_Comments[50] = "# ~chi_20 -> Z ~chi_10";
  ParticleNeutralino2.Array_Decays[51][0] = PDGZboson; ParticleNeutralino2.Array_Decays[51][1] = PDGneutralino3; ParticleNeutralino2.Array_Decays[51][2] = neutralino2amplitudeZbosonneutralino3; ParticleNeutralino2.Array_Decays[51][3] = 2; ParticleNeutralino2.Array_Comments[51] = "# ~chi_20 -> Z ~chi_30";
  ParticleNeutralino2.Array_Decays[52][0] = PDGZboson; ParticleNeutralino2.Array_Decays[52][1] = PDGneutralino4; ParticleNeutralino2.Array_Decays[52][2] = neutralino2amplitudeZbosonneutralino4; ParticleNeutralino2.Array_Decays[52][3] = 2; ParticleNeutralino2.Array_Comments[52] = "# ~chi_20 -> Z ~chi_40";
  ParticleNeutralino2.Array_Decays[53][0] = PDGh0; ParticleNeutralino2.Array_Decays[53][1] = PDGneutralino1; ParticleNeutralino2.Array_Decays[53][2] = neutralino2amplitudehneutralino1; ParticleNeutralino2.Array_Decays[53][3] = 2; ParticleNeutralino2.Array_Comments[53] = "# ~chi_20 -> h ~chi_10";
  ParticleNeutralino2.Array_Decays[54][0] = PDGh0; ParticleNeutralino2.Array_Decays[54][1] = PDGneutralino3; ParticleNeutralino2.Array_Decays[54][2] = neutralino2amplitudehneutralino3; ParticleNeutralino2.Array_Decays[54][3] = 2; ParticleNeutralino2.Array_Comments[54] = "# ~chi_20 -> h ~chi_30";
  ParticleNeutralino2.Array_Decays[55][0] = PDGh0; ParticleNeutralino2.Array_Decays[55][1] = PDGneutralino4; ParticleNeutralino2.Array_Decays[55][2] = neutralino2amplitudehneutralino4; ParticleNeutralino2.Array_Decays[55][3] = 2; ParticleNeutralino2.Array_Comments[55] = "# ~chi_20 -> h ~chi_40";
  ParticleNeutralino2.Array_Decays[56][0] = PDGH0; ParticleNeutralino2.Array_Decays[56][1] = PDGneutralino1; ParticleNeutralino2.Array_Decays[56][2] = neutralino2amplitudeHneutralino1; ParticleNeutralino2.Array_Decays[56][3] = 2; ParticleNeutralino2.Array_Comments[56] = "# ~chi_20 -> H ~chi_10";
  ParticleNeutralino2.Array_Decays[57][0] = PDGH0; ParticleNeutralino2.Array_Decays[57][1] = PDGneutralino3; ParticleNeutralino2.Array_Decays[57][2] = neutralino2amplitudeHneutralino3; ParticleNeutralino2.Array_Decays[57][3] = 2; ParticleNeutralino2.Array_Comments[57] = "# ~chi_20 -> H ~chi_30";
  ParticleNeutralino2.Array_Decays[58][0] = PDGH0; ParticleNeutralino2.Array_Decays[58][1] = PDGneutralino4; ParticleNeutralino2.Array_Decays[58][2] = neutralino2amplitudeHneutralino4; ParticleNeutralino2.Array_Decays[58][3] = 2; ParticleNeutralino2.Array_Comments[58] = "# ~chi_20 -> H ~chi_40";
  ParticleNeutralino2.Array_Decays[59][0] = PDGA0; ParticleNeutralino2.Array_Decays[59][1] = PDGneutralino1; ParticleNeutralino2.Array_Decays[59][2] = neutralino2amplitudeAneutralino1; ParticleNeutralino2.Array_Decays[59][3] = 2; ParticleNeutralino2.Array_Comments[59] = "# ~chi_20 -> A ~chi_10";
  ParticleNeutralino2.Array_Decays[60][0] = PDGA0; ParticleNeutralino2.Array_Decays[60][1] = PDGneutralino3; ParticleNeutralino2.Array_Decays[60][2] = neutralino2amplitudeAneutralino3; ParticleNeutralino2.Array_Decays[60][3] = 2; ParticleNeutralino2.Array_Comments[60] = "# ~chi_20 -> A ~chi_30";
  ParticleNeutralino2.Array_Decays[61][0] = PDGA0; ParticleNeutralino2.Array_Decays[61][1] = PDGneutralino4; ParticleNeutralino2.Array_Decays[61][2] = neutralino2amplitudeAneutralino4; ParticleNeutralino2.Array_Decays[61][3] = 2; ParticleNeutralino2.Array_Comments[61] = "# ~chi_20 -> A ~chi_40";

  ParticleNeutralino2.Array_Decays[62][0] = PDGphoton; ParticleNeutralino2.Array_Decays[62][1] = PDGgravitino; ParticleNeutralino2.Array_Decays[62][2] = neutralino2amplitudephotongravitino; ParticleNeutralino2.Array_Decays[62][3] = 2; ParticleNeutralino2.Array_Decays[74][4]=0; ParticleNeutralino2.Array_Comments[62] = "# ~chi_20 -> gamma ~G";
  ParticleNeutralino2.Array_Decays[63][0] = PDGZboson; ParticleNeutralino2.Array_Decays[63][1] = PDGgravitino; ParticleNeutralino2.Array_Decays[63][2] = neutralino2amplitudeZgravitino; ParticleNeutralino2.Array_Decays[63][3] = 2; ParticleNeutralino2.Array_Decays[63][4]=0; ParticleNeutralino2.Array_Comments[63] = "# ~chi_20 -> Z ~G";
  ParticleNeutralino2.Array_Decays[64][0] = PDGh0; ParticleNeutralino2.Array_Decays[64][1] = PDGgravitino; ParticleNeutralino2.Array_Decays[64][2] = neutralino2amplitudehgravitino; ParticleNeutralino2.Array_Decays[64][3] = 2; ParticleNeutralino2.Array_Decays[64][4] = 0; ParticleNeutralino2.Array_Comments[64] = "# ~chi_20 -> h ~G";
  ParticleNeutralino2.Array_Decays[65][0] = PDGH0; ParticleNeutralino2.Array_Decays[65][1] = PDGgravitino; ParticleNeutralino2.Array_Decays[65][2] = neutralino2amplitudeHgravitino; ParticleNeutralino2.Array_Decays[65][3] = 2; ParticleNeutralino2.Array_Decays[65][4] = 0; ParticleNeutralino2.Array_Comments[65] = "# ~chi_20 -> H ~G";
  ParticleNeutralino2.Array_Decays[66][0] = PDGA0; ParticleNeutralino2.Array_Decays[66][1] = PDGgravitino; ParticleNeutralino2.Array_Decays[66][2] = neutralino2amplitudeAgravitino; ParticleNeutralino2.Array_Decays[66][3] = 2; ParticleNeutralino2.Array_Decays[66][4] = 0; ParticleNeutralino2.Array_Comments[66] = "# ~chi_20 -> A ~G";

  ParticleNeutralino2.Array_Decays[67][0] = PDGneutralino1; ParticleNeutralino2.Array_Decays[67][1] = PDGup; ParticleNeutralino2.Array_Decays[67][4] = -PDGup; ParticleNeutralino2.Array_Decays[67][2] = neutralino2amplitudeneut1uubar; ParticleNeutralino2.Array_Decays[67][3] = 3; ParticleNeutralino2.Array_Comments[67] = "# ~chi_20 -> ~chi_10 u ubar";
  ParticleNeutralino2.Array_Decays[68][0] = PDGneutralino1; ParticleNeutralino2.Array_Decays[68][1] = PDGdown; ParticleNeutralino2.Array_Decays[68][4] = -PDGdown; ParticleNeutralino2.Array_Decays[68][2] = neutralino2amplitudeneut1ddbar; ParticleNeutralino2.Array_Decays[68][3] = 3; ParticleNeutralino2.Array_Comments[68] = "# ~chi_20 -> ~chi_10 d dbar";
  ParticleNeutralino2.Array_Decays[69][0] = PDGneutralino1; ParticleNeutralino2.Array_Decays[69][1] = PDGcharm; ParticleNeutralino2.Array_Decays[69][4] = -PDGcharm; ParticleNeutralino2.Array_Decays[69][2] = neutralino2amplitudeneut1ccbar; ParticleNeutralino2.Array_Decays[69][3] = 3; ParticleNeutralino2.Array_Comments[69] = "# ~chi_20 -> ~chi_10 c cbar";
  ParticleNeutralino2.Array_Decays[70][0] = PDGneutralino1; ParticleNeutralino2.Array_Decays[70][1] = PDGstrange; ParticleNeutralino2.Array_Decays[70][4] = -PDGstrange; ParticleNeutralino2.Array_Decays[70][2] = neutralino2amplitudeneut1ssbar; ParticleNeutralino2.Array_Decays[70][3] = 3; ParticleNeutralino2.Array_Comments[70] = "# ~chi_20 -> ~chi_10 s sbar";
  ParticleNeutralino2.Array_Decays[71][0] = PDGneutralino1; ParticleNeutralino2.Array_Decays[71][1] = PDGtop; ParticleNeutralino2.Array_Decays[71][4] = -PDGtop; ParticleNeutralino2.Array_Decays[71][2] = neutralino2amplitudeneut1ttbar; ParticleNeutralino2.Array_Decays[71][3] = 3; ParticleNeutralino2.Array_Comments[71] = "# ~chi_20 -> ~chi_10 t tbar";
  ParticleNeutralino2.Array_Decays[72][0] = PDGneutralino1; ParticleNeutralino2.Array_Decays[72][1] = PDGbottom; ParticleNeutralino2.Array_Decays[72][4] = -PDGbottom; ParticleNeutralino2.Array_Decays[72][2] = neutralino2amplitudeneut1bbbar; ParticleNeutralino2.Array_Decays[72][3] = 3; ParticleNeutralino2.Array_Comments[72] = "# ~chi_20 -> ~chi_10 b bbar";
  ParticleNeutralino2.Array_Decays[73][0] = PDGneutralino1; ParticleNeutralino2.Array_Decays[73][1] = PDGelectron; ParticleNeutralino2.Array_Decays[73][4] = -PDGelectron; ParticleNeutralino2.Array_Decays[73][2] = neutralino2amplitudeneut1eebar; ParticleNeutralino2.Array_Decays[73][3] = 3; ParticleNeutralino2.Array_Comments[73] = "# ~chi_20 -> ~chi_10 e- e+";
  ParticleNeutralino2.Array_Decays[74][0] = PDGneutralino1; ParticleNeutralino2.Array_Decays[74][1] = PDGmuon; ParticleNeutralino2.Array_Decays[74][4] = -PDGmuon; ParticleNeutralino2.Array_Decays[74][2] = neutralino2amplitudeneut1mumubar; ParticleNeutralino2.Array_Decays[74][3] = 3; ParticleNeutralino2.Array_Comments[74] = "# ~chi_20 -> ~chi_10 mu- mu+";
  ParticleNeutralino2.Array_Decays[75][0] = PDGneutralino1; ParticleNeutralino2.Array_Decays[75][1] = PDGtau; ParticleNeutralino2.Array_Decays[75][4] = -PDGtau; ParticleNeutralino2.Array_Decays[75][2] = neutralino2amplitudeneut1tautaubar; ParticleNeutralino2.Array_Decays[75][3] = 3; ParticleNeutralino2.Array_Comments[75] = "# ~chi_20 -> ~chi_10 tau- tau+";
  ParticleNeutralino2.Array_Decays[76][0] = PDGneutralino1; ParticleNeutralino2.Array_Decays[76][1] = PDGnuelectron; ParticleNeutralino2.Array_Decays[76][4] = -PDGnuelectron; ParticleNeutralino2.Array_Decays[76][2] = neutralino2amplitudeneut1nuenuebar; ParticleNeutralino2.Array_Decays[76][3] = 3; ParticleNeutralino2.Array_Comments[76] = "# ~chi_20 -> ~chi_10 nue nuebar";
  ParticleNeutralino2.Array_Decays[77][0] = PDGneutralino1; ParticleNeutralino2.Array_Decays[77][1] = PDGnumuon; ParticleNeutralino2.Array_Decays[77][4] = -PDGnumuon; ParticleNeutralino2.Array_Decays[77][2] = neutralino2amplitudeneut1numunumubar; ParticleNeutralino2.Array_Decays[77][3] = 3; ParticleNeutralino2.Array_Comments[77] = "# ~chi_20 -> ~chi_10 numu numubar";
  ParticleNeutralino2.Array_Decays[78][0] = PDGneutralino1; ParticleNeutralino2.Array_Decays[78][1] = PDGnutau; ParticleNeutralino2.Array_Decays[78][4] = -PDGnutau; ParticleNeutralino2.Array_Decays[78][2] = neutralino2amplitudeneut1nutaunutaubar; ParticleNeutralino2.Array_Decays[78][3] = 3; ParticleNeutralino2.Array_Comments[78] = "# ~chi_20 -> ~chi_10 nutau nutaubar";
   
  ParticleNeutralino2.Array_Decays[79][0] = PDGchargino1; ParticleNeutralino2.Array_Decays[79][1] = PDGup; ParticleNeutralino2.Array_Decays[79][4] = -PDGdown; ParticleNeutralino2.Array_Decays[79][2] = neutralino2amplitudechargino1udbar; ParticleNeutralino2.Array_Decays[79][3] = 3; ParticleNeutralino2.Array_Comments[79] = "# ~chi_20 -> chi_1- u db";
   ParticleNeutralino2.Array_Decays[80][0] = PDGchargino1; ParticleNeutralino2.Array_Decays[80][1] = PDGcharm; ParticleNeutralino2.Array_Decays[80][4] = -PDGstrange; ParticleNeutralino2.Array_Decays[80][2] = neutralino2amplitudechargino1csbar; ParticleNeutralino2.Array_Decays[80][3] = 3; ParticleNeutralino2.Array_Comments[80] = "# ~chi_20 -> chi_1- c sb";
   ParticleNeutralino2.Array_Decays[81][0] = PDGchargino1; ParticleNeutralino2.Array_Decays[81][1] = PDGnuelectron; ParticleNeutralino2.Array_Decays[81][4] = -PDGelectron; ParticleNeutralino2.Array_Decays[81][2] = neutralino2amplitudechargino1enuebar; ParticleNeutralino2.Array_Decays[81][3] = 3; ParticleNeutralino2.Array_Comments[81] = "# ~chi_20 -> chi_1- nu_e eb";
   ParticleNeutralino2.Array_Decays[82][0] = PDGchargino1; ParticleNeutralino2.Array_Decays[82][1] = PDGnumuon; ParticleNeutralino2.Array_Decays[82][4] = -PDGmuon; ParticleNeutralino2.Array_Decays[82][2] = neutralino2amplitudechargino1munumubar; ParticleNeutralino2.Array_Decays[82][3] = 3; ParticleNeutralino2.Array_Comments[82] = "# ~chi_20 -> chi_1- nu_mu mub";
   ParticleNeutralino2.Array_Decays[83][0] = PDGchargino1; ParticleNeutralino2.Array_Decays[83][1] = PDGnutau; ParticleNeutralino2.Array_Decays[83][4] = -PDGtau; ParticleNeutralino2.Array_Decays[83][2] = neutralino2amplitudechargino1taunutaubar; ParticleNeutralino2.Array_Decays[83][3] = 3; ParticleNeutralino2.Array_Comments[83] = "# ~chi_20 -> chi_1- nu_tau taub";
   ParticleNeutralino2.Array_Decays[84][0] = PDGchargino2; ParticleNeutralino2.Array_Decays[84][1] = PDGup; ParticleNeutralino2.Array_Decays[84][4] = -PDGdown; ParticleNeutralino2.Array_Decays[84][2] = neutralino2amplitudechargino2udbar; ParticleNeutralino2.Array_Decays[84][3] = 3; ParticleNeutralino2.Array_Comments[84] = "# ~chi_20 -> chi_2- u dbar";
   ParticleNeutralino2.Array_Decays[85][0] = PDGchargino2; ParticleNeutralino2.Array_Decays[85][1] = PDGcharm; ParticleNeutralino2.Array_Decays[85][4] = -PDGstrange; ParticleNeutralino2.Array_Decays[85][2] = neutralino2amplitudechargino2csbar; ParticleNeutralino2.Array_Decays[85][3] = 3; ParticleNeutralino2.Array_Comments[85] = "# ~chi_20 -> chi_2- c sbar";
   ParticleNeutralino2.Array_Decays[86][0] = PDGchargino2; ParticleNeutralino2.Array_Decays[86][1] = PDGnuelectron; ParticleNeutralino2.Array_Decays[86][4] = -PDGelectron; ParticleNeutralino2.Array_Decays[86][2] = neutralino2amplitudechargino2enuebar; ParticleNeutralino2.Array_Decays[86][3] = 3; ParticleNeutralino2.Array_Comments[86] = "# ~chi_20 -> chi_2- nu_e eb";
   ParticleNeutralino2.Array_Decays[87][0] = PDGchargino2; ParticleNeutralino2.Array_Decays[87][1] = PDGnumuon; ParticleNeutralino2.Array_Decays[87][4] = -PDGmuon; ParticleNeutralino2.Array_Decays[87][2] = neutralino2amplitudechargino2munumubar; ParticleNeutralino2.Array_Decays[87][3] = 3; ParticleNeutralino2.Array_Comments[87] = "# ~chi_20 -> chi_2- nu_mu mub";
   ParticleNeutralino2.Array_Decays[88][0] = PDGchargino2; ParticleNeutralino2.Array_Decays[88][1] = PDGnutau; ParticleNeutralino2.Array_Decays[88][4] = -PDGtau; ParticleNeutralino2.Array_Decays[88][2] = neutralino2amplitudechargino2taunutaubar; ParticleNeutralino2.Array_Decays[88][3] = 3; ParticleNeutralino2.Array_Comments[88] = "# ~chi_20 -> chi_2- nu_tau taubar";
  
  double Neut2_No_1to2_Decays = 0;

  if (neutNLSP == 1) { Neut2_No_1to2_Decays = ParticleNeutralino2.No_1to2_Decays + ParticleNeutralino2.No_grav_Decays;}
  else { Neut2_No_1to2_Decays = ParticleNeutralino2.No_1to2_Decays;}
   
 for (int j = 0; j<Neut2_No_1to2_Decays; j++) {
   ParticleNeutralino2.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
  }

 for (int j=0; j<Neut2_No_1to2_Decays; j++) {
    ParticleNeutralino2.two_width = ParticleNeutralino2.two_width + ParticleNeutralino2.Array_Decays[j][2];
  }
 for (int j=Neut2_No_1to2_Decays; j<ParticleNeutralino2.No_of_Decays; j++) {
   ParticleNeutralino2.three_width = ParticleNeutralino2.three_width + ParticleNeutralino2.Array_Decays[j][2];
 }
  
  if ( ParticleNeutralino2.three_width != ParticleNeutralino2.three_width) /// Tests for a nan as only nans aren't equal to themselves
    {
      cout << "Three body decays give nan for neutralino 2 - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
      ParticleNeutralino2.No_of_Decays = Neut2_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
      ParticleNeutralino2.total_width = ParticleNeutralino2.two_width;
    }
  else {
    ParticleNeutralino2.total_width = ParticleNeutralino2.two_width + ParticleNeutralino2.three_width;
  }
   
  for (int i =0; i<ParticleNeutralino2.No_of_Decays; i++) {
     ParticleNeutralino2.Array_Decays[i][5]= ParticleNeutralino2.Array_Decays[i][2]/ParticleNeutralino2.total_width;
   }


 /// cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 /// cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleNeutralino2.PDG << setw(12) << scientific << setprecision(8) <<  ParticleNeutralino2.total_width << "   " << "# neutralino2 decays" << endl;
 /// cout.precision(7);
 /// cout << left << setw(6) << "#" << setw(18) << "BR" << setw(8) << "NDA" << setw(12) << left << " PDG1" << setw(12) << " PDG2" << setw(12) << " PDG3 " << endl;
 /// for (int k=0; k<ParticleNeutralino2.No_of_Decays; k++) {
 ///   if( ParticleNeutralino2.Array_Decays[k][2] != 0 && ParticleNeutralino2.Array_Decays[k][5] > BRTol) {
 ///         cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleNeutralino2.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleNeutralino2.Array_Decays[k][3];  printRowPDG(cout, ParticleNeutralino2.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleNeutralino2.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleNeutralino2.Array_Comments[k] << endl;
 ///   }
 /// }
 /// cout << "#" << endl;

///Uncomment section below if want partial widths as well as branching ratios
 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleNeutralino2.PDG << setw(12) << scientific << setprecision(8) <<  ParticleNeutralino2.total_width << "   " << "# neutralino2 decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "PW" << setw(18) << "BR" << setw(8) << "NDA" << setw(12) << left << " PDG1" << setw(12) << " PDG2" << setw(12) << " PDG3 " << endl;
 for (int k=0; k<ParticleNeutralino2.No_of_Decays; k++) {
   if( ParticleNeutralino2.Array_Decays[k][2] != 0 && ParticleNeutralino2.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleNeutralino2.Array_Decays[k][2] << setprecision(8) << ParticleNeutralino2.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << " " << ParticleNeutralino2.Array_Decays[k][3] << setw(4) << " ";  printRowPDG(cout, ParticleNeutralino2.Array_Decays[k][0]); cout << "    "; printRowPDG(cout,ParticleNeutralino2.Array_Decays[k][1]); cout << "    "; printRowPDG(cout,ParticleNeutralino2.Array_Decays[k][4]); cout << "   " << left << setprecision(0) << setw(15) << ParticleNeutralino2.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl; 


///Neutralino3 Decays
 
 double neutralino3amplitudeuLubar, neutralino3amplitudeuRubar, neutralino3amplitudeuLbaru, neutralino3amplitudeuRbaru, neutralino3amplitudedLdbar, neutralino3amplitudedRdbar, neutralino3amplitudedLbard, neutralino3amplitudedRbard, neutralino3amplitudecLcbar, neutralino3amplitudecRcbar, neutralino3amplitudecLbarc, neutralino3amplitudecRbarc, neutralino3amplitudesLsbar, neutralino3amplitudesRsbar, neutralino3amplitudesLbars, neutralino3amplitudesRbars, neutralino3amplitudeeLebar, neutralino3amplitudeeRebar, neutralino3amplitudeeLbare, neutralino3amplitudeeRbare, neutralino3amplitudemuLmubar, neutralino3amplitudemuRmubar, neutralino3amplitudemuLbarmu, neutralino3amplitudemuRbarmu, neutralino3amplitudesnuenuebar, neutralino3amplitudesnuebarnue, neutralino3amplitudesnumunumubar, neutralino3amplitudesnumubarnumu, neutralino3amplitudetopstop1bar, neutralino3amplitudetopstop2bar, neutralino3amplitudetopbarstop1, neutralino3amplitudetopbarstop2, neutralino3amplitudebottomsbottom1bar, neutralino3amplitudebottomsbottom2bar, neutralino3amplitudebottombarsbottom1, neutralino3amplitudebottombarsbottom2, neutralino3amplitudetaustau1bar, neutralino3amplitudetaustau2bar, neutralino3amplitudetaubarstau1, neutralino3amplitudetaubarstau2, neutralino3amplitudenutausnutaubar, neutralino3amplitudenutaubarsnutau, neutralino3amplitudeWbosonpluscharginoW1, neutralino3amplitudeWbosonpluscharginoW2, neutralino3amplitudeWbosonminuscharginoW1, neutralino3amplitudeWbosonminuscharginoW2, neutralino3amplitudeHpluscharginoW1, neutralino3amplitudeHpluscharginoW2, neutralino3amplitudeHminuscharginoW1, neutralino3amplitudeHminuscharginoW2, neutralino3amplitudeZbosonneutralino1, neutralino3amplitudeZbosonneutralino2, neutralino3amplitudeZbosonneutralino4, neutralino3amplitudehneutralino1, neutralino3amplitudehneutralino2, neutralino3amplitudehneutralino4, neutralino3amplitudeHneutralino1, neutralino3amplitudeHneutralino2, neutralino3amplitudeHneutralino4, neutralino3amplitudeAneutralino1, neutralino3amplitudeAneutralino2, neutralino3amplitudeAneutralino4, neutralino3amplitudephotongravitino, neutralino3amplitudeZgravitino, neutralino3amplitudehgravitino, neutralino3amplitudeHgravitino, neutralino3amplitudeAgravitino;

 double neutralino3amplitudeneut1uubar, neutralino3amplitudeneut1ddbar, neutralino3amplitudeneut1ccbar, neutralino3amplitudeneut1ssbar, neutralino3amplitudeneut1ttbar, neutralino3amplitudeneut1bbbar, neutralino3amplitudeneut1eebar, neutralino3amplitudeneut1mumubar, neutralino3amplitudeneut1tautaubar, neutralino3amplitudeneut1nuenuebar, neutralino3amplitudeneut1numunumubar, neutralino3amplitudeneut1nutaunutaubar, neutralino3amplitudeneut2uubar, neutralino3amplitudeneut2ddbar, neutralino3amplitudeneut2ccbar, neutralino3amplitudeneut2ssbar, neutralino3amplitudeneut2ttbar, neutralino3amplitudeneut2bbbar, neutralino3amplitudeneut2eebar, neutralino3amplitudeneut2mumubar, neutralino3amplitudeneut2tautaubar, neutralino3amplitudeneut2nuenuebar, neutralino3amplitudeneut2numunumubar, neutralino3amplitudeneut2nutaunutaubar, neutralino3amplitudechargino1udbar, neutralino3amplitudechargino1csbar, neutralino3amplitudechargino1enuebar, neutralino3amplitudechargino1munumubar, neutralino3amplitudechargino1taunutaubar, neutralino3amplitudechargino2udbar, neutralino3amplitudechargino2csbar, neutralino3amplitudechargino2enuebar, neutralino3amplitudechargino2munumubar, neutralino3amplitudechargino2taunutaubar;
 
 neutralino3amplitudeuLubar = neutralinoamplitudedecayquarksquarkLorR (mneut(3), MUP, mu(1,1), g, gp, mixNeut, 1, 'L', 3);
 neutralino3amplitudeuRubar = neutralinoamplitudedecayquarksquarkLorR (mneut(3), MUP, mu(2,1), g, gp, mixNeut, 1, 'R', 3);
 neutralino3amplitudeuLbaru = neutralinoamplitudedecayquarksquarkLorR (mneut(3), MUP, mu(1,1), g, gp, mixNeut, 1, 'L', 3); 
 neutralino3amplitudeuRbaru = neutralinoamplitudedecayquarksquarkLorR (mneut(3), MUP, mu(2,1), g, gp, mixNeut, 1, 'R', 3);
 neutralino3amplitudedLdbar = neutralinoamplitudedecayquarksquarkLorR (mneut(3), MDOWN, md(1,1), g, gp, mixNeut, 2, 'L', 3);
 neutralino3amplitudedRdbar = neutralinoamplitudedecayquarksquarkLorR (mneut(3), MDOWN, md(2,1), g, gp, mixNeut, 2, 'R', 3);
 neutralino3amplitudedLbard = neutralinoamplitudedecayquarksquarkLorR (mneut(3), MDOWN, md(1,1), g, gp, mixNeut, 2, 'L', 3);
 neutralino3amplitudedRbard = neutralinoamplitudedecayquarksquarkLorR (mneut(3), MDOWN, md(2,1), g, gp, mixNeut, 2, 'R', 3);
 neutralino3amplitudecLcbar = neutralinoamplitudedecayquarksquarkLorR (mneut(3), MCHARM, mu(1,2), g, gp, mixNeut, 1, 'L', 3);
 neutralino3amplitudecRcbar = neutralinoamplitudedecayquarksquarkLorR (mneut(3), MCHARM, mu(2,2), g, gp, mixNeut, 1, 'R', 3);
 neutralino3amplitudecLbarc = neutralinoamplitudedecayquarksquarkLorR (mneut(3), MCHARM, mu(1,2), g, gp, mixNeut, 1, 'L', 3);
 neutralino3amplitudecRbarc = neutralinoamplitudedecayquarksquarkLorR (mneut(3), MCHARM, mu(2,2), g, gp, mixNeut, 1, 'R', 3);
 neutralino3amplitudesLsbar = neutralinoamplitudedecayquarksquarkLorR (mneut(3), MSTRANGE, md(1,2), g, gp, mixNeut, 2, 'L', 3);
 neutralino3amplitudesRsbar = neutralinoamplitudedecayquarksquarkLorR (mneut(3), MSTRANGE, md(2,2), g, gp, mixNeut, 2, 'R', 3);
 neutralino3amplitudesLbars = neutralinoamplitudedecayquarksquarkLorR (mneut(3), MSTRANGE, md(1,2), g, gp, mixNeut, 2, 'L', 3);
 neutralino3amplitudesRbars = neutralinoamplitudedecayquarksquarkLorR (mneut(3), MSTRANGE, md(2,2), g, gp, mixNeut, 2, 'R', 3);
 neutralino3amplitudeeLebar = neutralinoamplitudedecayleptonsleptonLorR (mneut(3), MELECTRON, me(1,1), g, gp, mixNeut, 'L', 3);
 neutralino3amplitudeeRebar = neutralinoamplitudedecayleptonsleptonLorR (mneut(3), MELECTRON, me(2,1), g, gp, mixNeut, 'R', 3);
 neutralino3amplitudeeLbare = neutralinoamplitudedecayleptonsleptonLorR (mneut(3), MELECTRON, me(1,1), g, gp, mixNeut, 'L', 3);
 neutralino3amplitudeeRbare = neutralinoamplitudedecayleptonsleptonLorR (mneut(3), MELECTRON, me(2,1), g, gp, mixNeut, 'R', 3);
 neutralino3amplitudemuLmubar = neutralinoamplitudedecayleptonsleptonLorR (mneut(3), MMUON, me(1,2), g, gp, mixNeut, 'L', 3);
 neutralino3amplitudemuRmubar = neutralinoamplitudedecayleptonsleptonLorR (mneut(3), MMUON, me(2,2), g, gp, mixNeut, 'R', 3);
 neutralino3amplitudemuLbarmu = neutralinoamplitudedecayleptonsleptonLorR (mneut(3), MMUON, me(1,2), g, gp, mixNeut, 'L', 3);
 neutralino3amplitudemuRbarmu = neutralinoamplitudedecayleptonsleptonLorR (mneut(3), MMUON, me(2,2), g, gp, mixNeut, 'R', 3);
 neutralino3amplitudesnuenuebar = neutralinoamplitudedecayneutrinosneutrinoL (mneut(3), 0, msnu(1), g, gp, mixNeut, 3);
 neutralino3amplitudesnuebarnue = neutralinoamplitudedecayneutrinosneutrinoL (mneut(3), 0, msnu(1), g, gp, mixNeut, 3);
 neutralino3amplitudesnumunumubar = neutralinoamplitudedecayneutrinosneutrinoL (mneut(3), 0, msnu(2), g, gp, mixNeut, 3);
 neutralino3amplitudesnumubarnumu = neutralinoamplitudedecayneutrinosneutrinoL (mneut(3), 0, msnu(2), g, gp, mixNeut, 3);
 neutralino3amplitudetopstop1bar = neutralinoamplitudedecaysquark3quarkmix (mneut(3), MTOP, mu(1,3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 1, 3);
 neutralino3amplitudetopstop2bar = neutralinoamplitudedecaysquark3quarkmix (mneut(3), MTOP, mu(2,3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 2, 3);
 neutralino3amplitudetopbarstop1 = neutralinoamplitudedecaysquark3quarkmix (mneut(3), MTOP, mu(1,3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 1, 3);
 neutralino3amplitudetopbarstop2 = neutralinoamplitudedecaysquark3quarkmix (mneut(3), MTOP, mu(2,3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 2, 3);
 neutralino3amplitudebottomsbottom1bar = neutralinoamplitudedecaysquark3quarkmix (mneut(3), MBOTTOM, md(1,3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 1, 3);
 neutralino3amplitudebottomsbottom2bar = neutralinoamplitudedecaysquark3quarkmix (mneut(3), MBOTTOM, md(2,3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 2, 3);
 neutralino3amplitudebottombarsbottom1 = neutralinoamplitudedecaysquark3quarkmix (mneut(3), MBOTTOM, md(1,3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 1, 3);
 neutralino3amplitudebottombarsbottom2 = neutralinoamplitudedecaysquark3quarkmix (mneut(3), MBOTTOM, md(2,3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 2, 3);
 neutralino3amplitudetaustau1bar = neutralinoamplitudedecaystautau (mneut(3), MTAU, me(1,3), runmw, thetatau, beta, mixNeut, g, gp, 1, 3);
 neutralino3amplitudetaustau2bar = neutralinoamplitudedecaystautau (mneut(3), MTAU, me(2,3), runmw, thetatau, beta, mixNeut, g, gp, 2, 3);
 neutralino3amplitudetaubarstau1 = neutralinoamplitudedecaystautau (mneut(3), MTAU, me(1,3), runmw, thetatau, beta, mixNeut, g, gp, 1, 3);
 neutralino3amplitudetaubarstau2 = neutralinoamplitudedecaystautau (mneut(3), MTAU, me(2,3), runmw, thetatau, beta, mixNeut, g, gp, 2, 3);
 neutralino3amplitudenutausnutaubar = neutralinoamplitudedecayneutrinosneutrinoL (mneut(3), 0, msnu(3), g, gp, mixNeut, 3);
 neutralino3amplitudenutaubarsnutau = neutralinoamplitudedecayneutrinosneutrinoL (mneut(3), 0, msnu(3), g, gp, mixNeut, 3);
 neutralino3amplitudeWbosonpluscharginoW1 = neutralinoamplitudedecaycharginoWboson (mneut(3), polemw, MCH1, g, thetaL2, thetaR2, mixNeut, 3, 1);
 neutralino3amplitudeWbosonpluscharginoW2 = neutralinoamplitudedecaycharginoWboson (mneut(3), polemw, MCH2, g, thetaL2, thetaR2, mixNeut, 3, 2);
 neutralino3amplitudeWbosonminuscharginoW1 = neutralinoamplitudedecaycharginoWboson (mneut(3), polemw, MCH1, g, thetaL2, thetaR2, mixNeut, 3, 1);
 neutralino3amplitudeWbosonminuscharginoW2 = neutralinoamplitudedecaycharginoWboson (mneut(3), polemw, MCH2, g, thetaL2, thetaR2, mixNeut, 3, 2);
 neutralino3amplitudeHpluscharginoW1 = neutralinoamplitudedecaycharginoHplus (mneut(3), mHpm, MCH1, g, gp, beta, thetaL2, thetaR2, mixNeut, 3, 1);
 neutralino3amplitudeHpluscharginoW2 = neutralinoamplitudedecaycharginoHplus (mneut(3), mHpm, MCH2, g, gp, beta, thetaL2, thetaR2, mixNeut, 3, 2);
 neutralino3amplitudeHminuscharginoW1 = neutralinoamplitudedecaycharginoHplus (mneut(3), mHpm, MCH1, g, gp, beta, thetaL2, thetaR2, mixNeut, 3, 1);
 neutralino3amplitudeHminuscharginoW2 = neutralinoamplitudedecaycharginoHplus (mneut(3), mHpm, MCH2, g, gp, beta, thetaL2, thetaR2, mixNeut, 3, 2);
 neutralino3amplitudeZbosonneutralino1 = neutralinoamplitudedecayneutralinoZboson (mneut(3), mz, mneut(1), g, gp, mixNeut, 3, 1);
 neutralino3amplitudeZbosonneutralino2 = neutralinoamplitudedecayneutralinoZboson (mneut(3), mz, mneut(2), g, gp, mixNeut, 3, 2);
 neutralino3amplitudeZbosonneutralino4 = neutralinoamplitudedecayneutralinoZboson (mneut(3), mz, mneut(4), g, gp, mixNeut, 3, 4);
 neutralino3amplitudehneutralino1 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(3), mh0(1), mneut(1), g, gp, mixNeut, alpha, 3, 1, 'h');
 neutralino3amplitudehneutralino2 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(3), mh0(1), mneut(2), g, gp, mixNeut, alpha, 3, 2, 'h');
 neutralino3amplitudehneutralino4 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(3), mh0(1), mneut(4), g, gp, mixNeut, alpha, 3, 4, 'h');
 neutralino3amplitudeHneutralino1 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(3), mh0(2), mneut(1), g, gp, mixNeut, alpha, 3, 1, 'H');
 neutralino3amplitudeHneutralino2 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(3), mh0(2), mneut(2), g, gp, mixNeut, alpha, 3, 2, 'H');
 neutralino3amplitudeHneutralino4 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(3), mh0(2), mneut(4), g, gp, mixNeut, alpha, 3, 4, 'H');
 neutralino3amplitudeAneutralino1 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(3), mA0(1), mneut(1), g, gp, mixNeut, beta, 3, 1, 'A');
 neutralino3amplitudeAneutralino2 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(3), mA0(1), mneut(2), g, gp, mixNeut, beta, 3, 2, 'A');
 neutralino3amplitudeAneutralino4 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(3), mA0(1), mneut(4), g, gp, mixNeut, beta, 3, 4, 'A');

 neutralino3amplitudephotongravitino = neutralinoamplitudedecayphotongravitino(mneut(3), mgravitino, MPlreduced, mixNeut, g, gp, 3, gravonoff, neutNLSP);
 neutralino3amplitudeZgravitino = neutralinoamplitudedecayZgravitino(mneut(3), mz, mgravitino, MPlreduced, mixNeut, g, gp, beta, 3, gravonoff, neutNLSP);
 neutralino3amplitudehgravitino = neutralinoamplitudedecayphigravitino(mneut(3), mh0(1), mgravitino, MPlreduced, mixNeut, alpha, beta, 3, gravonoff, 'h', neutNLSP);
 neutralino3amplitudeHgravitino = neutralinoamplitudedecayphigravitino(mneut(3), mh0(2), mgravitino, MPlreduced, mixNeut, alpha, beta, 3, gravonoff, 'H', neutNLSP);
 neutralino3amplitudeAgravitino = neutralinoamplitudedecayphigravitino(mneut(3), mA0(1), mgravitino, MPlreduced, mixNeut, alpha, beta, 3, gravonoff, 'A', neutNLSP);

 


 neutralino3amplitudeneut1uubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), mu(1,1), mu(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(1), MUP, alphas, 0, runmw, g, gp, alpha, beta, MUP, mixNeut, 3, 1, onetothree, 'u');
 neutralino3amplitudeneut1ddbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), md(1,1), md(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(1), MDOWN, alphas, 0, runmw, g, gp, alpha, beta, MDOWN, mixNeut, 3, 1, onetothree, 'd');
 neutralino3amplitudeneut1ccbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), mu(1,2), mu(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(1), MCHARM, alphas, 0, runmw, g, gp, alpha, beta, MCHARM, mixNeut, 3, 1, onetothree, 'u');
 neutralino3amplitudeneut1ssbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), md(1,2), md(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(1), MSTRANGE, alphas, 0, runmw, g, gp, alpha, beta, MSTRANGE, mixNeut, 3, 1, onetothree, 'd');
 neutralino3amplitudeneut1ttbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), mu(1,3), mu(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(1), MTOP, alphas, thetat, runmw, g, gp, alpha, beta, runmt, mixNeut, 3, 1, onetothree, 'u');
 neutralino3amplitudeneut1bbbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), md(1,3), md(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(1), MBOTTOM, alphas, thetab, runmw, g, gp, alpha, beta, runmb, mixNeut, 3, 1, onetothree, 'd');
 neutralino3amplitudeneut1eebar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), me(1,1), me(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(1), MELECTRON, alphas, 0, runmw, g, gp, alpha, beta, MELECTRON, mixNeut, 3, 1, onetothree, 'l');
 neutralino3amplitudeneut1mumubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), me(1,2), me(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(1), MMUON, alphas, 0, runmw, g, gp, alpha, beta, MMUON, mixNeut, 3, 1, onetothree, 'l');
 neutralino3amplitudeneut1tautaubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), me(1,3), me(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(1), MTAU, alphas, thetatau-PI/2, runmw, g, gp, alpha, beta, runmtau, mixNeut, 3, 1, onetothree, 'l');
 neutralino3amplitudeneut1nuenuebar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), msnu(1), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(1), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 3, 1, onetothree, 'n');
 neutralino3amplitudeneut1numunumubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), msnu(2), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(1), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 3, 1, onetothree, 'n');
 neutralino3amplitudeneut1nutaunutaubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), msnu(3), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(1), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 3, 1, onetothree, 'n');
 neutralino3amplitudeneut2uubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), mu(1,1), mu(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(2), MUP, alphas, 0, runmw, g, gp, alpha, beta, MUP, mixNeut, 3, 2, onetothree, 'u');
 neutralino3amplitudeneut2ddbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), md(1,1), md(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(2), MDOWN, alphas, 0, runmw, g, gp, alpha, beta, MDOWN, mixNeut, 3, 2, onetothree, 'd');
 neutralino3amplitudeneut2ccbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), mu(1,2), mu(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(2), MCHARM, alphas, 0, runmw, g, gp, alpha, beta, MCHARM, mixNeut, 3, 2, onetothree, 'u');
 neutralino3amplitudeneut2ssbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), md(1,2), md(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(2), MSTRANGE, alphas, 0, runmw, g, gp, alpha, beta, MSTRANGE, mixNeut, 3, 2, onetothree, 'd');
 neutralino3amplitudeneut2ttbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), mu(1,3), mu(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(2), MTOP, alphas, thetat, runmw, g, gp, alpha, beta, runmt, mixNeut, 3, 2, onetothree, 'u');
 neutralino3amplitudeneut2bbbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), md(1,3), md(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(2), MBOTTOM, alphas, thetab, runmw, g, gp, alpha, beta, runmb, mixNeut, 3, 2, onetothree, 'd');
 neutralino3amplitudeneut2eebar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), me(1,1), me(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(2), MELECTRON, alphas, 0, runmw, g, gp, alpha, beta, MELECTRON, mixNeut, 3, 2, onetothree, 'l');
 neutralino3amplitudeneut2mumubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), me(1,2), me(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(2), MMUON, alphas, 0, runmw, g, gp, alpha, beta, MMUON, mixNeut, 3, 2, onetothree, 'l');
 neutralino3amplitudeneut2tautaubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), me(1,3), me(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(2), MTAU, alphas, thetatau-PI/2, runmw, g, gp, alpha, beta, runmtau, mixNeut, 3, 2, onetothree, 'l');
 neutralino3amplitudeneut2nuenuebar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), msnu(1), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(2), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 3, 2, onetothree, 'n');
 neutralino3amplitudeneut2numunumubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), msnu(2), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(2), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 3, 2, onetothree, 'n');
 neutralino3amplitudeneut2nutaunutaubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(3), msnu(3), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(2), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 3, 2, onetothree, 'n');
 
 neutralino3amplitudechargino1udbar = neutralinoamplitudedecaycharginoffprimebar (mneut(3), mu(1,1), mu(2,1), md(1,1), md(2,1), polemw, mHpm, mch(1), MUP, MDOWN, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, runmu, runmd, mixNeut, 3, 1, onetothree, 'q', 'n');
 neutralino3amplitudechargino1csbar = neutralinoamplitudedecaycharginoffprimebar (mneut(3), mu(1,2), mu(2,2), md(1,2), md(2,2), polemw, mHpm, mch(1), MCHARM, MSTRANGE, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, runmc, runms, mixNeut, 3, 1, onetothree, 'q', 'n');
 neutralino3amplitudechargino1enuebar = neutralinoamplitudedecaycharginoffprimebar (mneut(3), me(1,1), me(2,1), msnu(1), 100000000000, polemw, mHpm, mch(1), 0, MELECTRON, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, 0, MELECTRON, mixNeut, 3, 1, onetothree, 'l', 'n');
 neutralino3amplitudechargino1munumubar = neutralinoamplitudedecaycharginoffprimebar (mneut(3), me(1,2), me(2,2), msnu(2), 100000000000, polemw, mHpm, mch(1), 0, MMUON, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, 0, MMUON, mixNeut, 3, 1, onetothree, 'l', 'n');
 neutralino3amplitudechargino1taunutaubar = neutralinoamplitudedecaycharginoffprimebar (mneut(3), me(1,3), me(2,3), msnu(3), 100000000000, polemw, mHpm, mch(1), 0, MTAU, 0, thetatau, g, gp, alphas, beta, thetaL2, thetaR2, 0, runmtau, mixNeut, 3, 1, onetothree, 'l', 'n');
 neutralino3amplitudechargino2udbar = neutralinoamplitudedecaycharginoffprimebar (mneut(3), mu(1,1), mu(2,1), md(1,1), md(2,1), polemw, mHpm, mch(2), MUP, MDOWN, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, runmu, runmd, mixNeut, 3, 2, onetothree, 'q', 'n');
 neutralino3amplitudechargino2csbar = neutralinoamplitudedecaycharginoffprimebar (mneut(3), mu(1,2), mu(2,2), md(1,2), md(2,2), polemw, mHpm, mch(2), MCHARM, MSTRANGE, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, runmc, runms, mixNeut, 3, 2, onetothree, 'q', 'n');
 neutralino3amplitudechargino2enuebar = neutralinoamplitudedecaycharginoffprimebar (mneut(3), me(1,1), me(2,1), msnu(1), 100000000000, polemw, mHpm, mch(2), 0, MELECTRON, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, 0, MELECTRON, mixNeut, 3, 2, onetothree, 'l', 'n');
 neutralino3amplitudechargino2munumubar = neutralinoamplitudedecaycharginoffprimebar (mneut(3), me(1,2), me(2,2), msnu(2), 100000000000, polemw, mHpm, mch(2), 0, MMUON, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, 0, MMUON, mixNeut, 3, 2, onetothree, 'l', 'n');
 neutralino3amplitudechargino2taunutaubar = neutralinoamplitudedecaycharginoffprimebar (mneut(3), me(1,3), me(2,3), msnu(3), 100000000000, polemw, mHpm, mch(2), 0, MTAU, 0, thetatau, g, gp, alphas, beta, thetaL2, thetaR2, 0, runmtau, mixNeut, 3, 2, onetothree, 'l', 'n');
 
   ParticleNeutralino3.Array_Decays[0][0] = -PDGup; ParticleNeutralino3.Array_Decays[0][1] = PDGsupL; ParticleNeutralino3.Array_Decays[0][2] = neutralino3amplitudeuLubar; ParticleNeutralino3.Array_Decays[0][3] = 2; ParticleNeutralino3.Array_Comments[0] = "# ~chi_30 -> ub ~u_L";
   ParticleNeutralino3.Array_Decays[1][0] = -PDGup; ParticleNeutralino3.Array_Decays[1][1] = PDGsupR; ParticleNeutralino3.Array_Decays[1][2] = neutralino3amplitudeuRubar; ParticleNeutralino3.Array_Decays[1][3] = 2; ParticleNeutralino3.Array_Comments[1] = "# ~chi_30 -> ub ~u_R";
   ParticleNeutralino3.Array_Decays[2][0] = PDGup; ParticleNeutralino3.Array_Decays[2][1] = -PDGsupL; ParticleNeutralino3.Array_Decays[2][2] = neutralino3amplitudeuLbaru; ParticleNeutralino3.Array_Decays[2][3] = 2; ParticleNeutralino3.Array_Comments[2] = "# ~chi_30 -> u ~u_L*";
   ParticleNeutralino3.Array_Decays[3][0] = PDGup; ParticleNeutralino3.Array_Decays[3][1] = -PDGsupR; ParticleNeutralino3.Array_Decays[3][2] = neutralino3amplitudeuRbaru; ParticleNeutralino3.Array_Decays[3][3] = 2; ParticleNeutralino3.Array_Comments[3] = "# ~chi_30 -> u ~u_R*";
   ParticleNeutralino3.Array_Decays[4][0] = -PDGdown; ParticleNeutralino3.Array_Decays[4][1] = PDGsdownL; ParticleNeutralino3.Array_Decays[4][2] = neutralino3amplitudedLdbar; ParticleNeutralino3.Array_Decays[4][3] = 2; ParticleNeutralino3.Array_Comments[4] = "# ~chi_30 -> db ~d_L";
   ParticleNeutralino3.Array_Decays[5][0] = -PDGdown; ParticleNeutralino3.Array_Decays[5][1] = PDGsdownR; ParticleNeutralino3.Array_Decays[5][2] = neutralino3amplitudedRdbar; ParticleNeutralino3.Array_Decays[5][3] = 2; ParticleNeutralino3.Array_Comments[5] = "# ~chi_30 -> db ~d_R";
   ParticleNeutralino3.Array_Decays[6][0] = PDGdown; ParticleNeutralino3.Array_Decays[6][1] = -PDGsdownL; ParticleNeutralino3.Array_Decays[6][2] = neutralino3amplitudedLbard; ParticleNeutralino3.Array_Decays[6][3] = 2; ParticleNeutralino3.Array_Comments[6] = "# ~chi_30 -> d ~d_L*";
   ParticleNeutralino3.Array_Decays[7][0] = PDGdown; ParticleNeutralino3.Array_Decays[7][1] = -PDGsdownR; ParticleNeutralino3.Array_Decays[7][2] = neutralino3amplitudedRbard; ParticleNeutralino3.Array_Decays[7][3] = 2; ParticleNeutralino3.Array_Comments[7] = "# ~chi_30 -> d ~d_R*";
   ParticleNeutralino3.Array_Decays[8][0] = -PDGcharm; ParticleNeutralino3.Array_Decays[8][1] = PDGscharmL; ParticleNeutralino3.Array_Decays[8][2] = neutralino3amplitudecLcbar; ParticleNeutralino3.Array_Decays[8][3] = 2; ParticleNeutralino3.Array_Comments[8] = "# ~chi_30 -> cb ~c_L";
   ParticleNeutralino3.Array_Decays[9][0] = -PDGcharm; ParticleNeutralino3.Array_Decays[9][1] = PDGscharmR; ParticleNeutralino3.Array_Decays[9][2] = neutralino3amplitudecRcbar; ParticleNeutralino3.Array_Decays[9][3] = 2; ParticleNeutralino3.Array_Comments[9] = "# ~chi_30 -> cb ~c_R";
   ParticleNeutralino3.Array_Decays[10][0] = PDGcharm; ParticleNeutralino3.Array_Decays[10][1] = -PDGscharmL; ParticleNeutralino3.Array_Decays[10][2] = neutralino3amplitudecLbarc; ParticleNeutralino3.Array_Decays[10][3] = 2; ParticleNeutralino3.Array_Comments[10] = "# ~chi_30 -> c ~c_L*"; 
   ParticleNeutralino3.Array_Decays[11][0] = PDGcharm; ParticleNeutralino3.Array_Decays[11][1] = -PDGscharmR; ParticleNeutralino3.Array_Decays[11][2] = neutralino3amplitudecRbarc; ParticleNeutralino3.Array_Decays[11][3] = 2; ParticleNeutralino3.Array_Comments[11] = "# ~chi_30 -> c ~c_R*";
   ParticleNeutralino3.Array_Decays[12][0] = -PDGstrange; ParticleNeutralino3.Array_Decays[12][1] = PDGsstrangeL; ParticleNeutralino3.Array_Decays[12][2] = neutralino3amplitudesLsbar; ParticleNeutralino3.Array_Decays[12][3] = 2; ParticleNeutralino3.Array_Comments[12] = "# ~chi_30 -> sb ~s_L";
   ParticleNeutralino3.Array_Decays[13][0] = -PDGstrange; ParticleNeutralino3.Array_Decays[13][1] = PDGsstrangeR; ParticleNeutralino3.Array_Decays[13][2] = neutralino3amplitudesRsbar; ParticleNeutralino3.Array_Decays[13][3] = 2; ParticleNeutralino3.Array_Comments[13] = "# ~chi_30 -> sb ~s_R";
   ParticleNeutralino3.Array_Decays[14][0] = PDGstrange; ParticleNeutralino3.Array_Decays[14][1] = -PDGsstrangeL; ParticleNeutralino3.Array_Decays[14][2] = neutralino3amplitudesLbars; ParticleNeutralino3.Array_Decays[14][3] = 2; ParticleNeutralino3.Array_Comments[14] = "# ~chi_30 -> s ~s_L*";
   ParticleNeutralino3.Array_Decays[15][0] = PDGstrange; ParticleNeutralino3.Array_Decays[15][1] = -PDGsstrangeR; ParticleNeutralino3.Array_Decays[15][2] = neutralino3amplitudesRbars; ParticleNeutralino3.Array_Decays[15][3] = 2; ParticleNeutralino3.Array_Comments[15] = "# ~chi_30 -> s ~s_R*";
   ParticleNeutralino3.Array_Decays[16][0] = -PDGelectron; ParticleNeutralino3.Array_Decays[16][1] = PDGselectronL; ParticleNeutralino3.Array_Decays[16][2] = neutralino3amplitudeeLebar; ParticleNeutralino3.Array_Decays[16][3] = 2; ParticleNeutralino3.Array_Comments[16] = "# ~chi_30 -> e+ ~e_L-";
   ParticleNeutralino3.Array_Decays[17][0] = -PDGelectron; ParticleNeutralino3.Array_Decays[17][1] = PDGselectronR; ParticleNeutralino3.Array_Decays[17][2] = neutralino3amplitudeeRebar; ParticleNeutralino3.Array_Decays[17][3] = 2; ParticleNeutralino3.Array_Comments[17] = "# ~chi_30 -> e+ ~e_R-";
   ParticleNeutralino3.Array_Decays[18][0] = PDGelectron; ParticleNeutralino3.Array_Decays[18][1] = -PDGselectronL; ParticleNeutralino3.Array_Decays[18][2] = neutralino3amplitudeeLbare; ParticleNeutralino3.Array_Decays[18][3] = 2; ParticleNeutralino3.Array_Comments[18] = "# ~chi_30 -> e- ~e_L+";
   ParticleNeutralino3.Array_Decays[19][0] = PDGelectron; ParticleNeutralino3.Array_Decays[19][1] = -PDGselectronR; ParticleNeutralino3.Array_Decays[19][2] = neutralino3amplitudeeRbare; ParticleNeutralino3.Array_Decays[19][3] = 2; ParticleNeutralino3.Array_Comments[19] = "# ~chi_30 -> e- ~e_R+";   
   ParticleNeutralino3.Array_Decays[20][0] = -PDGmuon; ParticleNeutralino3.Array_Decays[20][1] = PDGsmuonL; ParticleNeutralino3.Array_Decays[20][2] = neutralino3amplitudemuLmubar; ParticleNeutralino3.Array_Decays[20][3] = 2; ParticleNeutralino3.Array_Comments[20] = "# ~chi_30 -> mu+ ~mu_L-";
   ParticleNeutralino3.Array_Decays[21][0] = -PDGmuon; ParticleNeutralino3.Array_Decays[21][1] = PDGsmuonR; ParticleNeutralino3.Array_Decays[21][2] = neutralino3amplitudemuRmubar; ParticleNeutralino3.Array_Decays[21][3] = 2; ParticleNeutralino3.Array_Comments[21] = "# ~chi_30 -> mu+ ~mu_R-";
   ParticleNeutralino3.Array_Decays[22][0] = PDGmuon; ParticleNeutralino3.Array_Decays[22][1] = -PDGsmuonL; ParticleNeutralino3.Array_Decays[22][2] = neutralino3amplitudemuLbarmu; ParticleNeutralino3.Array_Decays[22][3] = 2; ParticleNeutralino3.Array_Comments[22] = "# ~chi_30 -> mu- ~mu_L+";
   ParticleNeutralino3.Array_Decays[23][0] = PDGmuon; ParticleNeutralino3.Array_Decays[23][1] = -PDGsmuonR; ParticleNeutralino3.Array_Decays[23][2] = neutralino3amplitudemuRbarmu; ParticleNeutralino3.Array_Decays[23][3] = 2; ParticleNeutralino3.Array_Comments[23] = "# ~chi_30 -> mu- ~mu_R+";
   ParticleNeutralino3.Array_Decays[24][0] = PDGnuelectron; ParticleNeutralino3.Array_Decays[24][1] = -PDGnuselectronL; ParticleNeutralino3.Array_Decays[24][2] = neutralino3amplitudesnuebarnue; ParticleNeutralino3.Array_Decays[24][3] = 2; ParticleNeutralino3.Array_Comments[24] = "# ~chi_30 -> nu_e ~nu_eL*";
   ParticleNeutralino3.Array_Decays[25][0] = -PDGnuelectron; ParticleNeutralino3.Array_Decays[25][1] = PDGnuselectronL; ParticleNeutralino3.Array_Decays[25][2] = neutralino3amplitudesnuenuebar; ParticleNeutralino3.Array_Decays[25][3] = 2; ParticleNeutralino3.Array_Comments[25] = "# ~chi_30 -> nu_eb ~nu_eL";
   ParticleNeutralino3.Array_Decays[26][0] = PDGnumuon; ParticleNeutralino3.Array_Decays[26][1] = -PDGnusmuonL; ParticleNeutralino3.Array_Decays[26][2] = neutralino3amplitudesnumubarnumu; ParticleNeutralino3.Array_Decays[26][3] = 2; ParticleNeutralino3.Array_Comments[26] = "# ~chi_30 -> nu_mu ~nu_muL*";
   ParticleNeutralino3.Array_Decays[27][0] = -PDGnumuon; ParticleNeutralino3.Array_Decays[27][1] = PDGnusmuonL; ParticleNeutralino3.Array_Decays[27][2] = neutralino3amplitudesnumunumubar; ParticleNeutralino3.Array_Decays[27][3] = 2; ParticleNeutralino3.Array_Comments[27] = "# ~chi_30 -> nu_mub ~nu_muL";
   ParticleNeutralino3.Array_Decays[28][0] = PDGtop; ParticleNeutralino3.Array_Decays[28][1] = -PDGstop1; ParticleNeutralino3.Array_Decays[28][2] = neutralino3amplitudetopstop1bar; ParticleNeutralino3.Array_Decays[28][3] = 2; ParticleNeutralino3.Array_Comments[28] = "# ~chi_30 -> t ~t_1*";
   ParticleNeutralino3.Array_Decays[29][0] = PDGtop; ParticleNeutralino3.Array_Decays[29][1] = -PDGstop2; ParticleNeutralino3.Array_Decays[29][2] = neutralino3amplitudetopstop2bar; ParticleNeutralino3.Array_Decays[29][3] = 2; ParticleNeutralino3.Array_Comments[29] = "# ~chi_30 -> t ~t_2*";
   ParticleNeutralino3.Array_Decays[30][0] = -PDGtop; ParticleNeutralino3.Array_Decays[30][1] = PDGstop1; ParticleNeutralino3.Array_Decays[30][2] = neutralino3amplitudetopbarstop1; ParticleNeutralino3.Array_Decays[30][3] = 2; ParticleNeutralino3.Array_Comments[30] = "# ~chi_30 -> tb ~t_1";
   ParticleNeutralino3.Array_Decays[31][0] = -PDGtop; ParticleNeutralino3.Array_Decays[31][1] = PDGstop2; ParticleNeutralino3.Array_Decays[31][2] = neutralino3amplitudetopbarstop2; ParticleNeutralino3.Array_Decays[31][3] = 2; ParticleNeutralino3.Array_Comments[31] = "# ~chi_30 -> tb ~t_2";
   ParticleNeutralino3.Array_Decays[32][0] = PDGbottom; ParticleNeutralino3.Array_Decays[32][1] = -PDGsbottom1; ParticleNeutralino3.Array_Decays[32][2] = neutralino3amplitudebottomsbottom1bar; ParticleNeutralino3.Array_Decays[32][3] = 2; ParticleNeutralino3.Array_Comments[32] = "# ~chi_30 -> b ~b_1*";
   ParticleNeutralino3.Array_Decays[33][0] = PDGbottom; ParticleNeutralino3.Array_Decays[33][1] = -PDGsbottom2; ParticleNeutralino3.Array_Decays[33][2] = neutralino3amplitudebottomsbottom2bar; ParticleNeutralino3.Array_Decays[33][3] = 2; ParticleNeutralino3.Array_Comments[33] = "# ~chi_30 -> b ~b_2*";
   ParticleNeutralino3.Array_Decays[34][0] = -PDGbottom; ParticleNeutralino3.Array_Decays[34][1] = PDGsbottom1; ParticleNeutralino3.Array_Decays[34][2] = neutralino3amplitudebottombarsbottom1; ParticleNeutralino3.Array_Decays[34][3] = 2; ParticleNeutralino3.Array_Comments[34] = "# ~chi_30 -> bb ~b_1";
   ParticleNeutralino3.Array_Decays[35][0] = -PDGbottom; ParticleNeutralino3.Array_Decays[35][1] = PDGsbottom2; ParticleNeutralino3.Array_Decays[35][2] = neutralino3amplitudebottombarsbottom2; ParticleNeutralino3.Array_Decays[35][3] = 2; ParticleNeutralino3.Array_Comments[35] = "# ~chi_30 -> bb ~b_2";
    ParticleNeutralino3.Array_Decays[36][0] = -PDGstau1; ParticleNeutralino3.Array_Decays[36][1] = PDGtau; ParticleNeutralino3.Array_Decays[36][2] = neutralino3amplitudetaustau1bar; ParticleNeutralino3.Array_Decays[36][3] = 2; ParticleNeutralino3.Array_Comments[36] = "# ~chi_30 -> tau- ~tau_1+";
   ParticleNeutralino3.Array_Decays[37][0] = -PDGstau2; ParticleNeutralino3.Array_Decays[37][1] = PDGtau; ParticleNeutralino3.Array_Decays[37][2] = neutralino3amplitudetaustau2bar; ParticleNeutralino3.Array_Decays[37][3] = 2; ParticleNeutralino3.Array_Comments[37] = "# ~chi_30 -> tau- ~tau_2+";
   ParticleNeutralino3.Array_Decays[38][0] = PDGstau1; ParticleNeutralino3.Array_Decays[38][1] = -PDGtau; ParticleNeutralino3.Array_Decays[38][2] = neutralino3amplitudetaubarstau1; ParticleNeutralino3.Array_Decays[38][3] = 2; ParticleNeutralino3.Array_Comments[38] = "# ~chi_30 -> tau+ ~tau_1-";
   ParticleNeutralino3.Array_Decays[39][0] = PDGstau2; ParticleNeutralino3.Array_Decays[39][1] = -PDGtau; ParticleNeutralino3.Array_Decays[39][2] = neutralino3amplitudetaubarstau2; ParticleNeutralino3.Array_Decays[39][3] = 2; ParticleNeutralino3.Array_Comments[39] = "# ~chi_30 -> tau+ ~tau_2-"; 
    ParticleNeutralino3.Array_Decays[40][0] = PDGnutau; ParticleNeutralino3.Array_Decays[40][1] = -PDGnustauL; ParticleNeutralino3.Array_Decays[40][2] = neutralino3amplitudenutausnutaubar; ParticleNeutralino3.Array_Decays[40][3] = 2; ParticleNeutralino3.Array_Comments[40] = "# ~chi_30 -> nu_tau ~nu_tauL*";
   ParticleNeutralino3.Array_Decays[41][0] = -PDGnutau; ParticleNeutralino3.Array_Decays[41][1] = PDGnustauL; ParticleNeutralino3.Array_Decays[41][2] = neutralino3amplitudenutaubarsnutau; ParticleNeutralino3.Array_Decays[41][3] = 2; ParticleNeutralino3.Array_Comments[41] = "# ~chi_30 -> nu_taub ~nu_tauL";
   ParticleNeutralino3.Array_Decays[42][0] = PDGWplus; ParticleNeutralino3.Array_Decays[42][1] = -PDGchargino1; ParticleNeutralino3.Array_Decays[42][2] = neutralino3amplitudeWbosonpluscharginoW1; ParticleNeutralino3.Array_Decays[42][3] = 2; ParticleNeutralino3.Array_Comments[42] = "# ~chi_30 -> W+ ~chi_1-";
   ParticleNeutralino3.Array_Decays[43][0] = PDGWplus; ParticleNeutralino3.Array_Decays[43][1] = -PDGchargino2; ParticleNeutralino3.Array_Decays[43][2] = neutralino3amplitudeWbosonpluscharginoW2; ParticleNeutralino3.Array_Decays[43][3] = 2; ParticleNeutralino3.Array_Comments[43] = "# ~chi_30 -> W+ ~chi_2-*";
   ParticleNeutralino3.Array_Decays[44][0] = -PDGWplus; ParticleNeutralino3.Array_Decays[44][1] = PDGchargino1; ParticleNeutralino3.Array_Decays[44][2] = neutralino3amplitudeWbosonminuscharginoW1; ParticleNeutralino3.Array_Decays[44][3] = 2; ParticleNeutralino3.Array_Comments[44] = "# ~chi_30 -> W- ~chi_1+";
   ParticleNeutralino3.Array_Decays[45][0] = -PDGWplus; ParticleNeutralino3.Array_Decays[45][1] = PDGchargino2; ParticleNeutralino3.Array_Decays[45][2] = neutralino3amplitudeWbosonminuscharginoW2; ParticleNeutralino3.Array_Decays[45][3] = 2; ParticleNeutralino3.Array_Comments[45] = "# ~chi_30 -> W- ~chi_2+";
   ParticleNeutralino3.Array_Decays[46][0] = PDGHplus; ParticleNeutralino3.Array_Decays[46][1] = -PDGchargino1; ParticleNeutralino3.Array_Decays[46][2] = neutralino3amplitudeHpluscharginoW1; ParticleNeutralino3.Array_Decays[46][3] = 2; ParticleNeutralino3.Array_Comments[46] = "# ~chi_30 -> H+ ~chi_1-";
   ParticleNeutralino3.Array_Decays[47][0] = PDGHplus; ParticleNeutralino3.Array_Decays[47][1] = -PDGchargino2; ParticleNeutralino3.Array_Decays[47][2] = neutralino3amplitudeHpluscharginoW2; ParticleNeutralino3.Array_Decays[47][3] = 2; ParticleNeutralino3.Array_Comments[47] = "# ~chi_30 -> H+ ~chi_2-";
   ParticleNeutralino3.Array_Decays[48][0] = -PDGHplus; ParticleNeutralino3.Array_Decays[48][1] = PDGchargino1; ParticleNeutralino3.Array_Decays[48][2] = neutralino3amplitudeHminuscharginoW1; ParticleNeutralino3.Array_Decays[48][3] = 2; ParticleNeutralino3.Array_Comments[48] = "# ~chi_30 -> H- ~chi_1+";
   ParticleNeutralino3.Array_Decays[49][0] = -PDGHplus; ParticleNeutralino3.Array_Decays[49][1] = PDGchargino2; ParticleNeutralino3.Array_Decays[49][2] = neutralino3amplitudeHminuscharginoW2; ParticleNeutralino3.Array_Decays[49][3] = 2; ParticleNeutralino3.Array_Comments[49] = "# ~chi_30 -> H- ~chi_2+";
   ParticleNeutralino3.Array_Decays[50][0] = PDGZboson; ParticleNeutralino3.Array_Decays[50][1] = PDGneutralino1; ParticleNeutralino3.Array_Decays[50][2] = neutralino3amplitudeZbosonneutralino1; ParticleNeutralino3.Array_Decays[50][3] = 2; ParticleNeutralino3.Array_Comments[50] = "# ~chi_30 -> Z ~chi_10";
   ParticleNeutralino3.Array_Decays[51][0] = PDGZboson; ParticleNeutralino3.Array_Decays[51][1] = PDGneutralino2; ParticleNeutralino3.Array_Decays[51][2] = neutralino3amplitudeZbosonneutralino2; ParticleNeutralino3.Array_Decays[51][3] = 2; ParticleNeutralino3.Array_Comments[51] = "# ~chi_30 -> Z ~chi_20";
   ParticleNeutralino3.Array_Decays[52][0] = PDGZboson; ParticleNeutralino3.Array_Decays[52][1] = PDGneutralino4; ParticleNeutralino3.Array_Decays[52][2] = neutralino3amplitudeZbosonneutralino4; ParticleNeutralino3.Array_Decays[52][3] = 2; ParticleNeutralino3.Array_Comments[52] = "# ~chi_30 -> Z ~chi_40";
   ParticleNeutralino3.Array_Decays[53][0] = PDGh0; ParticleNeutralino3.Array_Decays[53][1] = PDGneutralino1; ParticleNeutralino3.Array_Decays[53][2] = neutralino3amplitudehneutralino1; ParticleNeutralino3.Array_Decays[53][3] = 2; ParticleNeutralino3.Array_Comments[53] = "# ~chi_30 -> h ~chi_10";
   ParticleNeutralino3.Array_Decays[54][0] = PDGh0; ParticleNeutralino3.Array_Decays[54][1] = PDGneutralino2; ParticleNeutralino3.Array_Decays[54][2] = neutralino3amplitudehneutralino2; ParticleNeutralino3.Array_Decays[54][3] = 2; ParticleNeutralino3.Array_Comments[54] = "# ~chi_30 -> h ~chi_20";
   ParticleNeutralino3.Array_Decays[55][0] = PDGh0; ParticleNeutralino3.Array_Decays[55][1] = PDGneutralino4; ParticleNeutralino3.Array_Decays[55][2] = neutralino3amplitudehneutralino4; ParticleNeutralino3.Array_Decays[55][3] = 2; ParticleNeutralino3.Array_Comments[55] = "# ~chi_30 -> h ~chi_40";
   ParticleNeutralino3.Array_Decays[56][0] = PDGH0; ParticleNeutralino3.Array_Decays[56][1] = PDGneutralino1; ParticleNeutralino3.Array_Decays[56][2] = neutralino3amplitudeHneutralino1; ParticleNeutralino3.Array_Decays[56][3] = 2; ParticleNeutralino3.Array_Comments[56] = "# ~chi_30 -> H ~chi_10";
   ParticleNeutralino3.Array_Decays[57][0] = PDGH0; ParticleNeutralino3.Array_Decays[57][1] = PDGneutralino2; ParticleNeutralino3.Array_Decays[57][2] = neutralino3amplitudeHneutralino2; ParticleNeutralino3.Array_Decays[57][3] = 2; ParticleNeutralino3.Array_Comments[57] = "# ~chi_30 -> H ~chi_20";
   ParticleNeutralino3.Array_Decays[58][0] = PDGH0; ParticleNeutralino3.Array_Decays[58][1] = PDGneutralino4; ParticleNeutralino3.Array_Decays[58][2] = neutralino3amplitudeHneutralino4; ParticleNeutralino3.Array_Decays[58][3] = 2; ParticleNeutralino3.Array_Comments[58] = "# ~chi_30 -> H ~chi_40";
   ParticleNeutralino3.Array_Decays[59][0] = PDGA0; ParticleNeutralino3.Array_Decays[59][1] = PDGneutralino1; ParticleNeutralino3.Array_Decays[59][2] = neutralino3amplitudeAneutralino1; ParticleNeutralino3.Array_Decays[59][3] = 2; ParticleNeutralino3.Array_Comments[59] = "# ~chi_30 -> A ~chi_10";
   ParticleNeutralino3.Array_Decays[60][0] = PDGA0; ParticleNeutralino3.Array_Decays[60][1] = PDGneutralino2; ParticleNeutralino3.Array_Decays[60][2] = neutralino3amplitudeAneutralino2; ParticleNeutralino3.Array_Decays[60][3] = 2; ParticleNeutralino3.Array_Comments[60] = "# ~chi_30 -> A ~chi_20";
   ParticleNeutralino3.Array_Decays[61][0] = PDGA0; ParticleNeutralino3.Array_Decays[61][1] = PDGneutralino4; ParticleNeutralino3.Array_Decays[61][2] = neutralino3amplitudeAneutralino4; ParticleNeutralino3.Array_Decays[61][3] = 2; ParticleNeutralino3.Array_Comments[61] = "# ~chi_30 -> A ~chi_40";

     ParticleNeutralino3.Array_Decays[62][0] = PDGphoton; ParticleNeutralino3.Array_Decays[62][1] = PDGgravitino; ParticleNeutralino3.Array_Decays[62][2] = neutralino3amplitudephotongravitino; ParticleNeutralino3.Array_Decays[62][3] = 2; ParticleNeutralino3.Array_Comments[62] = "# ~chi_30 -> gamma ~G";
  ParticleNeutralino3.Array_Decays[63][0] = PDGZboson; ParticleNeutralino3.Array_Decays[63][1] = PDGgravitino; ParticleNeutralino3.Array_Decays[63][2] = neutralino3amplitudeZgravitino; ParticleNeutralino3.Array_Decays[63][3] = 2; ParticleNeutralino3.Array_Comments[63] = "# ~chi_30 -> Z ~G";
  ParticleNeutralino3.Array_Decays[64][0] = PDGh0; ParticleNeutralino3.Array_Decays[64][1] = PDGgravitino; ParticleNeutralino3.Array_Decays[64][2] = neutralino3amplitudehgravitino; ParticleNeutralino3.Array_Decays[64][3] = 2; ParticleNeutralino3.Array_Comments[64] = "# ~chi_30 -> h ~G";
  ParticleNeutralino3.Array_Decays[65][0] = PDGH0; ParticleNeutralino3.Array_Decays[65][1] = PDGgravitino; ParticleNeutralino3.Array_Decays[65][2] = neutralino3amplitudeHgravitino; ParticleNeutralino3.Array_Decays[65][3] = 2; ParticleNeutralino3.Array_Comments[65] = "# ~chi_30 -> H ~G";
  ParticleNeutralino3.Array_Decays[66][0] = PDGA0; ParticleNeutralino3.Array_Decays[66][1] = PDGgravitino; ParticleNeutralino3.Array_Decays[66][2] = neutralino3amplitudeAgravitino; ParticleNeutralino1.Array_Decays[66][3] = 2; ParticleNeutralino3.Array_Comments[66] = "# ~chi_30 -> A ~G";

   ParticleNeutralino3.Array_Decays[67][0] = PDGneutralino1; ParticleNeutralino3.Array_Decays[67][1] = PDGup; ParticleNeutralino3.Array_Decays[67][4] = -PDGup; ParticleNeutralino3.Array_Decays[67][2] = neutralino3amplitudeneut1uubar; ParticleNeutralino3.Array_Decays[67][3] = 3; ParticleNeutralino3.Array_Comments[67] = "# ~chi_30 -> ~chi_10 u ubar";
  ParticleNeutralino3.Array_Decays[68][0] = PDGneutralino1; ParticleNeutralino3.Array_Decays[68][1] = PDGdown; ParticleNeutralino3.Array_Decays[68][4] = -PDGdown; ParticleNeutralino3.Array_Decays[68][2] = neutralino3amplitudeneut1ddbar; ParticleNeutralino3.Array_Decays[68][3] = 3; ParticleNeutralino3.Array_Comments[68] = "# ~chi_30 -> ~chi_10 d dbar";
  ParticleNeutralino3.Array_Decays[69][0] = PDGneutralino1; ParticleNeutralino3.Array_Decays[69][1] = PDGcharm; ParticleNeutralino3.Array_Decays[69][4] = -PDGcharm; ParticleNeutralino3.Array_Decays[69][2] = neutralino3amplitudeneut1ccbar; ParticleNeutralino3.Array_Decays[69][3] = 3; ParticleNeutralino3.Array_Comments[69] = "# ~chi_30 -> ~chi_10 c cbar";
  ParticleNeutralino3.Array_Decays[70][0] = PDGneutralino1; ParticleNeutralino3.Array_Decays[70][1] = PDGstrange; ParticleNeutralino3.Array_Decays[70][4] = -PDGstrange; ParticleNeutralino3.Array_Decays[70][2] = neutralino3amplitudeneut1ssbar; ParticleNeutralino3.Array_Decays[70][3] = 3; ParticleNeutralino3.Array_Comments[70] = "# ~chi_30 -> ~chi_10 s sbar";
  ParticleNeutralino3.Array_Decays[71][0] = PDGneutralino1; ParticleNeutralino3.Array_Decays[71][1] = PDGtop; ParticleNeutralino3.Array_Decays[71][4] = -PDGtop; ParticleNeutralino3.Array_Decays[71][2] = neutralino3amplitudeneut1ttbar; ParticleNeutralino3.Array_Decays[71][3] = 3; ParticleNeutralino3.Array_Comments[71] = "# ~chi_30 -> ~chi_10 t tbar";
  ParticleNeutralino3.Array_Decays[72][0] = PDGneutralino1; ParticleNeutralino3.Array_Decays[72][1] = PDGbottom; ParticleNeutralino3.Array_Decays[72][4] = -PDGbottom; ParticleNeutralino3.Array_Decays[72][2] = neutralino3amplitudeneut1bbbar; ParticleNeutralino3.Array_Decays[72][3] = 3; ParticleNeutralino3.Array_Comments[72] = "# ~chi_30 -> ~chi_10 b bbar";
  ParticleNeutralino3.Array_Decays[73][0] = PDGneutralino1; ParticleNeutralino3.Array_Decays[73][1] = PDGelectron; ParticleNeutralino3.Array_Decays[73][4] = -PDGelectron; ParticleNeutralino3.Array_Decays[73][2] = neutralino3amplitudeneut1eebar; ParticleNeutralino3.Array_Decays[73][3] = 3; ParticleNeutralino3.Array_Comments[73] = "# ~chi_30 -> ~chi_10 e- e+";
  ParticleNeutralino3.Array_Decays[74][0] = PDGneutralino1; ParticleNeutralino3.Array_Decays[74][1] = PDGmuon; ParticleNeutralino3.Array_Decays[74][4] = -PDGmuon; ParticleNeutralino3.Array_Decays[74][2] = neutralino3amplitudeneut1mumubar; ParticleNeutralino3.Array_Decays[74][3] = 3; ParticleNeutralino3.Array_Comments[74] = "# ~chi_30 -> ~chi_10 mu- mu+";
  ParticleNeutralino3.Array_Decays[75][0] = PDGneutralino1; ParticleNeutralino3.Array_Decays[75][1] = PDGtau; ParticleNeutralino3.Array_Decays[75][4] = -PDGtau; ParticleNeutralino3.Array_Decays[75][2] = neutralino3amplitudeneut1tautaubar; ParticleNeutralino3.Array_Decays[75][3] = 3; ParticleNeutralino3.Array_Comments[75] = "# ~chi_30 -> ~chi_10 tau- tau+";
  ParticleNeutralino3.Array_Decays[76][0] = PDGneutralino1; ParticleNeutralino3.Array_Decays[76][1] = PDGnuelectron; ParticleNeutralino3.Array_Decays[76][4] = -PDGnuelectron; ParticleNeutralino3.Array_Decays[76][2] = neutralino3amplitudeneut1nuenuebar; ParticleNeutralino3.Array_Decays[76][3] = 3; ParticleNeutralino3.Array_Comments[76] = "# ~chi_30 -> ~chi_10 nue nuebar";
  ParticleNeutralino3.Array_Decays[77][0] = PDGneutralino1; ParticleNeutralino3.Array_Decays[77][1] = PDGnumuon; ParticleNeutralino3.Array_Decays[77][4] = -PDGnumuon; ParticleNeutralino3.Array_Decays[77][2] = neutralino3amplitudeneut1numunumubar; ParticleNeutralino3.Array_Decays[77][3] = 3; ParticleNeutralino3.Array_Comments[77] = "# ~chi_30 -> ~chi_10 numu numubar";
  ParticleNeutralino3.Array_Decays[78][0] = PDGneutralino1; ParticleNeutralino3.Array_Decays[78][1] = PDGnutau; ParticleNeutralino3.Array_Decays[78][4] = -PDGnutau; ParticleNeutralino3.Array_Decays[78][2] = neutralino3amplitudeneut1nutaunutaubar; ParticleNeutralino3.Array_Decays[78][3] = 3; ParticleNeutralino3.Array_Comments[78] = "# ~chi_30 -> ~chi_10 nutau nutaubar";
   ParticleNeutralino3.Array_Decays[79][0] = PDGneutralino2; ParticleNeutralino3.Array_Decays[79][1] = PDGup; ParticleNeutralino3.Array_Decays[79][4] = -PDGup; ParticleNeutralino3.Array_Decays[79][2] = neutralino3amplitudeneut2uubar; ParticleNeutralino3.Array_Decays[79][3] = 3; ParticleNeutralino3.Array_Comments[79] = "# ~chi_30 -> ~chi_20 u ubar";
  ParticleNeutralino3.Array_Decays[80][0] = PDGneutralino2; ParticleNeutralino3.Array_Decays[80][1] = PDGdown; ParticleNeutralino3.Array_Decays[80][4] = -PDGdown; ParticleNeutralino3.Array_Decays[80][2] = neutralino3amplitudeneut2ddbar; ParticleNeutralino3.Array_Decays[80][3] = 3; ParticleNeutralino3.Array_Comments[80] = "# ~chi_30 -> ~chi_20 d dbar";
  ParticleNeutralino3.Array_Decays[81][0] = PDGneutralino2; ParticleNeutralino3.Array_Decays[81][1] = PDGcharm; ParticleNeutralino3.Array_Decays[81][4] = -PDGcharm; ParticleNeutralino3.Array_Decays[81][2] = neutralino3amplitudeneut2ccbar; ParticleNeutralino3.Array_Decays[81][3] = 3; ParticleNeutralino3.Array_Comments[81] = "# ~chi_30 -> ~chi_20 c cbar";
  ParticleNeutralino3.Array_Decays[82][0] = PDGneutralino2; ParticleNeutralino3.Array_Decays[82][1] = PDGstrange; ParticleNeutralino3.Array_Decays[82][4] = -PDGstrange; ParticleNeutralino3.Array_Decays[82][2] = neutralino3amplitudeneut2ssbar; ParticleNeutralino3.Array_Decays[82][3] = 3; ParticleNeutralino3.Array_Comments[82] = "# ~chi_30 -> ~chi_20 s sbar";
  ParticleNeutralino3.Array_Decays[83][0] = PDGneutralino2; ParticleNeutralino3.Array_Decays[83][1] = PDGtop; ParticleNeutralino3.Array_Decays[83][4] = -PDGtop; ParticleNeutralino3.Array_Decays[83][2] = neutralino3amplitudeneut2ttbar; ParticleNeutralino3.Array_Decays[83][3] = 3; ParticleNeutralino3.Array_Comments[83] = "# ~chi_30 -> ~chi_20 t tbar";
  ParticleNeutralino3.Array_Decays[84][0] = PDGneutralino2; ParticleNeutralino3.Array_Decays[84][1] = PDGbottom; ParticleNeutralino3.Array_Decays[84][4] = -PDGbottom; ParticleNeutralino3.Array_Decays[84][2] = neutralino3amplitudeneut2bbbar; ParticleNeutralino3.Array_Decays[84][3] = 3; ParticleNeutralino3.Array_Comments[84] = "# ~chi_30 -> ~chi_20 b bbar";
  ParticleNeutralino3.Array_Decays[85][0] = PDGneutralino2; ParticleNeutralino3.Array_Decays[85][1] = PDGelectron; ParticleNeutralino3.Array_Decays[85][4] = -PDGelectron; ParticleNeutralino3.Array_Decays[85][2] = neutralino3amplitudeneut2eebar; ParticleNeutralino3.Array_Decays[85][3] = 3; ParticleNeutralino3.Array_Comments[85] = "# ~chi_30 -> ~chi_20 e- e+";
  ParticleNeutralino3.Array_Decays[86][0] = PDGneutralino2; ParticleNeutralino3.Array_Decays[86][1] = PDGmuon; ParticleNeutralino3.Array_Decays[86][4] = -PDGmuon; ParticleNeutralino3.Array_Decays[86][2] = neutralino3amplitudeneut2mumubar; ParticleNeutralino3.Array_Decays[86][3] = 3; ParticleNeutralino3.Array_Comments[86] = "# ~chi_30 -> ~chi_20 mu- mu+";
  ParticleNeutralino3.Array_Decays[87][0] = PDGneutralino2; ParticleNeutralino3.Array_Decays[87][1] = PDGtau; ParticleNeutralino3.Array_Decays[87][4] = -PDGtau; ParticleNeutralino3.Array_Decays[87][2] = neutralino3amplitudeneut2tautaubar; ParticleNeutralino3.Array_Decays[87][3] = 3; ParticleNeutralino3.Array_Comments[87] = "# ~chi_30 -> ~chi_20 tau- tau+";
  ParticleNeutralino3.Array_Decays[88][0] = PDGneutralino2; ParticleNeutralino3.Array_Decays[88][1] = PDGnuelectron; ParticleNeutralino3.Array_Decays[88][4] = -PDGnuelectron; ParticleNeutralino3.Array_Decays[88][2] = neutralino3amplitudeneut2nuenuebar; ParticleNeutralino3.Array_Decays[88][3] = 3; ParticleNeutralino3.Array_Comments[88] = "# ~chi_30 -> ~chi_20 nue nuebar";
  ParticleNeutralino3.Array_Decays[89][0] = PDGneutralino2; ParticleNeutralino3.Array_Decays[89][1] = PDGnumuon; ParticleNeutralino3.Array_Decays[89][4] = -PDGnumuon; ParticleNeutralino3.Array_Decays[89][2] = neutralino3amplitudeneut2numunumubar; ParticleNeutralino3.Array_Decays[89][3] = 3; ParticleNeutralino3.Array_Comments[83] = "# ~chi_30 -> ~chi_20 numu numubar";
  ParticleNeutralino3.Array_Decays[90][0] = PDGneutralino2; ParticleNeutralino3.Array_Decays[90][1] = PDGnutau; ParticleNeutralino3.Array_Decays[90][4] = -PDGnutau; ParticleNeutralino3.Array_Decays[90][2] = neutralino3amplitudeneut2nutaunutaubar; ParticleNeutralino3.Array_Decays[90][3] = 3; ParticleNeutralino3.Array_Comments[90] = "# ~chi_30 -> ~chi_20 nutau nutaubar";

    ParticleNeutralino3.Array_Decays[91][0] = PDGchargino1; ParticleNeutralino3.Array_Decays[91][1] = PDGup; ParticleNeutralino3.Array_Decays[91][4] = -PDGdown; ParticleNeutralino3.Array_Decays[91][2] = neutralino3amplitudechargino1udbar; ParticleNeutralino3.Array_Decays[91][3] = 3; ParticleNeutralino3.Array_Comments[91] = "# ~chi_30 -> chi_1- u db";
   ParticleNeutralino3.Array_Decays[92][0] = PDGchargino1; ParticleNeutralino3.Array_Decays[92][1] = PDGcharm; ParticleNeutralino3.Array_Decays[92][4] = -PDGstrange; ParticleNeutralino3.Array_Decays[92][2] = neutralino3amplitudechargino1csbar; ParticleNeutralino3.Array_Decays[92][3] = 3; ParticleNeutralino3.Array_Comments[92] = "# ~chi_30 -> chi_1- c sb";
   ParticleNeutralino3.Array_Decays[93][0] = PDGchargino1; ParticleNeutralino3.Array_Decays[93][1] = PDGnuelectron; ParticleNeutralino3.Array_Decays[93][4] = -PDGelectron; ParticleNeutralino3.Array_Decays[93][2] = neutralino3amplitudechargino1enuebar; ParticleNeutralino3.Array_Decays[93][3] = 3; ParticleNeutralino3.Array_Comments[93] = "# ~chi_30 -> chi_1- nu_e eb";
   ParticleNeutralino3.Array_Decays[94][0] = PDGchargino1; ParticleNeutralino3.Array_Decays[94][1] = PDGnumuon; ParticleNeutralino3.Array_Decays[94][4] = -PDGmuon; ParticleNeutralino3.Array_Decays[94][2] = neutralino3amplitudechargino1munumubar; ParticleNeutralino3.Array_Decays[94][3] = 3; ParticleNeutralino3.Array_Comments[94] = "# ~chi_30 -> chi_1- nu_mu mub";
   ParticleNeutralino3.Array_Decays[95][0] = PDGchargino1; ParticleNeutralino3.Array_Decays[95][1] = PDGnutau; ParticleNeutralino3.Array_Decays[95][4] = -PDGtau; ParticleNeutralino3.Array_Decays[95][2] = neutralino3amplitudechargino1taunutaubar; ParticleNeutralino3.Array_Decays[95][3] = 3; ParticleNeutralino3.Array_Comments[95] = "# ~chi_30 -> chi_1- nu_tau taub";
   ParticleNeutralino3.Array_Decays[96][0] = PDGchargino2; ParticleNeutralino3.Array_Decays[96][1] = PDGup; ParticleNeutralino3.Array_Decays[96][4] = -PDGdown; ParticleNeutralino3.Array_Decays[96][2] = neutralino3amplitudechargino2udbar; ParticleNeutralino3.Array_Decays[96][3] = 3; ParticleNeutralino3.Array_Comments[96] = "# ~chi_30 -> chi_2- u dbar";
   ParticleNeutralino3.Array_Decays[97][0] = PDGchargino2; ParticleNeutralino3.Array_Decays[97][1] = PDGcharm; ParticleNeutralino3.Array_Decays[97][4] = -PDGstrange; ParticleNeutralino3.Array_Decays[97][2] = neutralino3amplitudechargino2csbar; ParticleNeutralino3.Array_Decays[97][3] = 3; ParticleNeutralino3.Array_Comments[97] = "# ~chi_30 -> chi_2- c sbar";
   ParticleNeutralino3.Array_Decays[98][0] = PDGchargino2; ParticleNeutralino3.Array_Decays[98][1] = PDGnuelectron; ParticleNeutralino3.Array_Decays[98][4] = -PDGelectron; ParticleNeutralino3.Array_Decays[98][2] = neutralino3amplitudechargino2enuebar; ParticleNeutralino3.Array_Decays[98][3] = 3; ParticleNeutralino3.Array_Comments[98] = "# ~chi_30 -> chi_2- nu_e eb";
   ParticleNeutralino3.Array_Decays[99][0] = PDGchargino2; ParticleNeutralino3.Array_Decays[99][1] = PDGnumuon; ParticleNeutralino3.Array_Decays[99][4] = -PDGmuon; ParticleNeutralino3.Array_Decays[99][2] = neutralino3amplitudechargino2munumubar; ParticleNeutralino3.Array_Decays[99][3] = 3; ParticleNeutralino3.Array_Comments[99] = "# ~chi_30 -> chi_2- nu_mu mub";
   ParticleNeutralino3.Array_Decays[100][0] = PDGchargino2; ParticleNeutralino3.Array_Decays[100][1] = PDGnutau; ParticleNeutralino3.Array_Decays[100][4] = -PDGtau; ParticleNeutralino3.Array_Decays[100][2] = neutralino3amplitudechargino2taunutaubar; ParticleNeutralino3.Array_Decays[100][3] = 3; ParticleNeutralino3.Array_Comments[100] = "# ~chi_30 -> chi_2- nu_tau taubar";

  double Neut3_No_1to2_Decays = 0;

  if (neutNLSP == 1) { Neut3_No_1to2_Decays = ParticleNeutralino3.No_1to2_Decays + ParticleNeutralino3.No_grav_Decays;}
  else { Neut3_No_1to2_Decays = ParticleNeutralino3.No_1to2_Decays;}
   
 for (int j = 0; j<Neut3_No_1to2_Decays; j++) {
   ParticleNeutralino3.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
  }

 for (int j=0; j<Neut3_No_1to2_Decays; j++) {
    ParticleNeutralino3.two_width = ParticleNeutralino3.two_width + ParticleNeutralino3.Array_Decays[j][2];
  }
 for (int j=Neut3_No_1to2_Decays; j<ParticleNeutralino3.No_of_Decays; j++) {
   ParticleNeutralino3.three_width = ParticleNeutralino3.three_width + ParticleNeutralino3.Array_Decays[j][2];
 }
  
  if ( ParticleNeutralino3.three_width != ParticleNeutralino3.three_width) /// Tests for a nan as only nans aren't equal to themselves
    {
      cout << "Three body decays give nan for neutralino 3 - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
      ParticleNeutralino3.No_of_Decays = Neut3_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
      ParticleNeutralino3.total_width = ParticleNeutralino3.two_width;
    }
  else {
    ParticleNeutralino3.total_width = ParticleNeutralino3.two_width + ParticleNeutralino3.three_width;
  }
   
  for (int i =0; i<ParticleNeutralino3.No_of_Decays; i++) {
     ParticleNeutralino3.Array_Decays[i][5]= ParticleNeutralino3.Array_Decays[i][2]/ParticleNeutralino3.total_width;
   }


 /// cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 ///cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleNeutralino3.PDG << setw(12) << scientific << setprecision(8) <<  ParticleNeutralino3.total_width << "   " << "# neutralino3 decays" << endl;
 ///cout.precision(7);
 ///cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 ///for (int k=0; k<ParticleNeutralino3.No_of_Decays; k++) {
 ///  if( ParticleNeutralino3.Array_Decays[k][2] != 0 && ParticleNeutralino3.Array_Decays[k][5] > BRTol) {
 ///        cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleNeutralino3.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleNeutralino3.Array_Decays[k][3];  printRowPDG(cout, ParticleNeutralino3.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleNeutralino3.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleNeutralino3.Array_Comments[k] << endl;
 ///  }
 ///}
 ///cout << "#" << endl;

///Uncomment section below if want partial widths as well as branching ratios
 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleNeutralino3.PDG << setw(12) << scientific << setprecision(8) <<  ParticleNeutralino3.total_width << "   " << "# neutralino3 decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "PW" << setw(18) << "BR" << setw(8) << "NDA" << setw(12) << left << " PDG1" << setw(12) << " PDG2" << setw(12) << " PDG3 " << endl;
 for (int k=0; k<ParticleNeutralino3.No_of_Decays; k++) {
   if( ParticleNeutralino3.Array_Decays[k][2] != 0 && ParticleNeutralino3.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleNeutralino3.Array_Decays[k][2] << setprecision(8) << ParticleNeutralino3.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << " " << ParticleNeutralino3.Array_Decays[k][3] << setw(4) << " ";  printRowPDG(cout, ParticleNeutralino3.Array_Decays[k][0]); cout << "    "; printRowPDG(cout,ParticleNeutralino3.Array_Decays[k][1]); cout << "    "; printRowPDG(cout,ParticleNeutralino3.Array_Decays[k][4]); cout << "   " << left << setprecision(0) << setw(15) << ParticleNeutralino3.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl; 


///Neutralino4 Decays
 
 double neutralino4amplitudeuLubar, neutralino4amplitudeuRubar, neutralino4amplitudeuLbaru, neutralino4amplitudeuRbaru, neutralino4amplitudedLdbar, neutralino4amplitudedRdbar, neutralino4amplitudedLbard, neutralino4amplitudedRbard, neutralino4amplitudecLcbar, neutralino4amplitudecRcbar, neutralino4amplitudecLbarc, neutralino4amplitudecRbarc, neutralino4amplitudesLsbar, neutralino4amplitudesRsbar, neutralino4amplitudesLbars, neutralino4amplitudesRbars, neutralino4amplitudeeLebar, neutralino4amplitudeeRebar, neutralino4amplitudeeLbare, neutralino4amplitudeeRbare, neutralino4amplitudemuLmubar, neutralino4amplitudemuRmubar, neutralino4amplitudemuLbarmu, neutralino4amplitudemuRbarmu,neutralino4amplitudesnuenuebar, neutralino4amplitudesnuebarnue, neutralino4amplitudesnumunumubar, neutralino4amplitudesnumubarnumu, neutralino4amplitudetopstop1bar, neutralino4amplitudetopstop2bar, neutralino4amplitudetopbarstop1, neutralino4amplitudetopbarstop2, neutralino4amplitudebottomsbottom1bar, neutralino4amplitudebottomsbottom2bar, neutralino4amplitudebottombarsbottom1, neutralino4amplitudebottombarsbottom2, neutralino4amplitudetaustau1bar, neutralino4amplitudetaustau2bar, neutralino4amplitudetaubarstau1, neutralino4amplitudetaubarstau2, neutralino4amplitudenutausnutaubar, neutralino4amplitudenutaubarsnutau, neutralino4amplitudeWbosonpluscharginoW1, neutralino4amplitudeWbosonpluscharginoW2, neutralino4amplitudeWbosonminuscharginoW1, neutralino4amplitudeWbosonminuscharginoW2, neutralino4amplitudeHpluscharginoW1, neutralino4amplitudeHpluscharginoW2, neutralino4amplitudeHminuscharginoW1, neutralino4amplitudeHminuscharginoW2, neutralino4amplitudeZbosonneutralino1, neutralino4amplitudeZbosonneutralino2, neutralino4amplitudeZbosonneutralino3, neutralino4amplitudehneutralino1, neutralino4amplitudehneutralino2, neutralino4amplitudehneutralino3, neutralino4amplitudeHneutralino1, neutralino4amplitudeHneutralino2, neutralino4amplitudeHneutralino3, neutralino4amplitudeAneutralino1, neutralino4amplitudeAneutralino2, neutralino4amplitudeAneutralino3, neutralino4amplitudephotongravitino, neutralino4amplitudeZgravitino, neutralino4amplitudehgravitino, neutralino4amplitudeHgravitino, neutralino4amplitudeAgravitino;
 
 double neutralino4amplitudeneut1uubar, neutralino4amplitudeneut1ddbar, neutralino4amplitudeneut1ccbar, neutralino4amplitudeneut1ssbar, neutralino4amplitudeneut1ttbar, neutralino4amplitudeneut1bbbar, neutralino4amplitudeneut1eebar, neutralino4amplitudeneut1mumubar, neutralino4amplitudeneut1tautaubar, neutralino4amplitudeneut1nuenuebar, neutralino4amplitudeneut1numunumubar, neutralino4amplitudeneut1nutaunutaubar, neutralino4amplitudeneut2uubar, neutralino4amplitudeneut2ddbar, neutralino4amplitudeneut2ccbar, neutralino4amplitudeneut2ssbar, neutralino4amplitudeneut2ttbar, neutralino4amplitudeneut2bbbar, neutralino4amplitudeneut2eebar, neutralino4amplitudeneut2mumubar, neutralino4amplitudeneut2tautaubar, neutralino4amplitudeneut2nuenuebar, neutralino4amplitudeneut2numunumubar, neutralino4amplitudeneut2nutaunutaubar, neutralino4amplitudeneut3uubar, neutralino4amplitudeneut3ddbar, neutralino4amplitudeneut3ccbar, neutralino4amplitudeneut3ssbar, neutralino4amplitudeneut3ttbar, neutralino4amplitudeneut3bbbar, neutralino4amplitudeneut3eebar, neutralino4amplitudeneut3mumubar, neutralino4amplitudeneut3tautaubar, neutralino4amplitudeneut3nuenuebar, neutralino4amplitudeneut3numunumubar, neutralino4amplitudeneut3nutaunutaubar, neutralino4amplitudechargino1udbar, neutralino4amplitudechargino1csbar, neutralino4amplitudechargino1enuebar, neutralino4amplitudechargino1munumubar, neutralino4amplitudechargino1taunutaubar, neutralino4amplitudechargino2udbar, neutralino4amplitudechargino2csbar, neutralino4amplitudechargino2enuebar, neutralino4amplitudechargino2munumubar, neutralino4amplitudechargino2taunutaubar;

 neutralino4amplitudeuLubar = neutralinoamplitudedecayquarksquarkLorR (mneut(4), MUP, mu(1,1), g, gp, mixNeut, 1, 'L', 4);
 neutralino4amplitudeuRubar = neutralinoamplitudedecayquarksquarkLorR (mneut(4), MUP, mu(2,1), g, gp, mixNeut, 1, 'R', 4);
 neutralino4amplitudeuLbaru = neutralinoamplitudedecayquarksquarkLorR (mneut(4), MUP, mu(1,1), g, gp, mixNeut, 1, 'L', 4); 
 neutralino4amplitudeuRbaru = neutralinoamplitudedecayquarksquarkLorR (mneut(4), MUP, mu(2,1), g, gp, mixNeut, 1, 'R', 4);
 neutralino4amplitudedLdbar = neutralinoamplitudedecayquarksquarkLorR (mneut(4), MDOWN, md(1,1), g, gp, mixNeut, 2, 'L', 4);
 neutralino4amplitudedRdbar = neutralinoamplitudedecayquarksquarkLorR (mneut(4), MDOWN, md(2,1), g, gp, mixNeut, 2, 'R', 4);
 neutralino4amplitudedLbard = neutralinoamplitudedecayquarksquarkLorR (mneut(4), MDOWN, md(1,1), g, gp, mixNeut, 2, 'L', 4);
 neutralino4amplitudedRbard = neutralinoamplitudedecayquarksquarkLorR (mneut(4), MDOWN, md(2,1), g, gp, mixNeut, 2, 'R', 4);
 neutralino4amplitudecLcbar = neutralinoamplitudedecayquarksquarkLorR (mneut(4), MCHARM, mu(1,2), g, gp, mixNeut, 1, 'L', 4);
 neutralino4amplitudecRcbar = neutralinoamplitudedecayquarksquarkLorR (mneut(4), MCHARM, mu(2,2), g, gp, mixNeut, 1, 'R', 4);
 neutralino4amplitudecLbarc = neutralinoamplitudedecayquarksquarkLorR (mneut(4), MCHARM, mu(1,2), g, gp, mixNeut, 1, 'L', 4);
 neutralino4amplitudecRbarc = neutralinoamplitudedecayquarksquarkLorR (mneut(4), MCHARM, mu(2,2), g, gp, mixNeut, 1, 'R', 4);
 neutralino4amplitudesLsbar = neutralinoamplitudedecayquarksquarkLorR (mneut(4), MSTRANGE, md(1,2), g, gp, mixNeut, 2, 'L', 4);
 neutralino4amplitudesRsbar = neutralinoamplitudedecayquarksquarkLorR (mneut(4), MSTRANGE, md(2,2), g, gp, mixNeut, 2, 'R', 4);
 neutralino4amplitudesLbars = neutralinoamplitudedecayquarksquarkLorR (mneut(4), MSTRANGE, md(1,2), g, gp, mixNeut, 2, 'L', 4);
 neutralino4amplitudesRbars = neutralinoamplitudedecayquarksquarkLorR (mneut(4), MSTRANGE, md(2,2), g, gp, mixNeut, 2, 'R', 4);
 neutralino4amplitudeeLebar = neutralinoamplitudedecayleptonsleptonLorR (mneut(4), MELECTRON, me(1,1), g, gp, mixNeut, 'L', 4);
 neutralino4amplitudeeRebar = neutralinoamplitudedecayleptonsleptonLorR (mneut(4), MELECTRON, me(2,1), g, gp, mixNeut, 'R', 4);
 neutralino4amplitudeeLbare = neutralinoamplitudedecayleptonsleptonLorR (mneut(4), MELECTRON, me(1,1), g, gp, mixNeut, 'L', 4);
 neutralino4amplitudeeRbare = neutralinoamplitudedecayleptonsleptonLorR (mneut(4), MELECTRON, me(2,1), g, gp, mixNeut, 'R', 4);
 neutralino4amplitudemuLmubar = neutralinoamplitudedecayleptonsleptonLorR (mneut(4), MMUON, me(1,2), g, gp, mixNeut, 'L', 4);
 neutralino4amplitudemuRmubar = neutralinoamplitudedecayleptonsleptonLorR (mneut(4), MMUON, me(2,2), g, gp, mixNeut, 'R', 4);
 neutralino4amplitudemuLbarmu = neutralinoamplitudedecayleptonsleptonLorR (mneut(4), MMUON, me(1,2), g, gp, mixNeut, 'L', 4);
 neutralino4amplitudemuRbarmu = neutralinoamplitudedecayleptonsleptonLorR (mneut(4), MMUON, me(2,2), g, gp, mixNeut, 'R', 4);
 neutralino4amplitudesnuenuebar = neutralinoamplitudedecayneutrinosneutrinoL (mneut(4), 0, msnu(1), g, gp, mixNeut, 4);
 neutralino4amplitudesnuebarnue = neutralinoamplitudedecayneutrinosneutrinoL (mneut(4), 0, msnu(1), g, gp, mixNeut, 4);
 neutralino4amplitudesnumunumubar = neutralinoamplitudedecayneutrinosneutrinoL (mneut(4), 0, msnu(2), g, gp, mixNeut, 4);
 neutralino4amplitudesnumubarnumu = neutralinoamplitudedecayneutrinosneutrinoL (mneut(4), 0, msnu(2), g, gp, mixNeut, 4);
 neutralino4amplitudetopstop1bar = neutralinoamplitudedecaysquark3quarkmix (mneut(4), MTOP, mu(1,3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 1, 4);
 neutralino4amplitudetopstop2bar = neutralinoamplitudedecaysquark3quarkmix (mneut(4), MTOP, mu(2,3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 2, 4);
 neutralino4amplitudetopbarstop1 = neutralinoamplitudedecaysquark3quarkmix (mneut(4), MTOP, mu(1,3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 1, 4);
 neutralino4amplitudetopbarstop2 = neutralinoamplitudedecaysquark3quarkmix (mneut(4), MTOP, mu(2,3), runmw, thetat, beta, mixNeut, g, gp, runmt, 1, 2, 4);
 neutralino4amplitudebottomsbottom1bar = neutralinoamplitudedecaysquark3quarkmix (mneut(4), MBOTTOM, md(1,3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 1, 4);
 neutralino4amplitudebottomsbottom2bar = neutralinoamplitudedecaysquark3quarkmix (mneut(4), MBOTTOM, md(2,3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 2, 4);
 neutralino4amplitudebottombarsbottom1 = neutralinoamplitudedecaysquark3quarkmix (mneut(4), MBOTTOM, md(1,3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 1, 4);
 neutralino4amplitudebottombarsbottom2 = neutralinoamplitudedecaysquark3quarkmix (mneut(4), MBOTTOM, md(2,3), runmw, thetab, beta, mixNeut, g, gp, runmb, 2, 2, 4);
 neutralino4amplitudetaustau1bar = neutralinoamplitudedecaystautau (mneut(4), MTAU, me(1,3), runmw, thetatau, beta, mixNeut, g, gp, 1, 4);
 neutralino4amplitudetaustau2bar = neutralinoamplitudedecaystautau (mneut(4), MTAU, me(2,3), runmw, thetatau, beta, mixNeut, g, gp, 2, 4);
 neutralino4amplitudetaubarstau1 = neutralinoamplitudedecaystautau (mneut(4), MTAU, me(1,3), runmw, thetatau, beta, mixNeut, g, gp, 1, 4);
 neutralino4amplitudetaubarstau2 = neutralinoamplitudedecaystautau (mneut(4), MTAU, me(2,3), runmw, thetatau, beta, mixNeut, g, gp, 2, 4);
 neutralino4amplitudenutausnutaubar = neutralinoamplitudedecayneutrinosneutrinoL (mneut(4), 0, msnu(3), g, gp, mixNeut, 4);
 neutralino4amplitudenutaubarsnutau = neutralinoamplitudedecayneutrinosneutrinoL (mneut(4), 0, msnu(3), g, gp, mixNeut, 4);
 neutralino4amplitudeWbosonpluscharginoW1 = neutralinoamplitudedecaycharginoWboson (mneut(4), polemw, MCH1, g, thetaL2, thetaR2, mixNeut, 4, 1);
 neutralino4amplitudeWbosonpluscharginoW2 = neutralinoamplitudedecaycharginoWboson (mneut(4), polemw, MCH2, g, thetaL2, thetaR2, mixNeut, 4, 2);
 neutralino4amplitudeWbosonminuscharginoW1 = neutralinoamplitudedecaycharginoWboson (mneut(4), polemw, MCH1, g, thetaL2, thetaR2, mixNeut, 4, 1);
 neutralino4amplitudeWbosonminuscharginoW2 = neutralinoamplitudedecaycharginoWboson (mneut(4), polemw, MCH2, g, thetaL2, thetaR2, mixNeut, 4, 2);
 neutralino4amplitudeHpluscharginoW1 = neutralinoamplitudedecaycharginoHplus (mneut(4), mHpm, MCH1, g, gp, beta, thetaL2, thetaR2, mixNeut, 4, 1);
 neutralino4amplitudeHpluscharginoW2 = neutralinoamplitudedecaycharginoHplus (mneut(4), mHpm, MCH2, g, gp, beta, thetaL2, thetaR2, mixNeut, 4, 2);
 neutralino4amplitudeHminuscharginoW1 = neutralinoamplitudedecaycharginoHplus (mneut(4), mHpm, MCH1, g, gp, beta, thetaL2, thetaR2, mixNeut, 4, 1);
 neutralino4amplitudeHminuscharginoW2 = neutralinoamplitudedecaycharginoHplus (mneut(4), mHpm, MCH2, g, gp, beta, thetaL2, thetaR2, mixNeut, 4, 2);
 neutralino4amplitudeZbosonneutralino1 = neutralinoamplitudedecayneutralinoZboson (mneut(4), mz, mneut(1), g, gp, mixNeut, 4, 1);
 neutralino4amplitudeZbosonneutralino2 = neutralinoamplitudedecayneutralinoZboson (mneut(4), mz, mneut(2), g, gp, mixNeut, 4, 2);
 neutralino4amplitudeZbosonneutralino3 = neutralinoamplitudedecayneutralinoZboson (mneut(4), mz, mneut(3), g, gp, mixNeut, 4, 3);
 neutralino4amplitudehneutralino1 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(4), mh0(1), mneut(1), g, gp, mixNeut, alpha, 4, 1, 'h');
 neutralino4amplitudehneutralino2 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(4), mh0(1), mneut(2), g, gp, mixNeut, alpha, 4, 2, 'h');
 neutralino4amplitudehneutralino3 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(4), mh0(1), mneut(3), g, gp, mixNeut, alpha, 4, 3, 'h');
 neutralino4amplitudeHneutralino1 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(4), mh0(2), mneut(1), g, gp, mixNeut, alpha, 4, 1, 'H');
 neutralino4amplitudeHneutralino2 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(4), mh0(2), mneut(2), g, gp, mixNeut, alpha, 4, 2, 'H');
 neutralino4amplitudeHneutralino3 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(4), mh0(2), mneut(3), g, gp, mixNeut, alpha, 4, 3, 'H');
 neutralino4amplitudeAneutralino1 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(4), mA0(1), mneut(1), g, gp, mixNeut, beta, 4, 1, 'A');
 neutralino4amplitudeAneutralino2 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(4), mA0(1), mneut(2), g, gp, mixNeut, beta, 4, 2, 'A');
 neutralino4amplitudeAneutralino3 = neutralinoamplitudedecayneutralinoneutHiggs (mneut(4), mA0(1), mneut(3), g, gp, mixNeut, beta, 4, 3, 'A');

 neutralino4amplitudephotongravitino = neutralinoamplitudedecayphotongravitino (mneut(4), mgravitino, MPlreduced, mixNeut, g, gp, 4, gravonoff, neutNLSP);
 neutralino4amplitudeZgravitino = neutralinoamplitudedecayZgravitino(mneut(4), mz, mgravitino, MPlreduced, mixNeut, g, gp, beta, 4, gravonoff, neutNLSP);
 neutralino4amplitudehgravitino = neutralinoamplitudedecayphigravitino(mneut(4), mh0(1), mgravitino, MPlreduced, mixNeut, alpha, beta, 4, gravonoff, 'h', neutNLSP);
 neutralino4amplitudeHgravitino = neutralinoamplitudedecayphigravitino(mneut(4), mh0(2), mgravitino, MPlreduced, mixNeut, alpha, beta, 4, gravonoff, 'H', neutNLSP);
 neutralino4amplitudeAgravitino = neutralinoamplitudedecayphigravitino(mneut(4), mA0(1), mgravitino, MPlreduced, mixNeut, alpha, beta, 4, gravonoff, 'A', neutNLSP);
 
 

 neutralino4amplitudeneut1uubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), mu(1,1), mu(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(1), MUP, alphas, 0, runmw, g, gp, alpha, beta, MUP, mixNeut, 4, 1, onetothree, 'u');
 neutralino4amplitudeneut1ddbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), md(1,1), md(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(1), MDOWN, alphas, 0, runmw, g, gp, alpha, beta, MDOWN, mixNeut, 4, 1, onetothree, 'd');
 neutralino4amplitudeneut1ccbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), mu(1,2), mu(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(1), MCHARM, alphas, 0, runmw, g, gp, alpha, beta, MCHARM, mixNeut, 4, 1, onetothree, 'u');
 neutralino4amplitudeneut1ssbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), md(1,2), md(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(1), MSTRANGE, alphas, 0, runmw, g, gp, alpha, beta, MSTRANGE, mixNeut, 4, 1, onetothree, 'd');
 neutralino4amplitudeneut1ttbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), mu(1,3), mu(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(1), MTOP, alphas, thetat, runmw, g, gp, alpha, beta, runmt, mixNeut, 4, 1, onetothree, 'u');
 neutralino4amplitudeneut1bbbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), md(1,3), md(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(1), MBOTTOM, alphas, thetab, runmw, g, gp, alpha, beta, runmb, mixNeut, 4, 1, onetothree, 'd');
 neutralino4amplitudeneut1eebar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), me(1,1), me(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(1), MELECTRON, alphas, 0, runmw, g, gp, alpha, beta, MELECTRON, mixNeut, 4, 1, onetothree, 'l');
 neutralino4amplitudeneut1mumubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), me(1,2), me(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(1), MMUON, alphas, 0, runmw, g, gp, alpha, beta, MMUON, mixNeut, 4, 1, onetothree, 'l');
 neutralino4amplitudeneut1tautaubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), me(1,3), me(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(1), MTAU, alphas, thetatau-PI/2, runmw, g, gp, alpha, beta, runmtau, mixNeut, 4, 1, onetothree, 'l');
 neutralino4amplitudeneut1nuenuebar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), msnu(1), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(1), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 4, 1, onetothree, 'n');
 neutralino4amplitudeneut1numunumubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), msnu(2), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(1), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 4, 1, onetothree, 'n');
 neutralino4amplitudeneut1nutaunutaubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), msnu(3), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(1), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 4, 1, onetothree, 'n');
 neutralino4amplitudeneut2uubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), mu(1,1), mu(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(2), MUP, alphas, 0, runmw, g, gp, alpha, beta, MUP, mixNeut, 4, 2, onetothree, 'u');
 neutralino4amplitudeneut2ddbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), md(1,1), md(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(2), MDOWN, alphas, 0, runmw, g, gp, alpha, beta, MDOWN, mixNeut, 4, 2, onetothree, 'd');
 neutralino4amplitudeneut2ccbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), mu(1,2), mu(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(2), MCHARM, alphas, 0, runmw, g, gp, alpha, beta, MCHARM, mixNeut, 4, 2, onetothree, 'u');
 neutralino4amplitudeneut2ssbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), md(1,2), md(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(2), MSTRANGE, alphas, 0, runmw, g, gp, alpha, beta, MSTRANGE, mixNeut, 4, 2, onetothree, 'd');
 neutralino4amplitudeneut2ttbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), mu(1,3), mu(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(2), MTOP, alphas, thetat, runmw, g, gp, alpha, beta, runmt, mixNeut, 4, 2, onetothree, 'u');
 neutralino4amplitudeneut2bbbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), md(1,3), md(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(2), MBOTTOM, alphas, thetab, runmw, g, gp, alpha, beta, runmb, mixNeut, 4, 2, onetothree, 'd');
 neutralino4amplitudeneut2eebar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), me(1,1), me(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(2), MELECTRON, alphas, 0, runmw, g, gp, alpha, beta, MELECTRON, mixNeut, 4, 2, onetothree, 'l');
 neutralino4amplitudeneut2mumubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), me(1,2), me(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(2), MMUON, alphas, 0, runmw, g, gp, alpha, beta, MMUON, mixNeut, 4, 2, onetothree, 'l');
 neutralino4amplitudeneut2tautaubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), me(1,3), me(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(2), MTAU, alphas, thetatau-PI/2, runmw, g, gp, alpha, beta, runmtau, mixNeut, 4, 2, onetothree, 'l');
 neutralino4amplitudeneut2nuenuebar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), msnu(1), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(2), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 4, 2, onetothree, 'n');
 neutralino4amplitudeneut2numunumubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), msnu(2), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(2), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 4, 2, onetothree, 'n');
 neutralino4amplitudeneut2nutaunutaubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), msnu(3), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(2), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 4, 2, onetothree, 'n');
 neutralino4amplitudeneut3uubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), mu(1,1), mu(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(3), MUP, alphas, 0, runmw, g, gp, alpha, beta, runmu, mixNeut, 4, 3, onetothree, 'u');
 neutralino4amplitudeneut3ddbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), md(1,1), md(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(3), MDOWN, alphas, 0, runmw, g, gp, alpha, beta, runmd, mixNeut, 4, 3, onetothree, 'd');
 neutralino4amplitudeneut3ccbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), mu(1,2), mu(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(3), MCHARM, alphas, 0, runmw, g, gp, alpha, beta, runmc, mixNeut, 4, 3, onetothree, 'u');
 neutralino4amplitudeneut3ssbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), md(1,2), md(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(3), MSTRANGE, alphas, 0, runmw, g, gp, alpha, beta, runms, mixNeut, 4, 3, onetothree, 'd');
 neutralino4amplitudeneut3ttbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), mu(1,3), mu(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(3), MTOP, alphas, thetat, runmw, g, gp, alpha, beta, runmt, mixNeut, 4, 3, onetothree, 'u');
 neutralino4amplitudeneut3bbbar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), md(1,3), md(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(3), MBOTTOM, alphas, thetab, runmw, g, gp, alpha, beta, runmb, mixNeut, 4, 3, onetothree, 'd');
 neutralino4amplitudeneut3eebar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), me(1,1), me(2,1), mz, mh0(1), mh0(2), mA0(1), mneut(3), MELECTRON, alphas, 0, runmw, g, gp, alpha, beta, MELECTRON, mixNeut, 4, 3, onetothree, 'l');
 neutralino4amplitudeneut3mumubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), me(1,2), me(2,2), mz, mh0(1), mh0(2), mA0(1), mneut(3), MMUON, alphas, 0, runmw, g, gp, alpha, beta, MMUON, mixNeut, 4, 3, onetothree, 'l');
 neutralino4amplitudeneut3tautaubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), me(1,3), me(2,3), mz, mh0(1), mh0(2), mA0(1), mneut(3), MTAU, alphas, thetatau-PI/2, runmw, g, gp, alpha, beta, runmtau, mixNeut, 4, 3, onetothree, 'l');
 neutralino4amplitudeneut3nuenuebar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), msnu(1), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(3), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 4, 3, onetothree, 'n');
 neutralino4amplitudeneut3numunumubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), msnu(2), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(3), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 4, 3, onetothree, 'n');
 neutralino4amplitudeneut3nutaunutaubar = neutralinoamplitudedecaydgaussneutralinoffbar (mneut(4), msnu(3), 100000000000, mz, mh0(1), mh0(2), mA0(1), mneut(3), 0, alphas, 0, runmw, g, gp, alpha, beta, 0, mixNeut, 4, 3, onetothree, 'n');

 neutralino4amplitudechargino1udbar = neutralinoamplitudedecaycharginoffprimebar (mneut(4), mu(1,1), mu(2,1), md(1,1), md(2,1), polemw, mHpm, mch(1), MUP, MDOWN, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, runmu, runmd, mixNeut, 4, 1, onetothree, 'q', 'n');
 neutralino4amplitudechargino1csbar = neutralinoamplitudedecaycharginoffprimebar (mneut(4), mu(1,2), mu(2,2), md(1,2), md(2,2), polemw, mHpm, mch(1), MCHARM, MSTRANGE, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, runmc, runms, mixNeut, 4, 1, onetothree, 'q', 'n');
 neutralino4amplitudechargino1enuebar = neutralinoamplitudedecaycharginoffprimebar (mneut(4), me(1,1), me(2,1), msnu(1), 100000000000, polemw, mHpm, mch(1), 0, MELECTRON, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, 0, MELECTRON, mixNeut, 4, 1, onetothree, 'l', 'n');
 neutralino4amplitudechargino1munumubar = neutralinoamplitudedecaycharginoffprimebar (mneut(4), me(1,2), me(2,2), msnu(2), 100000000000, polemw, mHpm, mch(1), 0, MMUON, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, 0, MMUON, mixNeut, 4, 1, onetothree, 'l', 'n');
 neutralino4amplitudechargino1taunutaubar = neutralinoamplitudedecaycharginoffprimebar (mneut(4), me(1,3), me(2,3), msnu(3), 100000000000, polemw, mHpm, mch(1), 0, MTAU, 0, thetatau, g, gp, alphas, beta, thetaL2, thetaR2, 0, runmtau, mixNeut, 4, 1, onetothree, 'l', 'n');
 neutralino4amplitudechargino2udbar = neutralinoamplitudedecaycharginoffprimebar (mneut(4), mu(1,1), mu(2,1), md(1,1), md(2,1), polemw, mHpm, mch(2), MUP, MDOWN, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, runmu, runmd, mixNeut, 4, 2, onetothree, 'q', 'n');
 neutralino4amplitudechargino2csbar = neutralinoamplitudedecaycharginoffprimebar (mneut(4), mu(1,2), mu(2,2), md(1,2), md(2,2), polemw, mHpm, mch(2), MCHARM, MSTRANGE, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, runmc, runms, mixNeut, 4, 2, onetothree, 'q', 'n');
 neutralino4amplitudechargino2enuebar = neutralinoamplitudedecaycharginoffprimebar (mneut(4), me(1,1), me(2,1), msnu(1), 100000000000, polemw, mHpm, mch(2), 0, MELECTRON, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, 0, MELECTRON, mixNeut, 4, 2, onetothree, 'l', 'n');
 neutralino4amplitudechargino2munumubar = neutralinoamplitudedecaycharginoffprimebar (mneut(4), me(1,2), me(2,2), msnu(2), 100000000000, polemw, mHpm, mch(2), 0, MMUON, 0, 0, g, gp, alphas, beta, thetaL2, thetaR2, 0, MMUON, mixNeut, 4, 2, onetothree, 'l', 'n');
 neutralino4amplitudechargino2taunutaubar = neutralinoamplitudedecaycharginoffprimebar (mneut(4), me(1,3), me(2,3), msnu(3), 100000000000, polemw, mHpm, mch(2), 0, MTAU, 0, thetatau, g, gp, alphas, beta, thetaL2, thetaR2, 0, runmtau, mixNeut, 4, 2, onetothree, 'l', 'n');
 
   ParticleNeutralino4.Array_Decays[0][0] = -PDGup; ParticleNeutralino4.Array_Decays[0][1] = PDGsupL; ParticleNeutralino4.Array_Decays[0][2] = neutralino4amplitudeuLubar; ParticleNeutralino4.Array_Decays[0][3] = 2; ParticleNeutralino4.Array_Comments[0] = "# ~chi_40 -> ub ~u_L";
   ParticleNeutralino4.Array_Decays[1][0] = -PDGup; ParticleNeutralino4.Array_Decays[1][1] = PDGsupR; ParticleNeutralino4.Array_Decays[1][2] = neutralino4amplitudeuRubar; ParticleNeutralino4.Array_Decays[1][3] = 2; ParticleNeutralino4.Array_Comments[1] = "# ~chi_40 -> ub ~u_R";
   ParticleNeutralino4.Array_Decays[2][0] = PDGup; ParticleNeutralino4.Array_Decays[2][1] = -PDGsupL; ParticleNeutralino4.Array_Decays[2][2] = neutralino4amplitudeuLbaru; ParticleNeutralino4.Array_Decays[2][3] = 2; ParticleNeutralino4.Array_Comments[2] = "# ~chi_40 -> u ~u_L*";
   ParticleNeutralino4.Array_Decays[3][0] = PDGup; ParticleNeutralino4.Array_Decays[3][1] = -PDGsupR; ParticleNeutralino4.Array_Decays[3][2] = neutralino4amplitudeuRbaru; ParticleNeutralino4.Array_Decays[3][3] = 2; ParticleNeutralino4.Array_Comments[3] = "# ~chi_40 -> u ~u_R*";
   ParticleNeutralino4.Array_Decays[4][0] = -PDGdown; ParticleNeutralino4.Array_Decays[4][1] = PDGsdownL; ParticleNeutralino4.Array_Decays[4][2] = neutralino4amplitudedLdbar;ParticleNeutralino4.Array_Decays[4][3] = 2;  ParticleNeutralino4.Array_Comments[4] = "# ~chi_40 -> db ~d_L";
   ParticleNeutralino4.Array_Decays[5][0] = -PDGdown; ParticleNeutralino4.Array_Decays[5][1] = PDGsdownR; ParticleNeutralino4.Array_Decays[5][2] = neutralino4amplitudedRdbar; ParticleNeutralino4.Array_Decays[5][3] = 2; ParticleNeutralino4.Array_Comments[5] = "# ~chi_40 -> db ~d_R";
   ParticleNeutralino4.Array_Decays[6][0] = PDGdown; ParticleNeutralino4.Array_Decays[6][1] = -PDGsdownL; ParticleNeutralino4.Array_Decays[6][2] = neutralino4amplitudedLbard; ParticleNeutralino4.Array_Decays[6][3] = 2; ParticleNeutralino4.Array_Comments[6] = "# ~chi_40 -> d ~d_L*";
   ParticleNeutralino4.Array_Decays[7][0] = PDGdown; ParticleNeutralino4.Array_Decays[7][1] = -PDGsdownR; ParticleNeutralino4.Array_Decays[7][2] = neutralino4amplitudedRbard; ParticleNeutralino4.Array_Decays[7][3] = 2; ParticleNeutralino4.Array_Comments[7] = "# ~chi_40 -> d ~d_R*";
   ParticleNeutralino4.Array_Decays[8][0] = -PDGcharm; ParticleNeutralino4.Array_Decays[8][1] = PDGscharmL; ParticleNeutralino4.Array_Decays[8][2] = neutralino4amplitudecLcbar; ParticleNeutralino4.Array_Decays[8][3] = 2; ParticleNeutralino4.Array_Comments[8] = "# ~chi_40 -> cb ~c_L";
   ParticleNeutralino4.Array_Decays[9][0] = -PDGcharm; ParticleNeutralino4.Array_Decays[9][1] = PDGscharmR; ParticleNeutralino4.Array_Decays[9][2] = neutralino4amplitudecRcbar; ParticleNeutralino4.Array_Decays[9][3] = 2; ParticleNeutralino4.Array_Comments[9] = "# ~chi_40 -> cb ~c_R";
   ParticleNeutralino4.Array_Decays[10][0] = PDGcharm; ParticleNeutralino4.Array_Decays[10][1] = -PDGscharmL; ParticleNeutralino4.Array_Decays[10][2] = neutralino4amplitudecLbarc; ParticleNeutralino4.Array_Decays[10][3] = 2; ParticleNeutralino4.Array_Comments[10] = "# ~chi_40 -> c ~c_L*";
   ParticleNeutralino4.Array_Decays[11][0] = PDGcharm; ParticleNeutralino4.Array_Decays[11][1] = -PDGscharmR; ParticleNeutralino4.Array_Decays[11][2] = neutralino4amplitudecRbarc; ParticleNeutralino4.Array_Decays[11][3] = 2; ParticleNeutralino4.Array_Comments[11] = "# ~chi_40 -> c ~c_R*";
   ParticleNeutralino4.Array_Decays[12][0] = -PDGstrange; ParticleNeutralino4.Array_Decays[12][1] = PDGsstrangeL; ParticleNeutralino4.Array_Decays[12][2] = neutralino4amplitudesLsbar; ParticleNeutralino4.Array_Decays[12][3] = 2; ParticleNeutralino4.Array_Comments[12] = "# ~chi_40 -> sb ~s_L"; 
   ParticleNeutralino4.Array_Decays[13][0] = -PDGstrange; ParticleNeutralino4.Array_Decays[13][1] = PDGsstrangeR; ParticleNeutralino4.Array_Decays[13][2] = neutralino4amplitudesRsbar; ParticleNeutralino4.Array_Decays[13][3] = 2; ParticleNeutralino4.Array_Comments[13] = "# ~chi_40 -> sb ~s_R";
   ParticleNeutralino4.Array_Decays[14][0] = PDGstrange; ParticleNeutralino4.Array_Decays[14][1] = -PDGsstrangeL; ParticleNeutralino4.Array_Decays[14][2] = neutralino4amplitudesLbars; ParticleNeutralino4.Array_Decays[14][3] = 2; ParticleNeutralino4.Array_Comments[14] = "# ~chi_40 -> s ~s_L*";
   ParticleNeutralino4.Array_Decays[15][0] = PDGstrange; ParticleNeutralino4.Array_Decays[15][1] = -PDGsstrangeR; ParticleNeutralino4.Array_Decays[15][2] = neutralino4amplitudesRbars; ParticleNeutralino4.Array_Decays[15][3] = 2; ParticleNeutralino4.Array_Comments[15] = "# ~chi_40 -> s ~s_R*";
    ParticleNeutralino4.Array_Decays[16][0] = -PDGelectron; ParticleNeutralino4.Array_Decays[16][1] = PDGselectronL; ParticleNeutralino4.Array_Decays[16][2] = neutralino4amplitudeeLebar; ParticleNeutralino4.Array_Decays[16][3] = 2; ParticleNeutralino4.Array_Comments[16] = "# ~chi_40 -> e+ ~e_L-";
   ParticleNeutralino4.Array_Decays[17][0] = -PDGelectron; ParticleNeutralino4.Array_Decays[17][1] = PDGselectronR; ParticleNeutralino4.Array_Decays[17][2] = neutralino4amplitudeeRebar; ParticleNeutralino4.Array_Decays[17][3] = 2; ParticleNeutralino4.Array_Comments[17] = "# ~chi_40 -> e+ ~e_R-";
   ParticleNeutralino4.Array_Decays[18][0] = PDGelectron; ParticleNeutralino4.Array_Decays[18][1] = -PDGselectronL; ParticleNeutralino4.Array_Decays[18][2] = neutralino4amplitudeeLbare; ParticleNeutralino4.Array_Decays[18][3] = 2; ParticleNeutralino4.Array_Comments[18] = "# ~chi_40 -> e ~e_L+";
   ParticleNeutralino4.Array_Decays[19][0] = PDGelectron; ParticleNeutralino4.Array_Decays[19][1] = -PDGselectronR; ParticleNeutralino4.Array_Decays[19][2] = neutralino4amplitudeeRbare; ParticleNeutralino4.Array_Decays[19][3] = 2; ParticleNeutralino4.Array_Comments[19] = "# ~chi_40 -> e ~e_R+";   
   ParticleNeutralino4.Array_Decays[20][0] = -PDGmuon; ParticleNeutralino4.Array_Decays[20][1] = PDGsmuonL; ParticleNeutralino4.Array_Decays[20][2] = neutralino4amplitudemuLmubar; ParticleNeutralino4.Array_Decays[20][3] = 2; ParticleNeutralino4.Array_Comments[20] = "# ~chi_40 -> mu+ ~mu_L-";
   ParticleNeutralino4.Array_Decays[21][0] = -PDGmuon; ParticleNeutralino4.Array_Decays[21][1] = PDGsmuonR; ParticleNeutralino4.Array_Decays[21][2] = neutralino4amplitudemuRmubar; ParticleNeutralino4.Array_Decays[21][3] = 2; ParticleNeutralino4.Array_Comments[21] = "# ~chi_40 -> mu+ ~mu_R-";
   ParticleNeutralino4.Array_Decays[22][0] = PDGmuon; ParticleNeutralino4.Array_Decays[22][1] = -PDGsmuonL; ParticleNeutralino4.Array_Decays[22][2] = neutralino4amplitudemuLbarmu; ParticleNeutralino4.Array_Decays[22][3] = 2; ParticleNeutralino4.Array_Comments[22] = "# ~chi_40 -> mu- ~mu_L+";
   ParticleNeutralino4.Array_Decays[23][0] = PDGmuon; ParticleNeutralino4.Array_Decays[23][1] = -PDGsmuonR; ParticleNeutralino4.Array_Decays[23][2] = neutralino4amplitudemuRbarmu; ParticleNeutralino4.Array_Decays[23][3] = 2; ParticleNeutralino4.Array_Comments[23] = "# ~chi_40 -> mu- ~mu_R+";
   ParticleNeutralino4.Array_Decays[24][0] = PDGnuelectron; ParticleNeutralino4.Array_Decays[24][1] = -PDGnuselectronL; ParticleNeutralino4.Array_Decays[24][2] = neutralino4amplitudesnuebarnue; ParticleNeutralino4.Array_Decays[24][3] = 2; ParticleNeutralino4.Array_Comments[24] = "# ~chi_40 -> nu_e ~nu_eL*";
   ParticleNeutralino4.Array_Decays[25][0] = -PDGnuelectron; ParticleNeutralino4.Array_Decays[25][1] = PDGnuselectronL; ParticleNeutralino4.Array_Decays[25][2] = neutralino4amplitudesnuenuebar; ParticleNeutralino4.Array_Decays[25][3] = 2; ParticleNeutralino4.Array_Comments[25] = "# ~chi_40 -> nu_eb ~nu_eL";
   ParticleNeutralino4.Array_Decays[26][0] = PDGnumuon; ParticleNeutralino4.Array_Decays[26][1] = -PDGnusmuonL; ParticleNeutralino4.Array_Decays[26][2] = neutralino4amplitudesnumubarnumu; ParticleNeutralino4.Array_Decays[26][3] = 2; ParticleNeutralino4.Array_Comments[26] = "# ~chi_40 -> numu ~nu_muL*";
   ParticleNeutralino4.Array_Decays[27][0] = -PDGnumuon; ParticleNeutralino4.Array_Decays[27][1] = PDGnusmuonL; ParticleNeutralino4.Array_Decays[27][2] = neutralino4amplitudesnumunumubar; ParticleNeutralino4.Array_Decays[27][3] = 2; ParticleNeutralino4.Array_Comments[27] = "# ~chi_40 -> nu_mub ~nu_uL";
   ParticleNeutralino4.Array_Decays[28][0] = PDGtop; ParticleNeutralino4.Array_Decays[28][1] = -PDGstop1; ParticleNeutralino4.Array_Decays[28][2] = neutralino4amplitudetopstop1bar; ParticleNeutralino4.Array_Decays[28][3] = 2; ParticleNeutralino4.Array_Comments[28] = "# ~chi_40 -> t ~t_1*";
   ParticleNeutralino4.Array_Decays[29][0] = PDGtop; ParticleNeutralino4.Array_Decays[29][1] = -PDGstop2; ParticleNeutralino4.Array_Decays[29][2] = neutralino4amplitudetopstop2bar; ParticleNeutralino4.Array_Decays[29][3] = 2; ParticleNeutralino4.Array_Comments[29] = "# ~chi_40 -> t ~t_2*";
   ParticleNeutralino4.Array_Decays[30][0] = -PDGtop; ParticleNeutralino4.Array_Decays[30][1] = PDGstop1; ParticleNeutralino4.Array_Decays[30][2] = neutralino4amplitudetopbarstop1; ParticleNeutralino4.Array_Decays[30][3] = 2; ParticleNeutralino4.Array_Comments[30] = "# ~chi_40 -> tb ~t_1";
   ParticleNeutralino4.Array_Decays[31][0] = -PDGtop; ParticleNeutralino4.Array_Decays[31][1] = PDGstop2; ParticleNeutralino4.Array_Decays[31][2] = neutralino4amplitudetopbarstop2; ParticleNeutralino4.Array_Decays[31][3] = 2; ParticleNeutralino4.Array_Comments[31] = "# ~chi_40 -> tb ~t_2";
   ParticleNeutralino4.Array_Decays[32][0] = PDGbottom; ParticleNeutralino4.Array_Decays[32][1] = -PDGsbottom1; ParticleNeutralino4.Array_Decays[32][2] = neutralino4amplitudebottomsbottom1bar; ParticleNeutralino4.Array_Decays[32][3] = 2; ParticleNeutralino4.Array_Comments[32] = "# ~chi_40 -> b ~b_1*";
   ParticleNeutralino4.Array_Decays[33][0] = PDGbottom; ParticleNeutralino4.Array_Decays[33][1] = -PDGsbottom2; ParticleNeutralino4.Array_Decays[33][2] = neutralino4amplitudebottomsbottom2bar; ParticleNeutralino4.Array_Decays[33][3] = 2; ParticleNeutralino4.Array_Comments[33] = "# ~chi_40 -> b ~b_2*";
   ParticleNeutralino4.Array_Decays[34][0] = -PDGbottom; ParticleNeutralino4.Array_Decays[34][1] = PDGsbottom1; ParticleNeutralino4.Array_Decays[34][2] = neutralino4amplitudebottombarsbottom1; ParticleNeutralino4.Array_Decays[34][3] = 2; ParticleNeutralino4.Array_Comments[34] = "# ~chi_40 -> bb ~b_1*";
   ParticleNeutralino4.Array_Decays[35][0] = -PDGbottom; ParticleNeutralino4.Array_Decays[35][1] = PDGsbottom2; ParticleNeutralino4.Array_Decays[35][2] = neutralino4amplitudebottombarsbottom2; ParticleNeutralino4.Array_Decays[35][3] = 2; ParticleNeutralino4.Array_Comments[35] = "# ~chi_40 -> bb ~b_2*";
   ParticleNeutralino4.Array_Decays[36][0] = -PDGstau1; ParticleNeutralino4.Array_Decays[36][1] = PDGtau; ParticleNeutralino4.Array_Decays[36][2] = neutralino4amplitudetaustau1bar; ParticleNeutralino4.Array_Decays[36][3] = 2; ParticleNeutralino4.Array_Comments[36] = "# ~chi_40 -> tau- ~tau_1+";
   ParticleNeutralino4.Array_Decays[37][0] = -PDGstau2; ParticleNeutralino4.Array_Decays[37][1] = PDGtau; ParticleNeutralino4.Array_Decays[37][2] = neutralino4amplitudetaustau2bar; ParticleNeutralino4.Array_Decays[37][3] = 2; ParticleNeutralino4.Array_Comments[37] = "# ~chi_40 -> tau- ~tau_2+";
   ParticleNeutralino4.Array_Decays[38][0] = PDGstau1; ParticleNeutralino4.Array_Decays[38][1] = -PDGtau; ParticleNeutralino4.Array_Decays[38][2] = neutralino4amplitudetaubarstau1; ParticleNeutralino4.Array_Decays[38][3] = 2; ParticleNeutralino4.Array_Comments[38] = "# ~chi_40 -> tau+ ~tau_1-";
   ParticleNeutralino4.Array_Decays[39][0] = PDGstau2; ParticleNeutralino4.Array_Decays[39][1] = -PDGtau; ParticleNeutralino4.Array_Decays[39][2] = neutralino4amplitudetaubarstau2; ParticleNeutralino4.Array_Decays[39][3] = 2; ParticleNeutralino4.Array_Comments[39] = "# ~chi_40 -> tau+ ~tau_2-";
   ParticleNeutralino4.Array_Decays[40][0] = PDGnutau; ParticleNeutralino4.Array_Decays[40][1] = -PDGnustauL; ParticleNeutralino4.Array_Decays[40][2] = neutralino4amplitudenutausnutaubar; ParticleNeutralino4.Array_Decays[40][3] = 2; ParticleNeutralino4.Array_Comments[40] = "# ~chi_40 -> nu_tau ~nu_tauL*";
  ParticleNeutralino4.Array_Decays[41][0] = -PDGnutau; ParticleNeutralino4.Array_Decays[41][1] = PDGnustauL; ParticleNeutralino4.Array_Decays[41][2] = neutralino4amplitudenutaubarsnutau; ParticleNeutralino4.Array_Decays[41][3] = 2; ParticleNeutralino4.Array_Comments[41] = "# ~chi_40 -> nu_taub ~nu_tauL";
  ParticleNeutralino4.Array_Decays[42][0] = PDGWplus; ParticleNeutralino4.Array_Decays[42][1] = -PDGchargino1; ParticleNeutralino4.Array_Decays[42][2] = neutralino4amplitudeWbosonpluscharginoW1; ParticleNeutralino4.Array_Decays[42][3] = 2; ParticleNeutralino4.Array_Comments[42] = "# ~chi_40 -> W+ ~chi_1-";
   ParticleNeutralino4.Array_Decays[43][0] = PDGWplus; ParticleNeutralino4.Array_Decays[43][1] = -PDGchargino2; ParticleNeutralino4.Array_Decays[43][2] = neutralino4amplitudeWbosonpluscharginoW2; ParticleNeutralino4.Array_Decays[43][3] = 2; ParticleNeutralino4.Array_Comments[43] = "# ~chi_40 -> W+ ~chi_2-";
   ParticleNeutralino4.Array_Decays[44][0] = -PDGWplus; ParticleNeutralino4.Array_Decays[44][1] = PDGchargino1; ParticleNeutralino4.Array_Decays[44][2] = neutralino4amplitudeWbosonminuscharginoW1; ParticleNeutralino4.Array_Decays[44][3] = 2; ParticleNeutralino4.Array_Comments[44] = "# ~chi_40 -> W- ~chi_1+";
   ParticleNeutralino4.Array_Decays[45][0] = -PDGWplus; ParticleNeutralino4.Array_Decays[45][1] = PDGchargino2; ParticleNeutralino4.Array_Decays[45][2] = neutralino4amplitudeWbosonminuscharginoW2; ParticleNeutralino4.Array_Decays[45][3] = 2; ParticleNeutralino4.Array_Comments[45] = "# ~chi_40 -> W- ~chi_2+";
   ParticleNeutralino4.Array_Decays[46][0] = PDGHplus; ParticleNeutralino4.Array_Decays[46][1] = -PDGchargino1; ParticleNeutralino4.Array_Decays[46][2] = neutralino4amplitudeHpluscharginoW1; ParticleNeutralino4.Array_Decays[46][3] = 2; ParticleNeutralino4.Array_Comments[46] = "# ~chi_40 -> H+ ~chi_1-";
   ParticleNeutralino4.Array_Decays[47][0] = PDGHplus; ParticleNeutralino4.Array_Decays[47][1] = -PDGchargino2; ParticleNeutralino4.Array_Decays[47][2] = neutralino4amplitudeHpluscharginoW2; ParticleNeutralino4.Array_Decays[47][3] = 2; ParticleNeutralino4.Array_Comments[47] = "# ~chi_40 -> H+ ~chi_2-";
   ParticleNeutralino4.Array_Decays[48][0] = -PDGHplus; ParticleNeutralino4.Array_Decays[48][1] = PDGchargino1; ParticleNeutralino4.Array_Decays[48][2] = neutralino4amplitudeHminuscharginoW1; ParticleNeutralino4.Array_Decays[48][3] = 2; ParticleNeutralino4.Array_Comments[48] = "# ~chi_40 -> H- ~chi_1+";
   ParticleNeutralino4.Array_Decays[49][0] = -PDGHplus; ParticleNeutralino4.Array_Decays[49][1] = PDGchargino2; ParticleNeutralino4.Array_Decays[49][2] = neutralino4amplitudeHminuscharginoW2; ParticleNeutralino4.Array_Decays[49][3] = 2; ParticleNeutralino4.Array_Comments[49] = "# ~chi_40 -> H- ~chi_2+";
   ParticleNeutralino4.Array_Decays[50][0] = PDGZboson; ParticleNeutralino4.Array_Decays[50][1] = PDGneutralino1; ParticleNeutralino4.Array_Decays[50][2] = neutralino4amplitudeZbosonneutralino1; ParticleNeutralino4.Array_Decays[50][3] = 2; ParticleNeutralino4.Array_Comments[50] = "# ~chi_40 -> Z ~chi_10";
   ParticleNeutralino4.Array_Decays[51][0] = PDGZboson; ParticleNeutralino4.Array_Decays[51][1] = PDGneutralino2; ParticleNeutralino4.Array_Decays[51][2] = neutralino4amplitudeZbosonneutralino2; ParticleNeutralino4.Array_Decays[51][3] = 2; ParticleNeutralino4.Array_Comments[51] = "# ~chi_40 -> Z ~chi_20";
   ParticleNeutralino4.Array_Decays[52][0] = PDGZboson; ParticleNeutralino4.Array_Decays[52][1] = PDGneutralino3; ParticleNeutralino4.Array_Decays[52][2] = neutralino4amplitudeZbosonneutralino3; ParticleNeutralino4.Array_Decays[52][3] = 2; ParticleNeutralino4.Array_Comments[52] = "# ~chi_40 -> Z ~chi_30";
   ParticleNeutralino4.Array_Decays[53][0] = PDGh0; ParticleNeutralino4.Array_Decays[53][1] = PDGneutralino1; ParticleNeutralino4.Array_Decays[53][2] = neutralino4amplitudehneutralino1; ParticleNeutralino4.Array_Decays[53][3] = 2; ParticleNeutralino4.Array_Comments[53] = "# ~chi_40 -> h ~chi_10";
   ParticleNeutralino4.Array_Decays[54][0] = PDGh0; ParticleNeutralino4.Array_Decays[54][1] = PDGneutralino2; ParticleNeutralino4.Array_Decays[54][2] = neutralino4amplitudehneutralino2; ParticleNeutralino4.Array_Decays[54][3] = 2; ParticleNeutralino4.Array_Comments[54] = "# ~chi_40 -> h ~chi_20"; 
   ParticleNeutralino4.Array_Decays[55][0] = PDGh0; ParticleNeutralino4.Array_Decays[55][1] = PDGneutralino3; ParticleNeutralino4.Array_Decays[55][2] = neutralino4amplitudehneutralino3; ParticleNeutralino4.Array_Decays[55][3] = 2; ParticleNeutralino4.Array_Comments[55] = "# ~chi_40 -> h ~chi_30";
   ParticleNeutralino4.Array_Decays[56][0] = PDGH0; ParticleNeutralino4.Array_Decays[56][1] = PDGneutralino1; ParticleNeutralino4.Array_Decays[56][2] = neutralino4amplitudeHneutralino1; ParticleNeutralino4.Array_Decays[56][3] = 2; ParticleNeutralino4.Array_Comments[56] = "# ~chi_40 -> H ~chi_10";
   ParticleNeutralino4.Array_Decays[57][0] = PDGH0; ParticleNeutralino4.Array_Decays[57][1] = PDGneutralino2; ParticleNeutralino4.Array_Decays[57][2] = neutralino4amplitudeHneutralino2; ParticleNeutralino4.Array_Decays[57][3] = 2; ParticleNeutralino4.Array_Comments[57] = "# ~chi_40 -> H ~chi_20";
   ParticleNeutralino4.Array_Decays[58][0] = PDGH0; ParticleNeutralino4.Array_Decays[58][1] = PDGneutralino3; ParticleNeutralino4.Array_Decays[58][2] = neutralino4amplitudeHneutralino3; ParticleNeutralino4.Array_Decays[58][3] = 2; ParticleNeutralino4.Array_Comments[58] = "# ~chi_40 -> H ~chi_30";
   ParticleNeutralino4.Array_Decays[59][0] = PDGA0; ParticleNeutralino4.Array_Decays[59][1] = PDGneutralino1; ParticleNeutralino4.Array_Decays[59][2] = neutralino4amplitudeAneutralino1; ParticleNeutralino4.Array_Decays[59][3] = 2; ParticleNeutralino4.Array_Comments[59] = "# ~chi_40 -> A ~chi_10";
   ParticleNeutralino4.Array_Decays[60][0] = PDGA0; ParticleNeutralino4.Array_Decays[60][1] = PDGneutralino2; ParticleNeutralino4.Array_Decays[60][2] = neutralino4amplitudeAneutralino2; ParticleNeutralino4.Array_Decays[60][3] = 2; ParticleNeutralino4.Array_Comments[60] = "# ~chi_40 -> A ~chi_20";
   ParticleNeutralino4.Array_Decays[61][0] = PDGA0; ParticleNeutralino4.Array_Decays[61][1] = PDGneutralino3; ParticleNeutralino4.Array_Decays[61][2] = neutralino4amplitudeAneutralino3; ParticleNeutralino4.Array_Decays[61][3] = 2; ParticleNeutralino4.Array_Comments[61] = "# ~chi_40 -> A ~chi_30";

   ParticleNeutralino4.Array_Decays[62][0] = PDGphoton; ParticleNeutralino4.Array_Decays[62][1] = PDGgravitino; ParticleNeutralino4.Array_Decays[62][2] = neutralino4amplitudephotongravitino; ParticleNeutralino4.Array_Decays[62][3] = 2; ParticleNeutralino4.Array_Comments[62] = "# ~chi_40 -> gamma ~G";
   ParticleNeutralino4.Array_Decays[63][0] = PDGZboson; ParticleNeutralino4.Array_Decays[63][1] = PDGgravitino; ParticleNeutralino4.Array_Decays[63][2] = neutralino4amplitudeZgravitino; ParticleNeutralino4.Array_Decays[63][3] = 2; ParticleNeutralino4.Array_Comments[63] = "# ~chi_40 -> Z ~G";
   ParticleNeutralino4.Array_Decays[64][0] = PDGh0; ParticleNeutralino4.Array_Decays[64][1] = PDGgravitino; ParticleNeutralino4.Array_Decays[64][2] = neutralino4amplitudehgravitino; ParticleNeutralino4.Array_Decays[64][3] = 2; ParticleNeutralino4.Array_Comments[64] = "# ~chi_40 -> h ~G";
   ParticleNeutralino4.Array_Decays[65][0] = PDGH0; ParticleNeutralino4.Array_Decays[65][1] = PDGgravitino; ParticleNeutralino4.Array_Decays[65][2] = neutralino4amplitudeHgravitino; ParticleNeutralino4.Array_Decays[65][3] = 2; ParticleNeutralino4.Array_Comments[65] = "# ~chi_40 -> H ~G";
   ParticleNeutralino4.Array_Decays[66][0] = PDGA0; ParticleNeutralino4.Array_Decays[66][1] = PDGgravitino; ParticleNeutralino4.Array_Decays[66][2] = neutralino4amplitudeAgravitino; ParticleNeutralino4.Array_Decays[66][3] = 2; ParticleNeutralino4.Array_Comments[66] = "# ~chi_40 -> A ~G";
   
   ParticleNeutralino4.Array_Decays[67][0] = PDGneutralino1; ParticleNeutralino4.Array_Decays[67][1] = PDGup; ParticleNeutralino4.Array_Decays[67][4] = -PDGup; ParticleNeutralino4.Array_Decays[67][2] = neutralino4amplitudeneut1uubar; ParticleNeutralino4.Array_Decays[67][3] = 3; ParticleNeutralino4.Array_Comments[67] = "# ~chi_40 -> ~chi_10 u ubar";
  ParticleNeutralino4.Array_Decays[68][0] = PDGneutralino1; ParticleNeutralino4.Array_Decays[68][1] = PDGdown; ParticleNeutralino4.Array_Decays[68][4] = -PDGdown; ParticleNeutralino4.Array_Decays[68][2] = neutralino4amplitudeneut1ddbar; ParticleNeutralino4.Array_Decays[68][3] = 3; ParticleNeutralino4.Array_Comments[63] = "# ~chi_40 -> ~chi_10 d dbar";
  ParticleNeutralino4.Array_Decays[69][0] = PDGneutralino1; ParticleNeutralino4.Array_Decays[69][1] = PDGcharm; ParticleNeutralino4.Array_Decays[69][4] = -PDGcharm; ParticleNeutralino4.Array_Decays[69][2] = neutralino4amplitudeneut1ccbar; ParticleNeutralino4.Array_Decays[69][3] = 3; ParticleNeutralino4.Array_Comments[69] = "# ~chi_40 -> ~chi_10 c cbar";
  ParticleNeutralino4.Array_Decays[70][0] = PDGneutralino1; ParticleNeutralino4.Array_Decays[70][1] = PDGstrange; ParticleNeutralino4.Array_Decays[70][4] = -PDGstrange; ParticleNeutralino4.Array_Decays[70][2] = neutralino4amplitudeneut1ssbar; ParticleNeutralino4.Array_Decays[70][3] = 3; ParticleNeutralino4.Array_Comments[70] = "# ~chi_40 -> ~chi_10 s sbar";
  ParticleNeutralino4.Array_Decays[70][0] = PDGneutralino1; ParticleNeutralino4.Array_Decays[70][1] = PDGtop; ParticleNeutralino4.Array_Decays[70][4] = -PDGtop; ParticleNeutralino4.Array_Decays[70][2] = neutralino4amplitudeneut1ttbar; ParticleNeutralino4.Array_Decays[70][3] = 3; ParticleNeutralino4.Array_Comments[70] = "# ~chi_40 -> ~chi_10 t tbar";
  ParticleNeutralino4.Array_Decays[71][0] = PDGneutralino1; ParticleNeutralino4.Array_Decays[71][1] = PDGbottom; ParticleNeutralino4.Array_Decays[71][4] = -PDGbottom; ParticleNeutralino4.Array_Decays[71][2] = neutralino4amplitudeneut1bbbar; ParticleNeutralino4.Array_Decays[71][3] = 3; ParticleNeutralino4.Array_Comments[71] = "# ~chi_40 -> ~chi_10 b bbar";
  ParticleNeutralino4.Array_Decays[72][0] = PDGneutralino1; ParticleNeutralino4.Array_Decays[72][1] = PDGelectron; ParticleNeutralino4.Array_Decays[72][4] = -PDGelectron; ParticleNeutralino4.Array_Decays[72][2] = neutralino4amplitudeneut1eebar; ParticleNeutralino4.Array_Decays[72][3] = 3; ParticleNeutralino4.Array_Comments[72] = "# ~chi_40 -> ~chi_10 e- e+";
  ParticleNeutralino4.Array_Decays[73][0] = PDGneutralino1; ParticleNeutralino4.Array_Decays[73][1] = PDGmuon; ParticleNeutralino4.Array_Decays[73][4] = -PDGmuon; ParticleNeutralino4.Array_Decays[73][2] = neutralino4amplitudeneut1mumubar; ParticleNeutralino4.Array_Decays[73][3] = 3; ParticleNeutralino4.Array_Comments[73] = "# ~chi_40 -> ~chi_10 mu- mu+";
  ParticleNeutralino4.Array_Decays[74][0] = PDGneutralino1; ParticleNeutralino4.Array_Decays[74][1] = PDGtau; ParticleNeutralino4.Array_Decays[74][4] = -PDGtau; ParticleNeutralino4.Array_Decays[74][2] = neutralino4amplitudeneut1tautaubar; ParticleNeutralino4.Array_Decays[74][3] = 3; ParticleNeutralino4.Array_Comments[74] = "# ~chi_40 -> ~chi_10 tau- tau+";
  ParticleNeutralino4.Array_Decays[75][0] = PDGneutralino1; ParticleNeutralino4.Array_Decays[75][1] = PDGnuelectron; ParticleNeutralino4.Array_Decays[75][4] = -PDGnuelectron; ParticleNeutralino4.Array_Decays[75][2] = neutralino4amplitudeneut1nuenuebar; ParticleNeutralino4.Array_Decays[75][3] = 3; ParticleNeutralino4.Array_Comments[75] = "# ~chi_40 -> ~chi_10 nue nuebar";
  ParticleNeutralino4.Array_Decays[76][0] = PDGneutralino1; ParticleNeutralino4.Array_Decays[76][1] = PDGnumuon; ParticleNeutralino4.Array_Decays[76][4] = -PDGnumuon; ParticleNeutralino4.Array_Decays[76][2] = neutralino4amplitudeneut1numunumubar; ParticleNeutralino4.Array_Decays[76][3] = 3; ParticleNeutralino4.Array_Comments[76] = "# ~chi_40 -> ~chi_10 numu numubar";
  ParticleNeutralino4.Array_Decays[77][0] = PDGneutralino1; ParticleNeutralino4.Array_Decays[77][1] = PDGnutau; ParticleNeutralino4.Array_Decays[77][4] = -PDGnutau; ParticleNeutralino4.Array_Decays[77][2] = neutralino4amplitudeneut1nutaunutaubar; ParticleNeutralino4.Array_Decays[77][3] = 3; ParticleNeutralino4.Array_Comments[77] = "# ~chi_40 -> ~chi_10 nutau nutaubar";
   ParticleNeutralino4.Array_Decays[78][0] = PDGneutralino2; ParticleNeutralino4.Array_Decays[78][1] = PDGup; ParticleNeutralino4.Array_Decays[78][4] = -PDGup; ParticleNeutralino4.Array_Decays[78][2] = neutralino4amplitudeneut2uubar; ParticleNeutralino4.Array_Decays[78][3] = 3; ParticleNeutralino4.Array_Comments[78] = "# ~chi_40 -> ~chi_20 u ubar";
  ParticleNeutralino4.Array_Decays[79][0] = PDGneutralino2; ParticleNeutralino4.Array_Decays[79][1] = PDGdown; ParticleNeutralino4.Array_Decays[79][4] = -PDGdown; ParticleNeutralino4.Array_Decays[79][2] = neutralino4amplitudeneut2ddbar; ParticleNeutralino4.Array_Decays[79][3] = 3; ParticleNeutralino4.Array_Comments[79] = "# ~chi_40 -> ~chi_20 d dbar";
  ParticleNeutralino4.Array_Decays[80][0] = PDGneutralino2; ParticleNeutralino4.Array_Decays[80][1] = PDGcharm; ParticleNeutralino4.Array_Decays[80][4] = -PDGcharm; ParticleNeutralino4.Array_Decays[80][2] = neutralino4amplitudeneut2ccbar; ParticleNeutralino4.Array_Decays[80][3] = 3; ParticleNeutralino4.Array_Comments[80] = "# ~chi_40 -> ~chi_20 c cbar";
  ParticleNeutralino4.Array_Decays[81][0] = PDGneutralino2; ParticleNeutralino4.Array_Decays[81][1] = PDGstrange; ParticleNeutralino4.Array_Decays[81][4] = -PDGstrange; ParticleNeutralino4.Array_Decays[81][2] = neutralino4amplitudeneut2ssbar; ParticleNeutralino4.Array_Decays[81][3] = 3; ParticleNeutralino4.Array_Comments[81] = "# ~chi_40 -> ~chi_20 s sbar";
  ParticleNeutralino4.Array_Decays[82][0] = PDGneutralino2; ParticleNeutralino4.Array_Decays[82][1] = PDGtop; ParticleNeutralino4.Array_Decays[82][4] = -PDGtop; ParticleNeutralino4.Array_Decays[82][2] = neutralino4amplitudeneut2ttbar; ParticleNeutralino4.Array_Decays[82][3] = 3; ParticleNeutralino4.Array_Comments[82] = "# ~chi_40 -> ~chi_20 t tbar";
  ParticleNeutralino4.Array_Decays[83][0] = PDGneutralino2; ParticleNeutralino4.Array_Decays[83][1] = PDGbottom; ParticleNeutralino4.Array_Decays[83][4] = -PDGbottom; ParticleNeutralino4.Array_Decays[83][2] = neutralino4amplitudeneut2bbbar; ParticleNeutralino4.Array_Decays[83][3] = 3; ParticleNeutralino4.Array_Comments[83] = "# ~chi_40 -> ~chi_20 b bbar";
  ParticleNeutralino4.Array_Decays[84][0] = PDGneutralino2; ParticleNeutralino4.Array_Decays[84][1] = PDGelectron; ParticleNeutralino4.Array_Decays[84][4] = -PDGelectron; ParticleNeutralino4.Array_Decays[84][2] = neutralino4amplitudeneut2eebar; ParticleNeutralino4.Array_Decays[84][3] = 3; ParticleNeutralino4.Array_Comments[84] = "# ~chi_40 -> ~chi_20 e- e+";
  ParticleNeutralino4.Array_Decays[85][0] = PDGneutralino2; ParticleNeutralino4.Array_Decays[85][1] = PDGmuon; ParticleNeutralino4.Array_Decays[85][4] = -PDGmuon; ParticleNeutralino4.Array_Decays[85][2] = neutralino4amplitudeneut2mumubar; ParticleNeutralino4.Array_Decays[85][3] = 3; ParticleNeutralino4.Array_Comments[85] = "# ~chi_40 -> ~chi_20 mu- mu+";
  ParticleNeutralino4.Array_Decays[86][0] = PDGneutralino2; ParticleNeutralino4.Array_Decays[86][1] = PDGtau; ParticleNeutralino4.Array_Decays[86][4] = -PDGtau; ParticleNeutralino4.Array_Decays[86][2] = neutralino4amplitudeneut2tautaubar; ParticleNeutralino4.Array_Decays[86][3] = 3; ParticleNeutralino4.Array_Comments[86] = "# ~chi_40 -> ~chi_20 tau- tau+";
  ParticleNeutralino4.Array_Decays[87][0] = PDGneutralino2; ParticleNeutralino4.Array_Decays[87][1] = PDGnuelectron; ParticleNeutralino4.Array_Decays[87][4] = -PDGnuelectron; ParticleNeutralino4.Array_Decays[87][2] = neutralino4amplitudeneut2nuenuebar; ParticleNeutralino4.Array_Decays[87][3] = 3; ParticleNeutralino4.Array_Comments[87] = "# ~chi_40 -> ~chi_20 nue nuebar";
  ParticleNeutralino4.Array_Decays[88][0] = PDGneutralino2; ParticleNeutralino4.Array_Decays[88][1] = PDGnumuon; ParticleNeutralino4.Array_Decays[88][4] = -PDGnumuon; ParticleNeutralino4.Array_Decays[88][2] = neutralino4amplitudeneut2numunumubar; ParticleNeutralino4.Array_Decays[88][3] = 3; ParticleNeutralino4.Array_Comments[88] = "# ~chi_40 -> ~chi_20 numu numubar";
  ParticleNeutralino4.Array_Decays[89][0] = PDGneutralino2; ParticleNeutralino4.Array_Decays[89][1] = PDGnutau; ParticleNeutralino4.Array_Decays[89][4] = -PDGnutau; ParticleNeutralino4.Array_Decays[89][2] = neutralino4amplitudeneut2nutaunutaubar; ParticleNeutralino4.Array_Decays[89][3] = 3; ParticleNeutralino4.Array_Comments[89] = "# ~chi_40 -> ~chi_20 nutau nutaubar";
     ParticleNeutralino4.Array_Decays[90][0] = PDGneutralino3; ParticleNeutralino4.Array_Decays[90][1] = PDGup; ParticleNeutralino4.Array_Decays[90][4] = -PDGup; ParticleNeutralino4.Array_Decays[90][2] = neutralino4amplitudeneut3uubar; ParticleNeutralino4.Array_Decays[90][3] = 3; ParticleNeutralino4.Array_Comments[90] = "# ~chi_40 -> ~chi_30 u ubar";
  ParticleNeutralino4.Array_Decays[91][0] = PDGneutralino3; ParticleNeutralino4.Array_Decays[91][1] = PDGdown; ParticleNeutralino4.Array_Decays[91][4] = -PDGdown; ParticleNeutralino4.Array_Decays[91][2] = neutralino4amplitudeneut3ddbar; ParticleNeutralino4.Array_Decays[91][3] = 3; ParticleNeutralino4.Array_Comments[91] = "# ~chi_40 -> ~chi_30 d dbar";
  ParticleNeutralino4.Array_Decays[92][0] = PDGneutralino3; ParticleNeutralino4.Array_Decays[92][1] = PDGcharm; ParticleNeutralino4.Array_Decays[92][4] = -PDGcharm; ParticleNeutralino4.Array_Decays[92][2] = neutralino4amplitudeneut3ccbar; ParticleNeutralino4.Array_Decays[92][3] = 3; ParticleNeutralino4.Array_Comments[92] = "# ~chi_40 -> ~chi_30 c cbar";
  ParticleNeutralino4.Array_Decays[93][0] = PDGneutralino3; ParticleNeutralino4.Array_Decays[93][1] = PDGstrange; ParticleNeutralino4.Array_Decays[93][4] = -PDGstrange; ParticleNeutralino4.Array_Decays[93][2] = neutralino4amplitudeneut3ssbar; ParticleNeutralino4.Array_Decays[93][3] = 3; ParticleNeutralino4.Array_Comments[93] = "# ~chi_40 -> ~chi_30 s sbar";
  ParticleNeutralino4.Array_Decays[94][0] = PDGneutralino3; ParticleNeutralino4.Array_Decays[94][1] = PDGtop; ParticleNeutralino4.Array_Decays[94][4] = -PDGtop; ParticleNeutralino4.Array_Decays[94][2] = neutralino4amplitudeneut3ttbar; ParticleNeutralino4.Array_Decays[94][3] = 3; ParticleNeutralino4.Array_Comments[94] = "# ~chi_40 -> ~chi_30 t tbar";
  ParticleNeutralino4.Array_Decays[95][0] = PDGneutralino3; ParticleNeutralino4.Array_Decays[95][1] = PDGbottom; ParticleNeutralino4.Array_Decays[95][4] = -PDGbottom; ParticleNeutralino4.Array_Decays[95][2] = neutralino4amplitudeneut3bbbar; ParticleNeutralino4.Array_Decays[95][3] = 3; ParticleNeutralino4.Array_Comments[95] = "# ~chi_40 -> ~chi_30 b bbar";
  ParticleNeutralino4.Array_Decays[96][0] = PDGneutralino3; ParticleNeutralino4.Array_Decays[96][1] = PDGelectron; ParticleNeutralino4.Array_Decays[96][4] = -PDGelectron; ParticleNeutralino4.Array_Decays[96][2] = neutralino4amplitudeneut3eebar; ParticleNeutralino4.Array_Decays[96][3] = 3; ParticleNeutralino4.Array_Comments[96] = "# ~chi_40 -> ~chi_30 e- e+";
  ParticleNeutralino4.Array_Decays[97][0] = PDGneutralino3; ParticleNeutralino4.Array_Decays[97][1] = PDGmuon; ParticleNeutralino4.Array_Decays[97][4] = -PDGmuon; ParticleNeutralino4.Array_Decays[97][2] = neutralino4amplitudeneut3mumubar; ParticleNeutralino4.Array_Decays[97][3] = 3; ParticleNeutralino4.Array_Comments[97] = "# ~chi_40 -> ~chi_30 mu- mu+";
  ParticleNeutralino4.Array_Decays[98][0] = PDGneutralino3; ParticleNeutralino4.Array_Decays[98][1] = PDGtau; ParticleNeutralino4.Array_Decays[98][4] = -PDGtau; ParticleNeutralino4.Array_Decays[98][2] = neutralino4amplitudeneut3tautaubar; ParticleNeutralino4.Array_Decays[98][3] = 3; ParticleNeutralino4.Array_Comments[98] = "# ~chi_40 -> ~chi_30 tau- tau+";
  ParticleNeutralino4.Array_Decays[99][0] = PDGneutralino3; ParticleNeutralino4.Array_Decays[99][1] = PDGnuelectron; ParticleNeutralino4.Array_Decays[99][4] = -PDGnuelectron; ParticleNeutralino4.Array_Decays[99][2] = neutralino4amplitudeneut3nuenuebar; ParticleNeutralino4.Array_Decays[99][3] = 3; ParticleNeutralino4.Array_Comments[99] = "# ~chi_40 -> ~chi_30 nue nuebar";
  ParticleNeutralino4.Array_Decays[100][0] = PDGneutralino3; ParticleNeutralino4.Array_Decays[100][1] = PDGnumuon; ParticleNeutralino4.Array_Decays[100][4] = -PDGnumuon; ParticleNeutralino4.Array_Decays[100][2] = neutralino4amplitudeneut3numunumubar; ParticleNeutralino4.Array_Decays[100][3] = 3; ParticleNeutralino4.Array_Comments[100] = "# ~chi_40 -> ~chi_30 numu numubar";
  ParticleNeutralino4.Array_Decays[101][0] = PDGneutralino3; ParticleNeutralino4.Array_Decays[101][1] = PDGnutau; ParticleNeutralino4.Array_Decays[101][4] = -PDGnutau; ParticleNeutralino4.Array_Decays[101][2] = neutralino4amplitudeneut3nutaunutaubar; ParticleNeutralino4.Array_Decays[101][3] = 3; ParticleNeutralino4.Array_Comments[101] = "# ~chi_40 -> ~chi_30 nutau nutaubar";

  ParticleNeutralino4.Array_Decays[102][0] = PDGchargino1; ParticleNeutralino4.Array_Decays[102][1] = PDGup; ParticleNeutralino4.Array_Decays[102][4] = -PDGdown; ParticleNeutralino4.Array_Decays[102][2] = neutralino4amplitudechargino1udbar; ParticleNeutralino4.Array_Decays[102][3] = 3; ParticleNeutralino4.Array_Comments[102] = "# ~chi_40 -> chi_1- u db";
   ParticleNeutralino4.Array_Decays[103][0] = PDGchargino1; ParticleNeutralino4.Array_Decays[103][1] = PDGcharm; ParticleNeutralino4.Array_Decays[103][4] = -PDGstrange; ParticleNeutralino4.Array_Decays[103][2] = neutralino4amplitudechargino1csbar; ParticleNeutralino4.Array_Decays[103][3] = 3; ParticleNeutralino4.Array_Comments[103] = "# ~chi_40 -> chi_1- c sb";
   ParticleNeutralino4.Array_Decays[104][0] = PDGchargino1; ParticleNeutralino4.Array_Decays[104][1] = PDGnuelectron; ParticleNeutralino4.Array_Decays[104][4] = -PDGelectron; ParticleNeutralino4.Array_Decays[104][2] = neutralino4amplitudechargino1enuebar; ParticleNeutralino4.Array_Decays[104][3] = 3; ParticleNeutralino4.Array_Comments[104] = "# ~chi_40 -> chi_1- nu_e eb";
   ParticleNeutralino4.Array_Decays[105][0] = PDGchargino1; ParticleNeutralino4.Array_Decays[105][1] = PDGnumuon; ParticleNeutralino4.Array_Decays[105][4] = -PDGmuon; ParticleNeutralino4.Array_Decays[105][2] = neutralino4amplitudechargino1munumubar; ParticleNeutralino4.Array_Decays[105][3] = 3; ParticleNeutralino4.Array_Comments[105] = "# ~chi_40 -> chi_1- nu_mu mub";
   ParticleNeutralino4.Array_Decays[106][0] = PDGchargino1; ParticleNeutralino4.Array_Decays[106][1] = PDGnutau; ParticleNeutralino4.Array_Decays[106][4] = -PDGtau; ParticleNeutralino4.Array_Decays[106][2] = neutralino4amplitudechargino1taunutaubar; ParticleNeutralino4.Array_Decays[106][3] = 3; ParticleNeutralino4.Array_Comments[106] = "# ~chi_40 -> chi_1- nu_tau taub";
   ParticleNeutralino4.Array_Decays[107][0] = PDGchargino2; ParticleNeutralino4.Array_Decays[107][1] = PDGup; ParticleNeutralino4.Array_Decays[107][4] = -PDGdown; ParticleNeutralino4.Array_Decays[107][2] = neutralino4amplitudechargino2udbar; ParticleNeutralino4.Array_Decays[107][3] = 3; ParticleNeutralino4.Array_Comments[107] = "# ~chi_40 -> chi_2- u dbar";
   ParticleNeutralino4.Array_Decays[108][0] = PDGchargino2; ParticleNeutralino4.Array_Decays[108][1] = PDGcharm; ParticleNeutralino4.Array_Decays[108][4] = -PDGstrange; ParticleNeutralino4.Array_Decays[108][2] = neutralino4amplitudechargino2csbar; ParticleNeutralino4.Array_Decays[108][3] = 3; ParticleNeutralino4.Array_Comments[108] = "# ~chi_40 -> chi_2- c sbar";
   ParticleNeutralino4.Array_Decays[109][0] = PDGchargino2; ParticleNeutralino4.Array_Decays[109][1] = PDGnuelectron; ParticleNeutralino4.Array_Decays[109][4] = -PDGelectron; ParticleNeutralino4.Array_Decays[109][2] = neutralino4amplitudechargino2enuebar; ParticleNeutralino4.Array_Decays[109][3] = 3; ParticleNeutralino4.Array_Comments[109] = "# ~chi_40 -> chi_2- nu_e eb";
   ParticleNeutralino4.Array_Decays[110][0] = PDGchargino2; ParticleNeutralino4.Array_Decays[110][1] = PDGnumuon; ParticleNeutralino4.Array_Decays[110][4] = -PDGmuon; ParticleNeutralino4.Array_Decays[110][2] = neutralino4amplitudechargino2munumubar; ParticleNeutralino4.Array_Decays[110][3] = 3; ParticleNeutralino4.Array_Comments[110] = "# ~chi_40 -> chi_2- nu_mu mub";
   ParticleNeutralino4.Array_Decays[111][0] = PDGchargino2; ParticleNeutralino4.Array_Decays[111][1] = PDGnutau; ParticleNeutralino4.Array_Decays[111][4] = -PDGtau; ParticleNeutralino4.Array_Decays[111][2] = neutralino4amplitudechargino2taunutaubar; ParticleNeutralino4.Array_Decays[111][3] = 3; ParticleNeutralino4.Array_Comments[111] = "# ~chi_40 -> chi_2- nu_tau taubar";

  double Neut4_No_1to2_Decays = 0;

  if (neutNLSP == 1) { Neut4_No_1to2_Decays = ParticleNeutralino4.No_1to2_Decays + ParticleNeutralino4.No_grav_Decays;}
  else { Neut4_No_1to2_Decays = ParticleNeutralino4.No_1to2_Decays;}
   
 for (int j = 0; j<Neut4_No_1to2_Decays; j++) {
   ParticleNeutralino4.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
  }

 for (int j=0; j<Neut4_No_1to2_Decays; j++) {
    ParticleNeutralino4.two_width = ParticleNeutralino4.two_width + ParticleNeutralino4.Array_Decays[j][2];
  }
 for (int j=Neut4_No_1to2_Decays; j<ParticleNeutralino4.No_of_Decays; j++) {
   ParticleNeutralino4.three_width = ParticleNeutralino4.three_width + ParticleNeutralino4.Array_Decays[j][2];
 }
  
  if ( ParticleNeutralino4.three_width != ParticleNeutralino4.three_width) /// Tests for a nan as only nans aren't equal to themselves
    {
      cout << "Three body decays give nan for neutralino 4 - problem! Therefore total and partial widths and branching ratios output only includes 1->2 decays" << endl;
      ParticleNeutralino4.No_of_Decays = Neut4_No_1to2_Decays; ///So only 1 to 2 decays are output if a 1 to 3 decay gives a nan
      ParticleNeutralino4.total_width = ParticleNeutralino4.two_width;
    }
  else {
    ParticleNeutralino4.total_width = ParticleNeutralino4.two_width + ParticleNeutralino4.three_width;
  }
   
  for (int i =0; i<ParticleNeutralino4.No_of_Decays; i++) {
     ParticleNeutralino4.Array_Decays[i][5]= ParticleNeutralino4.Array_Decays[i][2]/ParticleNeutralino4.total_width;
   }


 ///cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 ///cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleNeutralino4.PDG << setw(12) << scientific << setprecision(8) <<  ParticleNeutralino4.total_width << "   " << "# neutralino4 decays" << endl;
 ///cout.precision(7);
 ///cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 ///for (int k=0; k<ParticleNeutralino4.No_of_Decays; k++) {
 ///  if( ParticleNeutralino4.Array_Decays[k][2] != 0 && ParticleNeutralino4.Array_Decays[k][5] > BRTol) {
 ///        cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleNeutralino4.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleNeutralino4.Array_Decays[k][3];  printRowPDG(cout, ParticleNeutralino4.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleNeutralino4.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleNeutralino4.Array_Comments[k] << endl;
 ///  }
 /// }
 ///cout << "#" << endl;

///Uncomment section below if want partial widths as well as branching ratios
 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleNeutralino4.PDG << setw(12) << scientific << setprecision(8) <<  ParticleNeutralino4.total_width << "   " << "# neutralino4 decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "PW" << setw(18) << "BR" << setw(8) << "NDA" << setw(12) << left << " PDG1" << setw(12) << " PDG2" << setw(12) << " PDG3 " << endl;
 for (int k=0; k<ParticleNeutralino4.No_of_Decays; k++) {
   if( ParticleNeutralino4.Array_Decays[k][2] != 0 && ParticleNeutralino4.Array_Decays[k][5] > BRTol) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleNeutralino4.Array_Decays[k][2] << setprecision(8) << ParticleNeutralino4.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << " " << ParticleNeutralino4.Array_Decays[k][3] << setw(4) << " ";  printRowPDG(cout, ParticleNeutralino4.Array_Decays[k][0]); cout << "    "; printRowPDG(cout,ParticleNeutralino4.Array_Decays[k][1]); cout << "    "; printRowPDG(cout,ParticleNeutralino4.Array_Decays[k][4]); cout << "   " << left << setprecision(0) << setw(15) << ParticleNeutralino4.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl; 


///Higgs decays

///higgsl decays

 double h0amplitudeuantiu, h0amplitudedantid, h0amplitudesantis, h0amplitudecantic, h0amplitudebantib, h0amplitudeeantie, h0amplitudemuantimu, h0amplitudetauantitau, h0amplitudeneutZ1neutZ1, h0amplitudeneutZ1neutZ2, h0amplitudeneutZ1neutZ3, h0amplitudeneutZ1neutZ4, h0amplitudeneutZ2neutZ2, h0amplitudeneutZ2neutZ3, h0amplitudeneutZ2neutZ4, h0amplitudeneutZ3neutZ3, h0amplitudeneutZ3neutZ4, h0amplitudeneutZ4neutZ4, h0amplitudecharW1charW1, h0amplitudecharW1charW2, h0amplitudecharW2charW2, h0amplitudehiggsAhiggsA, h0amplitudehiggsAZboson, h0amplitudesupLantisupL, h0amplitudesupLantisupR, h0amplitudesupRantisupL, h0amplitudesupRantisupR, h0amplitudesdownLantisdownL, h0amplitudesdownLantisdownR, h0amplitudesdownRantisdownL, h0amplitudesdownRantisdownR, h0amplitudescharmLantischarmL, h0amplitudescharmLantischarmR, h0amplitudescharmRantischarmL, h0amplitudescharmRantischarmR, h0amplitudesstrangeLantisstrangeL, h0amplitudesstrangeLantisstrangeR, h0amplitudesstrangeRantisstrangeL, h0amplitudesstrangeRantisstrangeR, h0amplitudesnueLantisnueL, h0amplitudeselectronLantiselectronL, h0amplitudeselectronRantiselectronR, h0amplitudeselectronLantiselectronR, h0amplitudeselectronRantiselectronL, h0amplitudesnumuLantisnumuL, h0amplitudesnutauLantisnutauL, h0amplitudesmuonLantismuonL, h0amplitudesmuonRantismuonR, h0amplitudesmuonLantismuonR, h0amplitudesmuonRantismuonL, h0amplitudestau1antistau1, h0amplitudestau2antistau2, h0amplitudestau1antistau2, h0amplitudestau2antistau1, h0amplitudestop1antistop1, h0amplitudestop1antistop2, h0amplitudestop2antistop1, h0amplitudestop2antistop2, h0amplitudesbottom1antisbottom1, h0amplitudesbottom1antisbottom2, h0amplitudesbottom2antisbottom1, h0amplitudesbottom2antisbottom2, h0amplitudegluongluon, h0amplitudegammagamma, h0amplitudeWW, h0amplitudeZZ, h0amplitudeZgamma;

 h0amplitudeuantiu = higgslorHamplitudedecayquarkantiquark (mh0(1), MUP, g, alpha, beta, runmw, 1, 'l');
 h0amplitudedantid = higgslorHamplitudedecayquarkantiquark (mh0(1), MDOWN, g, alpha, beta, runmw, 0, 'l');
 h0amplitudecantic = higgslorHamplitudedecayquarkantiquark (mh0(1), MCHARM, g, alpha, beta, runmw, 1, 'l');
 h0amplitudesantis = higgslorHamplitudedecayquarkantiquark (mh0(1), MSTRANGE, g, alpha, beta, runmw, 0, 'l');
 h0amplitudebantib = higgslorHamplitudedecayquarkantiquark (mh0(1), runmb, g, alpha, beta, runmw, 0, 'l'); ///No decay to two tops as kinematically forbidden, ///use runmb here to reduce necessary corrections
 h0amplitudeeantie = higgslorHamplitudedecayquarkantiquark (mh0(1), MELECTRON, g, alpha, beta, runmw, 0, 'l')/3; ///0 as leptons are like down-type quarks, divided by three as Nc is three for quarks but 1 for leptons
 h0amplitudemuantimu = higgslorHamplitudedecayquarkantiquark (mh0(1), MMUON, g, alpha, beta, runmw, 0, 'l')/3;
 h0amplitudetauantitau = higgslorHamplitudedecayquarkantiquark (mh0(1), MTAU, g, alpha, beta, runmw, 0, 'l')/3;
 h0amplitudeneutZ1neutZ1 = higgsphiamplitudedecayneutralinoneutralino (mh0(1), mneut(1), mneut(1), g, tanthetaW, alpha, mixNeut, 1, 1, 'h');
 h0amplitudeneutZ1neutZ2 = higgsphiamplitudedecayneutralinoneutralino (mh0(1), mneut(1), mneut(2), g, tanthetaW, alpha, mixNeut, 1, 2, 'h');
 h0amplitudeneutZ1neutZ3 = higgsphiamplitudedecayneutralinoneutralino (mh0(1), mneut(1), mneut(3), g, tanthetaW, alpha, mixNeut, 1, 3, 'h');
 h0amplitudeneutZ1neutZ4 = higgsphiamplitudedecayneutralinoneutralino (mh0(1), mneut(1), mneut(4), g, tanthetaW, alpha, mixNeut, 1, 4, 'h');
 h0amplitudeneutZ2neutZ2 = higgsphiamplitudedecayneutralinoneutralino (mh0(1), mneut(2), mneut(2), g, tanthetaW, alpha, mixNeut, 2, 2, 'h');
 h0amplitudeneutZ2neutZ3 = higgsphiamplitudedecayneutralinoneutralino (mh0(1), mneut(2), mneut(3), g, tanthetaW, alpha, mixNeut, 2, 3, 'h');
 h0amplitudeneutZ2neutZ4 = higgsphiamplitudedecayneutralinoneutralino (mh0(1), mneut(2), mneut(4), g, tanthetaW, alpha, mixNeut, 2, 4, 'h');
 h0amplitudeneutZ3neutZ3 = higgsphiamplitudedecayneutralinoneutralino (mh0(1), mneut(3), mneut(3), g, tanthetaW, alpha, mixNeut, 3, 3, 'h');
 h0amplitudeneutZ3neutZ4 = higgsphiamplitudedecayneutralinoneutralino (mh0(1), mneut(3), mneut(4), g, tanthetaW, alpha, mixNeut, 3, 4, 'h');
 h0amplitudeneutZ4neutZ4 = higgsphiamplitudedecayneutralinoneutralino (mh0(1), mneut(4), mneut(4), g, tanthetaW, alpha, mixNeut, 4, 4, 'h');
 h0amplitudecharW1charW1 = higgsphiamplitudedecaysamechargino (mh0(1), mch(1), g, thetaL2, thetaR2, alpha, beta, 1, 'h');
 h0amplitudecharW2charW2 = higgsphiamplitudedecaysamechargino (mh0(1), mch(2), g, thetaL2, thetaR2, alpha, beta, 2, 'h');
 h0amplitudecharW1charW2 = higgsphiamplitudedecaydifchargino (mh0(1), mch(1), mch(2), g, thetaL2, thetaR2, alpha, beta, 'h');
 h0amplitudehiggsAhiggsA = higgshamplitudedecayAA (mh0(1), mA0(1), g, gp, alpha, beta, runmw);
 h0amplitudehiggsAZboson = higgshamplitudedecayhiggsAZboson (mh0(1), mz, mA0(1), g, gp, alpha, beta);
 h0amplitudesupLantisupL = higgshamplitudedecay2squarksamehand (mh0(1), mu(1,1), mu(1,1), g, gp, alpha, beta, runmw, MUP, MDOWN, 1);
 h0amplitudesupRantisupR = higgshamplitudedecay2squarksamehand (mh0(1), mu(2,1), mu(2,1), g, gp, alpha, beta, runmw, MUP, MDOWN, 3);
 h0amplitudesdownLantisdownL = higgshamplitudedecay2squarksamehand (mh0(1), md(1,1), md(1,1), g, gp, alpha, beta, runmw, MUP, MDOWN, 2);
 h0amplitudesdownRantisdownR = higgshamplitudedecay2squarksamehand (mh0(1), md(2,1), mu(2,1), g, gp, alpha, beta, runmw, MUP, MDOWN, 4);
 h0amplitudescharmLantischarmL = higgshamplitudedecay2squarksamehand (mh0(1), mu(1,2), mu(1,2), g, gp, alpha, beta, runmw, MCHARM, MSTRANGE, 1);
 h0amplitudescharmRantischarmR = higgshamplitudedecay2squarksamehand (mh0(1), mu(2,2), mu(2,2), g, gp, alpha, beta, runmw, MCHARM, MSTRANGE, 3);
 h0amplitudesstrangeLantisstrangeL = higgshamplitudedecay2squarksamehand (mh0(1), md(2,1), md(2,1), g, gp, alpha, beta, runmw, MCHARM, MSTRANGE, 2);
 h0amplitudesstrangeRantisstrangeR = higgshamplitudedecay2squarksamehand (mh0(1), md(2,2), md(2,2), g, gp, alpha, beta, runmw, MCHARM, MSTRANGE, 4);
 h0amplitudesupLantisupR = higgshamplitudedecay2squarkdiffhand (mh0(1), mu(1,1), mu(2,1), g, alpha, beta, runmw, MUP, MDOWN, greekmu, Au, Ad, 1);
 h0amplitudesupRantisupL = higgshamplitudedecay2squarkdiffhand (mh0(1), mu(1,1), mu(2,1), g, alpha, beta, runmw, MUP, MDOWN, greekmu, Au, Ad, 1);
 h0amplitudesdownLantisdownR = higgshamplitudedecay2squarkdiffhand (mh0(1), md(1,1), md(2,1), g, alpha, beta, runmw, MUP, MDOWN, greekmu, Au, Ad, 2);
 h0amplitudesdownRantisdownL = higgshamplitudedecay2squarkdiffhand (mh0(1), md(1,1), md(2,1), g, alpha, beta, runmw, MUP, MDOWN, greekmu, Au, Ad, 2);
 h0amplitudescharmLantischarmR = higgshamplitudedecay2squarkdiffhand (mh0(1), mu(1,2), mu(2,2), g, alpha, beta, runmw, MCHARM, MSTRANGE, greekmu, Ac, As, 1);
 h0amplitudescharmRantischarmL = higgshamplitudedecay2squarkdiffhand (mh0(1), mu(1,2), mu(2,2), g, alpha, beta, runmw, MCHARM, MSTRANGE, greekmu, Ac, As, 1);
 h0amplitudesstrangeLantisstrangeR = higgshamplitudedecay2squarkdiffhand (mh0(1), md(2,1), md(2,2), g, alpha, beta, runmw, MCHARM, MSTRANGE, greekmu, Ac, As, 2);
 h0amplitudesstrangeRantisstrangeL = higgshamplitudedecay2squarkdiffhand (mh0(1), md(2,1), md(2,2), g, alpha, beta, runmw, MCHARM, MSTRANGE, greekmu, Ac, As, 2);
 h0amplitudesnueLantisnueL = higgshamplitudedecay2sleptonsamehand (mh0(1), msnu(1), msnu(1), g, gp, alpha, beta, runmw, MELECTRON, 1);
 h0amplitudeselectronLantiselectronL = higgshamplitudedecay2sleptonsamehand (mh0(1), me(1,1), me(1,1), g, gp, alpha, beta, runmw, MELECTRON, 2);
 h0amplitudeselectronRantiselectronR = higgshamplitudedecay2sleptonsamehand (mh0(1), me(2,1), me(2,1), g, gp, alpha, beta, runmw, MELECTRON, 3);
 h0amplitudeselectronLantiselectronR = higgshamplitudedecay2sleptondiffhand (mh0(1), me(1,1), me(2,1), g, alpha, beta, runmw, MELECTRON, greekmu, Ae, 1);
 h0amplitudeselectronRantiselectronL = higgshamplitudedecay2sleptondiffhand (mh0(1), me(2,1), me(1,1), g, alpha, beta, runmw, MELECTRON, greekmu, Ae, 1);
 h0amplitudesnumuLantisnumuL = higgshamplitudedecay2sleptonsamehand (mh0(1), msnu(2), msnu(2), g, gp, alpha, beta, runmw, MMUON, 1);
 h0amplitudesmuonLantismuonL = higgshamplitudedecay2sleptonsamehand (mh0(1), me(1,2), me(1,2), g, gp, alpha, beta, runmw, MMUON, 2);
 h0amplitudesmuonRantismuonR = higgshamplitudedecay2sleptonsamehand (mh0(1), me(2,2), me(2,2), g, gp, alpha, beta, runmw, MMUON, 3);
 h0amplitudesmuonLantismuonR = higgshamplitudedecay2sleptondiffhand (mh0(1), me(1,2), me(2,2), g, alpha, beta, runmw, MMUON, greekmu, Amu, 1);
 h0amplitudesmuonRantismuonL = higgshamplitudedecay2sleptondiffhand (mh0(1), me(2,2), me(2,1), g, alpha, beta, runmw, MMUON, greekmu, Amu, 1);
 h0amplitudesnutauLantisnutauL = higgshamplitudedecay2sleptonsamehand (mh0(1), msnu(3), msnu(3), g, gp, alpha, beta, runmw, MTAU, 1);
 h0amplitudestop1antistop1 = higgshamplitudedecaystop1stop1 (mh0(1), mu(1,3), mu(1,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetat); ///note for consistency with earlier decays perhaps one should use runmt and runmb here - don't for now as MTOP and MBOTTOM give greater agreement with susyhit as susyhit uses non-running masses here
 ///h0amplitudestop1antistop1 = higgshamplitudedecaystop1stop1 (mhiggsscan, mu(1,3), mu(1,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetat);
 h0amplitudestop2antistop2 = higgshamplitudedecaystop2stop2 (mh0(1), mu(2,3), mu(2,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetat); ///note for consistency with earlier decays perhaps one should use runmt and runmb here - don't for now as MTOP and MBOTTOM give greater agreement with susyhit as susyhit uses non-running masses here
 ///h0amplitudestop2antistop2 = higgshamplitudedecaystop2stop2 (mhiggsscan, mu(2,3), mu(2,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetat);
 h0amplitudestop1antistop2 = higgshamplitudedecaystop1stop2 (mh0(1), mu(1,3), mu(2,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetat); ///note for consistency with earlier decays perhaps one should use runmt and runmb here - don't for now as MTOP and MBOTTOM give greater agreement with susyhit as susyhit uses non-running masses here
 ///h0amplitudestop1antistop2 = higgshamplitudedecaystop1stop2 (mhiggsscan, mu(1,3), mu(2,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetat);
 h0amplitudestop2antistop1 = higgshamplitudedecaystop1stop2 (mh0(1), mu(2,3), mu(1,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetat); ///note for consistency with earlier decays perhaps one should use runmt and runmb here - don't for now as MTOP and MBOTTOM give greater agreement with susyhit as susyhit uses non-running masses here
 ///h0amplitudestop2antistop1 = higgshamplitudedecaystop1stop2 (mhiggsscan, mu(2,3), mu(1,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetat);
 h0amplitudesbottom1antisbottom1 = higgshamplitudedecaysbottom1sbottom1(mh0(1), md(1,3), md(1,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetab); ///note for consistency with earlier decays perhaps one should use runmt and runmb here - don't for now as MTOP and MBOTTOM give greater agreement with susyhit as susyhit uses non-running masses here
 ///h0amplitudesbottom1antisbottom1 = higgshamplitudedecaysbottom1sbottom1(mhiggsscan, md(1,3), md(1,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetab);
 h0amplitudesbottom2antisbottom2 = higgshamplitudedecaysbottom2sbottom2(mh0(1), md(2,3), md(2,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetab); ///note for consistency with earlier decays perhaps one should use runmt and runmb here - don't for now as MTOP and MBOTTOM give greater agreement with susyhit as susyhit uses non-running masses here
 ///h0amplitudesbottom2antisbottom2 = higgshamplitudedecaysbottom2sbottom2(mhiggsscan, md(2,3), md(2,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetab);
 h0amplitudesbottom1antisbottom2 = higgshamplitudedecaysbottom1sbottom2 (mh0(1), md(1,3), md(2,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetab); ///note for consistency with earlier decays perhaps one should use runmt and runmb here - don't for now as MTOP and MBOTTOM give greater agreement with susyhit as susyhit uses non-running masses here
 ///h0amplitudesbottom1antisbottom2 = higgshamplitudedecaysbottom1sbottom2 (mhiggsscan, md(1,3), md(2,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetab);
 h0amplitudesbottom2antisbottom1 = higgshamplitudedecaysbottom1sbottom2 (mh0(1), md(2,3), md(1,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetab); ///note for consistency with earlier decays perhaps one should use runmt and runmb here - don't for now as MTOP and MBOTTOM give greater agreement with susyhit as susyhit uses non-running masses here
 h0amplitudestau1antistau1 = higgshamplitudedecaystau1stau1 (mh0(1), me(1,3), me(1,3), g, gp, alpha, beta, runmw, MTAU, greekmu, Atau, thetatau);
 h0amplitudestau2antistau2 = higgshamplitudedecaystau2stau2 (mh0(1), me(2,3), me(2,3), g, gp, alpha, beta, runmw, MTAU, greekmu, Atau, thetatau);
 h0amplitudestau1antistau2 = higgshamplitudedecaystau1stau2 (mh0(1), me(1,3), me(2,3), g, gp, alpha, beta, runmw, MTAU, greekmu, Atau, thetatau);
 h0amplitudestau2antistau1 = higgshamplitudedecaystau1stau2 (mh0(1), me(2,3), me(1,3), g, gp, alpha, beta, runmw, MTAU, greekmu, Atau, thetatau);


  h0amplitudegammagamma = higgsesamplitudedecaygammagammatotal(mh0(1), g, gp, runmw, polemw, alpha, beta, MTOP, MBOTTOM, MCHARM, MTAU, mHpm, mu(1,3), mu(2,3), md(1,3), md(2,3), me(1,3), me(2,3), mch(1), mch(2), thetaL, thetaR, thetat, thetab, thetatau, greekmu, At, Ab, Atau, 'h');

 h0amplitudegluongluon = higgsesamplitudedecaygluongluontotal(mh0(1), g, g3atmh0, gp, runmw, alpha, beta, MTOP, MBOTTOM, MCHARM, mu(1,3), mu(2,3), md(1,3), md(2,3), thetaL, thetaR, thetat, thetab, greekmu, At, Ab, 'h');
 h0amplitudeWW = higgshamplitudedecayVV(mh0(1), polemw, mz, g, gp, alpha, beta, 'W')(1);
 h0amplitudeZZ = higgshamplitudedecayVV(mh0(1), polemw, mz, g, gp, alpha, beta, 'Z')(1);
 h0amplitudeZgamma = higgsesamplitudedecayZbosonphotontotal(mh0(1), mz, g, gp, polemw, runmw, alpha, beta, MTOP, MBOTTOM, MCHARM, MSTRANGE, mu(1,3), mu(2,3), md(1,3), md(2,3), mHpm, thetaL, thetaR, thetat, thetab, greekmu, At, Ab, 'h'); 
 
 int h0WWcommentcode, h0ZZcommentcode, h0WWNDA=0, h0ZZNDA=0;
 h0WWcommentcode = higgshamplitudedecayVV(mh0(1), polemw, mz, g, gp, alpha, beta, 'W')(2);
 string h0WWcomment, h0ZZcomment;
 if (h0WWcommentcode == 1) {
   h0WWcomment = "# h -> WW* -> W f f'bar";
   h0WWNDA = 3;
 }
 else if(h0WWcommentcode == 2) {
   h0WWcomment = "# h -> W+ W-";
   h0WWNDA = 2;
 }
 h0ZZcommentcode = higgshamplitudedecayVV(mh0(1), polemw, mz, g, gp, alpha, beta, 'Z')(2);
 if (h0ZZcommentcode == 1) {
   h0ZZcomment = "# h -> ZZ* -> Z f f'bar";
   h0ZZNDA = 3;
 }
 else if(h0ZZcommentcode == 2) {
   h0ZZcomment = "# h -> Z Z";
   h0ZZNDA = 2;
 }


 Particlehiggsl.Array_Decays[0][0] = PDGup; Particlehiggsl.Array_Decays[0][1] = -PDGup; Particlehiggsl.Array_Decays[0][2] = h0amplitudeuantiu; Particlehiggsl.Array_Decays[0][3] = 2; Particlehiggsl.Array_Comments[0] = "# h -> u ub";
 Particlehiggsl.Array_Decays[1][0] = PDGdown; Particlehiggsl.Array_Decays[1][1] = -PDGdown; Particlehiggsl.Array_Decays[1][2] = h0amplitudedantid; Particlehiggsl.Array_Decays[1][3] = 2; Particlehiggsl.Array_Comments[1] = "# h -> d db";
 Particlehiggsl.Array_Decays[2][0] = PDGcharm; Particlehiggsl.Array_Decays[2][1] = -PDGcharm; Particlehiggsl.Array_Decays[2][2] = h0amplitudecantic; Particlehiggsl.Array_Decays[2][3] = 2; Particlehiggsl.Array_Comments[2] = "# h -> c cb";
 Particlehiggsl.Array_Decays[3][0] = PDGstrange; Particlehiggsl.Array_Decays[3][1] = -PDGstrange; Particlehiggsl.Array_Decays[3][2] = h0amplitudesantis; Particlehiggsl.Array_Decays[3][3] = 2; Particlehiggsl.Array_Comments[3] = "# h -> s sb";
 Particlehiggsl.Array_Decays[4][0] = PDGbottom; Particlehiggsl.Array_Decays[4][1] = -PDGbottom; Particlehiggsl.Array_Decays[4][2] = h0amplitudebantib; Particlehiggsl.Array_Decays[4][3] = 2; Particlehiggsl.Array_Comments[4] = "# h -> b bb";
 Particlehiggsl.Array_Decays[5][0] = PDGelectron; Particlehiggsl.Array_Decays[5][1] = -PDGelectron; Particlehiggsl.Array_Decays[5][2] = h0amplitudeeantie; Particlehiggsl.Array_Decays[5][3] = 2; Particlehiggsl.Array_Comments[5] = "# h -> e- e+";
 Particlehiggsl.Array_Decays[6][0] = PDGmuon; Particlehiggsl.Array_Decays[6][1] = -PDGmuon; Particlehiggsl.Array_Decays[6][2] = h0amplitudemuantimu; Particlehiggsl.Array_Decays[6][3] = 2; Particlehiggsl.Array_Comments[6] = "# h -> mu- mu+";
 Particlehiggsl.Array_Decays[7][0] = PDGtau; Particlehiggsl.Array_Decays[7][1] = -PDGtau; Particlehiggsl.Array_Decays[7][2] = h0amplitudetauantitau; Particlehiggsl.Array_Decays[7][3] = 2; Particlehiggsl.Array_Comments[7] = "# h-> tau- tau+";
 Particlehiggsl.Array_Decays[8][0] = PDGneutralino1; Particlehiggsl.Array_Decays[8][1] = PDGneutralino1; Particlehiggsl.Array_Decays[8][2] = h0amplitudeneutZ1neutZ1; Particlehiggsl.Array_Decays[8][3] = 2; Particlehiggsl.Array_Comments[8] = "# h -> ~chi_10 ~chi_10";
 Particlehiggsl.Array_Decays[9][0] = PDGneutralino1; Particlehiggsl.Array_Decays[9][1] = PDGneutralino2; Particlehiggsl.Array_Decays[9][2] = h0amplitudeneutZ1neutZ2; Particlehiggsl.Array_Decays[9][3] = 2; Particlehiggsl.Array_Comments[9] = "# h -> ~chi_10 ~chi_20";
 Particlehiggsl.Array_Decays[10][0] = PDGneutralino1; Particlehiggsl.Array_Decays[10][1] = PDGneutralino3; Particlehiggsl.Array_Decays[10][2] = h0amplitudeneutZ1neutZ3; Particlehiggsl.Array_Decays[10][3] = 2; Particlehiggsl.Array_Comments[10] = "# h -> ~chi_10 ~chi_30";
 Particlehiggsl.Array_Decays[11][0] = PDGneutralino1; Particlehiggsl.Array_Decays[11][1] = PDGneutralino4; Particlehiggsl.Array_Decays[11][2] = h0amplitudeneutZ1neutZ4; Particlehiggsl.Array_Decays[11][3] = 2; Particlehiggsl.Array_Comments[11] = "# h -> ~chi_10 ~chi_40";
 Particlehiggsl.Array_Decays[12][0] = PDGneutralino2; Particlehiggsl.Array_Decays[12][1] = PDGneutralino2; Particlehiggsl.Array_Decays[12][2] = h0amplitudeneutZ2neutZ2; Particlehiggsl.Array_Decays[12][3] = 2; Particlehiggsl.Array_Comments[12] = "# h -> ~chi_20 ~chi_20";
 Particlehiggsl.Array_Decays[13][0] = PDGneutralino2; Particlehiggsl.Array_Decays[13][1] = PDGneutralino3; Particlehiggsl.Array_Decays[13][2] = h0amplitudeneutZ2neutZ3; Particlehiggsl.Array_Decays[13][3] = 2; Particlehiggsl.Array_Comments[13] = "# h -> ~chi_20 ~chi_30";
 Particlehiggsl.Array_Decays[14][0] = PDGneutralino2; Particlehiggsl.Array_Decays[14][1] = PDGneutralino4; Particlehiggsl.Array_Decays[14][2] = h0amplitudeneutZ2neutZ4; Particlehiggsl.Array_Decays[14][3] = 2; Particlehiggsl.Array_Comments[14] = "# h -> ~chi_20 ~chi_40";
 Particlehiggsl.Array_Decays[15][0] = PDGneutralino3; Particlehiggsl.Array_Decays[15][1] = PDGneutralino3; Particlehiggsl.Array_Decays[15][2] = h0amplitudeneutZ3neutZ3; Particlehiggsl.Array_Decays[15][3] = 2; Particlehiggsl.Array_Comments[15] = "# h -> ~chi_30 ~chi_30";
 Particlehiggsl.Array_Decays[16][0] = PDGneutralino3; Particlehiggsl.Array_Decays[16][1] = PDGneutralino4; Particlehiggsl.Array_Decays[16][2] = h0amplitudeneutZ3neutZ4; Particlehiggsl.Array_Decays[16][3] = 2; Particlehiggsl.Array_Comments[16] = "# h -> ~chi_30 ~chi_40";
 Particlehiggsl.Array_Decays[17][0] = PDGneutralino4; Particlehiggsl.Array_Decays[17][1] = PDGneutralino4; Particlehiggsl.Array_Decays[17][2] = h0amplitudeneutZ4neutZ4; Particlehiggsl.Array_Decays[17][3] = 2; Particlehiggsl.Array_Comments[17] = "# h -> ~chi_40 ~chi_40";
 Particlehiggsl.Array_Decays[18][0] = PDGchargino1; Particlehiggsl.Array_Decays[18][1] = -PDGchargino1; Particlehiggsl.Array_Decays[18][2] = h0amplitudecharW1charW1; Particlehiggsl.Array_Decays[18][3] = 2; Particlehiggsl.Array_Comments[18] = "# h -> ~chi_1+ ~chi_1-";
 Particlehiggsl.Array_Decays[19][0] = PDGchargino2; Particlehiggsl.Array_Decays[19][1] = -PDGchargino2; Particlehiggsl.Array_Decays[19][2] = h0amplitudecharW2charW2; Particlehiggsl.Array_Decays[19][3] = 2; Particlehiggsl.Array_Comments[19] = "# h -> ~chi_2+ ~chi_2-";
 Particlehiggsl.Array_Decays[20][0] = PDGchargino1; Particlehiggsl.Array_Decays[20][1] = -PDGchargino2; Particlehiggsl.Array_Decays[20][2] = h0amplitudecharW1charW2; Particlehiggsl.Array_Decays[20][3] = 2; Particlehiggsl.Array_Comments[20] = "# h -> ~chi_1+ ~chi_2-";
 Particlehiggsl.Array_Decays[21][0] = PDGchargino2; Particlehiggsl.Array_Decays[21][1] = -PDGchargino1; Particlehiggsl.Array_Decays[21][2] = h0amplitudecharW1charW2; Particlehiggsl.Array_Decays[21][3] = 2; Particlehiggsl.Array_Comments[21] = "# h -> ~chi_2+ ~chi_1-"; ///amplitude same as decay to W1+ and W2- by CP invariance
 Particlehiggsl.Array_Decays[22][0] = PDGA0; Particlehiggsl.Array_Decays[22][1] = PDGA0; Particlehiggsl.Array_Decays[22][2] = h0amplitudehiggsAhiggsA; Particlehiggsl.Array_Decays[22][3] = 2; Particlehiggsl.Array_Comments[22] = "# h -> A A";
 Particlehiggsl.Array_Decays[23][0] = PDGZboson; Particlehiggsl.Array_Decays[23][1] = PDGA0; Particlehiggsl.Array_Decays[23][2] = h0amplitudehiggsAZboson; Particlehiggsl.Array_Decays[23][3] = 2; Particlehiggsl.Array_Comments[23] = "# h -> A Z";
 Particlehiggsl.Array_Decays[24][0] = PDGsupL; Particlehiggsl.Array_Decays[24][1] = -PDGsupL; Particlehiggsl.Array_Decays[24][2] = h0amplitudesupLantisupL; Particlehiggsl.Array_Decays[24][3] = 2; Particlehiggsl.Array_Comments[24] = "# h -> ~u_L ~u_L*";
 Particlehiggsl.Array_Decays[25][0] = PDGsupR; Particlehiggsl.Array_Decays[25][1] = -PDGsupR; Particlehiggsl.Array_Decays[25][2] = h0amplitudesupRantisupR; Particlehiggsl.Array_Decays[25][3] = 2; Particlehiggsl.Array_Comments[25] = "# h -> ~u_R ~u_R*";
 Particlehiggsl.Array_Decays[26][0] = PDGsupL; Particlehiggsl.Array_Decays[26][1] = -PDGsupR; Particlehiggsl.Array_Decays[26][2] = h0amplitudesupLantisupR; Particlehiggsl.Array_Decays[26][3] = 2; Particlehiggsl.Array_Comments[26] = "# h -> ~u_L ~u_R*";
 Particlehiggsl.Array_Decays[27][0] = PDGsupR; Particlehiggsl.Array_Decays[27][1] = -PDGsupL; Particlehiggsl.Array_Decays[27][2] = h0amplitudesupRantisupL; Particlehiggsl.Array_Decays[27][3] = 2; Particlehiggsl.Array_Comments[27] = "# h -> ~u_R ~u_L*";
 Particlehiggsl.Array_Decays[28][0] = PDGsdownL; Particlehiggsl.Array_Decays[28][1] = -PDGsdownL; Particlehiggsl.Array_Decays[28][2] = h0amplitudesdownLantisdownL; Particlehiggsl.Array_Decays[28][3] = 2; Particlehiggsl.Array_Comments[28] = "# h -> ~d_L ~d_L*";
 Particlehiggsl.Array_Decays[29][0] = PDGsdownR; Particlehiggsl.Array_Decays[29][1] = -PDGsdownR; Particlehiggsl.Array_Decays[29][2] = h0amplitudesdownRantisdownR; Particlehiggsl.Array_Decays[29][3] = 2; Particlehiggsl.Array_Comments[29] = "# h -> ~d_R ~d_R*";
 Particlehiggsl.Array_Decays[30][0] = PDGsdownL; Particlehiggsl.Array_Decays[30][1] = -PDGsdownR; Particlehiggsl.Array_Decays[30][2] = h0amplitudesdownLantisdownR; Particlehiggsl.Array_Decays[30][3] = 2; Particlehiggsl.Array_Comments[30] = "# h -> ~d_L ~d_R*";
 Particlehiggsl.Array_Decays[31][0] = PDGsdownR; Particlehiggsl.Array_Decays[31][1] = -PDGsdownL; Particlehiggsl.Array_Decays[31][2] = h0amplitudesdownRantisdownL; Particlehiggsl.Array_Decays[31][3] = 2; Particlehiggsl.Array_Comments[31] = "# h -> ~d_R ~d_L*";
 Particlehiggsl.Array_Decays[32][0] = PDGscharmL; Particlehiggsl.Array_Decays[32][1] = -PDGscharmL; Particlehiggsl.Array_Decays[32][2] = h0amplitudescharmLantischarmL; Particlehiggsl.Array_Decays[32][3] = 2; Particlehiggsl.Array_Comments[32] = "# h -> ~c_L ~c_L*";
 Particlehiggsl.Array_Decays[33][0] = PDGscharmR; Particlehiggsl.Array_Decays[33][1] = -PDGscharmR; Particlehiggsl.Array_Decays[33][2] = h0amplitudescharmRantischarmR; Particlehiggsl.Array_Decays[33][3] = 2; Particlehiggsl.Array_Comments[33] = "# h -> ~c_R ~c_R*";
 Particlehiggsl.Array_Decays[34][0] = PDGscharmL; Particlehiggsl.Array_Decays[34][1] = -PDGscharmR; Particlehiggsl.Array_Decays[34][2] = h0amplitudescharmLantischarmR; Particlehiggsl.Array_Decays[34][3] = 2; Particlehiggsl.Array_Comments[34] = "# h -> ~c_L ~c_R*";
 Particlehiggsl.Array_Decays[35][0] = PDGscharmR; Particlehiggsl.Array_Decays[35][1] = -PDGscharmL; Particlehiggsl.Array_Decays[35][2] = h0amplitudescharmRantischarmL; Particlehiggsl.Array_Decays[35][3] = 2; Particlehiggsl.Array_Comments[35] = "# h -> ~c_R ~c_L*";
 Particlehiggsl.Array_Decays[36][0] = PDGsstrangeL; Particlehiggsl.Array_Decays[36][1] = -PDGsstrangeL; Particlehiggsl.Array_Decays[36][2] = h0amplitudesstrangeLantisstrangeL; Particlehiggsl.Array_Decays[36][3] = 2; Particlehiggsl.Array_Comments[36] = "# h -> ~s_L ~s_L*";
 Particlehiggsl.Array_Decays[37][0] = PDGsstrangeR; Particlehiggsl.Array_Decays[37][1] = -PDGsstrangeR; Particlehiggsl.Array_Decays[37][2] = h0amplitudesstrangeRantisstrangeR; Particlehiggsl.Array_Decays[37][3] = 2; Particlehiggsl.Array_Comments[37] = "# h -> ~s_R ~s_R*";
 Particlehiggsl.Array_Decays[38][0] = PDGsstrangeL; Particlehiggsl.Array_Decays[38][1] = -PDGsstrangeR; Particlehiggsl.Array_Decays[38][2] = h0amplitudesstrangeLantisstrangeR; Particlehiggsl.Array_Decays[38][3] = 2; Particlehiggsl.Array_Comments[38] = "# h -> ~s_L ~s_R*";
 Particlehiggsl.Array_Decays[39][0] = PDGsstrangeR; Particlehiggsl.Array_Decays[39][1] = -PDGsstrangeL; Particlehiggsl.Array_Decays[39][2] = h0amplitudesstrangeRantisstrangeL; Particlehiggsl.Array_Decays[39][3] = 2; Particlehiggsl.Array_Comments[39] = "# h -> ~s_R ~s_L*";
 Particlehiggsl.Array_Decays[40][0] = PDGnuselectronL; Particlehiggsl.Array_Decays[40][1] = -PDGnuselectronL; Particlehiggsl.Array_Decays[40][2] = h0amplitudesnueLantisnueL; Particlehiggsl.Array_Decays[40][3] = 2; Particlehiggsl.Array_Comments[40] = "# h -> ~nu_eL ~nu_eL*";
 Particlehiggsl.Array_Decays[41][0] = PDGselectronL; Particlehiggsl.Array_Decays[41][1] = -PDGselectronL; Particlehiggsl.Array_Decays[41][2] = h0amplitudeselectronLantiselectronL; Particlehiggsl.Array_Decays[41][3] = 2; Particlehiggsl.Array_Comments[41] = "# h -> ~e_L- ~e_L+";
 Particlehiggsl.Array_Decays[42][0] = PDGselectronR; Particlehiggsl.Array_Decays[42][1] = -PDGselectronR; Particlehiggsl.Array_Decays[42][2] = h0amplitudeselectronRantiselectronR; Particlehiggsl.Array_Decays[42][3] = 2; Particlehiggsl.Array_Comments[42] = "# h -> ~e_R- ~e_R+";
 Particlehiggsl.Array_Decays[43][0] = PDGselectronL; Particlehiggsl.Array_Decays[43][1] = -PDGselectronR; Particlehiggsl.Array_Decays[43][2] = h0amplitudeselectronLantiselectronR; Particlehiggsl.Array_Decays[43][3] = 2; Particlehiggsl.Array_Comments[43] = "# h -> ~e_L- ~e_R+";
 Particlehiggsl.Array_Decays[44][0] = PDGselectronR; Particlehiggsl.Array_Decays[44][1] = -PDGselectronL; Particlehiggsl.Array_Decays[44][2] = h0amplitudeselectronRantiselectronL; Particlehiggsl.Array_Decays[44][3] = 2; Particlehiggsl.Array_Comments[44] = "# h -> ~e_R- ~e_L+";
 Particlehiggsl.Array_Decays[45][0] = PDGnusmuonL; Particlehiggsl.Array_Decays[45][1] = -PDGnusmuonL; Particlehiggsl.Array_Decays[45][2] = h0amplitudesnumuLantisnumuL; Particlehiggsl.Array_Decays[45][3] = 2; Particlehiggsl.Array_Comments[45] = "# h -> ~nu_muL ~nu_muL*";
 Particlehiggsl.Array_Decays[46][0] = PDGsmuonL; Particlehiggsl.Array_Decays[46][1] = -PDGsmuonL; Particlehiggsl.Array_Decays[46][2] = h0amplitudesmuonLantismuonL; Particlehiggsl.Array_Decays[46][3] = 2; Particlehiggsl.Array_Comments[46] = "# h -> ~mu_L- ~mu_L+";
 Particlehiggsl.Array_Decays[47][0] = PDGsmuonR; Particlehiggsl.Array_Decays[47][1] = -PDGsmuonR; Particlehiggsl.Array_Decays[47][2] = h0amplitudesmuonRantismuonR; Particlehiggsl.Array_Decays[47][3] = 2; Particlehiggsl.Array_Comments[47] = "# h -> ~mu_R- ~mu_R+";
 Particlehiggsl.Array_Decays[48][0] = PDGsmuonL; Particlehiggsl.Array_Decays[48][1] = -PDGsmuonR; Particlehiggsl.Array_Decays[48][2] = h0amplitudesmuonLantismuonR; Particlehiggsl.Array_Decays[48][3] = 2; Particlehiggsl.Array_Comments[48] = "# h -> ~mu_L- ~mu_R+";
 Particlehiggsl.Array_Decays[49][0] = PDGsmuonR; Particlehiggsl.Array_Decays[49][1] = -PDGsmuonL; Particlehiggsl.Array_Decays[49][2] = h0amplitudesmuonRantismuonL; Particlehiggsl.Array_Decays[49][3] = 2; Particlehiggsl.Array_Comments[49] = "# h -> ~mu_R- ~mu_L+";	
 Particlehiggsl.Array_Decays[50][0] = PDGnustauL; Particlehiggsl.Array_Decays[50][1] = -PDGnustauL; Particlehiggsl.Array_Decays[50][2] = h0amplitudesnutauLantisnutauL; Particlehiggsl.Array_Decays[50][3] = 2; Particlehiggsl.Array_Comments[50] = "# h -> ~nu_tauL ~nu_tauL*";   Particlehiggsl.Array_Decays[51][0] = PDGstop1; Particlehiggsl.Array_Decays[51][1] = -PDGstop1; Particlehiggsl.Array_Decays[51][2] = h0amplitudestop1antistop1; Particlehiggsl.Array_Decays[51][3] = 2; Particlehiggsl.Array_Comments[51] = "# h -> ~t_1 ~t_1*";	  
 Particlehiggsl.Array_Decays[52][0] = PDGstop2; Particlehiggsl.Array_Decays[52][1] = -PDGstop2; Particlehiggsl.Array_Decays[52][2] = h0amplitudestop2antistop2; Particlehiggsl.Array_Decays[52][3] = 2; Particlehiggsl.Array_Comments[52] = "# h -> ~t_2 ~t_2*";
 Particlehiggsl.Array_Decays[53][0] = PDGstop1; Particlehiggsl.Array_Decays[53][1] = -PDGstop2; Particlehiggsl.Array_Decays[53][2] = h0amplitudestop1antistop2; Particlehiggsl.Array_Decays[53][3] = 2; Particlehiggsl.Array_Comments[53] = "# h -> ~t_1 ~t_2*";	  
 Particlehiggsl.Array_Decays[54][0] = PDGstop2; Particlehiggsl.Array_Decays[54][1] = -PDGstop1; Particlehiggsl.Array_Decays[54][2] = h0amplitudestop2antistop1; Particlehiggsl.Array_Decays[54][3] = 2; Particlehiggsl.Array_Comments[54] = "# h -> ~t_2 ~t_1*";
 Particlehiggsl.Array_Decays[55][0] = PDGsbottom1; Particlehiggsl.Array_Decays[55][1] = -PDGsbottom1; Particlehiggsl.Array_Decays[55][2] = h0amplitudesbottom1antisbottom1; Particlehiggsl.Array_Decays[55][3] = 2; Particlehiggsl.Array_Comments[55] = "# h -> ~b_1 ~b_1*";	  
 Particlehiggsl.Array_Decays[56][0] = PDGsbottom2; Particlehiggsl.Array_Decays[56][1] = -PDGsbottom2; Particlehiggsl.Array_Decays[56][2] = h0amplitudesbottom2antisbottom2; Particlehiggsl.Array_Decays[56][3] = 2; Particlehiggsl.Array_Comments[56] = "# h -> ~b_2 ~b_2*";
 Particlehiggsl.Array_Decays[57][0] = PDGsbottom1; Particlehiggsl.Array_Decays[57][1] = -PDGsbottom2; Particlehiggsl.Array_Decays[57][2] = h0amplitudesbottom1antisbottom2; Particlehiggsl.Array_Decays[57][3] = 2; Particlehiggsl.Array_Comments[57] = "# h -> ~b_1 ~b_2*";	  
 Particlehiggsl.Array_Decays[58][0] = PDGsbottom2; Particlehiggsl.Array_Decays[58][1] = -PDGsbottom1; Particlehiggsl.Array_Decays[58][2] = h0amplitudesbottom2antisbottom1; Particlehiggsl.Array_Decays[58][3] = 2; Particlehiggsl.Array_Comments[58] = "# h -> ~b_2 ~b_1*";
 Particlehiggsl.Array_Decays[59][0] = PDGstau1; Particlehiggsl.Array_Decays[59][1] = -PDGstau1; Particlehiggsl.Array_Decays[59][2] = h0amplitudestau1antistau1; Particlehiggsl.Array_Decays[59][3] = 2; Particlehiggsl.Array_Comments[59] = "# h -> ~tau_1- ~tau_1+";
 Particlehiggsl.Array_Decays[60][0] = PDGstau2; Particlehiggsl.Array_Decays[60][1] = -PDGstau2; Particlehiggsl.Array_Decays[60][2] = h0amplitudestau2antistau2; Particlehiggsl.Array_Decays[60][3] = 2; Particlehiggsl.Array_Comments[60] = "# h -> ~tau_2- ~tau_2+";
 Particlehiggsl.Array_Decays[61][0] = PDGstau1; Particlehiggsl.Array_Decays[61][1] = -PDGstau2; Particlehiggsl.Array_Decays[61][2] = h0amplitudestau1antistau2; Particlehiggsl.Array_Decays[61][3] = 2; Particlehiggsl.Array_Comments[61] = "# h -> ~tau_1- ~tau_2+";
 Particlehiggsl.Array_Decays[62][0] = PDGstau2; Particlehiggsl.Array_Decays[62][1] = -PDGstau1; Particlehiggsl.Array_Decays[62][2] = h0amplitudestau2antistau1; Particlehiggsl.Array_Decays[62][3] = 2; Particlehiggsl.Array_Comments[62] = "# h -> ~tau_2- ~tau_1+";
 Particlehiggsl.Array_Decays[63][0] = PDGphoton; Particlehiggsl.Array_Decays[63][1] = PDGphoton; Particlehiggsl.Array_Decays[63][2] = h0amplitudegammagamma; Particlehiggsl.Array_Decays[63][3] = 2; Particlehiggsl.Array_Comments[63] = "# h -> gamma gamma";
 Particlehiggsl.Array_Decays[64][0] = PDGgluon; Particlehiggsl.Array_Decays[64][1] = PDGgluon; Particlehiggsl.Array_Decays[64][2] = h0amplitudegluongluon; Particlehiggsl.Array_Decays[64][3] = 2; Particlehiggsl.Array_Comments[64] = "# h -> gluon gluon";
 Particlehiggsl.Array_Decays[65][0] = PDGZboson; Particlehiggsl.Array_Decays[65][1] = PDGphoton; Particlehiggsl.Array_Decays[65][2] = h0amplitudeZgamma; Particlehiggsl.Array_Decays[65][3] = 2; Particlehiggsl.Array_Comments[65] = "# h -> Z gamma";
 Particlehiggsl.Array_Decays[66][0] = PDGWplus; Particlehiggsl.Array_Decays[66][1] = -PDGWplus; Particlehiggsl.Array_Decays[66][2] = h0amplitudeWW; Particlehiggsl.Array_Decays[66][3] = h0WWNDA; Particlehiggsl.Array_Comments[66] = h0WWcomment;
 Particlehiggsl.Array_Decays[67][0] = PDGZboson; Particlehiggsl.Array_Decays[67][1] = PDGZboson; Particlehiggsl.Array_Decays[67][2] = h0amplitudeZZ; Particlehiggsl.Array_Decays[67][3] = h0ZZNDA; Particlehiggsl.Array_Comments[67] = h0ZZcomment;

 double higgsl_No_1to2_Decays = 0;
 
 higgsl_No_1to2_Decays = Particlehiggsl.No_1to2_Decays; /// As higgs NLSP decays to gravitinos unimportant as dominated by higgs to diphoton/digluon so not included any higgs to gravitino decays
   
 for (int j = 0; j<higgsl_No_1to2_Decays; j++) {
   Particlehiggsl.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
  }

 for (int j=0; j<higgsl_No_1to2_Decays; j++) {
    Particlehiggsl.two_width = Particlehiggsl.two_width + Particlehiggsl.Array_Decays[j][2];
  }
 for (int j=higgsl_No_1to2_Decays; j<Particlehiggsl.No_of_Decays; j++) {
   Particlehiggsl.three_width = Particlehiggsl.three_width + Particlehiggsl.Array_Decays[j][2];
 }

 for(int j=0; j<Particlehiggsl.No_of_Decays; j++) {
   Particlehiggsl.Array_Decays[j][4] = 0;
 }

 /// Note no need for test for nans here as the higgs 1 -> 3 decay formulae are all purely analytic algebraic expressions, therefore no numerical integration is involved so we can't get nans.

    Particlehiggsl.total_width = Particlehiggsl.two_width + Particlehiggsl.three_width;
  
   
  for (int i =0; i<Particlehiggsl.No_of_Decays; i++) {
     Particlehiggsl.Array_Decays[i][5]= Particlehiggsl.Array_Decays[i][2]/Particlehiggsl.total_width;
   } 

///cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 ///cout << "DECAY " << setw(12) << fixed << setprecision(0) << Particlehiggsl.PDG << setw(12) << scientific << setprecision(8) <<  Particlehiggsl.total_width << "   " << "# h_0 (light higgs) decays" << endl;
 ///cout.precision(7);
 ///cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 ///for (int k=0; k<Particlehiggsl.No_of_Decays; k++) {
   ///if( Particlehiggsl.Array_Decays[k][2] != 0 ) {
     ///cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << Particlehiggsl.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << Particlehiggsl.Array_Decays[k][3];  printRowPDG(cout, Particlehiggsl.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,Particlehiggsl.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << Particlehiggsl.Array_Comments[k] << endl;
     ///}
     ///else{}
   ///}
 /// cout << "#" << endl; 


///Uncomment if want partial widths as well as brancing ratios
   cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
   cout << "DECAY " << setw(12) << fixed << setprecision(0) << Particlehiggsl.PDG << setw(12) << scientific << setprecision(8) <<  Particlehiggsl.total_width << "   " << "# h_0 (light higgs) decays" << endl;
   cout.precision(7);
   cout << left << setw(6) << "#" << setw(18) << "PW" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
   for (int k=0; k<Particlehiggsl.No_of_Decays; k++) {
     if( Particlehiggsl.Array_Decays[k][2] != 0 ) {
       cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << Particlehiggsl.Array_Decays[k][2] << setprecision(8) << Particlehiggsl.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << " " << Particlehiggsl.Array_Decays[k][3] << setw(4) << " ";  printRowPDG(cout, Particlehiggsl.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,Particlehiggsl.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << Particlehiggsl.Array_Comments[k] << endl;
     }
   }
   cout << "#" << endl; 


///higgsH decays

   double H0amplitudeuantiu, H0amplitudedantid, H0amplitudesantis, H0amplitudecantic, H0amplitudebantib, H0amplitudetantit, H0amplitudeeantie, H0amplitudemuantimu, H0amplitudetauantitau, H0amplitudeneutZ1neutZ1, H0amplitudeneutZ1neutZ2, H0amplitudeneutZ1neutZ3, H0amplitudeneutZ1neutZ4, H0amplitudeneutZ2neutZ2, H0amplitudeneutZ2neutZ3, H0amplitudeneutZ2neutZ4, H0amplitudeneutZ3neutZ3, H0amplitudeneutZ3neutZ4, H0amplitudeneutZ4neutZ4, H0amplitudecharW1charW1, H0amplitudecharW1charW2, H0amplitudecharW2charW2, H0amplitudeh0h0, H0amplitudehiggsAhiggsA, H0amplitudeHplusHminus, H0amplitudehiggsAZboson, H0amplitudesupLantisupL, H0amplitudesupLantisupR, H0amplitudesupRantisupL, H0amplitudesupRantisupR, H0amplitudesdownLantisdownL, H0amplitudesdownLantisdownR, H0amplitudesdownRantisdownL, H0amplitudesdownRantisdownR, H0amplitudescharmLantischarmL, H0amplitudescharmLantischarmR, H0amplitudescharmRantischarmL, H0amplitudescharmRantischarmR, H0amplitudesstrangeLantisstrangeL, H0amplitudesstrangeLantisstrangeR, H0amplitudesstrangeRantisstrangeL, H0amplitudesstrangeRantisstrangeR, H0amplitudesnueLantisnueL, H0amplitudeselectronLantiselectronL, H0amplitudeselectronRantiselectronR, H0amplitudeselectronLantiselectronR, H0amplitudeselectronRantiselectronL, H0amplitudesnumuLantisnumuL, H0amplitudesnutauLantisnutauL, H0amplitudesmuonLantismuonL, H0amplitudesmuonRantismuonR, H0amplitudesmuonLantismuonR, H0amplitudesmuonRantismuonL, H0amplitudestau1antistau1, H0amplitudestau2antistau2, H0amplitudestau1antistau2, H0amplitudestau2antistau1, H0amplitudestop1antistop1, H0amplitudestop1antistop2, H0amplitudestop2antistop1, H0amplitudestop2antistop2, H0amplitudesbottom1antisbottom1, H0amplitudesbottom1antisbottom2, H0amplitudesbottom2antisbottom1, H0amplitudesbottom2antisbottom2, H0amplitudegluongluon, H0amplitudegammagamma, H0amplitudeWbosonWboson, H0amplitudeZbosonZboson, H0amplitudeZgamma;

 H0amplitudeuantiu = higgslorHamplitudedecayquarkantiquark (mh0(2), MUP, g, alpha, beta, runmw, 1, 'H');
 H0amplitudedantid = higgslorHamplitudedecayquarkantiquark (mh0(2), MDOWN, g, alpha, beta, runmw, 0, 'H');
 H0amplitudecantic = higgslorHamplitudedecayquarkantiquark (mh0(2), MCHARM, g, alpha, beta, runmw, 1, 'H');
 H0amplitudesantis = higgslorHamplitudedecayquarkantiquark (mh0(2), MSTRANGE, g, alpha, beta, runmw, 0, 'H');
 H0amplitudebantib = higgslorHamplitudedecayquarkantiquark (mh0(2), runmb, g, alpha, beta, runmw, 0, 'H'); ///use runmb here to reduce necessary corrections
 H0amplitudetantit = higgslorHamplitudedecayquarkantiquark (mh0(2), MTOP, g, alpha, beta, runmw, 1, 'H'); ///don't use runmt here as closer to answer with corrections with usual mass
 H0amplitudeeantie = higgslorHamplitudedecayquarkantiquark (mh0(2), MELECTRON, g, alpha, beta, runmw, 0, 'H')/3; ///0 as leptons are like down-type quarks, divide by 3 as No of colours is 1 for leptons cf 3 for quarks
 H0amplitudemuantimu = higgslorHamplitudedecayquarkantiquark (mh0(2), MMUON, g, alpha, beta, runmw, 0, 'H')/3;
 H0amplitudetauantitau = higgslorHamplitudedecayquarkantiquark (mh0(2), MTAU, g, alpha, beta, runmw, 0, 'H')/3;
 H0amplitudeneutZ1neutZ1 = higgsphiamplitudedecayneutralinoneutralino (mh0(2), mneut(1), mneut(1), g, tanthetaW, alpha, mixNeut, 1, 1, 'H');
 H0amplitudeneutZ1neutZ2 = higgsphiamplitudedecayneutralinoneutralino (mh0(2), mneut(1), mneut(2), g, tanthetaW, alpha, mixNeut, 1, 2, 'H');
 H0amplitudeneutZ1neutZ3 = higgsphiamplitudedecayneutralinoneutralino (mh0(2), mneut(1), mneut(3), g, tanthetaW, alpha, mixNeut, 1, 3, 'H');
 H0amplitudeneutZ1neutZ4 = higgsphiamplitudedecayneutralinoneutralino (mh0(2), mneut(1), mneut(4), g, tanthetaW, alpha, mixNeut, 1, 4, 'H');
 H0amplitudeneutZ2neutZ2 = higgsphiamplitudedecayneutralinoneutralino (mh0(2), mneut(2), mneut(2), g, tanthetaW, alpha, mixNeut, 2, 2, 'H');
 H0amplitudeneutZ2neutZ3 = higgsphiamplitudedecayneutralinoneutralino (mh0(2), mneut(2), mneut(3), g, tanthetaW, alpha, mixNeut, 2, 3, 'H');
 H0amplitudeneutZ2neutZ4 = higgsphiamplitudedecayneutralinoneutralino (mh0(2), mneut(2), mneut(4), g, tanthetaW, alpha, mixNeut, 2, 4, 'H');
 H0amplitudeneutZ3neutZ3 = higgsphiamplitudedecayneutralinoneutralino (mh0(2), mneut(3), mneut(3), g, tanthetaW, alpha, mixNeut, 3, 3, 'H');
 H0amplitudeneutZ3neutZ4 = higgsphiamplitudedecayneutralinoneutralino (mh0(2), mneut(3), mneut(4), g, tanthetaW, alpha, mixNeut, 3, 4, 'H');
 H0amplitudeneutZ4neutZ4 = higgsphiamplitudedecayneutralinoneutralino (mh0(2), mneut(4), mneut(4), g, tanthetaW, alpha, mixNeut, 4, 4, 'H');
 H0amplitudecharW1charW1 = higgsphiamplitudedecaysamechargino (mh0(2), mch(1), g, thetaL2, thetaR2, alpha, beta, 1, 'H');
 H0amplitudecharW2charW2 = higgsphiamplitudedecaysamechargino (mh0(2), mch(2), g, thetaL2, thetaR2, alpha, beta, 2, 'H');
 H0amplitudecharW1charW2 = higgsphiamplitudedecaydifchargino (mh0(2), mch(1), mch(2), g, thetaL2, thetaR2, alpha, beta, 'H');
 H0amplitudeh0h0 = higgsHamplitudedecayhh (mh0(2), mh0(1), g, gp, alpha, beta, runmw);
 H0amplitudehiggsAhiggsA = higgsHamplitudedecayAA (mh0(2), mA0(1), g, gp, alpha, beta, runmw);
 H0amplitudeHplusHminus = higgsHamplitudedecayHplusHminus (mh0(2), mHpm, g, gp, alpha, beta, runmw);
 H0amplitudehiggsAZboson = higgsHamplitudedecayhiggsAZboson (mh0(2), mz, mA0(1), g, gp, alpha, beta);
 H0amplitudesupLantisupL = higgsHamplitudedecay2squarksamehand (mh0(2), mu(1,1), mu(1,1), g, gp, alpha, beta, runmw, MUP, MDOWN, 1);
 H0amplitudesupRantisupR = higgsHamplitudedecay2squarksamehand (mh0(2), mu(2,1), mu(2,1), g, gp, alpha, beta, runmw, MUP, MDOWN, 3);
 H0amplitudesdownLantisdownL = higgsHamplitudedecay2squarksamehand (mh0(2), md(1,1), md(1,1), g, gp, alpha, beta, runmw, MUP, MDOWN, 2);
 H0amplitudesdownRantisdownR = higgsHamplitudedecay2squarksamehand (mh0(2), md(2,1), mu(2,1), g, gp, alpha, beta, runmw, MUP, MDOWN, 4);
 H0amplitudescharmLantischarmL = higgsHamplitudedecay2squarksamehand (mh0(2), mu(1,2), mu(1,2), g, gp, alpha, beta, runmw, MCHARM, MSTRANGE, 1);
 H0amplitudescharmRantischarmR = higgsHamplitudedecay2squarksamehand (mh0(2), mu(2,2), mu(2,2), g, gp, alpha, beta, runmw, MCHARM, MSTRANGE, 3);
 H0amplitudesstrangeLantisstrangeL = higgsHamplitudedecay2squarksamehand (mh0(2), md(2,1), md(2,1), g, gp, alpha, beta, runmw, MCHARM, MSTRANGE, 2);
 H0amplitudesstrangeRantisstrangeR = higgsHamplitudedecay2squarksamehand (mh0(2), md(2,2), md(2,2), g, gp, alpha, beta, runmw, MCHARM, MSTRANGE, 4);
 H0amplitudesupLantisupR = higgsHamplitudedecay2squarkdiffhand (mh0(2), mu(1,1), mu(2,1), g, alpha, beta, runmw, MUP, MDOWN, greekmu, Au, Ad, 1);
 H0amplitudesupRantisupL = higgsHamplitudedecay2squarkdiffhand (mh0(2), mu(1,1), mu(2,1), g, alpha, beta, runmw, MUP, MDOWN, greekmu, Au, Ad, 1);
 H0amplitudesdownLantisdownR = higgsHamplitudedecay2squarkdiffhand (mh0(2), md(1,1), md(2,1), g, alpha, beta, runmw, MUP, MDOWN, greekmu, Au, Ad, 2);
 H0amplitudesdownRantisdownL = higgsHamplitudedecay2squarkdiffhand (mh0(2), md(1,1), md(2,1), g, alpha, beta, runmw, MUP, MDOWN, greekmu, Au, Ad, 2);
 H0amplitudescharmLantischarmR = higgsHamplitudedecay2squarkdiffhand (mh0(2), mu(1,2), mu(2,2), g, alpha, beta, runmw, MCHARM, MSTRANGE, greekmu, Ac, As, 1);
 H0amplitudescharmRantischarmL = higgsHamplitudedecay2squarkdiffhand (mh0(2), mu(1,2), mu(2,2), g, alpha, beta, runmw, MCHARM, MSTRANGE, greekmu, Ac, As, 1);
 H0amplitudesstrangeLantisstrangeR = higgsHamplitudedecay2squarkdiffhand (mh0(2), md(2,1), md(2,2), g, alpha, beta, runmw, MCHARM, MSTRANGE, greekmu, Ac, As, 2);
 H0amplitudesstrangeRantisstrangeL = higgsHamplitudedecay2squarkdiffhand (mh0(2), md(2,1), md(2,2), g, alpha, beta, runmw, MCHARM, MSTRANGE, greekmu, Ac, As, 2);
 H0amplitudesnueLantisnueL = higgsHamplitudedecay2sleptonsamehand (mh0(2), msnu(1), msnu(1), g, gp, alpha, beta, runmw, MELECTRON, 1);
 H0amplitudeselectronLantiselectronL = higgsHamplitudedecay2sleptonsamehand (mh0(2), me(1,1), me(1,1), g, gp, alpha, beta, runmw, MELECTRON, 2);
 H0amplitudeselectronRantiselectronR = higgsHamplitudedecay2sleptonsamehand (mh0(2), me(2,1), me(2,1), g, gp, alpha, beta, runmw, MELECTRON, 3);
 H0amplitudeselectronLantiselectronR = higgsHamplitudedecay2sleptondiffhand (mh0(2), me(1,1), me(2,1), g, alpha, beta, runmw, MELECTRON, greekmu, Ae, 1);
 H0amplitudeselectronRantiselectronL = higgsHamplitudedecay2sleptondiffhand (mh0(2), me(2,1), me(1,1), g, alpha, beta, runmw, MELECTRON, greekmu, Ae, 1);
 H0amplitudesnumuLantisnumuL = higgsHamplitudedecay2sleptonsamehand (mh0(2), msnu(2), msnu(2), g, gp, alpha, beta, runmw, MMUON, 1);
 H0amplitudesmuonLantismuonL = higgsHamplitudedecay2sleptonsamehand (mh0(2), me(1,2), me(1,2), g, gp, alpha, beta, runmw, MMUON, 2);
 H0amplitudesmuonRantismuonR = higgsHamplitudedecay2sleptonsamehand (mh0(2), me(2,2), me(2,2), g, gp, alpha, beta, runmw, MMUON, 3);
 H0amplitudesmuonLantismuonR = higgsHamplitudedecay2sleptondiffhand (mh0(2), me(1,2), me(2,2), g, alpha, beta, runmw, MMUON, greekmu, Amu, 1);
 H0amplitudesmuonRantismuonL = higgsHamplitudedecay2sleptondiffhand (mh0(2), me(2,2), me(2,1), g, alpha, beta, runmw, MMUON, greekmu, Amu, 1);
 H0amplitudesnutauLantisnutauL = higgsHamplitudedecay2sleptonsamehand (mh0(2), msnu(3), msnu(3), g, gp, alpha, beta, runmw, MTAU, 1);
 H0amplitudestop1antistop1 = higgsHamplitudedecaystop1stop1 (mh0(2), mu(1,3), mu(1,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetat); ///note for consistency with earlier decays perhaps one should use runmt and runmb here - don't for now as MTOP and MBOTTOM give greater agreement with susyhit as susyhit uses non-running masses here
 H0amplitudestop2antistop2 = higgsHamplitudedecaystop2stop2 (mh0(2), mu(2,3), mu(2,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetat); ///note for consistency with earlier decays perhaps one should use runmt and runmb here - don't for now as MTOP and MBOTTOM give greater agreement with susyhit as susyhit uses non-running masses here
 H0amplitudestop1antistop2 = higgsHamplitudedecaystop1stop2 (mh0(2), mu(1,3), mu(2,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetat); ///note for consistency with earlier decays perhaps one should use runmt and runmb here - don't for now as MTOP and MBOTTOM give greater agreement with susyhit as susyhit uses non-running masses here
 H0amplitudestop2antistop1 = higgsHamplitudedecaystop1stop2 (mh0(2), mu(2,3), mu(1,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetat); ///note for consistency with earlier decays perhaps one should use runmt and runmb here - don't for now as MTOP and MBOTTOM give greater agreement with susyhit as susyhit uses non-running masses here
 H0amplitudesbottom1antisbottom1 = higgsHamplitudedecaysbottom1sbottom1(mh0(2), md(1,3), md(1,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetab); ///note for consistency with earlier decays perhaps one should use runmt and runmb here - don't for now as MTOP and MBOTTOM give greater agreement with susyhit as susyhit uses non-running masses here
 H0amplitudesbottom2antisbottom2 = higgsHamplitudedecaysbottom2sbottom2(mh0(2), md(2,3), md(2,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetab); ///note for consistency with earlier decays perhaps one should use runmt and runmb here - don't for now as MTOP and MBOTTOM give greater agreement with susyhit as susyhit uses non-running masses here
 H0amplitudesbottom1antisbottom2 = higgsHamplitudedecaysbottom1sbottom2 (mh0(2), md(1,3), md(2,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetab); ///note for consistency with earlier decays perhaps one should use runmt and runmb here - don't for now as MTOP and MBOTTOM give greater agreement with susyhit as susyhit uses non-running masses here
 H0amplitudesbottom2antisbottom1 = higgsHamplitudedecaysbottom1sbottom2 (mh0(2), md(2,3), md(1,3), g, gp, alpha, beta, runmw, MTOP, MBOTTOM, greekmu, At, Ab, thetab); ///note for consistency with earlier decays perhaps one should use runmt and runmb here - don't for now as MTOP and MBOTTOM give greater agreement with susyhit as susyhit uses non-running masses here
 H0amplitudestau1antistau1 = higgsHamplitudedecaystau1stau1 (mh0(2), me(1,3), me(1,3), g, gp, alpha, beta, runmw, MTAU, greekmu, Atau, thetatau);
 H0amplitudestau2antistau2 = higgsHamplitudedecaystau2stau2 (mh0(2), me(2,3), me(2,3), g, gp, alpha, beta, runmw, MTAU, greekmu, Atau, thetatau);
 H0amplitudestau1antistau2 = higgsHamplitudedecaystau1stau2 (mh0(2), me(1,3), me(2,3), g, gp, alpha, beta, runmw, MTAU, greekmu, Atau, thetatau);
 H0amplitudestau2antistau1 = higgsHamplitudedecaystau1stau2 (mh0(2), me(2,3), me(1,3), g, gp, alpha, beta, runmw, MTAU, greekmu, Atau, thetatau);
 
 H0amplitudegammagamma = higgsesamplitudedecaygammagammatotal(mh0(2), g, gp, runmw, polemw, alpha, beta, MTOP, MBOTTOM, MCHARM, MTAU, mHpm, mu(1,3), mu(2,3), md(1,3), md(2,3), me(1,3), me(2,3), mch(1), mch(2), thetaL, thetaR, thetat, thetab, thetatau, greekmu, At, Ab, Atau, 'H');
 H0amplitudegluongluon = higgsesamplitudedecaygluongluontotal(mh0(2), g, g3atmH0, gp, runmw, alpha, beta, MTOP, MBOTTOM, MCHARM, mu(1,3), mu(2,3), md(1,3), md(2,3), thetaL, thetaR, thetat, thetab, greekmu, At, Ab, 'H');
 H0amplitudeWbosonWboson = higgsHamplitudedecayVV(mh0(2), polemw, mz, g, gp, alpha, beta, 'W')(1);
 H0amplitudeZgamma = higgsesamplitudedecayZbosonphotontotal(mh0(2), mz, g, gp, polemw, runmw, alpha, beta, MTOP, MBOTTOM, MCHARM, MSTRANGE, mu(1,3), mu(2,3), md(1,3), md(2,3), mHpm, thetaL, thetaR, thetat, thetab, greekmu, At, Ab, 'H');

 int H0WWcommentcode, H0ZZcommentcode, H0WWNDA=0, H0ZZNDA=0;
 H0WWcommentcode = higgsHamplitudedecayVV(mh0(2), polemw, mz, g, gp, alpha, beta, 'W')(2);
 string H0WWcomment, H0ZZcomment;
 if (H0WWcommentcode == 1) {
   H0WWcomment = "# H -> WW* -> W f f'bar";
   H0WWNDA = 3;
 }
 else if(H0WWcommentcode == 2) {
   H0WWcomment = "# H -> W+ W-";
   H0WWNDA = 2;
 }
 H0amplitudeZbosonZboson = higgsHamplitudedecayVV(mh0(2), polemw, mz, g, gp, alpha, beta, 'Z')(1);
 H0ZZcommentcode = higgsHamplitudedecayVV(mh0(2), polemw, mz, g, gp, alpha, beta, 'Z')(2);
 if (H0ZZcommentcode == 1) {
   H0ZZcomment = "# H -> ZZ* -> Z f f'bar";
   H0ZZNDA = 3;
 }
 else if(H0ZZcommentcode == 2) {
   H0ZZcomment = "# H -> Z Z";
   H0ZZNDA = 2;
 }



 ParticleHiggsH.Array_Decays[0][0] = PDGup; ParticleHiggsH.Array_Decays[0][1] = -PDGup; ParticleHiggsH.Array_Decays[0][2] = H0amplitudeuantiu; ParticleHiggsH.Array_Decays[0][3] = 2; ParticleHiggsH.Array_Comments[0] = "# H -> u ub";
 ParticleHiggsH.Array_Decays[1][0] = PDGdown; ParticleHiggsH.Array_Decays[1][1] = -PDGdown; ParticleHiggsH.Array_Decays[1][2] = H0amplitudedantid; ParticleHiggsH.Array_Decays[1][3] = 2; ParticleHiggsH.Array_Comments[1] = "# H -> d db";
 ParticleHiggsH.Array_Decays[2][0] = PDGcharm; ParticleHiggsH.Array_Decays[2][1] = -PDGcharm; ParticleHiggsH.Array_Decays[2][2] = H0amplitudecantic; ParticleHiggsH.Array_Decays[2][3] = 2; ParticleHiggsH.Array_Comments[2] = "# H -> c cb";
 ParticleHiggsH.Array_Decays[3][0] = PDGstrange; ParticleHiggsH.Array_Decays[3][1] = -PDGstrange; ParticleHiggsH.Array_Decays[3][2] = H0amplitudesantis; ParticleHiggsH.Array_Decays[3][3] = 2; ParticleHiggsH.Array_Comments[3] = "# H -> s sb";
 ParticleHiggsH.Array_Decays[4][0] = PDGbottom; ParticleHiggsH.Array_Decays[4][1] = -PDGbottom; ParticleHiggsH.Array_Decays[4][2] = H0amplitudebantib; ParticleHiggsH.Array_Decays[4][3] = 2; ParticleHiggsH.Array_Comments[4] = "# H -> b bb";
 ParticleHiggsH.Array_Decays[5][0] = PDGtop; ParticleHiggsH.Array_Decays[5][1] = -PDGtop; ParticleHiggsH.Array_Decays[5][2] = H0amplitudetantit; ParticleHiggsH.Array_Decays[5][3] = 2; ParticleHiggsH.Array_Comments[5] = "# H -> t tb";
 ParticleHiggsH.Array_Decays[6][0] = PDGelectron; ParticleHiggsH.Array_Decays[6][1] = -PDGelectron; ParticleHiggsH.Array_Decays[6][2] = H0amplitudeeantie; ParticleHiggsH.Array_Decays[6][3] = 2; ParticleHiggsH.Array_Comments[6] = "# H -> e- e+";
 ParticleHiggsH.Array_Decays[7][0] = PDGmuon; ParticleHiggsH.Array_Decays[7][1] = -PDGmuon; ParticleHiggsH.Array_Decays[7][2] = H0amplitudemuantimu; ParticleHiggsH.Array_Decays[7][3] = 2; ParticleHiggsH.Array_Comments[7] = "# H -> mu- mu+";
 ParticleHiggsH.Array_Decays[8][0] = PDGtau; ParticleHiggsH.Array_Decays[8][1] = -PDGtau; ParticleHiggsH.Array_Decays[8][2] = H0amplitudetauantitau; ParticleHiggsH.Array_Decays[8][3] = 2; ParticleHiggsH.Array_Comments[8] = "# H -> tau- tau+";
 ParticleHiggsH.Array_Decays[9][0] = PDGneutralino1; ParticleHiggsH.Array_Decays[9][1] = PDGneutralino1; ParticleHiggsH.Array_Decays[9][2] = H0amplitudeneutZ1neutZ1; ParticleHiggsH.Array_Decays[9][3] = 2; ParticleHiggsH.Array_Comments[9] = "# H -> ~chi_10 ~chi_10";
 ParticleHiggsH.Array_Decays[10][0] = PDGneutralino1; ParticleHiggsH.Array_Decays[10][1] = PDGneutralino2; ParticleHiggsH.Array_Decays[10][2] = H0amplitudeneutZ1neutZ2; ParticleHiggsH.Array_Decays[10][3] = 2; ParticleHiggsH.Array_Comments[10] = "# H -> ~chi_10 ~chi_20";
 ParticleHiggsH.Array_Decays[11][0] = PDGneutralino1; ParticleHiggsH.Array_Decays[11][1] = PDGneutralino3; ParticleHiggsH.Array_Decays[11][2] = H0amplitudeneutZ1neutZ3; ParticleHiggsH.Array_Decays[11][3] = 2; ParticleHiggsH.Array_Comments[11] = "# H -> ~chi_10 ~chi_30";
 ParticleHiggsH.Array_Decays[12][0] = PDGneutralino1; ParticleHiggsH.Array_Decays[12][1] = PDGneutralino4; ParticleHiggsH.Array_Decays[12][2] = H0amplitudeneutZ1neutZ4; ParticleHiggsH.Array_Decays[12][3] = 2; ParticleHiggsH.Array_Comments[12] = "# H -> ~chi_10 ~chi_40";
 ParticleHiggsH.Array_Decays[13][0] = PDGneutralino2; ParticleHiggsH.Array_Decays[13][1] = PDGneutralino2; ParticleHiggsH.Array_Decays[13][2] = H0amplitudeneutZ2neutZ2; ParticleHiggsH.Array_Decays[13][3] = 2; ParticleHiggsH.Array_Comments[13] = "# H -> ~chi_20 ~chi_20";
 ParticleHiggsH.Array_Decays[14][0] = PDGneutralino2; ParticleHiggsH.Array_Decays[14][1] = PDGneutralino3; ParticleHiggsH.Array_Decays[14][2] = H0amplitudeneutZ2neutZ3; ParticleHiggsH.Array_Decays[14][3] = 2; ParticleHiggsH.Array_Comments[14] = "# H -> ~chi_20 ~chi_30";
 ParticleHiggsH.Array_Decays[15][0] = PDGneutralino2; ParticleHiggsH.Array_Decays[15][1] = PDGneutralino4; ParticleHiggsH.Array_Decays[15][2] = H0amplitudeneutZ2neutZ4; ParticleHiggsH.Array_Decays[15][3] = 2; ParticleHiggsH.Array_Comments[15] = "# H -> ~chi_20 ~chi_40";
 ParticleHiggsH.Array_Decays[16][0] = PDGneutralino3; ParticleHiggsH.Array_Decays[16][1] = PDGneutralino3; ParticleHiggsH.Array_Decays[16][2] = H0amplitudeneutZ3neutZ3; ParticleHiggsH.Array_Decays[16][3] = 2; ParticleHiggsH.Array_Comments[16] = "# H -> ~chi_30 ~chi_30";
 ParticleHiggsH.Array_Decays[17][0] = PDGneutralino3; ParticleHiggsH.Array_Decays[17][1] = PDGneutralino4; ParticleHiggsH.Array_Decays[17][2] = H0amplitudeneutZ3neutZ4; ParticleHiggsH.Array_Decays[17][3] = 2; ParticleHiggsH.Array_Comments[17] = "# H -> ~chi_30 ~chi_40";
 ParticleHiggsH.Array_Decays[18][0] = PDGneutralino4; ParticleHiggsH.Array_Decays[18][1] = PDGneutralino4; ParticleHiggsH.Array_Decays[18][2] = H0amplitudeneutZ4neutZ4; ParticleHiggsH.Array_Decays[18][3] = 2; ParticleHiggsH.Array_Comments[18] = "# H -> ~chi_40 ~chi_40";
 ParticleHiggsH.Array_Decays[19][0] = PDGchargino1; ParticleHiggsH.Array_Decays[19][1] = -PDGchargino1; ParticleHiggsH.Array_Decays[19][2] = H0amplitudecharW1charW1; ParticleHiggsH.Array_Decays[19][3] = 2; ParticleHiggsH.Array_Comments[19] = "# H -> ~chi_1+ ~chi_1-";
 ParticleHiggsH.Array_Decays[20][0] = PDGchargino2; ParticleHiggsH.Array_Decays[20][1] = -PDGchargino2; ParticleHiggsH.Array_Decays[20][2] = H0amplitudecharW2charW2; ParticleHiggsH.Array_Decays[20][3] = 2; ParticleHiggsH.Array_Comments[20] = "# H -> ~chi_2+ ~chi_2-";
 ParticleHiggsH.Array_Decays[21][0] = PDGchargino1; ParticleHiggsH.Array_Decays[21][1] = -PDGchargino2; ParticleHiggsH.Array_Decays[21][2] = H0amplitudecharW1charW2; ParticleHiggsH.Array_Decays[21][3] = 2; ParticleHiggsH.Array_Comments[21] = "# H -> ~chi_1+ ~chi_2-";
 ParticleHiggsH.Array_Decays[22][0] = PDGchargino2; ParticleHiggsH.Array_Decays[22][1] = -PDGchargino1; ParticleHiggsH.Array_Decays[22][2] = H0amplitudecharW1charW2; ParticleHiggsH.Array_Decays[22][3] = 2; ParticleHiggsH.Array_Comments[22] = "# H -> ~chi_2+ ~chi_1-"; ///amplitude same as decay to W1+ and W2- by CP invariance
 ParticleHiggsH.Array_Decays[23][0] = PDGh0; ParticleHiggsH.Array_Decays[23][1] = PDGh0; ParticleHiggsH.Array_Decays[23][2] = H0amplitudeh0h0; ParticleHiggsH.Array_Decays[23][3] = 2; ParticleHiggsH.Array_Comments[23] = "# H -> h h";
 ParticleHiggsH.Array_Decays[24][0] = PDGA0; ParticleHiggsH.Array_Decays[24][1] = PDGA0; ParticleHiggsH.Array_Decays[24][2] = H0amplitudehiggsAhiggsA; ParticleHiggsH.Array_Decays[24][3] = 2; ParticleHiggsH.Array_Comments[24] = "# H -> A A";
 ParticleHiggsH.Array_Decays[25][0] = PDGHplus; ParticleHiggsH.Array_Decays[25][1] = -PDGHplus; ParticleHiggsH.Array_Decays[25][2] = H0amplitudeHplusHminus; ParticleHiggsH.Array_Decays[25][3] = 2; ParticleHiggsH.Array_Comments[25] = "# H -> H+ H-";
 ParticleHiggsH.Array_Decays[26][0] = PDGA0; ParticleHiggsH.Array_Decays[26][1] = PDGZboson; ParticleHiggsH.Array_Decays[26][2] = H0amplitudehiggsAZboson; ParticleHiggsH.Array_Decays[26][3] = 2; ParticleHiggsH.Array_Comments[26] = "# H -> A Z";
  ParticleHiggsH.Array_Decays[24][0] = PDGsupL; ParticleHiggsH.Array_Decays[24][1] = -PDGsupL; ParticleHiggsH.Array_Decays[24][2] = H0amplitudesupLantisupL; ParticleHiggsH.Array_Decays[24][3] = 2; ParticleHiggsH.Array_Comments[24] = "# H -> ~u_L ~u_L*";
 ParticleHiggsH.Array_Decays[25][0] = PDGsupR; ParticleHiggsH.Array_Decays[25][1] = -PDGsupR; ParticleHiggsH.Array_Decays[25][2] = H0amplitudesupRantisupR; ParticleHiggsH.Array_Decays[25][3] = 2; ParticleHiggsH.Array_Comments[25] = "# H -> ~u_R ~u_R*";
 ParticleHiggsH.Array_Decays[26][0] = PDGsupL; ParticleHiggsH.Array_Decays[26][1] = -PDGsupR; ParticleHiggsH.Array_Decays[26][2] = H0amplitudesupLantisupR; ParticleHiggsH.Array_Decays[26][3] = 2; ParticleHiggsH.Array_Comments[26] = "# H -> ~u_L ~u_R*";
 ParticleHiggsH.Array_Decays[27][0] = PDGsupR; ParticleHiggsH.Array_Decays[27][1] = -PDGsupL; ParticleHiggsH.Array_Decays[27][2] = H0amplitudesupRantisupL; ParticleHiggsH.Array_Decays[27][3] = 2; ParticleHiggsH.Array_Comments[27] = "# H -> ~u_R ~u_L*";
 ParticleHiggsH.Array_Decays[28][0] = PDGsdownL; ParticleHiggsH.Array_Decays[28][1] = -PDGsdownL; ParticleHiggsH.Array_Decays[28][2] = H0amplitudesdownLantisdownL; ParticleHiggsH.Array_Decays[28][3] = 2; ParticleHiggsH.Array_Comments[28] = "# H -> ~d_L ~d_L*";
 ParticleHiggsH.Array_Decays[29][0] = PDGsdownR; ParticleHiggsH.Array_Decays[29][1] = -PDGsdownR; ParticleHiggsH.Array_Decays[29][2] = H0amplitudesdownRantisdownR; ParticleHiggsH.Array_Decays[29][3] = 2; ParticleHiggsH.Array_Comments[29] = "# H -> ~d_R ~d_R*";
 ParticleHiggsH.Array_Decays[30][0] = PDGsdownL; ParticleHiggsH.Array_Decays[30][1] = -PDGsdownR; ParticleHiggsH.Array_Decays[30][2] = H0amplitudesdownLantisdownR; ParticleHiggsH.Array_Decays[30][3] = 2; ParticleHiggsH.Array_Comments[30] = "# H -> ~d_L ~d_R*";
 ParticleHiggsH.Array_Decays[31][0] = PDGsdownR; ParticleHiggsH.Array_Decays[31][1] = -PDGsdownL; ParticleHiggsH.Array_Decays[31][2] = H0amplitudesdownRantisdownL; ParticleHiggsH.Array_Decays[31][3] = 2; ParticleHiggsH.Array_Comments[31] = "# H -> ~d_R ~d_L*";
 ParticleHiggsH.Array_Decays[32][0] = PDGscharmL; ParticleHiggsH.Array_Decays[32][1] = -PDGscharmL; ParticleHiggsH.Array_Decays[32][2] = H0amplitudescharmLantischarmL; ParticleHiggsH.Array_Decays[32][3] = 2; ParticleHiggsH.Array_Comments[32] = "# H -> ~c_L ~c_L*";
 ParticleHiggsH.Array_Decays[33][0] = PDGscharmR; ParticleHiggsH.Array_Decays[33][1] = -PDGscharmR; ParticleHiggsH.Array_Decays[33][2] = H0amplitudescharmRantischarmR; ParticleHiggsH.Array_Decays[33][3] = 2; ParticleHiggsH.Array_Comments[33] = "# H -> ~c_R ~c_R*";
 ParticleHiggsH.Array_Decays[34][0] = PDGscharmL; ParticleHiggsH.Array_Decays[34][1] = -PDGscharmR; ParticleHiggsH.Array_Decays[34][2] = H0amplitudescharmLantischarmR; ParticleHiggsH.Array_Decays[34][3] = 2; ParticleHiggsH.Array_Comments[34] = "# H -> ~c_L ~c_R*";
 ParticleHiggsH.Array_Decays[35][0] = PDGscharmR; ParticleHiggsH.Array_Decays[35][1] = -PDGscharmL; ParticleHiggsH.Array_Decays[35][2] = H0amplitudescharmRantischarmL; ParticleHiggsH.Array_Decays[35][3] = 2; ParticleHiggsH.Array_Comments[35] = "# H -> ~c_R ~c_L*";
 ParticleHiggsH.Array_Decays[36][0] = PDGsstrangeL; ParticleHiggsH.Array_Decays[36][1] = -PDGsstrangeL; ParticleHiggsH.Array_Decays[36][2] = H0amplitudesstrangeLantisstrangeL; ParticleHiggsH.Array_Decays[36][3] = 2; ParticleHiggsH.Array_Comments[36] = "# H -> ~s_L ~s_L*";
 ParticleHiggsH.Array_Decays[37][0] = PDGsstrangeR; ParticleHiggsH.Array_Decays[37][1] = -PDGsstrangeR; ParticleHiggsH.Array_Decays[37][2] = H0amplitudesstrangeRantisstrangeR; ParticleHiggsH.Array_Decays[37][3] = 2; ParticleHiggsH.Array_Comments[37] = "# H -> ~s_R ~s_R*";
 ParticleHiggsH.Array_Decays[38][0] = PDGsstrangeL; ParticleHiggsH.Array_Decays[38][1] = -PDGsstrangeR; ParticleHiggsH.Array_Decays[38][2] = H0amplitudesstrangeLantisstrangeR; ParticleHiggsH.Array_Decays[38][3] = 2; ParticleHiggsH.Array_Comments[38] = "# H -> ~s_L ~s_R*";
 ParticleHiggsH.Array_Decays[39][0] = PDGsstrangeR; ParticleHiggsH.Array_Decays[39][1] = -PDGsstrangeL; ParticleHiggsH.Array_Decays[39][2] = H0amplitudesstrangeRantisstrangeL; ParticleHiggsH.Array_Decays[39][3] = 2; ParticleHiggsH.Array_Comments[39] = "# H -> ~s_R ~s_L*";
 ParticleHiggsH.Array_Decays[40][0] = PDGnuselectronL; ParticleHiggsH.Array_Decays[40][1] = -PDGnuselectronL; ParticleHiggsH.Array_Decays[40][2] = H0amplitudesnueLantisnueL; ParticleHiggsH.Array_Decays[40][3] = 2; ParticleHiggsH.Array_Comments[40] = "# H -> ~nu_eL ~nu_eL*";
 ParticleHiggsH.Array_Decays[41][0] = PDGselectronL; ParticleHiggsH.Array_Decays[41][1] = -PDGselectronL; ParticleHiggsH.Array_Decays[41][2] = H0amplitudeselectronLantiselectronL; ParticleHiggsH.Array_Decays[41][3] = 2; ParticleHiggsH.Array_Comments[41] = "# H -> ~e_L- ~e_L+";
 ParticleHiggsH.Array_Decays[42][0] = PDGselectronR; ParticleHiggsH.Array_Decays[42][1] = -PDGselectronR; ParticleHiggsH.Array_Decays[42][2] = H0amplitudeselectronRantiselectronR; ParticleHiggsH.Array_Decays[42][3] = 2; ParticleHiggsH.Array_Comments[42] = "# H -> ~e_R- ~e_R+";
 ParticleHiggsH.Array_Decays[43][0] = PDGselectronL; ParticleHiggsH.Array_Decays[43][1] = -PDGselectronR; ParticleHiggsH.Array_Decays[43][2] = H0amplitudeselectronLantiselectronR; ParticleHiggsH.Array_Decays[43][3] = 2; ParticleHiggsH.Array_Comments[43] = "# H -> ~e_L- ~e_R+";
 ParticleHiggsH.Array_Decays[44][0] = PDGselectronR; ParticleHiggsH.Array_Decays[44][1] = -PDGselectronL; ParticleHiggsH.Array_Decays[44][2] = H0amplitudeselectronRantiselectronL; ParticleHiggsH.Array_Decays[44][3] = 2; ParticleHiggsH.Array_Comments[44] = "# H -> ~e_R- ~e_L+";
 ParticleHiggsH.Array_Decays[45][0] = PDGnusmuonL; ParticleHiggsH.Array_Decays[45][1] = -PDGnusmuonL; ParticleHiggsH.Array_Decays[45][2] = H0amplitudesnumuLantisnumuL; ParticleHiggsH.Array_Decays[45][3] = 2; ParticleHiggsH.Array_Comments[45] = "# H -> ~nu_muL ~nu_muL*";
 ParticleHiggsH.Array_Decays[46][0] = PDGsmuonL; ParticleHiggsH.Array_Decays[46][1] = -PDGsmuonL; ParticleHiggsH.Array_Decays[46][2] = H0amplitudesmuonLantismuonL; ParticleHiggsH.Array_Decays[46][3] = 2; ParticleHiggsH.Array_Comments[46] = "# H -> ~mu_L- ~mu_L+";
 ParticleHiggsH.Array_Decays[47][0] = PDGsmuonR; ParticleHiggsH.Array_Decays[47][1] = -PDGsmuonR; ParticleHiggsH.Array_Decays[47][2] = H0amplitudesmuonRantismuonR; ParticleHiggsH.Array_Decays[47][3] = 2; ParticleHiggsH.Array_Comments[47] = "# H -> ~mu_R- ~mu_R+";
 ParticleHiggsH.Array_Decays[48][0] = PDGsmuonL; ParticleHiggsH.Array_Decays[48][1] = -PDGsmuonR; ParticleHiggsH.Array_Decays[48][2] = H0amplitudesmuonLantismuonR; ParticleHiggsH.Array_Decays[48][3] = 2; ParticleHiggsH.Array_Comments[48] = "# H -> ~mu_L- ~mu_R+";
 ParticleHiggsH.Array_Decays[49][0] = PDGsmuonR; ParticleHiggsH.Array_Decays[49][1] = -PDGsmuonL; ParticleHiggsH.Array_Decays[49][2] = H0amplitudesmuonRantismuonL; ParticleHiggsH.Array_Decays[49][3] = 2; ParticleHiggsH.Array_Comments[49] = "# H -> ~mu_R- ~mu_L+";	
 ParticleHiggsH.Array_Decays[50][0] = PDGnustauL; ParticleHiggsH.Array_Decays[50][1] = -PDGnustauL; ParticleHiggsH.Array_Decays[50][2] = H0amplitudesnutauLantisnutauL; ParticleHiggsH.Array_Decays[50][3] = 2; ParticleHiggsH.Array_Comments[50] = "# H -> ~nu_tauL ~nu_tauL*";
 ParticleHiggsH.Array_Decays[51][0] = PDGstop1; ParticleHiggsH.Array_Decays[51][1] = -PDGstop1; ParticleHiggsH.Array_Decays[51][2] = H0amplitudestop1antistop1; ParticleHiggsH.Array_Decays[51][3] = 2; ParticleHiggsH.Array_Comments[51] = "# H -> ~t_1 ~t_1*";	  
 ParticleHiggsH.Array_Decays[52][0] = PDGstop2; ParticleHiggsH.Array_Decays[52][1] = -PDGstop2; ParticleHiggsH.Array_Decays[52][2] = H0amplitudestop2antistop2; ParticleHiggsH.Array_Decays[52][3] = 2; ParticleHiggsH.Array_Comments[52] = "# H -> ~t_2 ~t_2*";
 ParticleHiggsH.Array_Decays[53][0] = PDGstop1; ParticleHiggsH.Array_Decays[53][1] = -PDGstop2; ParticleHiggsH.Array_Decays[53][2] = H0amplitudestop1antistop2; ParticleHiggsH.Array_Decays[53][3] = 2; ParticleHiggsH.Array_Comments[53] = "# H -> ~t_1 ~t_2*";	  
 ParticleHiggsH.Array_Decays[54][0] = PDGstop2; ParticleHiggsH.Array_Decays[54][1] = -PDGstop1; ParticleHiggsH.Array_Decays[54][2] = H0amplitudestop2antistop1; ParticleHiggsH.Array_Decays[54][3] = 2; ParticleHiggsH.Array_Comments[54] = "# H -> ~t_2 ~t_1*";
 ParticleHiggsH.Array_Decays[55][0] = PDGsbottom1; ParticleHiggsH.Array_Decays[55][1] = -PDGsbottom1; ParticleHiggsH.Array_Decays[55][2] = H0amplitudesbottom1antisbottom1; ParticleHiggsH.Array_Decays[55][3] = 2; ParticleHiggsH.Array_Comments[55] = "# H -> ~b_1 ~b_1*";	  
 ParticleHiggsH.Array_Decays[56][0] = PDGsbottom2; ParticleHiggsH.Array_Decays[56][1] = -PDGsbottom2; ParticleHiggsH.Array_Decays[56][2] = H0amplitudesbottom2antisbottom2; ParticleHiggsH.Array_Decays[56][3] = 2; ParticleHiggsH.Array_Comments[56] = "# H -> ~b_2 ~b_2*";
 ParticleHiggsH.Array_Decays[57][0] = PDGsbottom1; ParticleHiggsH.Array_Decays[57][1] = -PDGsbottom2; ParticleHiggsH.Array_Decays[57][2] = H0amplitudesbottom1antisbottom2; ParticleHiggsH.Array_Decays[57][3] = 2; ParticleHiggsH.Array_Comments[57] = "# H -> ~b_1 ~b_2*";	  
 ParticleHiggsH.Array_Decays[58][0] = PDGsbottom2; ParticleHiggsH.Array_Decays[58][1] = -PDGsbottom1; ParticleHiggsH.Array_Decays[58][2] = H0amplitudesbottom2antisbottom1; ParticleHiggsH.Array_Decays[58][3] = 2; ParticleHiggsH.Array_Comments[58] = "# H -> ~b_2 ~b_1*";
 ParticleHiggsH.Array_Decays[59][0] = PDGstau1; ParticleHiggsH.Array_Decays[59][1] = -PDGstau1; ParticleHiggsH.Array_Decays[59][2] = H0amplitudestau1antistau1; ParticleHiggsH.Array_Decays[59][3] = 2; ParticleHiggsH.Array_Comments[59] = "# H -> ~tau_1- ~tau_1+";	  
 ParticleHiggsH.Array_Decays[60][0] = PDGstau2; ParticleHiggsH.Array_Decays[60][1] = -PDGstau2; ParticleHiggsH.Array_Decays[60][2] = H0amplitudestau2antistau2; ParticleHiggsH.Array_Decays[60][3] = 2; ParticleHiggsH.Array_Comments[60] = "# H -> ~tau_2- ~tau_2+";
 ParticleHiggsH.Array_Decays[61][0] = PDGstau1; ParticleHiggsH.Array_Decays[61][1] = -PDGstau2; ParticleHiggsH.Array_Decays[61][2] = H0amplitudestau1antistau2; ParticleHiggsH.Array_Decays[61][3] = 2; ParticleHiggsH.Array_Comments[61] = "# H -> ~tau_1- ~tau_2+";	  
 ParticleHiggsH.Array_Decays[62][0] = PDGstau2; ParticleHiggsH.Array_Decays[62][1] = -PDGstau1; ParticleHiggsH.Array_Decays[62][2] = H0amplitudestau2antistau1; ParticleHiggsH.Array_Decays[62][3] = 2; ParticleHiggsH.Array_Comments[62] = "# H -> ~tau_2- ~tau_1+";
 ParticleHiggsH.Array_Decays[63][0] = PDGphoton; ParticleHiggsH.Array_Decays[63][1] = PDGphoton; ParticleHiggsH.Array_Decays[63][2] = H0amplitudegammagamma; ParticleHiggsH.Array_Decays[63][3] = 2; ParticleHiggsH.Array_Comments[63] = "# H -> gamma gamma";
 ParticleHiggsH.Array_Decays[64][0] = PDGgluon; ParticleHiggsH.Array_Decays[64][1] = PDGgluon; ParticleHiggsH.Array_Decays[64][2] = H0amplitudegluongluon; ParticleHiggsH.Array_Decays[64][3] = 2; ParticleHiggsH.Array_Comments[64] = "# H -> gluon gluon";
 ParticleHiggsH.Array_Decays[65][0] = PDGZboson; ParticleHiggsH.Array_Decays[65][1] = PDGphoton; ParticleHiggsH.Array_Decays[65][2] = H0amplitudeZgamma; ParticleHiggsH.Array_Decays[65][3] = 2; ParticleHiggsH.Array_Comments[65] = "# H -> Z gamma";
 ParticleHiggsH.Array_Decays[66][0] = PDGWplus; ParticleHiggsH.Array_Decays[66][1] = -PDGWplus; ParticleHiggsH.Array_Decays[66][2] = H0amplitudeWbosonWboson; ParticleHiggsH.Array_Decays[66][3] = H0WWNDA; ParticleHiggsH.Array_Comments[66] = H0WWcomment;
 ParticleHiggsH.Array_Decays[67][0] = PDGZboson; ParticleHiggsH.Array_Decays[67][1] = -PDGZboson; ParticleHiggsH.Array_Decays[67][2] = H0amplitudeZbosonZboson; ParticleHiggsH.Array_Decays[67][3] = H0ZZNDA; ParticleHiggsH.Array_Comments[67] = H0ZZcomment;


 double HiggsH_No_1to2_Decays = 0;
 
 HiggsH_No_1to2_Decays = ParticleHiggsH.No_1to2_Decays; /// As higgsH can't be NLSP as heavier than higgsl
   
 for (int j = 0; j<HiggsH_No_1to2_Decays; j++) {
   ParticleHiggsH.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
  }

 for (int j=0; j<HiggsH_No_1to2_Decays; j++) {
    ParticleHiggsH.two_width = ParticleHiggsH.two_width + ParticleHiggsH.Array_Decays[j][2];
  }
 for (int j=HiggsH_No_1to2_Decays; j<ParticleHiggsH.No_of_Decays; j++) {
   ParticleHiggsH.three_width = ParticleHiggsH.three_width + ParticleHiggsH.Array_Decays[j][2];
 }

 for(int j=0; j<ParticleHiggsH.No_of_Decays; j++) {
   ParticleHiggsH.Array_Decays[j][4] = 0;
 }

 /// Note no need for test for nans here as the higgs 1 -> 3 decay formulae are all purely analytic algebraic expressions, therefore no numerical integration is involved so we can't get nans.

    ParticleHiggsH.total_width = ParticleHiggsH.two_width + ParticleHiggsH.three_width;
  
   
  for (int i =0; i<ParticleHiggsH.No_of_Decays; i++) {
     ParticleHiggsH.Array_Decays[i][5]= ParticleHiggsH.Array_Decays[i][2]/ParticleHiggsH.total_width;
   } 


 /// cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 /// cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleHiggsH.PDG << setw(12) << scientific << setprecision(8) <<  ParticleHiggsH.total_width << "   " << "# H_0 (heavy higgs) decays" << endl;
 /// cout.precision(7);
 /// cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 /// for (int k=0; k<ParticleHiggsH.No_of_Decays; k++) {
 ///   if( ParticleHiggsH.Array_Decays[k][2] != 0 ) {
 ///     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleHiggsH.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleHiggsH.Array_Decays[k][3];  printRowPDG(cout, ParticleHiggsH.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleHiggsH.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleHiggsH.Array_Comments[k] << endl;
 ///   }
 ///   else{}
 /// }
 /// cout << "#" << endl; 


///Uncomment section below if want partial widths as well as branching ratios
  cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleHiggsH.PDG << setw(12) << scientific << setprecision(8) <<  ParticleHiggsH.total_width << "   " << "# H_0 (heavy higgs) decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "PW" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleHiggsH.No_of_Decays; k++) {
   if( ParticleHiggsH.Array_Decays[k][2] != 0 ) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleHiggsH.Array_Decays[k][2] << setprecision(8) << ParticleHiggsH.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << " " << ParticleHiggsH.Array_Decays[k][3] << setw(4) << " ";  printRowPDG(cout, ParticleHiggsH.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleHiggsH.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleHiggsH.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl; 



///higgsA decays

 double A0amplitudeuantiu, A0amplitudedantid, A0amplitudesantis, A0amplitudecantic, A0amplitudebantib, A0amplitudetantit, A0amplitudeeantie, A0amplitudemuantimu, A0amplitudetauantitau, A0amplitudeneutZ1neutZ1, A0amplitudeneutZ1neutZ2, A0amplitudeneutZ1neutZ3, A0amplitudeneutZ1neutZ4, A0amplitudeneutZ2neutZ2, A0amplitudeneutZ2neutZ3, A0amplitudeneutZ2neutZ4, A0amplitudeneutZ3neutZ3, A0amplitudeneutZ3neutZ4, A0amplitudeneutZ4neutZ4, A0amplitudecharW1charW1, A0amplitudecharW1charW2, A0amplitudecharW2charW2, A0amplitudehiggshZboson, A0amplitudehiggsHZboson, A0amplitudesupLantisupR, A0amplitudesupRantisupL, A0amplitudesdownLantisdownR, A0amplitudesdownRantisdownL, A0amplitudescharmLantischarmR, A0amplitudescharmRantischarmL, A0amplitudesstrangeLantisstrangeR, A0amplitudesstrangeRantisstrangeL, A0amplitudestop1antistop2, A0amplitudestop2antistop1, A0amplitudesbottom1antisbottom2, A0amplitudesbottom2antisbottom1, A0amplitudeselectronLselectronR, A0amplitudeselectronRselectronL, A0amplitudesmuonLsmuonR, A0amplitudesmuonRsmuonL, A0amplitudestau1stau2, A0amplitudestau2stau1, A0amplitudegluongluon, A0amplitudegammagamma, A0amplitudeZgamma;

 A0amplitudeuantiu = higgsAamplitudedecayquarkantiquark (mA0(1), MUP, g, beta, runmw, 1);
 A0amplitudedantid = higgsAamplitudedecayquarkantiquark (mA0(1), MDOWN, g, beta, runmw, 0 );
 A0amplitudecantic = higgsAamplitudedecayquarkantiquark (mA0(1), MCHARM, g, beta, runmw, 1);
 A0amplitudesantis = higgsAamplitudedecayquarkantiquark (mA0(1), MSTRANGE, g, beta, runmw, 0);
 A0amplitudebantib = higgsAamplitudedecayquarkantiquark (mA0(1), MBOTTOM, g, beta, runmw, 0);
 A0amplitudetantit = higgsAamplitudedecayquarkantiquark (mA0(1), MTOP, g, beta, runmw, 1); 
 A0amplitudeeantie = higgsAamplitudedecayquarkantiquark (mA0(1), MELECTRON, g, beta, runmw, 0)/3; ///0 as leptons are like down-type quarks, divide by 3 as No of colours is 1 for leptons cf 3 for quarks
 A0amplitudemuantimu = higgsAamplitudedecayquarkantiquark (mA0(1), MMUON, g, beta, runmw, 0)/3;
 A0amplitudetauantitau = higgsAamplitudedecayquarkantiquark (mA0(1), MTAU, g, beta, runmw, 0)/3; 
 A0amplitudeneutZ1neutZ1 = higgsphiamplitudedecayneutralinoneutralino (mA0(1), mneut(1), mneut(1), g, tanthetaW, beta, mixNeut, 1, 1, 'A');
 A0amplitudeneutZ1neutZ2 = higgsphiamplitudedecayneutralinoneutralino (mA0(1), mneut(1), mneut(2), g, tanthetaW, beta, mixNeut, 1, 2, 'A');
 A0amplitudeneutZ1neutZ3 = higgsphiamplitudedecayneutralinoneutralino (mA0(1), mneut(1), mneut(3), g, tanthetaW, beta, mixNeut, 1, 3, 'A');
 A0amplitudeneutZ1neutZ4 = higgsphiamplitudedecayneutralinoneutralino (mA0(1), mneut(1), mneut(4), g, tanthetaW, beta, mixNeut, 1, 4, 'A');
 A0amplitudeneutZ2neutZ2 = higgsphiamplitudedecayneutralinoneutralino (mA0(1), mneut(2), mneut(2), g, tanthetaW, beta, mixNeut, 2, 2, 'A');
 A0amplitudeneutZ2neutZ3 = higgsphiamplitudedecayneutralinoneutralino (mA0(1), mneut(2), mneut(3), g, tanthetaW, beta, mixNeut, 2, 3, 'A');
 A0amplitudeneutZ2neutZ4 = higgsphiamplitudedecayneutralinoneutralino (mA0(1), mneut(2), mneut(4), g, tanthetaW, beta, mixNeut, 2, 4, 'A');
 A0amplitudeneutZ3neutZ3 = higgsphiamplitudedecayneutralinoneutralino (mA0(1), mneut(3), mneut(3), g, tanthetaW, beta, mixNeut, 3, 3, 'A');
 A0amplitudeneutZ3neutZ4 = higgsphiamplitudedecayneutralinoneutralino (mA0(1), mneut(3), mneut(4), g, tanthetaW, beta, mixNeut, 3, 4, 'A');
 A0amplitudeneutZ4neutZ4 = higgsphiamplitudedecayneutralinoneutralino (mA0(1), mneut(4), mneut(4), g, tanthetaW, beta, mixNeut, 4, 4, 'A');
 A0amplitudecharW1charW1 = higgsphiamplitudedecaysamechargino (mA0(1), mch(1), g, thetaL2, thetaR2, alpha, beta, 1, 'A');
 A0amplitudecharW2charW2 = higgsphiamplitudedecaysamechargino (mA0(1), mch(2), g, thetaL2, thetaR2, alpha, beta, 2, 'A');
 A0amplitudecharW1charW2 = higgsphiamplitudedecaydifchargino (mA0(1), mch(1), mch(2), g, thetaL2, thetaR2, alpha, beta, 'A');
 A0amplitudehiggshZboson = higgsAamplitudedecayhiggshZboson (mA0(1), mz, mh0(1), g, gp, alpha, beta);

 ///In general don't allow the A -> HZ decay for heavy higgs as it's ruled out by SUSY constraints on the mass spectrum (Djouadi Tome II)
 ///A0amplitudehiggsHZboson = higgsAamplitudedecayhiggsHZboson (mA0(1), mz, mh0(2), g, gp, alpha, beta);
 A0amplitudesupLantisupR = 3*higgsAamplitudedecaysfermions (mA0(1), mu(1,1), mu(2,1), g, runmw, MUP, greekmu, Au, beta, 'u');
 A0amplitudesupRantisupL = 3*higgsAamplitudedecaysfermions (mA0(1), mu(2,1), mu(1,1), g, runmw, MUP, greekmu, Au, beta, 'u');
 A0amplitudesdownLantisdownR = 3*higgsAamplitudedecaysfermions (mA0(1), md(1,1), md(2,1), g, runmw, MDOWN, greekmu, Ad, beta, 'd');
 A0amplitudesdownRantisdownL = 3*higgsAamplitudedecaysfermions (mA0(1), md(2,1), md(1,1), g, runmw, MDOWN, greekmu, Ad, beta, 'd');
 A0amplitudescharmLantischarmR = 3*higgsAamplitudedecaysfermions(mA0(1), mu(1,2), mu(2,2), g, runmw, MCHARM, greekmu, Ac, beta, 'u');
 A0amplitudescharmRantischarmL = 3*higgsAamplitudedecaysfermions(mA0(1), mu(2,2), mu(1,2), g, runmw, MCHARM, greekmu, Ac, beta, 'u');
 A0amplitudesstrangeLantisstrangeR = 3*higgsAamplitudedecaysfermions(mA0(1), md(1,2), md(2,2), g, runmw, MSTRANGE, greekmu, As, beta, 'd');
 A0amplitudesstrangeRantisstrangeL = 3*higgsAamplitudedecaysfermions(mA0(1), md(2,2), md(1,2), g, runmw, MSTRANGE, greekmu, As, beta, 'd');
 A0amplitudestop1antistop2 = 3*higgsAamplitudedecaysfermions(mA0(1), mu(1,3), mu(2,3), g, runmw, MTOP, greekmu, At, beta, 'u');
 A0amplitudestop2antistop1 = 3*higgsAamplitudedecaysfermions(mA0(1), mu(2,3), mu(1,3), g, runmw, MTOP, greekmu, At, beta, 'u');
 A0amplitudesbottom1antisbottom2 = 3*higgsAamplitudedecaysfermions(mA0(1), md(1,3), md(2,3), g, runmw, MBOTTOM, greekmu, Ab, beta, 'd');
 A0amplitudesbottom2antisbottom1 = 3*higgsAamplitudedecaysfermions(mA0(1), md(2,3), md(1,3), g, runmw, MBOTTOM, greekmu, Ab, beta, 'd');
 A0amplitudeselectronLselectronR = higgsAamplitudedecaysfermions(mA0(1), me(1,1), me(2,1), g, runmw, MELECTRON, greekmu, Ae, beta, 'd');
 A0amplitudeselectronRselectronL = higgsAamplitudedecaysfermions(mA0(1), me(2,1), me(1,1), g, runmw, MELECTRON, greekmu, Ae, beta, 'd');
 A0amplitudesmuonLsmuonR = higgsAamplitudedecaysfermions(mA0(1), me(1,2), me(2,2), g, runmw, MMUON, greekmu, Amu, beta, 'd');
 A0amplitudesmuonRsmuonL = higgsAamplitudedecaysfermions(mA0(1), me(2,2), me(1,2), g, runmw, MMUON, greekmu, Amu, beta, 'd');
 A0amplitudestau1stau2 = higgsAamplitudedecaysfermions(mA0(1), me(1,3), me(2,3), g, runmw, MTAU, greekmu, Atau, beta, 'd');
 A0amplitudestau2stau1 = higgsAamplitudedecaysfermions(mA0(1), me(2,3), me(1,3), g, runmw, MTAU, greekmu, Atau, beta, 'd');

 A0amplitudegammagamma = higgsesamplitudedecaygammagammatotal(mA0(1), g, gp, runmw, polemw, alpha, beta, MTOP, MBOTTOM, MCHARM, MTAU, mHpm, mu(1,3), mu(2,3), md(1,3), md(2,3), me(1,3), me(2,3), mch(1), mch(2), thetaL, thetaR, thetat, thetab, thetatau, greekmu, At, Ab, Atau, 'A');
 A0amplitudegluongluon = higgsesamplitudedecaygluongluontotal(mA0(1), g, g3atmA0, gp, runmw, alpha, beta, MTOP, MBOTTOM, MCHARM, mu(1,3), mu(2,3), md(1,3), md(2,3), thetaL, thetaR, thetat, thetab, greekmu, At, Ab, 'A');
 A0amplitudeZgamma = higgsesamplitudedecayZbosonphotontotal(mA0(1), mz, g, gp, polemw, runmw, alpha, beta, MTOP, MBOTTOM, MCHARM, MSTRANGE, mu(1,3), mu(2,3), md(1,3), md(2,3), mHpm, thetaL, thetaR, thetat, thetab, greekmu, At, Ab, 'A');


 ParticleHiggsA.Array_Decays[0][0] = PDGup; ParticleHiggsA.Array_Decays[0][1] = -PDGup; ParticleHiggsA.Array_Decays[0][2] = A0amplitudeuantiu; ParticleHiggsA.Array_Decays[0][3] = 2; ParticleHiggsA.Array_Comments[0] = "# A -> u ub";
 ParticleHiggsA.Array_Decays[1][0] = PDGdown; ParticleHiggsA.Array_Decays[1][1] = -PDGdown; ParticleHiggsA.Array_Decays[1][2] = A0amplitudedantid; ParticleHiggsA.Array_Decays[1][3] = 2; ParticleHiggsA.Array_Comments[1] = "# A -> d db";
 ParticleHiggsA.Array_Decays[2][0] = PDGcharm; ParticleHiggsA.Array_Decays[2][1] = -PDGcharm; ParticleHiggsA.Array_Decays[2][2] = A0amplitudecantic; ParticleHiggsA.Array_Decays[2][3] = 2; ParticleHiggsA.Array_Comments[2] = "# A -> c cb";
 ParticleHiggsA.Array_Decays[3][0] = PDGstrange; ParticleHiggsA.Array_Decays[3][1] = -PDGstrange; ParticleHiggsA.Array_Decays[3][2] = A0amplitudesantis; ParticleHiggsH.Array_Decays[3][3] = 2; ParticleHiggsA.Array_Comments[3] = "# A -> s sb";
 ParticleHiggsA.Array_Decays[4][0] = PDGbottom; ParticleHiggsA.Array_Decays[4][1] = -PDGbottom; ParticleHiggsA.Array_Decays[4][2] = A0amplitudebantib; ParticleHiggsA.Array_Decays[4][3] = 2; ParticleHiggsA.Array_Comments[4] = "# A -> b bb";
 ParticleHiggsA.Array_Decays[5][0] = PDGtop; ParticleHiggsA.Array_Decays[5][1] = -PDGtop; ParticleHiggsA.Array_Decays[5][2] = A0amplitudetantit; ParticleHiggsA.Array_Decays[5][3] = 2; ParticleHiggsA.Array_Comments[5] = "# A -> t tb";
 ParticleHiggsA.Array_Decays[6][0] = PDGelectron; ParticleHiggsA.Array_Decays[6][1] = -PDGelectron; ParticleHiggsA.Array_Decays[6][2] = A0amplitudeeantie; ParticleHiggsA.Array_Decays[6][3] = 2; ParticleHiggsA.Array_Comments[6] = "# A -> e- e+";
 ParticleHiggsA.Array_Decays[7][0] = PDGmuon; ParticleHiggsA.Array_Decays[7][1] = -PDGmuon; ParticleHiggsA.Array_Decays[7][2] = A0amplitudemuantimu; ParticleHiggsA.Array_Decays[7][3] = 2; ParticleHiggsA.Array_Comments[7] = "# A -> mu- mu+";
 ParticleHiggsA.Array_Decays[8][0] = PDGtau; ParticleHiggsA.Array_Decays[8][1] = -PDGtau; ParticleHiggsA.Array_Decays[8][2] = A0amplitudetauantitau; ParticleHiggsA.Array_Decays[8][3] = 2; ParticleHiggsA.Array_Comments[8] = "# A -> tau- tau+";
 ParticleHiggsA.Array_Decays[9][0] = PDGneutralino1; ParticleHiggsA.Array_Decays[9][1] = PDGneutralino1; ParticleHiggsA.Array_Decays[9][2] = A0amplitudeneutZ1neutZ1; ParticleHiggsA.Array_Decays[9][3] = 2; ParticleHiggsA.Array_Comments[9] = "# A -> ~chi_10 ~chi_10";
 ParticleHiggsA.Array_Decays[10][0] = PDGneutralino1; ParticleHiggsA.Array_Decays[10][1] = PDGneutralino2; ParticleHiggsA.Array_Decays[10][2] = A0amplitudeneutZ1neutZ2; ParticleHiggsA.Array_Decays[10][3] = 2; ParticleHiggsA.Array_Comments[10] = "# A -> ~chi_10 ~chi_20";
 ParticleHiggsA.Array_Decays[11][0] = PDGneutralino1; ParticleHiggsA.Array_Decays[11][1] = PDGneutralino3; ParticleHiggsA.Array_Decays[11][2] = A0amplitudeneutZ1neutZ3; ParticleHiggsA.Array_Decays[11][3] = 2; ParticleHiggsA.Array_Comments[11] = "# A -> ~chi_10 ~chi_30";
 ParticleHiggsA.Array_Decays[12][0] = PDGneutralino1; ParticleHiggsA.Array_Decays[12][1] = PDGneutralino4; ParticleHiggsA.Array_Decays[12][2] = A0amplitudeneutZ1neutZ4; ParticleHiggsA.Array_Decays[12][3] = 2; ParticleHiggsA.Array_Comments[12] = "# A -> ~chi_10 ~chi_40";
 ParticleHiggsA.Array_Decays[13][0] = PDGneutralino2; ParticleHiggsA.Array_Decays[13][1] = PDGneutralino2; ParticleHiggsA.Array_Decays[13][2] = A0amplitudeneutZ2neutZ2; ParticleHiggsA.Array_Decays[13][3] = 2; ParticleHiggsA.Array_Comments[13] = "# A -> ~chi_20 ~chi_20";
 ParticleHiggsA.Array_Decays[14][0] = PDGneutralino2; ParticleHiggsA.Array_Decays[14][1] = PDGneutralino3; ParticleHiggsA.Array_Decays[14][2] = A0amplitudeneutZ2neutZ3; ParticleHiggsA.Array_Decays[14][3] = 2; ParticleHiggsA.Array_Comments[14] = "# A -> ~chi_20 ~chi_30";
 ParticleHiggsA.Array_Decays[15][0] = PDGneutralino2; ParticleHiggsA.Array_Decays[15][1] = PDGneutralino4; ParticleHiggsA.Array_Decays[15][2] = A0amplitudeneutZ2neutZ4; ParticleHiggsA.Array_Decays[15][3] = 2; ParticleHiggsA.Array_Comments[15] = "# A -> ~chi_20 ~chi_40";
 ParticleHiggsA.Array_Decays[16][0] = PDGneutralino3; ParticleHiggsA.Array_Decays[16][1] = PDGneutralino3; ParticleHiggsA.Array_Decays[16][2] = A0amplitudeneutZ3neutZ3; ParticleHiggsA.Array_Decays[16][3] = 2; ParticleHiggsA.Array_Comments[16] = "# A -> ~chi_30 ~chi_30";
 ParticleHiggsA.Array_Decays[17][0] = PDGneutralino3; ParticleHiggsA.Array_Decays[17][1] = PDGneutralino4; ParticleHiggsA.Array_Decays[17][2] = A0amplitudeneutZ3neutZ4; ParticleHiggsA.Array_Decays[17][3] = 2; ParticleHiggsA.Array_Comments[17] = "# A -> ~chi_30 ~chi_40";
 ParticleHiggsA.Array_Decays[18][0] = PDGneutralino4; ParticleHiggsA.Array_Decays[18][1] = PDGneutralino4; ParticleHiggsA.Array_Decays[18][2] = A0amplitudeneutZ4neutZ4; ParticleHiggsA.Array_Decays[18][3] = 2; ParticleHiggsA.Array_Comments[18] = "# A -> ~chi_40 ~chi_40";
 ParticleHiggsA.Array_Decays[19][0] = PDGchargino1; ParticleHiggsA.Array_Decays[19][1] = -PDGchargino1; ParticleHiggsA.Array_Decays[19][2] = A0amplitudecharW1charW1; ParticleHiggsA.Array_Decays[19][3] = 2; ParticleHiggsA.Array_Comments[19] = "# A -> ~chi_1+ ~chi_1-";
 ParticleHiggsA.Array_Decays[20][0] = PDGchargino2; ParticleHiggsA.Array_Decays[20][1] = -PDGchargino2; ParticleHiggsA.Array_Decays[20][2] = A0amplitudecharW2charW2; ParticleHiggsA.Array_Decays[20][3] = 2; ParticleHiggsA.Array_Comments[20] = "# A -> ~chi_2+ ~chi_2-";
 ParticleHiggsA.Array_Decays[21][0] = PDGchargino1; ParticleHiggsA.Array_Decays[21][1] = -PDGchargino2; ParticleHiggsA.Array_Decays[21][2] = A0amplitudecharW1charW2; ParticleHiggsA.Array_Decays[21][3] = 2; ParticleHiggsA.Array_Comments[21] = "# A -> ~chi_1+ ~chi_2-";
 ParticleHiggsA.Array_Decays[22][0] = PDGchargino2; ParticleHiggsA.Array_Decays[22][1] = -PDGchargino1; ParticleHiggsA.Array_Decays[22][2] = A0amplitudecharW1charW2; ParticleHiggsA.Array_Decays[22][3] = 2; ParticleHiggsA.Array_Comments[22] = "# A -> ~chi_2+ ~chi_1-"; ///amplitude same as decay to W1+ and W2- by CP invariance
 ParticleHiggsA.Array_Decays[23][0] = PDGZboson; ParticleHiggsA.Array_Decays[23][1] = PDGh0; ParticleHiggsA.Array_Decays[23][2] = A0amplitudehiggshZboson; ParticleHiggsA.Array_Decays[23][3] = 2; ParticleHiggsA.Array_Comments[23] = "# A -> h Z";
 ParticleHiggsA.Array_Decays[24][0] = PDGZboson; ParticleHiggsA.Array_Decays[24][1] = PDGH0; ParticleHiggsA.Array_Decays[24][2] = A0amplitudehiggsHZboson; ParticleHiggsA.Array_Decays[24][3] = 2; ParticleHiggsA.Array_Comments[24] = "# A -> H Z";
 ParticleHiggsA.Array_Decays[25][0] = PDGsupL; ParticleHiggsA.Array_Decays[25][1] = PDGsupR; ParticleHiggsA.Array_Decays[25][2] = A0amplitudesupLantisupR; ParticleHiggsA.Array_Decays[25][3] = 2; ParticleHiggsA.Array_Comments[25] = "# A-> ~u_L ~u_R*"; 
 ParticleHiggsA.Array_Decays[26][0] = PDGsupR; ParticleHiggsA.Array_Decays[26][1] = PDGsupL; ParticleHiggsA.Array_Decays[26][2] = A0amplitudesupRantisupL; ParticleHiggsA.Array_Decays[26][3] = 2; ParticleHiggsA.Array_Comments[26] = "# A-> ~u_R ~u_L*";
 ParticleHiggsA.Array_Decays[27][0] = PDGsdownL; ParticleHiggsA.Array_Decays[27][1] = PDGsdownR; ParticleHiggsA.Array_Decays[27][2] = A0amplitudesdownLantisdownR; ParticleHiggsA.Array_Decays[27][3] = 2; ParticleHiggsA.Array_Comments[27] = "# A-> ~d_L ~d_R*";
 ParticleHiggsA.Array_Decays[28][0] = PDGsdownR; ParticleHiggsA.Array_Decays[28][1] = PDGsdownL; ParticleHiggsA.Array_Decays[28][2] = A0amplitudesdownRantisdownL; ParticleHiggsA.Array_Decays[28][3] = 2; ParticleHiggsA.Array_Comments[28] = "# A-> ~d_R ~d_L*";
 ParticleHiggsA.Array_Decays[29][0] = PDGscharmL; ParticleHiggsA.Array_Decays[29][1] = PDGscharmR; ParticleHiggsA.Array_Decays[29][2] = A0amplitudescharmLantischarmR; ParticleHiggsA.Array_Decays[29][3] = 2; ParticleHiggsA.Array_Comments[29] = "# A-> ~c_L ~c_R*"; 
 ParticleHiggsA.Array_Decays[30][0] = PDGscharmR; ParticleHiggsA.Array_Decays[30][1] = PDGscharmL; ParticleHiggsA.Array_Decays[30][2] = A0amplitudescharmRantischarmL; ParticleHiggsA.Array_Decays[30][3] = 2; ParticleHiggsA.Array_Comments[30] = "# A-> ~c_R ~c_L*";
 ParticleHiggsA.Array_Decays[31][0] = PDGsstrangeL; ParticleHiggsA.Array_Decays[31][1] = PDGsstrangeR; ParticleHiggsA.Array_Decays[31][2] = A0amplitudesstrangeLantisstrangeR; ParticleHiggsA.Array_Decays[31][3] = 2; ParticleHiggsA.Array_Comments[31] = "# A-> ~s_L ~s_R*";
 ParticleHiggsA.Array_Decays[32][0] = PDGsstrangeR; ParticleHiggsA.Array_Decays[32][1] = PDGsstrangeL; ParticleHiggsA.Array_Decays[32][2] = A0amplitudesstrangeRantisstrangeL; ParticleHiggsA.Array_Decays[32][3] = 2; ParticleHiggsA.Array_Comments[32] = "# A-> ~s_R ~s_L*";
 ParticleHiggsA.Array_Decays[33][0] = PDGstop1; ParticleHiggsA.Array_Decays[33][1] = PDGstop2; ParticleHiggsA.Array_Decays[33][2] = A0amplitudestop1antistop2; ParticleHiggsA.Array_Decays[33][3] = 2; ParticleHiggsA.Array_Comments[33] = "# A-> ~t_1 ~t_2*"; 
 ParticleHiggsA.Array_Decays[34][0] = PDGstop2; ParticleHiggsA.Array_Decays[34][1] = PDGstop1; ParticleHiggsA.Array_Decays[34][2] = A0amplitudestop2antistop1; ParticleHiggsA.Array_Decays[34][3] = 2; ParticleHiggsA.Array_Comments[34] = "# A-> ~t_2 ~t_1*";
 ParticleHiggsA.Array_Decays[35][0] = PDGsbottom1; ParticleHiggsA.Array_Decays[35][1] = PDGsbottom2; ParticleHiggsA.Array_Decays[35][2] = A0amplitudesbottom1antisbottom2; ParticleHiggsA.Array_Decays[35][3] = 2; ParticleHiggsA.Array_Comments[35] = "# A-> ~b_1 ~b_2*";
 ParticleHiggsA.Array_Decays[36][0] = PDGsbottom2; ParticleHiggsA.Array_Decays[36][1] = PDGsbottom1; ParticleHiggsA.Array_Decays[36][2] = A0amplitudesbottom2antisbottom1; ParticleHiggsA.Array_Decays[36][3] = 2; ParticleHiggsA.Array_Comments[36] = "# A-> ~b_2 ~b_1*";
 ParticleHiggsA.Array_Decays[37][0] = PDGselectronL; ParticleHiggsA.Array_Decays[37][1] = PDGselectronR; ParticleHiggsA.Array_Decays[37][2] = A0amplitudeselectronLselectronR; ParticleHiggsA.Array_Decays[37][3] = 2; ParticleHiggsA.Array_Comments[37] = "# A-> ~e_L- ~e_R+"; 
 ParticleHiggsA.Array_Decays[38][0] = PDGselectronR; ParticleHiggsA.Array_Decays[38][1] = PDGselectronL; ParticleHiggsA.Array_Decays[38][2] = A0amplitudeselectronRselectronL; ParticleHiggsA.Array_Decays[38][3] = 2; ParticleHiggsA.Array_Comments[38] = "# A-> ~e_R- ~e_L+";
 ParticleHiggsA.Array_Decays[39][0] = PDGsmuonL; ParticleHiggsA.Array_Decays[39][1] = PDGsmuonR; ParticleHiggsA.Array_Decays[39][2] = A0amplitudesmuonLsmuonR; ParticleHiggsA.Array_Decays[39][3] = 2; ParticleHiggsA.Array_Comments[39] = "# A-> ~mu_L- ~mu_R+";
 ParticleHiggsA.Array_Decays[40][0] = PDGsmuonR; ParticleHiggsA.Array_Decays[40][1] = PDGsmuonL; ParticleHiggsA.Array_Decays[40][2] = A0amplitudesmuonRsmuonL; ParticleHiggsA.Array_Decays[40][3] = 2; ParticleHiggsA.Array_Comments[40] = "# A-> ~mu_R- ~mu_L+";
 ParticleHiggsA.Array_Decays[41][0] = PDGstau1; ParticleHiggsA.Array_Decays[41][1] = PDGstau2; ParticleHiggsA.Array_Decays[41][2] = A0amplitudestau1stau2; ParticleHiggsA.Array_Decays[41][3] = 2; ParticleHiggsA.Array_Comments[41] = "# A-> ~tau_1- ~tau_2+";
 ParticleHiggsA.Array_Decays[42][0] = PDGstau2; ParticleHiggsA.Array_Decays[42][1] = PDGstau1; ParticleHiggsA.Array_Decays[42][2] = A0amplitudestau2stau1; ParticleHiggsA.Array_Decays[42][3] = 2; ParticleHiggsA.Array_Comments[42] = "# A-> ~tau_2- ~tau_1+";
 ParticleHiggsA.Array_Decays[43][0] = PDGphoton; ParticleHiggsA.Array_Decays[43][1] = PDGphoton; ParticleHiggsA.Array_Decays[43][2] = A0amplitudegammagamma; ParticleHiggsA.Array_Decays[43][3] = 2; ParticleHiggsA.Array_Comments[43] = "# A-> gamma gamma";
 ParticleHiggsA.Array_Decays[44][0] = PDGgluon; ParticleHiggsA.Array_Decays[44][1] = PDGgluon; ParticleHiggsA.Array_Decays[44][2] = A0amplitudegluongluon; ParticleHiggsA.Array_Decays[44][3] = 2; ParticleHiggsA.Array_Comments[44] = "# A-> gluon gluon";
 ParticleHiggsA.Array_Decays[45][0] = PDGZboson; ParticleHiggsA.Array_Decays[45][1] = PDGphoton; ParticleHiggsA.Array_Decays[45][2] = A0amplitudeZgamma; ParticleHiggsA.Array_Decays[45][3] = 2; ParticleHiggsA.Array_Comments[45] = "# A -> Z gamma"; 

 double HiggsA_No_1to2_Decays = 0;
 
 HiggsA_No_1to2_Decays = ParticleHiggsA.No_1to2_Decays; /// As higgsA can't be NLSP as heavier than higgsl
   
 for (int j = 0; j<HiggsA_No_1to2_Decays; j++) {
   ParticleHiggsA.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
  }

 for (int j=0; j<HiggsA_No_1to2_Decays; j++) {
    ParticleHiggsA.two_width = ParticleHiggsA.two_width + ParticleHiggsA.Array_Decays[j][2];
  }
 for (int j=HiggsA_No_1to2_Decays; j<ParticleHiggsA.No_of_Decays; j++) {
   ParticleHiggsA.three_width = ParticleHiggsA.three_width + ParticleHiggsA.Array_Decays[j][2];
 }

 for(int j=0; j<ParticleHiggsA.No_of_Decays; j++) {
   ParticleHiggsA.Array_Decays[j][4] = 0;
 }

 
 ParticleHiggsA.total_width = ParticleHiggsA.two_width + ParticleHiggsA.three_width;
  
   
  for (int i =0; i<ParticleHiggsA.No_of_Decays; i++) {
     ParticleHiggsA.Array_Decays[i][5]= ParticleHiggsA.Array_Decays[i][2]/ParticleHiggsA.total_width;
   } 

///cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
/// cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleHiggsA.PDG << setw(12) << scientific << setprecision(8) <<  ParticleHiggsA.total_width << "   " << "# A_0 (pseudoscalar higgs) decays" << endl;
 ///cout.precision(7);
/// cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
/// for (int k=0; k<ParticleHiggsA.No_of_Decays; k++) {
///   if( ParticleHiggsA.Array_Decays[k][2] != 0 ) {
///    cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleHiggsA.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleHiggsA.Array_Decays[k][3];  printRowPDG(cout, ParticleHiggsA.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleHiggsA.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleHiggsA.Array_Comments[k] << endl;
///   }
///   else{}
/// }
/// cout << "#" << endl; 


/// Uncomment section below if want partial widths as well as branching ratios
 cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
 cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleHiggsA.PDG << setw(12) << scientific << setprecision(8) <<  ParticleHiggsA.total_width << "   " << "# A_0 (pseudoscalar higgs) decays" << endl;
 cout.precision(7);
 cout << left << setw(6) << "#" << setw(18) << "PW" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
 for (int k=0; k<ParticleHiggsA.No_of_Decays; k++) {
   if( ParticleHiggsA.Array_Decays[k][2] != 0 ) {
     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleHiggsA.Array_Decays[k][2] << setprecision(8) << ParticleHiggsA.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << " " << ParticleHiggsA.Array_Decays[k][3] << setw(4) << " ";  printRowPDG(cout, ParticleHiggsA.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleHiggsA.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleHiggsA.Array_Comments[k] << endl;
   }
 }
 cout << "#" << endl; 

///Charged higgs+ decays

 double Hplusamplitudeupdown, Hplusamplitudecharmstrange, Hplusamplitudetopbottom, Hplusamplitudeelectronelectronneutrino, Hplusamplitudemuonmuonneutrino, Hplusamplitudetautauneutrino, Hplusamplitudeupstrange, Hplusamplitudeupbottom, Hplusamplitudecharmdown, Hplusamplitudecharmbottom, Hplusamplitudetopdown, Hplusamplitudetopstrange, HplusamplitudeneutZ1charW1, HplusamplitudeneutZ1charW2, HplusamplitudeneutZ2charW1, HplusamplitudeneutZ2charW2, HplusamplitudeneutZ3charW1, HplusamplitudeneutZ3charW2, HplusamplitudeneutZ4charW1, HplusamplitudeneutZ4charW2, HplusamplitudehW, HplusamplitudesupLsdownL, HplusamplitudesupRsdownL, HplusamplitudesupLsdownR, HplusamplitudesupRsdownR, HplusamplitudescharmLsstrangeL, HplusamplitudescharmLsstrangeR, HplusamplitudescharmRsstrangeL, HplusamplitudescharmRsstrangeR, Hplusamplitudestop1sbottom1, Hplusamplitudestop1sbottom2, Hplusamplitudestop2sbottom1, Hplusamplitudestop2sbottom2, HplusamplitudeselectronLsnue, HplusamplitudeselectronRsnue, HplusamplitudesmuonLsnumu, HplusamplitudesmuonRsnumu, Hplusamplitudestau1snutau, Hplusamplitudestau2snutau; ///note Hplus -> H W is kinematically forbidden if we take tree-level mass formulae in the MSSM
 
 Hplusamplitudeupdown = higgsHplusamplitudedecayquarkantiquark (mHpm, MUP, MDOWN, g, runmw, beta, VCKM, 1, 1);
 Hplusamplitudecharmstrange = higgsHplusamplitudedecayquarkantiquark (mHpm, MCHARM, MSTRANGE, g, runmw, beta, VCKM, 2, 2);
 Hplusamplitudetopbottom = higgsHplusamplitudedecayquarkantiquark (mHpm, MTOP, MBOTTOM, g, runmw, beta, VCKM, 3, 3);
 Hplusamplitudeupstrange = higgsHplusamplitudedecayquarkantiquark (mHpm, MUP, MSTRANGE, g, runmw, beta, VCKM, 1, 2);
 Hplusamplitudeupbottom = higgsHplusamplitudedecayquarkantiquark (mHpm, MUP, MBOTTOM, g, runmw, beta, VCKM, 1, 3);
 Hplusamplitudecharmdown = higgsHplusamplitudedecayquarkantiquark (mHpm, MCHARM, MDOWN, g, runmw, beta, VCKM, 2, 1);
 Hplusamplitudecharmbottom = higgsHplusamplitudedecayquarkantiquark (mHpm, MCHARM, MBOTTOM, g, runmw, beta, VCKM, 2, 3);
 Hplusamplitudetopdown = higgsHplusamplitudedecayquarkantiquark (mHpm, MTOP, MDOWN, g, runmw, beta, VCKM, 3, 1);
 Hplusamplitudetopstrange = higgsHplusamplitudedecayquarkantiquark (mHpm, MTOP, MSTRANGE, g, runmw, beta, VCKM, 3, 2);
 Hplusamplitudeelectronelectronneutrino = higgsHplusamplitudedecayquarkantiquark(mHpm, 0, MELECTRON, g, runmw, beta, I3, 1, 1)/3;
 Hplusamplitudemuonmuonneutrino = higgsHplusamplitudedecayquarkantiquark(mHpm, 0, MMUON, g, runmw, beta, I3, 2, 2)/3;
 Hplusamplitudetautauneutrino = higgsHplusamplitudedecayquarkantiquark(mHpm, 0, MTAU, g, runmw, beta, I3, 3, 3)/3;
 HplusamplitudeneutZ1charW1 = higgsHplusamplitudedecayneutralinochargino (mHpm, mneut(1), MCH1, g, gp, beta, thetaL2, thetaR2, mixNeut, 1, 1);
 HplusamplitudeneutZ1charW2 = higgsHplusamplitudedecayneutralinochargino (mHpm, mneut(1), MCH2, g, gp, beta, thetaL2, thetaR2, mixNeut, 1, 2);
 HplusamplitudeneutZ2charW1 = higgsHplusamplitudedecayneutralinochargino (mHpm, mneut(2), MCH1, g, gp, beta, thetaL2, thetaR2, mixNeut, 2, 1);
 HplusamplitudeneutZ2charW2 = higgsHplusamplitudedecayneutralinochargino (mHpm, mneut(2), MCH2, g, gp, beta, thetaL2, thetaR2, mixNeut, 2, 2);
 HplusamplitudeneutZ3charW1 = higgsHplusamplitudedecayneutralinochargino (mHpm, mneut(3), MCH1, g, gp, beta, thetaL2, thetaR2, mixNeut, 3, 1);
 HplusamplitudeneutZ3charW2 = higgsHplusamplitudedecayneutralinochargino (mHpm, mneut(3), MCH2, g, gp, beta, thetaL2, thetaR2, mixNeut, 3, 2);
 HplusamplitudeneutZ4charW1 = higgsHplusamplitudedecayneutralinochargino (mHpm, mneut(4), MCH1, g, gp, beta, thetaL2, thetaR2, mixNeut, 4, 1);
 HplusamplitudeneutZ4charW2 = higgsHplusamplitudedecayneutralinochargino (mHpm, mneut(4), MCH2, g, gp, beta, thetaL2, thetaR2, mixNeut, 4, 2);
 HplusamplitudehW = higgsHplusamplitudedecayWbosonhiggsh (mHpm, polemw, mh0(1), g, alpha, beta);
 HplusamplitudesupLsdownL = higgsHplusamplitudedecaysquarksquark (mHpm, mu(1,1), md(1,1), g, beta, runmw, MUP, MDOWN, greekmu, Au, Ad) (1);
 HplusamplitudesupRsdownR = higgsHplusamplitudedecaysquarksquark (mHpm, mu(2,1), md(2,1), g, beta, runmw, MUP, MDOWN, greekmu, Au, Ad) (2);
 HplusamplitudesupLsdownR = higgsHplusamplitudedecaysquarksquark (mHpm, mu(1,1), md(2,1), g, beta, runmw, MUP, MDOWN, greekmu, Au, Ad) (3);
 HplusamplitudesupRsdownL = higgsHplusamplitudedecaysquarksquark (mHpm, mu(2,1), md(2,1), g, beta, runmw, MUP, MDOWN, greekmu, Au, Ad) (4);
 HplusamplitudescharmLsstrangeL = higgsHplusamplitudedecaysquarksquark (mHpm, mu(1,2), md(1,2), g, beta, runmw, MCHARM, MSTRANGE, greekmu, Ac, As) (1);
 HplusamplitudescharmRsstrangeR = higgsHplusamplitudedecaysquarksquark (mHpm, mu(2,2), md(2,2), g, beta, runmw, MCHARM, MSTRANGE, greekmu, Ac, As) (2);
 HplusamplitudescharmLsstrangeR = higgsHplusamplitudedecaysquarksquark (mHpm, mu(1,2), md(2,2), g, beta, runmw, MCHARM, MSTRANGE, greekmu, Ac, As) (3);
 HplusamplitudescharmRsstrangeL = higgsHplusamplitudedecaysquarksquark (mHpm, mu(2,2), md(1,2), g, beta, runmw, MCHARM, MSTRANGE, greekmu, Ac, As) (4);
 HplusamplitudeselectronLsnue = higgsHplusamplitudedecaysquarksquark (mHpm, msnu(1), me(1,1), g, beta, runmw, 0, MELECTRON, greekmu, 0, Ae) (1)/3;
 HplusamplitudeselectronRsnue = higgsHplusamplitudedecaysquarksquark (mHpm, msnu(1), me(2,1), g, beta, runmw, 0, MELECTRON, greekmu, 0, Ae) (3)/3;
 HplusamplitudesmuonLsnumu = higgsHplusamplitudedecaysquarksquark (mHpm, msnu(2), me(1,2), g, beta, runmw, 0, MMUON, greekmu, 0, Amu) (1)/3;
 HplusamplitudesmuonRsnumu = higgsHplusamplitudedecaysquarksquark (mHpm, msnu(2), me(2,2), g, beta, runmw, 0, MMUON, greekmu, 0, Amu) (3)/3;
 Hplusamplitudestop1sbottom1 = higgsHplusamplitudedecaysquarksquarkmix (mHpm, mu(1,3), md(1,3), g, beta, runmw, MTOP, MBOTTOM, greekmu,  At, Ab, thetat, thetab) (1); 
 Hplusamplitudestop2sbottom2 = higgsHplusamplitudedecaysquarksquarkmix (mHpm, mu(2,3), md(2,3), g, beta, runmw, MTOP, MBOTTOM, greekmu,  At, Ab, thetat, thetab) (2);  
 Hplusamplitudestop1sbottom2 = higgsHplusamplitudedecaysquarksquarkmix (mHpm, mu(1,3), md(2,3), g, beta, runmw, MTOP, MBOTTOM, greekmu,  At, Ab, thetat, thetab) (3);
 Hplusamplitudestop2sbottom1 = higgsHplusamplitudedecaysquarksquarkmix (mHpm, mu(2,3), md(1,3), g, beta, runmw, MTOP, MBOTTOM, greekmu,  At, Ab, thetat, thetab) (4);
 Hplusamplitudestau1snutau = higgsHplusamplitudedecaysquarksquarkmix (mHpm, msnu(3), me(1,3), g, beta, runmw, 0, MTAU, greekmu, 0, Atau, 0, thetatau+PI/2) (1)/3;
 Hplusamplitudestau2snutau = higgsHplusamplitudedecaysquarksquarkmix (mHpm, msnu(3), me(2,3), g, beta, runmw, 0, MTAU, greekmu, 0, Atau, 0, thetatau+PI/2) (3)/3;
 
 

  ParticleHiggsplus.Array_Decays[0][0] = PDGup; ParticleHiggsplus.Array_Decays[0][1] = -PDGdown; ParticleHiggsplus.Array_Decays[0][2] = Hplusamplitudeupdown; ParticleHiggsplus.Array_Decays[0][3] = 2; ParticleHiggsplus.Array_Comments[0] = "# H+ -> u db";
  ParticleHiggsplus.Array_Decays[1][0] = PDGcharm; ParticleHiggsplus.Array_Decays[1][1] = -PDGstrange; ParticleHiggsplus.Array_Decays[1][2] = Hplusamplitudecharmstrange; ParticleHiggsplus.Array_Decays[1][3] = 2; ParticleHiggsplus.Array_Comments[1] = "# H+ -> c sb";
  ParticleHiggsplus.Array_Decays[2][0] = PDGtop; ParticleHiggsplus.Array_Decays[2][1] = -PDGbottom; ParticleHiggsplus.Array_Decays[2][2] = Hplusamplitudetopbottom; ParticleHiggsplus.Array_Decays[2][3] = 2; ParticleHiggsplus.Array_Comments[2] = "# H+ -> t bb";
  ParticleHiggsplus.Array_Decays[3][0] = PDGup; ParticleHiggsplus.Array_Decays[3][1] = -PDGstrange; ParticleHiggsplus.Array_Decays[3][2] = Hplusamplitudeupstrange; ParticleHiggsplus.Array_Decays[3][3] = 2; ParticleHiggsplus.Array_Comments[3] = "# H+ -> u sb";
  ParticleHiggsplus.Array_Decays[4][0] = PDGup; ParticleHiggsplus.Array_Decays[4][1] = -PDGbottom; ParticleHiggsplus.Array_Decays[4][2] = Hplusamplitudeupbottom; ParticleHiggsplus.Array_Decays[4][3] = 2; ParticleHiggsplus.Array_Comments[4] = "# H+ -> u bb";
  ParticleHiggsplus.Array_Decays[5][0] = PDGcharm; ParticleHiggsplus.Array_Decays[5][1] = -PDGdown; ParticleHiggsplus.Array_Decays[5][2] = Hplusamplitudecharmdown; ParticleHiggsplus.Array_Decays[5][3] = 2; ParticleHiggsplus.Array_Comments[5] = "# H+ -> c db";
  ParticleHiggsplus.Array_Decays[6][0] = PDGcharm; ParticleHiggsplus.Array_Decays[6][1] = -PDGbottom; ParticleHiggsplus.Array_Decays[6][2] = Hplusamplitudecharmbottom; ParticleHiggsplus.Array_Decays[6][3] = 2; ParticleHiggsplus.Array_Comments[6] = "# H+ -> c bb";
  ParticleHiggsplus.Array_Decays[7][0] = PDGtop; ParticleHiggsplus.Array_Decays[7][1] = -PDGdown; ParticleHiggsplus.Array_Decays[7][2] = Hplusamplitudetopdown; ParticleHiggsplus.Array_Decays[7][3] = 2; ParticleHiggsplus.Array_Comments[7] = "# H+ -> t db";
  ParticleHiggsplus.Array_Decays[8][0] = PDGtop; ParticleHiggsplus.Array_Decays[8][1] = -PDGstrange; ParticleHiggsplus.Array_Decays[8][2] = Hplusamplitudetopstrange; ParticleHiggsplus.Array_Decays[8][3] = 2; ParticleHiggsplus.Array_Comments[8] = "# H+ -> t sb";
  ParticleHiggsplus.Array_Decays[9][0] = PDGnuelectron; ParticleHiggsplus.Array_Decays[9][1] = -PDGelectron; ParticleHiggsplus.Array_Decays[9][2] = Hplusamplitudeelectronelectronneutrino; ParticleHiggsplus.Array_Decays[9][3] = 2; ParticleHiggsplus.Array_Comments[9] = "# H+ -> e+ nu_e";
  ParticleHiggsplus.Array_Decays[10][0] = PDGnumuon; ParticleHiggsplus.Array_Decays[10][1] = -PDGmuon; ParticleHiggsplus.Array_Decays[10][2] = Hplusamplitudemuonmuonneutrino; ParticleHiggsplus.Array_Decays[10][3] = 2; ParticleHiggsplus.Array_Comments[10] = "# H+ -> mu+ nu_mu";
  ParticleHiggsplus.Array_Decays[11][0] = PDGnutau; ParticleHiggsplus.Array_Decays[11][1] = -PDGtau; ParticleHiggsplus.Array_Decays[11][2] = Hplusamplitudetautauneutrino; ParticleHiggsplus.Array_Decays[11][3] = 2; ParticleHiggsplus.Array_Comments[11] = "# H+ -> tau+ nu_tau";
  ParticleHiggsplus.Array_Decays[12][0] = PDGneutralino1; ParticleHiggsplus.Array_Decays[12][1] = PDGchargino1; ParticleHiggsplus.Array_Decays[12][2] = HplusamplitudeneutZ1charW1; ParticleHiggsplus.Array_Decays[12][3] = 2; ParticleHiggsplus.Array_Comments[12] = "# H+ -> ~chi_10 ~chi_1+";
  ParticleHiggsplus.Array_Decays[13][0] = PDGneutralino1; ParticleHiggsplus.Array_Decays[13][1] = PDGchargino2; ParticleHiggsplus.Array_Decays[13][2] = HplusamplitudeneutZ1charW2; ParticleHiggsplus.Array_Decays[13][3] = 2; ParticleHiggsplus.Array_Comments[13] = "# H+ -> ~chi_10 ~chi_2+";
  ParticleHiggsplus.Array_Decays[14][0] = PDGneutralino2; ParticleHiggsplus.Array_Decays[14][1] = PDGchargino1; ParticleHiggsplus.Array_Decays[14][2] = HplusamplitudeneutZ2charW1; ParticleHiggsplus.Array_Decays[14][3] = 2; ParticleHiggsplus.Array_Comments[14] = "# H+ -> ~chi_20 ~chi_1+";
  ParticleHiggsplus.Array_Decays[15][0] = PDGneutralino2; ParticleHiggsplus.Array_Decays[15][1] = PDGchargino2; ParticleHiggsplus.Array_Decays[15][2] = HplusamplitudeneutZ2charW2; ParticleHiggsplus.Array_Decays[15][3] = 2; ParticleHiggsplus.Array_Comments[15] = "# H+ -> ~chi_20 ~chi_2+";
  ParticleHiggsplus.Array_Decays[16][0] = PDGneutralino3; ParticleHiggsplus.Array_Decays[16][1] = PDGchargino1; ParticleHiggsplus.Array_Decays[16][2] = HplusamplitudeneutZ3charW1; ParticleHiggsplus.Array_Decays[16][3] = 2; ParticleHiggsplus.Array_Comments[16] = "# H+ -> ~chi_30 ~chi_1+";
  ParticleHiggsplus.Array_Decays[17][0] = PDGneutralino3; ParticleHiggsplus.Array_Decays[17][1] = PDGchargino2; ParticleHiggsplus.Array_Decays[17][2] = HplusamplitudeneutZ3charW2; ParticleHiggsplus.Array_Decays[17][3] = 2; ParticleHiggsplus.Array_Comments[17] = "# H+ -> ~chi_30 ~chi_2+";
  ParticleHiggsplus.Array_Decays[18][0] = PDGneutralino4; ParticleHiggsplus.Array_Decays[18][1] = PDGchargino1; ParticleHiggsplus.Array_Decays[18][2] = HplusamplitudeneutZ4charW1; ParticleHiggsplus.Array_Decays[18][3] = 2; ParticleHiggsplus.Array_Comments[18] = "# H+ -> ~chi_40 ~chi_1+";
  ParticleHiggsplus.Array_Decays[19][0] = PDGneutralino4; ParticleHiggsplus.Array_Decays[19][1] = PDGchargino2; ParticleHiggsplus.Array_Decays[19][2] = HplusamplitudeneutZ4charW2; ParticleHiggsplus.Array_Decays[19][3] = 2; ParticleHiggsplus.Array_Comments[19] = "# H+ -> ~chi_40 ~chi_2+";
  ParticleHiggsplus.Array_Decays[20][0] = PDGWplus; ParticleHiggsplus.Array_Decays[20][1] = PDGh0; ParticleHiggsplus.Array_Decays[20][2] = HplusamplitudehW; ParticleHiggsplus.Array_Decays[20][3] = 2; ParticleHiggsplus.Array_Comments[20] = "# H+ -> W+ h";  
  ParticleHiggsplus.Array_Decays[21][0] = PDGsupL; ParticleHiggsplus.Array_Decays[21][1] = -PDGsdownL; ParticleHiggsplus.Array_Decays[21][2] = HplusamplitudesupLsdownL; ParticleHiggsplus.Array_Decays[21][3] = 2; ParticleHiggsplus.Array_Comments[21] = "# H+ -> ~u_L d_L*"; 
  ParticleHiggsplus.Array_Decays[22][0] = PDGsupR; ParticleHiggsplus.Array_Decays[22][1] = -PDGsdownR; ParticleHiggsplus.Array_Decays[22][2] = HplusamplitudesupRsdownR; ParticleHiggsplus.Array_Decays[22][3] = 2; ParticleHiggsplus.Array_Comments[22] = "# H+ -> ~u_R d_R*";
  ParticleHiggsplus.Array_Decays[23][0] = PDGsupL; ParticleHiggsplus.Array_Decays[23][1] = -PDGsdownR; ParticleHiggsplus.Array_Decays[23][2] = HplusamplitudesupLsdownR; ParticleHiggsplus.Array_Decays[23][3] = 2; ParticleHiggsplus.Array_Comments[23] = "# H+ -> ~u_L d_R*";
  ParticleHiggsplus.Array_Decays[24][0] = PDGsupR; ParticleHiggsplus.Array_Decays[24][1] = -PDGsdownL; ParticleHiggsplus.Array_Decays[24][2] = HplusamplitudesupRsdownL; ParticleHiggsplus.Array_Decays[24][3] = 2; ParticleHiggsplus.Array_Comments[24] = "# H+ -> ~u_R d_L*";
  ParticleHiggsplus.Array_Decays[25][0] = PDGscharmL; ParticleHiggsplus.Array_Decays[25][1] = -PDGsstrangeL; ParticleHiggsplus.Array_Decays[25][2] = HplusamplitudescharmLsstrangeL; ParticleHiggsplus.Array_Decays[25][3] = 2; ParticleHiggsplus.Array_Comments[25] = "# H+ -> ~c_L s_L*"; 
  ParticleHiggsplus.Array_Decays[26][0] = PDGscharmR; ParticleHiggsplus.Array_Decays[26][1] = -PDGsstrangeR; ParticleHiggsplus.Array_Decays[26][2] = HplusamplitudescharmRsstrangeR; ParticleHiggsplus.Array_Decays[26][3] = 2; ParticleHiggsplus.Array_Comments[26] = "# H+ -> ~c_R s_R*";
  ParticleHiggsplus.Array_Decays[27][0] = PDGscharmL; ParticleHiggsplus.Array_Decays[27][1] = -PDGsstrangeR; ParticleHiggsplus.Array_Decays[27][2] = HplusamplitudescharmLsstrangeR; ParticleHiggsplus.Array_Decays[27][3] = 2; ParticleHiggsplus.Array_Comments[27] = "# H+ -> ~c_L s_R*";
  ParticleHiggsplus.Array_Decays[28][0] = PDGscharmR; ParticleHiggsplus.Array_Decays[28][1] = -PDGsstrangeL; ParticleHiggsplus.Array_Decays[28][2] = HplusamplitudescharmRsstrangeL; ParticleHiggsplus.Array_Decays[28][3] = 2; ParticleHiggsplus.Array_Comments[28] = "# H+ -> ~c_R s_L*";
    ParticleHiggsplus.Array_Decays[29][0] = PDGnuselectronL; ParticleHiggsplus.Array_Decays[29][1] = -PDGselectronL; ParticleHiggsplus.Array_Decays[29][2] = HplusamplitudeselectronLsnue; ParticleHiggsplus.Array_Decays[29][3] = 2; ParticleHiggsplus.Array_Comments[29] = "# H+ -> ~e_L+ nu_eL";
    ParticleHiggsplus.Array_Decays[30][0] = PDGnuselectronL; ParticleHiggsplus.Array_Decays[30][1] = -PDGselectronR; ParticleHiggsplus.Array_Decays[30][2] = HplusamplitudeselectronRsnue; ParticleHiggsplus.Array_Decays[30][3] = 2; ParticleHiggsplus.Array_Comments[30] = "# H+ -> ~e_R+ nu_eL";
    ParticleHiggsplus.Array_Decays[31][0] = PDGnusmuonL; ParticleHiggsplus.Array_Decays[31][1] = -PDGsmuonL; ParticleHiggsplus.Array_Decays[31][2] = HplusamplitudesmuonLsnumu; ParticleHiggsplus.Array_Decays[31][3] = 2; ParticleHiggsplus.Array_Comments[31] = "# H+ -> ~mu_L+ nu_muL";
    ParticleHiggsplus.Array_Decays[32][0] = PDGnusmuonL; ParticleHiggsplus.Array_Decays[32][1] = -PDGsmuonR; ParticleHiggsplus.Array_Decays[32][2] = HplusamplitudesmuonRsnumu; ParticleHiggsplus.Array_Decays[32][3] = 2; ParticleHiggsplus.Array_Comments[32] = "# H+ -> ~mu_R+ nu_muL";
    ParticleHiggsplus.Array_Decays[33][0] = PDGstop1; ParticleHiggsplus.Array_Decays[33][1] = -PDGsbottom1; ParticleHiggsplus.Array_Decays[33][2] = Hplusamplitudestop1sbottom1; ParticleHiggsplus.Array_Decays[33][3] = 2; ParticleHiggsplus.Array_Comments[33] = "# H+ -> ~t_1 b_1*";
    ParticleHiggsplus.Array_Decays[34][0] = PDGstop2; ParticleHiggsplus.Array_Decays[34][1] = -PDGsbottom2; ParticleHiggsplus.Array_Decays[34][2] = Hplusamplitudestop2sbottom2; ParticleHiggsplus.Array_Decays[34][3] = 2; ParticleHiggsplus.Array_Comments[34] = "# H+ -> ~t_2 b_2*";
    ParticleHiggsplus.Array_Decays[35][0] = PDGstop1; ParticleHiggsplus.Array_Decays[35][1] = -PDGsbottom2; ParticleHiggsplus.Array_Decays[35][2] = Hplusamplitudestop1sbottom2; ParticleHiggsplus.Array_Decays[35][3] = 2; ParticleHiggsplus.Array_Comments[35] = "# H+ -> ~t_1 b_2*";
    ParticleHiggsplus.Array_Decays[36][0] = PDGstop2; ParticleHiggsplus.Array_Decays[36][1] = -PDGsbottom1; ParticleHiggsplus.Array_Decays[36][2] = Hplusamplitudestop2sbottom1; ParticleHiggsplus.Array_Decays[36][3] = 2; ParticleHiggsplus.Array_Comments[36] = "# H+ -> ~t_2 b_1*";
    ParticleHiggsplus.Array_Decays[37][0] = PDGnustauL; ParticleHiggsplus.Array_Decays[37][1] = -PDGstau1; ParticleHiggsplus.Array_Decays[37][2] = Hplusamplitudestau1snutau; ParticleHiggsplus.Array_Decays[37][3] = 2; ParticleHiggsplus.Array_Comments[37] = "# H+ -> ~tau_1+ nu_tauL";
    ParticleHiggsplus.Array_Decays[38][0] = PDGnustauL; ParticleHiggsplus.Array_Decays[38][1] = -PDGstau2; ParticleHiggsplus.Array_Decays[38][2] = Hplusamplitudestau2snutau; ParticleHiggsplus.Array_Decays[38][3] = 2; ParticleHiggsplus.Array_Comments[38] = "# H+ -> ~tau_2+ nu_tauL";

    double Higgsplus_No_1to2_Decays = 0;
 
    Higgsplus_No_1to2_Decays = ParticleHiggsplus.No_1to2_Decays; /// As higgsplus can't be NLSP as heavier than higgsl
   
    for (int j = 0; j<Higgsplus_No_1to2_Decays; j++) {
      ParticleHiggsplus.Array_Decays[j][4] = 0; ///0 indicates no 3rd daughter so 1->2 decay.
    }

    for (int j=0; j<Higgsplus_No_1to2_Decays; j++) {
      ParticleHiggsplus.two_width = ParticleHiggsplus.two_width + ParticleHiggsplus.Array_Decays[j][2];
    }
    for (int j=Higgsplus_No_1to2_Decays; j<ParticleHiggsplus.No_of_Decays; j++) {
      ParticleHiggsplus.three_width = ParticleHiggsplus.three_width + ParticleHiggsplus.Array_Decays[j][2];
    }
    
    for(int j=0; j<ParticleHiggsplus.No_of_Decays; j++) {
      ParticleHiggsplus.Array_Decays[j][4] = 0;
    }

    ParticleHiggsplus.total_width = ParticleHiggsplus.two_width + ParticleHiggsplus.three_width;
  
   
    for (int i =0; i<ParticleHiggsplus.No_of_Decays; i++) {
     ParticleHiggsplus.Array_Decays[i][5]= ParticleHiggsplus.Array_Decays[i][2]/ParticleHiggsplus.total_width;
    } 


///cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
/// cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleHiggsplus.PDG << setw(12) << scientific << setprecision(8) <<  ParticleHiggsplus.total_width << "   " << "# H+ (charged higgs+) decays" << endl;
/// cout.precision(7);
/// cout << left << setw(6) << "#" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
/// for (int k=0; k<ParticleHiggsplus.No_of_Decays; k++) {
///   if( ParticleHiggsplus.Array_Decays[k][2] != 0 ) {
///     cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleHiggsplus.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << ParticleHiggsplus.Array_Decays[k][3];  printRowPDG(cout, ParticleHiggsplus.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleHiggsplus.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleHiggsplus.Array_Comments[k] << endl;
///   }
///   else{}
/// }
/// cout << "#" << endl; 
///}

///Uncomment section below if want partial widths as well as branching ratios 
cout << left << setw(6) << "#" << setw(12) << "PDG" << setw(18) << "Width" << endl;
cout << "DECAY " << setw(12) << fixed << setprecision(0) << ParticleHiggsplus.PDG << setw(12) << scientific << setprecision(8) <<  ParticleHiggsplus.total_width << "   " << "# H+ (charged higgs+) decays" << endl;
cout.precision(7);
cout << left << setw(6) << "#" << setw(18) << "PW" << setw(18) << "BR" << setw(6) << "NDA" << setw(12) << left << "PDG1" << setw(12) << " PDG2" << endl;
for (int k=0; k<ParticleHiggsplus.No_of_Decays; k++) {
  if( ParticleHiggsplus.Array_Decays[k][2] != 0 ) {
    cout << left << setw(6) << " " << setw(18) << scientific << setprecision(8) << ParticleHiggsplus.Array_Decays[k][2] << setprecision(8) << ParticleHiggsplus.Array_Decays[k][5] << setprecision(0) << setw(6) << fixed << " " << ParticleHiggsplus.Array_Decays[k][3] << setw(4) << " ";  printRowPDG(cout, ParticleHiggsplus.Array_Decays[k][0]); cout << "   "; printRowPDG(cout,ParticleHiggsplus.Array_Decays[k][1]); cout << "   " << left << setprecision(0) << setw(15) << ParticleHiggsplus.Array_Comments[k] << endl;
  }
  else{}
 }
cout << "#" << endl; 
}




/// Function to calculate the gluino decay amplitudes
double gluinoamplitudedecay (double m1, double m2, double m3, double alphastrong) {
  double squareratio, squareplus, squareminus, amplitudeW;
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
      /// cout << "Decay not allowed as outgoing states heavier than incoming states" << endl;
      amplitudeW = 0;
    }
  else {
      squareplus = pow(m1,2) - pow((m2 + m3),2);
      squareminus = pow(m1,2) - pow((m2 - m3),2);
      squareratio = 1 + pow((m2/m1),2) - pow((m3/m1),2);
       amplitudeW = 1./4*alphastrong*(1/(2*m1))*squareratio*pow(squareplus*squareminus,0.5);
       /// amplitudeW = alphastrong/(8*m1)*(1-pow(m3/m1,2))*(pow(m1,2)-pow(m3,2));
       /// cout << "m1=" << m1 << " m2=" << m2 << " m3= " << m3 << " squareplus=" << squareplus << " squareminus=" << squareminus << " squareratio=" << squareratio << " alphastrong= " << alphastrong << endl;
    }
  return amplitudeW;
}


double gluinoamplitudedecaymix (double m1, double m2, double m3, double alphastrong, double squarkmix, double theta) {
  double squareratio, squareplus, squareminus, amplitudeW=0, squareratiomix1, squareratiomix2;
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    //    cout << "fabs(m3) + fabs(m2) - fabs(m1) = " << fabs(m3) + fabs(m2) - fabs(m1) << endl;
      ///  cout << "Decay not allowed as outgoing states heavier than incoming states" << endl;
      amplitudeW = 0;
    }
  else {
      squareplus = pow(m1,2) - pow((m2 + m3),2);
      squareminus = pow(m1,2) - pow((m2 - m3),2);
      squareratio = 1 + pow((m2/m1),2) - pow((m3/m1),2);
      if (squarkmix ==1) { 
	  squareratiomix1= squareratio - 2*sin(2*theta)*m2/m1;
	  ///double a = 2*sin(2*theta);
	  amplitudeW = (alphastrong*1./4)*squareratiomix1*(1/(2*m1))*pow(squareplus*squareminus,0.5); 
	  ///cout << "m1=" << m1 << "m2=" << m2 << "m3=" << m3 << "squareplus=" << squareplus << "squareminus=" << squareminus << "sqaureratiomix1=" << squareratiomix1 << " 2sinthetat=" << a << endl;
	}
      else if (squarkmix ==2) {
	  squareratiomix2 = squareratio + 2*sin(2*theta)*m2/m1;
	  ///double a = 2*sin(2*theta);
	  amplitudeW = (alphastrong*1./4)*squareratiomix2*(1/(2*m1))*pow(squareplus*squareminus,0.5);
	  ///cout << "m1=" << m1 << "m2=" << m2 << "m3=" << m3 << "squareplus=" << squareplus << "squareminus=" << squareminus << "sqaureratiomix2=" << squareratiomix2 << " 2sinthetat=" << a << endl;
	   	}
      ///cout << "theta is " << theta << endl;
    }
  return amplitudeW;
}


double squarkamplitudedecaygluino (double m1, double m2, double m3, double alphastrong) {
  double squareratio, squareplus, squareminus, amplitudeW;
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
      ///cout << "Decay not allowed as outgoing states heavier than incoming states" << endl;
      amplitudeW = 0;
    }
  else {  
      ///cout << "I think m1 is: " << m1 << " m2 is: " << m2 << " m3 is: " << m3 << endl;
      squareplus = pow(m1,2) - pow((m2 + m3),2);
      squareminus = pow(m1,2) - pow((m2 - m3),2);
      squareratio = 1 - pow((m2/m1),2) - pow((m3/m1),2);
   ///cout << "squareratio is " << squareratio << " squareplus is " << squareplus << " squareminus is " << squareminus << endl;
      amplitudeW = 4./3*alphastrong*(1/(2*m1))*squareratio*pow(squareplus*squareminus,0.5);
    }
  return amplitudeW;
}

double squarkamplitudedecaygluinomix (double m1, double m2, double m3, double alphastrong, double squarkmix, double theta) {
	double squareratiomix, squareplus, squareminus, amplitudeW=0;
	if (fabs(m1) < fabs(m2) +fabs(m3)) {
	  ///cout << "Decay not allowed as outgoing states heavier than incoming states" << endl;
		amplitudeW = 0;
    	}
	else {
	  ///cout << "I think m1 is: " << m1 << " m2 is: " << m2 << " m3 is: " << m3 << endl;
	  squareplus = pow(m1,2)-pow((m2+m3),2);
	  squareminus = pow(m1,2) - pow((m2-m3),2);
	  if (squarkmix == 1) {
	    squareratiomix = 1- pow(m2/m1,2) - pow(m3/m1,2) +2*sin(2*theta)*m2*m3/(pow(m1,2));
	    amplitudeW = 4./3*alphastrong*1/(2*m1)*squareratiomix*pow(squareplus*squareminus,0.5);
	  }
	  
	  else if (squarkmix == 2) {
	    squareratiomix = 1- pow(m2/m1,2) - pow(m3/m1,2) -2*sin(2*theta)*m2*m3/(pow(m1,2));
	    amplitudeW = 4./3*alphastrong*1/(2*m1)*squareratiomix*pow(squareplus*squareminus,0.5);
	  }
	}
	return amplitudeW;
}


double squarkamplitudedecaycharginoW1 (double m1, double m2, double m3, double g, double gamma) {
	double squareratio, squareplus, squareminus, amplitudeW;
	if (fabs(m1) < fabs(m2) +fabs(m3)) {
	  ///cout << "Decay not allowed as outgoing states heavier than incoming states" << endl;
		amplitudeW = 0;
    	}
	else {
	  ///cout << "I think m1 is: " << m1 << " m2 is: " << m2 << " m3 is: " << m3 << endl;
	  squareplus = 1 - pow(m3/m1+m2/m1,2);
	  squareminus = 1 - pow(m3/m1-m2/m1,2);
	  squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2);
	  ///cout << "squareratio is " << squareratio << " squareplus is " << squareplus << " squareminus is " << squareminus << endl;		

	    amplitudeW = pow(g,2)*pow(sin(gamma),2)/(16*M_PI)*m1*squareratio*pow(squareplus*squareminus,0.5);
	}
	return amplitudeW;
}
		  
double squarkamplitudedecaycharginoW2 (double m1, double m2, double m3, double g, double gamma) {
	double squareratio, squareplus, squareminus, amplitudeW;
	if (fabs(m1) < fabs(m2) +fabs(m3)) {
	  ///cout << "Decay not allowed as outgoing states heavier than incoming states" << endl;
		amplitudeW = 0;
    	}
	else {
	  ///cout << "I think m1 is: " << m1 << " m2 is: " << m2 << " m3 is: " << m3 << endl;
		squareplus = 1 - pow(m3/m1+m2/m1,2);
		squareminus = 1 - pow(m3/m1-m2/m1,2);
		squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2);
		///cout << "squareratio is " << squareratio << " squareplus is " << squareplus << " squareminus is " << squareminus << endl;		
		amplitudeW = pow(g,2)*pow(cos(gamma),2)/(16*M_PI)*m1*squareratio*pow(squareplus*squareminus,0.5);
	}
	return amplitudeW;
}


double squark1amplitudedecaycharginoW1mix (double m1, double m2, double m3, double g, double gammaL, double gammaR,  double theta, double beta, double mWboson, double runmt, double runmb, double torb) /// the variable torb depends on if it is stop (torb=1) or sbottom (torb =2) decaying and changes AprimeuW1 to AprimedW1 accordingly
{
  double squareratio=0, squareplus=0, squareminus=0, lambda=0, angular1=0, angular2=0, amplitudeW=0;
  DoubleVector squarkmixcharginocouplings (double g, double theta, double beta, double gammaL, double gammaR, double runmt, double runmb, double mWboson, int torb);
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Decay not allowed as outgoing states heavier than incoming states" << endl;
    amplitudeW = 0;
  }
  else {
    ///cout << "I think m1 is: " << m1 << " m2 is: " << m2 << " m3 is: " << m3 << endl;
    squareplus = 1 - pow(m3/m1+m2/m1,2);
    squareminus = 1 - pow(m3/m1-m2/m1,2);
    squareratio = 1- pow(m3/m1,2) - pow(m2/m1,2);
    ///cout << "squareratio is " << squareratio << " squareplus is " << squareplus << " squareminus is " << squareminus << endl;		
    lambda = pow(squareplus*squareminus,0.5);
    ///alsbot = cos(theta)*sin(gammaL)-sin(theta)*(fd/g)*cos(gammaL);
    ///aksbot = -cos(theta)*(fu/g)*cos(gammaR);
    
    angular1 = squarkmixcharginocouplings(g, theta, beta, gammaL, gammaR, runmt, runmb, mWboson, torb)(1);
    angular2 = squarkmixcharginocouplings(g, theta, beta, gammaL, gammaR, runmt, runmb, mWboson, torb)(2);
    
    ///cout << "fu is " << fu << " fd is " << fd << " AprimeW1 is " << AprimeW1 << " AprimeuW1 is " << AprimeuW1 << " AprimedW1 is " << AprimedW1 << endl;
    ///cout << "alsbot is " << alsbot << " aksbot is " << aksbot << endl;
    ///cout << " B1 is " << B1 << " B2 is " << B2  << endl;
    ///cout << "combo is " << combo << " lambda is " << lambda <<  endl;
    ///cout << "angular1 is " << angular1 << " angular2 is " << angular2 << endl;
    ///amplitudeW = m1/(16*PI)*(pow(g,2)*(pow(alsbot,2) + pow(aksbot,2))*squareratio - 4*pow(g,2)*alsbot*aksbot*m2*m3/(pow(m1,2)))*lambda;
    amplitudeW = m1/(16*PI)*(angular1*squareratio + m3*m2/(pow(m1,2))*angular2)*lambda; //test
    ///amplitudeW = m1/(16*M_PI)*lambda*(angular1*squareratio - m3*m2/(pow(m1,2))*angular2); // This formula and in fact this whole function should be checked!
    
  }
  return amplitudeW;
}



double squark1amplitudedecaycharginoW2mix (double m1, double m2, double m3, double g, double gammaL, double gammaR,  double theta, double beta, double mWboson, double runmt, double runmb, double torb) /// the variable torb depends on if it is stop (torb=1) or sbottom (torb =2) decaying and changes AprimeuW2 to AprimedW2 accordingly
{
  double squareratio=0, squareplus=0, squareminus=0, lambda=0, angular1=0, angular2=0, amplitudeW=0;
  DoubleVector squarkmixcharginocouplings (double g, double theta, double beta, double gammaL, double gammaR, double runmt, double runmb, double mWboson, int torb);
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Decay not allowed as outgoing states heavier than incoming states" << endl;
    amplitudeW = 0;
  }
  else {
    ///cout << "I think m1 is: " << m1 << " m2 is: " << m2 << " m3 is: " << m3 << endl;
    squareplus = 1 - pow(m3/m1+m2/m1,2);
    squareminus = 1 - pow(m3/m1-m2/m1,2);
    squareratio = 1- pow(m3/m1,2) - pow(m2/m1,2);
    ///cout << "squareratio is " << squareratio << " squareplus is " << squareplus << " squareminus is " << squareminus << endl;
    
    lambda = pow(squareplus*squareminus,0.5);
    angular1 = squarkmixcharginocouplings (g, theta, beta, gammaL, gammaR, runmt, runmb, mWboson, torb)(3);
    angular2 = squarkmixcharginocouplings (g, theta, beta, gammaL, gammaR, runmt, runmb, mWboson, torb)(4);
		
    amplitudeW = m1/(16*M_PI)*lambda*(angular1*squareratio + m3*m2/(pow(m1,2))*angular2); /// This formula and in fact this whole function should be checked!
  }
  return amplitudeW;
}



double squark2amplitudedecaycharginoW1mix (double m1, double m2, double m3, double g, double gammaL, double gammaR,  double theta, double beta, double mWboson, double runmt, double runmb, double torb) /// the variable torb depends on if it is stop (torb=1) or sbottom (torb =2) decaying and changes AprimeuW1 to AprimedW1 accordingly
{
  double squareratio=0, squareplus=0, squareminus=0, lambda=0, angular1=0, angular2=0, amplitudeW=0;
  DoubleVector squarkmixcharginocouplings (double g, double theta, double beta, double gammaL, double gammaR, double runmt, double runmb, double mWboson, int torb);

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Decay not allowed as outgoing states heavier than incoming states" << endl;
    amplitudeW = 0;
  }
  else {
    ///cout << "I think m1 is: " << m1 << " m2 is: " << m2 << " m3 is: " << m3 << endl;
    squareplus = 1 - pow(m3/m1+m2/m1,2);
    squareminus = 1 - pow(m3/m1-m2/m1,2);
    squareratio = 1- pow(m3/m1,2) - pow(m2/m1,2);
    ///cout << "squareratio is " << squareratio << " squareplus is " << squareplus << " squareminus is " << squareminus << endl;		
	 
    lambda = pow(squareplus*squareminus, 0.5);
    angular1 = squarkmixcharginocouplings (g, theta, beta, gammaL, gammaR, runmt, runmb, mWboson, torb)(5);
    angular2 = squarkmixcharginocouplings (g, theta, beta, gammaL, gammaR, runmt, runmb, mWboson, torb)(6);

    ///cout << scientific;
    ///cout.precision(5);
    ///cout << "angular1 = " << angular1 << " angular2 = " << angular2 << endl;
    ///cout << "angular1 = " << squarkmixcharginocouplings (g, theta, beta, gammaL, gammaR, runmt, runmb, mWboson, torb)(5) << " angular2 = " << squarkmixcharginocouplings (g, theta, beta, gammaL, gammaR, runmt, runmb, mWboson, torb)(6) << endl;

    
    amplitudeW = m1/(16*M_PI)*lambda*(angular1*squareratio + m3*m2/(pow(m1,2))*angular2); /// This formula and in fact this whole function should be checked!
  }
  return amplitudeW;
}

double squark2amplitudedecaycharginoW2mix (double m1, double m2, double m3, double g, double gammaL, double gammaR,  double theta, double beta, double mWboson, double runmt, double runmb, double torb) /// the variable torb depends on if it is stop (torb=1) or sbottom (torb =2) decaying and changes AprimeuW2 to AprimedW2 accordingly
{
  double squareratio=0, squareplus=0, squareminus=0, lambda = 0, angular1=0, angular2=0, amplitudeW=0;
  DoubleVector squarkmixcharginocouplings (double g, double theta, double beta, double gammaL, double gammaR, double runmt, double runmb, double mWboson, int torb);
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Decay not allowed as outgoing states heavier than incoming states" << endl;
    amplitudeW = 0;
  }
  else {
    ///cout << "I think m1 is: " << m1 << " m2 is: " << m2 << " m3 is: " << m3 << endl;
    squareplus = 1 - pow(m3/m1+m2/m1,2);
    squareminus = 1 - pow(m3/m1-m2/m1,2);
    squareratio = 1- pow(m3/m1,2) - pow(m2/m1,2);
    ///cout << "squareratio is " << squareratio << " squareplus is " << squareplus << " squareminus is " << squareminus << endl;		
    lambda = pow(squareplus*squareminus,0.5);
    angular1 = squarkmixcharginocouplings (g, theta, beta, gammaL, gammaR, runmt, runmb, mWboson, torb)(7);
    angular2 = squarkmixcharginocouplings (g, theta, beta, gammaL, gammaR, runmt, runmb, mWboson, torb)(8);
    
    amplitudeW = m1/(16*M_PI)*lambda*(angular1*squareratio + m3*m2/(pow(m1,2))*angular2); /// This formula and in fact this whole function should be checked!
  }
  return amplitudeW;
}

double squarkLamplitudedecayneutralino (double m1, double m2, double m3, double g, double gprime,  DoubleMatrix mixNeut, int neutralino, int uord ) ///neutralino takes values of 1, 2, 3, or 4 and denotes which neutralino mass eigenstate we decay into, uord takes value 1 for up quarks (or charm quarks) and -1 for down quarks (or strange quarks) in order to change the sign of the g*neutralinomixingmatrix[2][element] in AqZ accordingly
{
  double squareplus, squareminus, squareratio, AqZ, lambda, amplitudeW;
	if (fabs(m1) < fabs(m2) +fabs(m3)) {
	  ///cout << "Decay not allowed as outgoing states heavier than incoming states" << endl;
	  amplitudeW = 0;
    	}
	else {
	  /// cout << "I think m1 is: " << m1 << " m2 is: " << m2 << " m3 is: " << m3 << endl;
	  squareplus = 1 - pow(m3/m1+m2/m1,2);
	  squareminus = 1 - pow(m3/m1-m2/m1,2);
	  squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2);
	  ///AqZ = 1/(pow(2,0.5))*(uord*g*mixNeut(3,neutralino) + gprime*mixNeut(4,neutralino)/3); // this should be the formula according to Tata and Baer
	  ///AqZ = 1/(pow(2,0.5))*(uord*g*mixNeut(neutralino,2) + gprime*mixNeut(1,neutralino)/3);
	  AqZ = 1/(pow(2,0.5))*(uord*g*mixNeut(neutralino,2) + gprime*mixNeut(neutralino,1)/3); // trying different neutralino mixing elements as comparison with SUSYHIT suggests different mixNeut order
	  lambda = pow(squareplus*squareminus,0.5);
	  ///cout << endl;
	  ///cout << "lambda=" << lambda << " AqZ=" << AqZ << " squareratio=" << squareratio << endl;
	  amplitudeW = pow(AqZ,2)*m1/(16*PI)*squareratio*lambda; // need to check this formula, unsure about AqZ and also if it should be mod squared or just the squared I have done here!
	}
	return amplitudeW;
}

double squarkRamplitudedecayneutralino (double m1, double m2, double m3, double g, double gprime, DoubleMatrix mixNeut, int neutralino, int uord ) ///neutralino takes values of 1, 2, 3, or 4 and denotes which neutralino mass eigenstate we decay into, uord takes value 1 for up quarks (or charm quarks) and -1 for down quarks (or strange quarks) in order to change the sign and magnitude of the coefficient BqZ accordingly
{
  double squareplus, squareminus, squareratio, BqZ, uordchanger=0, lambda, amplitudeW;
	if (fabs(m1) < fabs(m2) +fabs(m3)) {
	  ///cout << "Decay not allowed as outgoing states heavier than incoming states" << endl;
	  amplitudeW = 0;
    	}
	else {
	  ///cout << "I think m1 is: " << m1 << " m2 is: " << m2 << " m3 is: " << m3 << endl;
	  squareplus = 1 - pow(m3/m1+m2/m1,2);
	  squareminus = 1 - pow(m3/m1-m2/m1,2);
	  squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2);
	  if ( uord == 1) { uordchanger =1;}
	  else if (uord == -1) { uordchanger =-0.5;}
	  ///BqZ = 1/(pow(2,0.5))*4./3*uordchanger*gprime*mixNeut(4,neutralino); this is what formula should be according to Tata and Baer
	  BqZ = 1/(pow(2,0.5))*4./3*uordchanger*gprime*mixNeut(neutralino,1); ///Following changes in AqZ suggested by SUSYHIT this suggests this BqZ may be better
	  ///cout << endl;
	  lambda = pow(squareplus*squareminus,0.5);
	  ///cout << "lambda=" << lambda << " BqZ=" << BqZ << " squareratio=" << squareratio << endl;
	  amplitudeW = pow(BqZ,2)*m1/(16*PI)*squareratio*lambda; /// need to check this formula, unsure about BqZ and also if it should be mod squared or just the squared I have done here!
	  
	}
	return amplitudeW;
}


double squark1amplitudedecayneutralinomix (double m1, double m2, double m3, double g, double gprime, double theta, double beta, double mWboson, DoubleMatrix mixNeut, double runmt, double runmb, int neutralino, int uord) ///neutralino takes values of 1, 2, 3, or 4 and denotes which neutralino mass eigenstate we decay into, uord takes value 1 for top quarks and -1 for bottom quarks in order to change the sign of the g*neutralinomixingmatrix[2][element] in AqZ accordingly, 
{
  double squareplus, squareminus, AqZ=0, BqZ=0, fq=0, neutelem=0, modasquared, modbsquared, combo1, combo2, lambda, amplitudeW; ///fq is the fermion Yukawa coupling - see pg 143 of Tata and Baer, neutelem ensures the third row of the neutralinomixingmatrix is selected for up type squarks and the fourth row is selected for down type squarks
  vector <double> a(2), b(2);
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Decay not allowed as outgoing states heavier than incoming states" << endl;
    amplitudeW = 0;
  }
  else {
    ///cout << "I think m1 is: " << m1 << " m2 is: " << m2 << " m3 is: " << m3 << endl;
    squareplus = 1 - pow(m3/m1+m2/m1,2);
    squareminus = 1 - pow(m3/m1-m2/m1,2);
    //squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2); /// not actually involved in the formula for the amplitude anymore but included for ease of comparison with my other amplitude functions
    if ( uord == 1) {
      ///fq = g*m2/(pow(2,0.5)*mWboson*sin(beta));
      fq = g*runmt/(pow(2,0.5)*mWboson*sin(beta));
      neutelem = 3;
      BqZ = 1/(pow(2,0.5))*4./3*gprime*mixNeut(neutralino,1);
    }
    else if (uord == -1) { 
      ///fq = g*m2/(pow(2,0.5)*mWboson*cos(beta));
      fq = g*runmb/(pow(2,0.5)*mWboson*cos(beta));
      neutelem = 4;
      BqZ = 1/(pow(2,0.5))*4./3*-1./2*gprime*mixNeut(neutralino,1);
    }
    
    AqZ = 1/(pow(2,0.5))*(uord*g*mixNeut(neutralino,2) + gprime*mixNeut(neutralino,1)/3);	
    /// Note for now I have taken AqZ and BqZ to be real - this effects which parts of a and b are real and imaginary, I have done this by assuming all masses are positive
    combo1 = fq*mixNeut(neutralino,neutelem)*cos(theta);
    combo2 = fq*mixNeut(neutralino,neutelem)*sin(theta);
		
    if (m3 < 0) {
      a[0] = 0.5*(-AqZ*cos(theta)-combo1 - BqZ*sin(theta)+combo2); /// real part
      a[1] = 0; /// imaginary part
      b[0] = 0.5*(AqZ*cos(theta) -combo1 - BqZ*sin(theta) - combo2); /// real part
      b[1] = 0; /// imaginary part
    }
    
    else if (m3 >=0) {
      a[0] = 0; /// real part
      a[1] = 0.5*((AqZ*cos(theta) - combo1) - BqZ*sin(theta) - combo2); /// imaginary part
      b[0] = 0; /// real part
      b[1] = 0.5*(-AqZ*cos(theta)-combo1 - BqZ*sin(theta) + combo2); ///imaginary part
	}
    
    ///a = (areal, aimag);
    ///b = (breal, bimag);
    modasquared = pow(a[0],2) + pow(a[1],2);
    modbsquared = pow(b[0],2) + pow(b[1],2);
    lambda = pow(squareplus*squareminus,0.5);
    amplitudeW = m1/(8*M_PI)*lambda*(modasquared*squareplus+modbsquared*squareminus);
    ///cout << endl;
    ///cout << "lambda " << lambda << " modasquared= " << modasquared << " modbsquared= " << modbsquared << endl;
    ///cout << "a is " << a[0]+a[1] << " b is " << b[0]+b[1] << endl;
    ///cout << "combo1 is " << combo1 << " combo2 is " << combo2 << " ft is " << fq << endl;
    ///cout << "squareplus= " << squareplus << " squareminus= " << squareminus << endl;
    ///cout << endl;
  }
  return amplitudeW;
}

double squark2amplitudedecayneutralinomix (double m1, double m2, double m3, double g, double gprime, double theta, double beta, double mWboson, DoubleMatrix mixNeut, double runmt, double runmb, int neutralino, int uord) ///neutralino takes values of 1, 2, 3, or 4 and denotes which neutralino mass eigenstate we decay into, uord takes value 1 for top quarks and -1 for bottom quarks in order to change the sign of the g*neutralinomixingmatrix[2][element] in AqZ accordingly, uordchanger changes the sign and magnitude of the coefficient of BqZ depending on if you have an up or down type squark
{
  double squareplus, squareminus,  AqZ, BqZ, uordchanger=0, fq=0, neutelem=0, areal, aimag, breal, bimag, modasquared, modbsquared, lambda, amplitudeW; ///fq is the fermion Yukawa coupling - see pg 143 of Tata and Baer, neutelem ensures the third row of the neutralinomixingmatrix is selected for up type squarks and the fourth row is selected for down type squarks
  ///complex<double> a,b; // NEED TO RELOOK THROUGH ALL THIS AS COMPLEX NUMBERS NOT WORKING PROPERLY
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Decay not allowed as outgoing states heavier than incoming states" << endl;
    amplitudeW = 0;
  }
  else {
    ///cout << "I think m1 is: " << m1 << " m2 is: " << m2 << " m3 is: " << m3 << endl;
    squareplus = 1 - pow(m3/m1+m2/m1,2);
    squareminus = 1 - pow(m3/m1-m2/m1,2);
    ///squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2); /// not actually involved in the formula for the amplitude anymore but included for ease of comparison with my other amplitude functions
    if ( uord == 1) {
      uordchanger =1;
      ///fq = g*m1/(pow(2,0.5)*mWboson*sin(beta));
	fq = g*runmt/(pow(2,0.5)*mWboson*sin(beta));
	neutelem = 3;
    }
    else if (uord == -1) { 
      uordchanger =-0.5;
      ///fq = g*m2/(pow(2,0.5)*mWboson*cos(beta));
      fq = g*runmb/(pow(2,0.5)*mWboson*cos(beta));				
      neutelem = 4;
    }
		
    AqZ = 1/(pow(2,0.5))*(uord*g*mixNeut(neutralino,2) + gprime*mixNeut(neutralino,1))/3;	
    BqZ = 1/(pow(2,0.5))*4./3*uordchanger*gprime*mixNeut(neutralino,1);
    /// Note for now I have taken AqZ and BqZ to be real - this effects which parts of a and b are real and imaginary, I have done this by assuming all masses are positive
    areal = 0.5*(-fq*mixNeut(neutralino,neutelem)*sin(theta)-fq*mixNeut(neutralino,neutelem)*cos(theta));
    aimag = 0.5*(AqZ*sin(theta)+BqZ*cos(theta));
    ///a = (areal, aimag);
    breal = 0.5*(-fq*mixNeut(neutralino,neutelem)*sin(theta)+fq*mixNeut(neutralino,neutelem)*cos(theta));
    bimag = 0.5*(-AqZ*sin(theta)+BqZ*cos(theta));
    ///b = (breal, bimag);
    modasquared = pow(areal,2)+pow(aimag,2);
    modbsquared = pow(breal,2)+pow(bimag,2);
    lambda = pow(squareplus*squareminus,0.5);
    amplitudeW = m1/(8*M_PI)*lambda*(modasquared*squareplus*+modbsquared*squareminus);
  }
  return amplitudeW;
}

double teststop1amplitudedecayneutralinomix (double m1, double m2, double m3, double mWboson, double theta, double beta, DoubleMatrix mixNeut, double g, double gp, double runmt, int neutralino) {
  double amplitudeW, squareplus, squareminus, lambda, ft, modasquared, modbsquared;
  vector <double> AtZ(2), BtZ(2), a(2), b(2);

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
  }

  else { 
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    ft = g*runmt/(pow(2,0.5)*mWboson*sin(beta));
      
    if (m3 >=0) /// so thetai is 1 in Tata and Baer formulae
	{
	  AtZ[0] = 0;
	  AtZ[1] = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	  BtZ[0] = 0;
	  BtZ[1] = 4/(3*pow(2,0.5))*(gp*mixNeut(neutralino,1));
	  ///AtZ[0] = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	  ///AtZ[1] = 0;
	  ///BtZ[0] = 4/(3*pow(2,0.5))*gp*mixNeut(neutralino,1);
	  ///BtZ[1] = 0;

	  a[0] = 0.5*(-AtZ[1]*cos(theta) + BtZ[1]*sin(theta));
	  a[1] = 0.5*(-ft*mixNeut(neutralino,3)*cos(theta) - ft*mixNeut(neutralino,3)*sin(theta));
	  b[0] = 0.5*(AtZ[1]*cos(theta) + BtZ[1]*sin(theta));
	  b[1] = 0.5*(-ft*mixNeut(neutralino,3)*cos(theta) + ft*mixNeut(neutralino,3)*sin(theta));
	  ///a[0] = 0;
	  ///a[1] = 0.5*(((AtZ[0]-ft*mixNeut(neutralino,3))*cos(theta)) - (BtZ[0] + ft*mixNeut(neutralino,3))*sin(theta));
	  ///b[0] = 0;
	  ///b[1] = 0.5*(((-AtZ[0] - ft*mixNeut(neutralino,3))*cos(theta)) - (BtZ[0] - ft*mixNeut(neutralino,3))*sin(theta));
	  ///temp3 = AtZ[1]*cos(theta);
	  ///temp4 = BtZ[1]*sin(theta);
	}
      
      else if (m3 < 0) /// so thetai is 0 in Tata and Baer formulae
	{
	  AtZ[0] = -1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	  AtZ[1] = 0;
	  BtZ[0] = 4/(3*pow(2,0.5))*gp*mixNeut(neutralino,1);
	  BtZ[1] = 0;
	  ///AtZ[0] = 0;
	  ///AtZ[1] = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	  ///BtZ[0] = 0;
	  ///BtZ[1] = -4/(3*pow(2,0.5))*gp*mixNeut(neutralino,1);
	  
	  a[0] = 0.5*(-ft*mixNeut(neutralino,3)*cos(theta) +ft*mixNeut(neutralino,3)*sin(theta));
	  a[1] = 0.5*(AtZ[0]*cos(theta) - BtZ[0]*sin(theta));
	  b[0] = 0.5*(ft*mixNeut(neutralino,3)*cos(theta)-ft*mixNeut(neutralino,3)*sin(theta));
	  b[1] = 0.5*(-AtZ[0]*cos(theta) - BtZ[0]*sin(theta));
	  ///a[0] = 0.5*(((-AtZ[1]- ft*mixNeut(neutralino,3))*cos(theta)) - (BtZ[1] - ft*mixNeut(neutralino,3))*sin(theta));
	  ///a[1] = 0;
	  ///b[0] = 0.5*(((AtZ[1] - ft*mixNeut(neutralino,3))*cos(theta)) - (BtZ[1] + ft*mixNeut(neutralino,3))*sin(theta));
	  ///b[1] = 0;
	  ///temp3 = AtZ[0]*cos(theta);
	  ///temp4 = BtZ[0]*sin(theta);
	}

    modasquared = pow(a[0],2) + pow(a[1],2);
    modbsquared = pow(b[0],2) + pow(b[1],2);
    ///temp1 = modasquared*squareplus;
    ///temp2 = modbsquared*squareminus;
      
      
    ///cout << "LOOK HERE! " << "modasquared= " << modasquared << " modbsquared= " << modbsquared << endl;
    ///cout << "modasquared*squareplus= " << temp1 << " modbsquared*squareminus= " << temp2 << endl;
    ///cout << "a[0]= " << a[0] << " a[1]= " << a[1] << " b[0]= " << b[0] << " b[1]= " << b[1] << endl;
    ///cout << "AtZ[i]*cos(theta)= " << temp3 << " BtZ[i]*sin(theta)= " << temp4 << endl;
    ///cout << endl;
    
    amplitudeW = m1/(8*PI)*lambda*(modasquared*squareplus + modbsquared*squareminus);
  }

  return amplitudeW;

}


double teststop2amplitudedecayneutralinomix (double m1, double m2, double m3, double mWboson, double theta, double beta, DoubleMatrix mixNeut, double g, double gp, double runmt, int neutralino) {
  double amplitudeW, squareplus, squareminus, lambda, ft, modasquared, modbsquared;
  vector <double> AtZ(2), BtZ(2), a(2), b(2);

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
  }

  else { 
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    ft = g*runmt/(pow(2,0.5)*mWboson*sin(beta));
      
    if (m3 >=0) /// so thetai is 1 in Tata and Baer formulae
      {
	AtZ[0] = 0;
	AtZ[1] = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	BtZ[0] = 0;
	BtZ[1] = 4/(3*pow(2,0.5))*(gp*mixNeut(neutralino,1));
	///AtZ[0] = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	///AtZ[1] = 0;
	///BtZ[0] = 4/(3*pow(2,0.5))*gp*mixNeut(neutralino,1);
	///BtZ[1] = 0;
	
	a[0] = 0.5*(-AtZ[1]*sin(theta) - BtZ[1]*cos(theta));
	a[1] = 0.5*(-ft*mixNeut(neutralino,3)*sin(theta) + ft*mixNeut(neutralino,3)*cos(theta));
	b[0] = 0.5*(AtZ[1]*sin(theta) - BtZ[1]*cos(theta));
	b[1] = 0.5*(-ft*mixNeut(neutralino,3)*sin(theta) - ft*mixNeut(neutralino,3)*cos(theta));
	///a[0] = 0;
	///a[1] = 0.5*(((AtZ[0]-ft*mixNeut(neutralino,3))*cos(theta)) - (BtZ[0] + ft*mixNeut(neutralino,3))*sin(theta));
	///b[0] = 0;
	///b[1] = 0.5*(((-AtZ[0] - ft*mixNeut(neutralino,3))*cos(theta)) - (BtZ[0] - ft*mixNeut(neutralino,3))*sin(theta));
	///temp3 = AtZ[1]*sin(theta);
	///temp4 = BtZ[1]*cos(theta);
      }
      
      else if (m3 < 0) /// so thetai is 0 in Tata and Baer formulae
	{
	  AtZ[0] = -1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	  AtZ[1] = 0;
	  BtZ[0] = 4/(3*pow(2,0.5))*gp*mixNeut(neutralino,1);
	  BtZ[1] = 0;
	  ///AtZ[0] = 0;
	  ///AtZ[1] = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	  ///BtZ[0] = 0;
	  ///BtZ[1] = -4/(3*pow(2,0.5))*gp*mixNeut(neutralino,1);
	  
	  a[0] = 0.5*(-ft*mixNeut(neutralino,3)*sin(theta) - ft*mixNeut(neutralino,3)*cos(theta));
	  a[1] = 0.5*(AtZ[0]*sin(theta) + BtZ[0]*cos(theta));
	  b[0] = 0.5*(ft*mixNeut(neutralino,3)*sin(theta) - ft*mixNeut(neutralino,3)*cos(theta));
	  b[1] = 0.5*(-AtZ[0]*sin(theta) + BtZ[0]*cos(theta));
	  ///a[0] = 0.5*(((-AtZ[1]- ft*mixNeut(neutralino,3))*cos(theta)) - (BtZ[1] - ft*mixNeut(neutralino,3))*sin(theta));
	  ///a[1] = 0;
	  ///b[0] = 0.5*(((AtZ[1] - ft*mixNeut(neutralino,3))*cos(theta)) - (BtZ[1] + ft*mixNeut(neutralino,3))*sin(theta));
	  ///b[1] = 0;
	  ///temp3 = AtZ[0]*sin(theta);
	  ///temp4 = BtZ[0]*cos(theta);
	}

      modasquared = pow(a[0],2) + pow(a[1],2);
      modbsquared = pow(b[0],2) + pow(b[1],2);
      ///temp1 = modasquared*squareplus;
      ///temp2 = modbsquared*squareminus;
      
      
      ///cout << "LOOK HERE! " << "modasquared= " << modasquared << " modbsquared= " << modbsquared << endl;
      ///cout << "modasquared*squareplus= " << temp1 << " modbsquared*squareminus= " << temp2 << endl;
      ///cout << "a[0]= " << a[0] << " a[1]= " << a[1] << " b[0]= " << b[0] << " b[1]= " << b[1] << endl;
      ///cout << "AtZ[i]*sin(theta)= " << temp3 << " BtZ[i]*cos(theta)= " << temp4 << endl;
      ///cout << endl;

      amplitudeW = m1/(8*PI)*lambda*(modasquared*squareplus + modbsquared*squareminus);
  }

  return amplitudeW;

}

double testsbottom1amplitudedecayneutralinomix (double m1, double m2, double m3, double mWboson, double theta, double beta, DoubleMatrix mixNeut, double g, double gp, double runmb, int neutralino) {
  double amplitudeW, squareplus, squareminus, lambda, fb, modasquared, modbsquared;
  vector <double> AbZ(2), BbZ(2), a(2), b(2);

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
  }

  else { 
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    fb = g*runmb/(pow(2,0.5)*mWboson*cos(beta));
      
    if (m3 >=0) /// so thetai is 1 in Tata and Baer formulae
      {
	AbZ[0] = 0;
	AbZ[1] = 1/(pow(2,0.5))*(-g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	BbZ[0] = 0;
	BbZ[1] = -2/(3*pow(2,0.5))*(gp*mixNeut(neutralino,1));
	///AbZ[0] = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	///AbZ[1] = 0;
	///BbZ[0] = 4/(3*pow(2,0.5))*gp*mixNeut(neutralino,1);
	///BbZ[1] = 0;

	a[0] = 0.5*(-AbZ[1]*cos(theta) + BbZ[1]*sin(theta));
	a[1] = 0.5*(-fb*mixNeut(neutralino,4)*cos(theta) - fb*mixNeut(neutralino,4)*sin(theta));
	b[0] = 0.5*(AbZ[1]*cos(theta) + BbZ[1]*sin(theta));
	b[1] = 0.5*(-fb*mixNeut(neutralino,4)*cos(theta) + fb*mixNeut(neutralino,4)*sin(theta));
	///a[0] = 0;
	///a[1] = 0.5*(((AbZ[0]-fb*mixNeut(neutralino,3))*cos(theta)) - (BbZ[0] + fb*mixNeut(neutralino,3))*sin(theta));
	///b[0] = 0;
	///b[1] = 0.5*(((-AbZ[0] - fb*mixNeut(neutralino,3))*cos(theta)) - (BbZ[0] - fb*mixNeut(neutralino,3))*sin(theta));
	///temp3 = AbZ[1]*cos(theta);
	///temp4 = BbZ[1]*sin(theta);
      }
    
    else if (m3 < 0) /// so thetai is 0 in Tata and Baer formulae
      {
	AbZ[0] = -1/(pow(2,0.5))*(-g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	AbZ[1] = 0;
	BbZ[0] = -2/(3*pow(2,0.5))*gp*mixNeut(neutralino,1);
	BbZ[1] = 0;
	///AbZ[0] = 0;
	///AbZ[1] = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	///BbZ[0] = 0;
	///BbZ[1] = -4/(3*pow(2,0.5))*gp*mixNeut(neutralino,1);
	  
	a[0] = 0.5*(-fb*mixNeut(neutralino,4)*cos(theta) +fb*mixNeut(neutralino,4)*sin(theta));
	a[1] = 0.5*(AbZ[0]*cos(theta) - BbZ[0]*sin(theta));
	b[0] = 0.5*(fb*mixNeut(neutralino,4)*cos(theta)-fb*mixNeut(neutralino,4)*sin(theta));
	b[1] = 0.5*(-AbZ[0]*cos(theta) - BbZ[0]*sin(theta));
	///a[0] = 0.5*(((-AbZ[1]- fb*mixNeut(neutralino,3))*cos(theta)) - (BbZ[1] - fb*mixNeut(neutralino,3))*sin(theta));
	///a[1] = 0;
	///b[0] = 0.5*(((AbZ[1] - fb*mixNeut(neutralino,3))*cos(theta)) - (BbZ[1] + fb*mixNeut(neutralino,3))*sin(theta));
	///b[1] = 0;
	///temp3 = AbZ[0]*cos(theta);
	///temp4 = BbZ[0]*sin(theta);
      }

    modasquared = pow(a[0],2) + pow(a[1],2);
    modbsquared = pow(b[0],2) + pow(b[1],2);
    ///temp1 = modasquared*squareplus;
    ///temp2 = modbsquared*squareminus;
      
      
    ///cout << "LOOK HERE! " << "modasquared= " << modasquared << " modbsquared= " << modbsquared << endl;
    ///cout << "modasquared*squareplus= " << temp1 << " modbsquared*squareminus= " << temp2 << endl;
    ///cout << "a[0]= " << a[0] << " a[1]= " << a[1] << " b[0]= " << b[0] << " b[1]= " << b[1] << endl;
    ///cout << "AbZ[i]*cos(theta)= " << temp3 << " BbZ[i]*sin(theta)= " << temp4 << endl;
    ///cout << endl;

    amplitudeW = m1/(8*PI)*lambda*(modasquared*squareplus + modbsquared*squareminus);
  }

  return amplitudeW;

}


double testsbottom2amplitudedecayneutralinomix (double m1, double m2, double m3, double mWboson, double theta, double beta, DoubleMatrix mixNeut, double g, double gp, double runmb, int neutralino) {
  double amplitudeW, squareplus, squareminus, lambda, fb, modasquared, modbsquared;
  vector <double> AbZ(2), BbZ(2), a(2), b(2);

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
  }

  else { 
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    fb = g*runmb/(pow(2,0.5)*mWboson*cos(beta));
      
    if (m3 >=0) /// so thetai is 1 in Tata and Baer formulae
      {
	AbZ[0] = 0;
	AbZ[1] = 1/(pow(2,0.5))*(-g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	BbZ[0] = 0;
	BbZ[1] = -2/(3*pow(2,0.5))*(gp*mixNeut(neutralino,1));
	///AbZ[0] = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	///AbZ[1] = 0;
	///BbZ[0] = 4/(3*pow(2,0.5))*gp*mixNeut(neutralino,1);
	///BbZ[1] = 0;
	
	a[0] = 0.5*(-AbZ[1]*sin(theta) - BbZ[1]*cos(theta));
	a[1] = 0.5*(-fb*mixNeut(neutralino,4)*sin(theta) + fb*mixNeut(neutralino,4)*cos(theta));
	b[0] = 0.5*(AbZ[1]*sin(theta) - BbZ[1]*cos(theta));
	b[1] = 0.5*(-fb*mixNeut(neutralino,4)*sin(theta) - fb*mixNeut(neutralino,4)*cos(theta));
	///a[0] = 0;
	///a[1] = 0.5*(((AbZ[0]-fb*mixNeut(neutralino,3))*cos(theta)) - (BbZ[0] + fb*mixNeut(neutralino,3))*sin(theta));
	///b[0] = 0;
	///b[1] = 0.5*(((-AbZ[0] - fb*mixNeut(neutralino,3))*cos(theta)) - (BbZ[0] - fb*mixNeut(neutralino,3))*sin(theta));
	///temp3 = AbZ[1]*sin(theta);
	///temp4 = -BbZ[1]*cos(theta);
      }
      
    else if (m3 < 0) /// so thetai is 0 in Tata and Baer formulae
      {
	AbZ[0] = -1/(pow(2,0.5))*(-g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	AbZ[1] = 0;
	BbZ[0] = -2/(3*pow(2,0.5))*gp*mixNeut(neutralino,1);
	BbZ[1] = 0;
	///AbZ[0] = 0;
	///AbZ[1] = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	///BbZ[0] = 0;
	///BbZ[1] = -4/(3*pow(2,0.5))*gp*mixNeut(neutralino,1);
	
	a[0] = 0.5*(-fb*mixNeut(neutralino,4)*sin(theta) -fb*mixNeut(neutralino,4)*cos(theta));
	a[1] = 0.5*(AbZ[0]*sin(theta) + BbZ[0]*cos(theta));
	b[0] = 0.5*(fb*mixNeut(neutralino,4)*sin(theta)+fb*mixNeut(neutralino,4)*cos(theta));
	b[1] = 0.5*(-AbZ[0]*sin(theta) + BbZ[0]*cos(theta));
	///a[0] = 0.5*(((-AbZ[1]- fb*mixNeut(neutralino,3))*cos(theta)) - (BbZ[1] - fb*mixNeut(neutralino,3))*sin(theta));
	///a[1] = 0;
	///b[0] = 0.5*(((AbZ[1] - fb*mixNeut(neutralino,3))*cos(theta)) - (BbZ[1] + fb*mixNeut(neutralino,3))*sin(theta));
	///b[1] = 0;
	///temp3 = AbZ[0]*sin(theta);
	///temp4 = -BbZ[0]*cos(theta);
      }

    modasquared = pow(a[0],2) + pow(a[1],2);
    modbsquared = pow(b[0],2) + pow(b[1],2);
    ///temp1 = modasquared*squareplus;
    ///temp2 = modbsquared*squareminus;
      
    
    /// cout << "LOOK HERE! " << "modasquared= " << modasquared << " modbsquared= " << modbsquared << endl;
    ///cout << "modasquared*squareplus= " << temp1 << " modbsquared*squareminus= " << temp2 << endl;
    ///cout << "a[0]= " << a[0] << " a[1]= " << a[1] << " b[0]= " << b[0] << " b[1]= " << b[1] << endl;
    ///cout << "AbZ[i]*cos(theta)= " << temp3 << " BbZ[i]*sin(theta)= " << temp4 << endl;
    cout << endl;

    amplitudeW = m1/(8*PI)*lambda*(modasquared*squareplus + modbsquared*squareminus);
  }

  return amplitudeW;

}

           
double testmederivedstop1amplitudedecayneutralinomix (double m1, double m2, double m3, double mWboson, double theta, double beta, DoubleMatrix mixNeut, double g, double gp, double runmt, int neutralino) {
  double amplitudeW, squareplus, squareminus, squareratio, lambda, ft, modalphatildasquared, modbetatildasquared;
  vector <double> AtZ(2), BtZ(2), alphatilda(2), betatilda(2), alphabetadagger(2), betaalphadagger(2);

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
  }
  
  else { 
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    squareratio = 1 - pow(m2/m1,2) - pow(m3/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    ft = g*runmt/(pow(2,0.5)*mWboson*sin(beta));
      
    if (m3 >=0) /// so thetai is 1 in Tata and Baer formulae
      {
	AtZ[0] = 0;
	AtZ[1] = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	BtZ[0] = 0;
	BtZ[1] = 4/(3*pow(2,0.5))*(gp*mixNeut(neutralino,1));
	
	alphatilda[0] = -AtZ[1]*cos(theta);
	alphatilda[1] = -ft*mixNeut(neutralino,3)*sin(theta); 
	betatilda[0] = BtZ[1]*sin(theta);
	betatilda[1] = -ft*mixNeut(neutralino,3)*cos(theta);
	///a[0] = 0.5*(-AtZ[1]*cos(theta) + BtZ[1]*sin(theta));
	///a[1] = 0.5*(-ft*mixNeut(neutralino,3)*cos(theta) - ft*mixNeut(neutralino,3)*sin(theta));
	///b[0] = 0.5*(AtZ[1]*cos(theta) + BtZ[1]*sin(theta));
	///b[1] = 0.5*(-ft*mixNeut(neutralino,3)*cos(theta) + ft*mixNeut(neutralino,3)*sin(theta));
	  
	
      }
      
    else if (m3 < 0) /// so thetai is 0 in Tata and Baer formulae
      {
	AtZ[0] = -1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp/3*mixNeut(neutralino,1));
	AtZ[1] = 0;
	BtZ[0] = 4/(3*pow(2,0.5))*gp*mixNeut(neutralino,1);
	BtZ[1] = 0;
	
	alphatilda[0] = ft*mixNeut(neutralino,3)*sin(theta);
	alphatilda[1] = AtZ[0]*cos(theta);
	betatilda[0] = -ft*mixNeut(neutralino,3)*mixNeut(neutralino,3)*cos(theta);
	betatilda[1] = -BtZ[0]*sin(theta);
	///a[0] = 0.5*(-ft*mixNeut(neutralino,3)*cos(theta) +ft*mixNeut(neutralino,3)*sin(theta));
	///a[1] = 0.5*(AtZ[0]*cos(theta) - BtZ[0]*sin(theta));
	///b[0] = 0.5*(ft*mixNeut(neutralino,3)*cos(theta)-ft*mixNeut(neutralino,3)*sin(theta));
	///b[1] = 0.5*(-AtZ[0]*cos(theta) - BtZ[0]*sin(theta));
	  
	 
      }

    modalphatildasquared = pow(alphatilda[0],2) + pow(alphatilda[1],2);
    modbetatildasquared = pow(betatilda[0],2) + pow(betatilda[1],2);
    alphabetadagger[0] = alphatilda[0]*betatilda[0] + alphatilda[1]*betatilda[1];
    alphabetadagger[1] = alphatilda[1]*betatilda[0] - alphatilda[0]*betatilda[1];
    betaalphadagger[0] = alphatilda[0]*betatilda[0] + alphatilda[1]*betatilda[1];
    betaalphadagger[1] = -alphatilda[1]*betatilda[0] + alphatilda[0]*betatilda[1];
    /// Note when we therefore add alphabetadagger and betaalphadagger the imaginary [1] parts cancel leaving only the real parts
    
    amplitudeW = m1/(32*PI)*lambda*((modalphatildasquared+modbetatildasquared)*squareratio + m2*m3/(pow(m1,2))*(alphabetadagger[0] + betaalphadagger[0]));

    ///cout << "lambda= " << lambda << " modalphatildasquared= " << modalphatildasquared << " modbetatildsquared= " << modbetatildasquared << endl;
    ///cout << "squareratio= " << squareratio << " alphabetadagger[0]= " << alphabetadagger[0] << " betaalphadagger= " << betaalphadagger[0] << endl;
  }

  return amplitudeW;
  
}

double testrealsquark3amplitudedecayneutralino (double m1, double m2, double m3, double mWboson, double theta, double beta, DoubleMatrix mixNeut, double g, double gp, double runmq, int squark , int oneortwo,  int neutralino) {

  double amplitudeW, squareplus, squareminus, lambda, fq=0, alphatilda=0, betatilda=0, a=0, b=0;
  

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
  }
  
  else { 
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    ///squareratio = 1 - pow(m2/m1,2) - pow(m3/m1,2); ///not used
    lambda = pow(squareplus*squareminus,0.5);
      
    ///sw = gp/pow((pow(g,2)+pow(gp,2)),0.5);
    ///cw = g/pow((pow(g,2)+pow(gp,2)),0.5);
    
    if (squark == 1) /// we have stops
      {
	fq = g*runmq/(pow(2,0.5)*mWboson*sin(beta));
	
	if (oneortwo == 1) /// we have stop1s
	  {
	    alphatilda = (cos(theta)*1/(pow(2,0.5))*(-g*mixNeut(neutralino,2) - gp/3*mixNeut(neutralino,1)) - fq*sin(theta)*mixNeut(neutralino,4)); /// this is just simpler (rearranged) form of atopr(1,i) from susyhit *g

	    ///alphatilda=g*(cos(theta)*pow(2,0.5)*(-2*(mixNeut(neutralino,1)*cw+mixNeut(neutralino,2)*sw)*sw/3 + (-0.5+2./3*pow(sw,2))*(-mixNeut(neutralino,1)*sw+mixNeut(neutralino,2)*cw)/cw)-sin(theta)*ft/g*mixNeut(neutralino,4)); /// this is just atopr(1,i) from susyhit * g
	    betatilda = (4/(3*pow(2,0.5))*gp*mixNeut(neutralino,1)*sin(theta) - fq*mixNeut(neutralino,4)*cos(theta)); /// this is just simpler (rearranged) form of btopr(1,i) from susyhit * g
	    ///betatilda=g*(-2*sin(theta)*pow(2,0.5)*sw*((-mixNeut(neutralino,1)*sw+mixNeut(neutralino,2)*cw)*(sw/cw)-(mixNeut(neutralino,1)*cw+mixNeut(neutralino,2)*sw))/3-cos(theta)*ft/g*mixNeut(neutralino,4)); /// this is just btopr(1,i) from susyhit * g
	  }
      
	else if (oneortwo == 2) /// we have stop2s
	  {
	    alphatilda = (-sin(theta)*1/(pow(2,0.5))*(mixNeut(neutralino,1)*gp/3 + mixNeut(neutralino,2)*g) + cos(theta)*fq*mixNeut(neutralino,4)); /// again simplified form of atopr(2,i) * g from susyhit
	    betatilda = -4/(3*pow(2,0.5))*cos(theta)*mixNeut(neutralino,1)*gp - fq*sin(theta)*mixNeut(neutralino,4); /// again simplified form of btopr(2,i) * g from susyhit
	  }
	
	else { cout << "problem: stop must be stop1 or stop2" << endl; }
      
      }
    
    else if ( squark ==2) /// we have sbottoms
      {
	fq = g*runmq/(pow(2,0.5)*mWboson*cos(beta));
	
	if ( oneortwo == 1) /// we have sbottom1s
	  {
	    alphatilda = (1/pow(2,0.5))*cos(theta)*(-mixNeut(neutralino,1)*gp/3 + mixNeut(neutralino,2)*g) - sin(theta)*mixNeut(neutralino,3)*fq; /// just simplified form of abot(1,i) * g from susyhit
	    betatilda = sin(theta)*2/(3*pow(2,0.5))*(-mixNeut(neutralino,1)*gp) - cos(theta)*fq*mixNeut(neutralino,3);
	  }
	else if (oneortwo == 2) /// we have sbottom2s
	  {
	    alphatilda = sin(theta)*(mixNeut(neutralino,1)*-gp*(1/(3*pow(2,0.5))) + mixNeut(neutralino,2)*g*1/(pow(2,0.5))) + cos(theta)*fq*mixNeut(neutralino,3); /// simplified abot(2,i)*g from susyhit
	    betatilda = cos(theta)*(2/(3*pow(2,0.5)))*gp*(mixNeut(neutralino,1)) - sin(theta)*fq*mixNeut(neutralino,3); /// simplified bbot(2,i)*g from susyhit
	    ///cout << " We're on sbottom2" << endl;
	  }
	  
	else { cout << "problem: must be sbottom1s or sbottom2s" << endl; }
      }
      
    else { cout << "problem: third generation squarks must be stops or sbottoms" << endl; }
          
    a = 0.5*(alphatilda + betatilda);
    b = 0.5*(betatilda - alphatilda);
                        
    amplitudeW = m1/(8*PI)*lambda*(pow(a,2)*squareplus + pow(b,2)*squareminus);
    ///amp2 = m1/(16*PI)*((pow(alphatilda,2) + pow(betatilda,2))*squareratio - 4*alphatilda*betatilda*m2*m3/(pow(m1,2)))*lambda;
      
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << " lambda= " << lambda << endl;
    ///cout << "squareplus= " << squareplus << " squareminus= " << squareminus << endl;
    ///cout << "atopr= " << alphatilda/g << " btopr= " << betatilda/g << endl;
    ///cout << "ct= " << cos(theta) << " cw= " << cw << " sw= " << sw << " ft= " << ft << endl;
    ///cout << "lambda= " << lambda << " alphatilda= " << alphatilda << " betatilda= " << betatilda << endl;
    ///cout <<  "a= " << a <<  " b= " << b << endl;
    ///cout << "amplitudeW= " << amplitudeW << " amp2= " << amp2 << endl;
  }

  return amplitudeW;
  
}
      
double squark3amplitudedecaysquark3Wboson (double m1, double m2, double m3, double g, double thetat, double thetab, int m1torb, int m1oneortwo, int m3torb, int m3oneortwo) /// m1torb tells the function if the initial squark is a stop or sbottom, m1oneortwo tells it whether it's the lighter or heavier squark, similarly for the final state squark with m3torb and m3oneortwo
{
  double amplitudeW, squareplus, squareminus, lambda, capthetai=0, capthetaf=0;
  
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    
    if(m1torb == 1) /// we have an initial stop
      {
	if(m1oneortwo == 1) /// we have an initial stop1
	  {
	    ///cout << " initial stop1!" << endl;
	    capthetai = pow(cos(thetat),2);
	  }
	else if (m1oneortwo ==2) // we have an initial stop2
	  {
	    ///cout << " initial stop2" << endl;
	    capthetai = pow(sin(thetat),2);
	  }
	else {cout << "problem1!" << endl;}
      }
    else if(m1torb == 2) /// we have an initial sbottom
      {
	if(m1oneortwo == 1) /// we have an initial sbottom1
	  {
	    ///cout << " initial sbottom1!" << endl;
	    capthetai = pow(cos(thetab),2);
	  }
	else if (m1oneortwo == 2) // we have an initial sbottom2
	  {
	    ///cout << " initial sbottom2!" << endl;
	    capthetai = pow(sin(thetab),2);
	  }
	else {cout << "problem2!" << endl;}
      }
    else {cout << "problem5!" << endl;}
      

    if(m3torb == 1) /// we have a final state stop
      {
	if(m3oneortwo == 1) // we have a final state stop1
	  {
	    ///cout << " final state stop1!" << endl;
	    capthetaf = pow(cos(thetat),2);
	  }
	else if (m3oneortwo ==2) /// we have a final state stop2
	  {
	    ///cout << " final state stop2!" << endl;
	    capthetaf = pow(sin(thetat),2);
	  }
	else {cout << "problem3!" << endl;}
      }
    else if(m3torb == 2) /// we have a final state sbottom
      {
	if(m3oneortwo == 1) /// we have a final state sbottom1
	  {
	    ///cout << " final state sbottom1!" << endl;
	    capthetaf = pow(cos(thetab),2);
	  }
	else if (m3oneortwo == 2) /// we have a final state sbottom2
	  {
	    /// cout << " final state sbottom2!" << endl;
	    capthetaf = pow(sin(thetab),2);
	  }
	else {cout << "problem4!" << endl;}
      }
    else {cout << "problem6!" << endl;}
    ///double temp = (pow(m1,3)/pow(m2,2));
    amplitudeW = pow(g,2)/(32*PI)*(pow(m1,3)/pow(m2,2))*pow(lambda,3)*capthetai*capthetaf;
    ///cout << "lambda= " << lambda << " g= " << g << " pow(m1,3)/pow(m2,2)= " << temp << endl;
    ///cout << "capthetai= " << capthetai << " capthetaf= " << capthetaf << " amplitudeW= " << amplitudeW << endl;
      
  }
  return amplitudeW;
}
      
double squark3amplitudedecaychargedHiggssquark3 (double m1, double m2, double m3, double g, double mWboson, double beta, double thetat, double thetab, double greekmu, double At, double Ab, double mt, double mb, int t1or2, int b1or2) {
  double amplitudeW, squareplus, squareminus, lambda, A, A11, A12, A21, A22, combo1, combo2, combo3, combo4;
  
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    combo1 = tan(beta) + 1/(tan(beta));
    combo2 = greekmu + At/(tan(beta));
    combo3 = greekmu + Ab*tan(beta);
    combo4 = (pow(mb,2)*tan(beta) + pow(mt,2)/(tan(beta))) - pow(mWboson,2)*sin(2*beta);
      
    A11 = g/(pow(2,0.5)*mWboson)*(mt*mb*combo1*sin(thetat)*sin(thetab) + mt*combo2*sin(thetat)*cos(thetab) + mb*combo3*sin(thetab)*cos(thetat) + combo4*cos(thetat)*cos(thetab));
    A12 = g/(pow(2,0.5)*mWboson)*(mt*mb*combo1*sin(thetat)*(-cos(thetab)) + mt*combo2*sin(thetat)*sin(thetab) + mb*combo3*(-cos(thetab))*cos(thetat) + combo4*cos(thetat)*sin(thetab));
    A21 = g/(pow(2,0.5)*mWboson)*(mt*mb*combo1*(-cos(thetat))*sin(thetab) + mt*combo2*(-cos(thetat))*cos(thetab) + mb*combo3*sin(thetab)*sin(thetat) + combo4*sin(thetat)*cos(thetab));
    A22 = g/(pow(2,0.5)*mWboson)*(mt*mb*combo1*(-cos(thetat))*(-cos(thetab)) + mt*combo2*-(cos(thetat))*sin(thetab) + mb*combo3*(-cos(thetab))*sin(thetat) + combo4*sin(thetat)*sin(thetab));

    if(t1or2 == 1) /// we have an initial stop1
      {
	if (b1or2 == 1) /// we have a final state sbottom1
	  {
	    A = A11;
	  }
	else if (b1or2 == 2) /// we have a final state sbottom2
	  {
	    A = A12;
	  }
      }
    if(t1or2 == 2) /// we have an initial stop2
      {
	if (b1or2 == 1) /// we have a final state sbottom1
	  {
	    A = A21;
	  }
	else if (b1or2 == 2) /// we have a final state sbottom2
	  {
	    A = A22;
	  }
      }
    
    amplitudeW = pow(A,2)*lambda/(16*PI*m1);
  }
  return amplitudeW;
  
}


      
double squark32amplitudedecayneutralHiggssquark3 (double m1, double m2, double m3, double g, double gp, double mWboson, double beta, double alpha, double thetat, double thetab, double greekmu, double At, double Ab, double mt, double mb, int torb, char phi) {
  double amplitudeW=0, squareplus, squareminus, lambda, A, B, Ah, AH, AA, Bh, BH, BA, combo1, combo2, combo3, combo4, combo5, combo6, combo7;
  ///char str1[] = "h"; char str2[] = "H"; char str3[] = "A";
  

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    combo1 = 1 - 5./3 * pow(gp/g,2);
    combo2 = -1 +1./3 * pow(gp/g,2);
    combo3 = At*cos(alpha) + greekmu*sin(alpha);
    combo4 = -At*sin(alpha) + greekmu*cos(alpha);
    combo5 = At/(tan(beta)) + greekmu;
    combo6 = -Ab*sin(alpha) - greekmu*cos(alpha);
    combo7 = Ab*cos(alpha) - greekmu*sin(alpha);
      
    Ah = g*mWboson*sin(beta+alpha)/4 * combo1*sin(2*thetat) + g*mt*cos(2*thetat)/(2*mWboson*sin(beta))*combo3;
    AH = -g*mWboson*cos(beta+alpha)/4 * combo1*sin(2*thetat) - g*mt*cos(2*thetat)/(2*mWboson*sin(beta))*combo4; /// possible minus sign issue here, both terms are same sign in susyhit -> changed second sign to - ?? whereas Tata and Baer has a signs of two terms opposite - note as it's squared anyway only relative sign between the two terms matters
    AA = g*mt*combo5/(2*mWboson);

    Bh = g*mWboson*sin(beta+alpha)/4 * combo2*sin(2*thetab) + g*mb*cos(2*thetab)/(2*mWboson*cos(beta))*combo6;
    BH = -g*mWboson*cos(beta+alpha)/4 * combo2*sin(2*thetab) + g*mb*cos(2*thetab)/(2*mWboson*cos(beta))*combo7;
    BA = g*mb*(Ab*tan(beta)+greekmu)/(2*mWboson);

    if(phi == 'h') {
      A=Ah;
      B=Bh;
      ///cout << "DECAY to h" << endl;
    }
      
    else if (phi == 'H') {
      A=AH;
      B=BH;
      ///cout << "DECAY to H: " << "AH= " << AH << " BH= " << BH << endl;
    }

    else if (phi == 'A') {
      A=AA;
      B=BA;
      ///cout << "DECAY to A" << endl;
    }
      
    else { cout << "char compare problem ... phi must be one of h, H, or A" << endl; }
    
    if (torb == 1) ///stop2 decay
      {
	amplitudeW = pow(A,2)*lambda/(16*PI*m1);
      }
    
    else if (torb == 2) ///sbottom2 decay
      {
	amplitudeW = pow(B,2)*lambda/(16*PI*m1);
      }
  }
  return amplitudeW;
}

	     
double squark32amplitudedecaysquark3Zboson (double m1, double m2, double m3, double g, double gp, double theta) {
  double amplitudeW, squareplus, squareminus, lambda, angular, costhetaW;  

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    angular = pow(cos(theta)*sin(theta),2);
    costhetaW = g/pow((pow(g,2)+pow(gp,2)),0.5);
    
    amplitudeW = pow(g,2)*pow(m1,3)/(64*PI*pow(m3*costhetaW,2))*pow(lambda,3)*angular;
  }
  return amplitudeW;
}

double sleptonamplitudedecayleptonneutralino (double m1, double m2, double m3, double g, double gp, DoubleMatrix mixNeut, char LorR, int neutralino) {
  double amplitudeW, squareplus, squareminus, squareratio, lambda, A, B, C;  

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    A = -1/(pow(2,0.5)) * (g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1));
    B = -pow(2,0.5)*gp*mixNeut(neutralino,1);
    if(LorR == 'L') {
      C=A;
    }
      
    else if (LorR == 'R') {
      C=B;
    }
      
    else { cout << "Initial slepton must be LH 'L' or RH 'R' " << endl; }
    
    amplitudeW = pow(C,2)*m1*fabs(squareratio)/(16*PI) * lambda;
  }
  return amplitudeW;
}


double sneutrinoamplitudedecayneutrinoneutralino (double m1, double m2, double m3, double g, double gp, DoubleMatrix mixNeut, int neutralino) {
  double amplitudeW, squareplus, squareminus, squareratio, lambda, A;  

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    A = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) - gp*mixNeut(neutralino,1));

    amplitudeW = pow(A,2)*m1*squareratio*lambda/(16*PI); /// note here as m2=0 then lambda and squareratio each reduce to (1-pow(m3/m1,2)) 
      }
  return amplitudeW;
}


double sleptonamplitudedecaychargino (double m1, double m2, double m3, double g, double theta, int chargino) ///for both sleptonL decays to charginos + neutrinos and for sneutrino decays to lepton + charginos - just change theta from thetaL in first case to thetaR in second case
{
  double amplitudeW, squareplus, squareminus, squareratio, lambda, trigtheta=0;  
  
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2);
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    if (chargino == 1) {
      trigtheta = sin(theta);
    }
    else if (chargino ==2) {
      trigtheta = cos(theta);
    }
    else {
      cout << "Chargino must be a chargino1 or a chargino2, hence int chargino 1 or 2 only allowed!" << endl;
    }	    
    amplitudeW = pow(g*trigtheta,2)*m1*squareratio*lambda/(16*PI); /// note in the slepton decay to neutrinos case m2 is zero so lambda reduces to squareratio - giving squareratio squared
      }
  return amplitudeW;
}

      
double stauamplitudedecaytauneutralino (double m1, double m2, double m3, double g, double gp, double mWboson, DoubleMatrix mixNeut, double theta, double beta, int oneortwo, int neutralino) {
  double amplitudeW, squareplus, squareminus, lambda, ftau, alphatilda=0, betatilda=0, a, b;  

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    ///squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2);
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    ftau = g*m2/(pow(2,0.5)*mWboson*cos(beta));
    if (oneortwo == 1) /// we have a stau1 decaying
      {
	alphatilda = 1/(pow(2,0.5))*sin(theta)*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1)) + ftau*mixNeut(neutralino,3)*cos(theta); /// ignored (-i)^thetai factor in front
	betatilda =  pow(2,0.5)*gp*mixNeut(neutralino,1)*-cos(theta) + ftau*mixNeut(neutralino,3)*sin(theta); ///ignored (i)^thetai factor in front/// ignored (i)^thetai factor in front
	///cout << "FIRST LOOP" << endl;
      }
    else if (oneortwo ==2) /// we have a stau2 decaying
      {
	alphatilda = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*-cos(theta) + ftau*mixNeut(neutralino,3)*sin(theta); /// ignored (-i)^thetai factor in front
	betatilda = pow(2,0.5)*gp*mixNeut(neutralino,1)*sin(theta) + ftau*mixNeut(neutralino,3)*cos(theta); /// ignored (i)^thetai factor in front
	///cout << "SECOND LOOP" << endl;
      }
    else {
      cout << "Stau must be a stau1 or a stau2, hence for int oneortwo 1 or 2 only allowed!" << endl;
    }
    a = 0.5*(alphatilda + betatilda);
    b = 0.5*(betatilda - alphatilda);
    amplitudeW = m1*lambda/(8*PI)*(pow(a,2)*squareplus + pow(b,2)*squareminus);
    ///amplitudeW = m1*lambda/(16*PI)*((pow(alphatilda,2)+pow(betatilda,2))*squareratio - 4*alphatilda*betatilda*m2*m3/pow(m1,2)); // same as above just rearranged
    ///cout << "alphatilda/g= " << alphatilda/g << " betatilda/g= " << betatilda/g << " lambda= " << lambda << endl; 
  }
  return amplitudeW;
}

double stausneutrinoamplitudedecaytauneutrinoneutralino (double m1, double m2, double m3, double g, double gp, DoubleMatrix mixNeut, int neutralino) {
  double amplitudeW, squareplus, squareminus, squareratio, lambda, A;  

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2);
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    A = 1/(pow(2,0.5))*(g*-mixNeut(neutralino,2) + gp*mixNeut(neutralino,1));
    amplitudeW = m1/(16*PI)*pow(A,2)*lambda*squareratio; /// note lambda and squareratio reduce to same thing here as m2 = 0
  }
  return amplitudeW;
}

double stauamplitudedecaynutauchargino (double m1, double m2, double m3, double g, double mWboson, double theta, double thetaL, double beta, double mtau, int oneortwo, int chargino) {
  double amplitudeW, squareplus, squareminus, squareratio, lambda, ftau, A=0, B=0, mixingpart;  
  
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2);
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    ftau = g*mtau/(pow(2,0.5)*mWboson*cos(beta));
      
      if (chargino ==1)	{
	A = g*sin(thetaL);
	B = -ftau*cos(thetaL);
	
      }

      else if(chargino ==2) {
	A = g*cos(thetaL);
	B = ftau*sin(thetaL);
      }
            
      else {cout << "Chargino must be a chargino1 or chargino2 - problem!" << endl;}
      
      if(oneortwo == 1) { 
	mixingpart = -A*sin(theta) + B*cos(theta);
      }
      else if (oneortwo == 2) {
	mixingpart = A*cos(theta) + B*sin(theta);
      }
      else {cout << "Stau must be a stau1 or stau2 - problem!" << endl;}
            
      amplitudeW = pow(mixingpart,2)*m1*lambda*squareratio/(16*PI); ///again lambda and squareratio reduce to same thing as m2 = 0
    }
  return amplitudeW;
}


double stausneutrinoamplitudedecaytauchargino (double m1, double m2, double m3, double g, double mWboson, double beta, double thetaL, double thetaR, int chargino) {
  double amplitudeW, squareplus, squareminus, squareratio, lambda, ftau, A, B, sumsquare;  

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2);
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    ftau = g*m2/(pow(2,0.5)*mWboson*cos(beta)); ///as m2 is mtau which is what we need to calculate ftau
    
    if(chargino==1) {
      A = g*sin(thetaR);
      B = -ftau*cos(thetaL);
    }
    else if (chargino==2) {
      A = g*cos(thetaR);
      B = ftau*sin(thetaL);
    }
    else {cout << "Chargino must be a chargino1 or chargino2 - problem!" << endl;}
    
    sumsquare = pow(A,2) + pow(B,2);
    ///cout << "A= " << A/g << " B= " << B/g << endl; 
    amplitudeW = m1*lambda/(16*PI)*(sumsquare*squareratio + 4*m2*m3/(pow(m1,2))*B*A);
  }
  return amplitudeW;
}


double stauamplitudedecaysnustauHminus (double m1, double m2, double m3, double g, double mWboson, double beta, double thetatau, double mtau, double greekmu, double Atau, int oneortwo) ///Also does decay mode snustau to Hplus and stau1/2 just with m1, m2 and m3 permuted.

{
  double amplitudeW, squareplus, squareminus, lambda, A, combo1, combo2;  

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    ///squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2);
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    
    combo1 = pow(mtau,2)*tan(beta) - pow(mWboson,2)*sin(2*beta);
    combo2 = mtau*(greekmu+Atau*tan(beta));

      if (oneortwo == 1) {
	A = g/(pow(2,0.5)*mWboson)*(combo1*sin(thetatau) - combo2*cos(thetatau));
      }
      else if (oneortwo == 2) {
	A = g/(pow(2,0.5)*mWboson)*(-combo1*cos(thetatau) - sin(thetatau)*combo2);
      }
      else {cout << "Stau must be a stau1 or stau2 - problem!" << endl;}
      
      amplitudeW = pow(A,2)*lambda/(16*PI*m1);
  }
  return amplitudeW;
}


double stauamplitudedecaysnustauWboson (double m1, double m2, double m3, double g, double thetatau, int oneortwo) ///m3 must be mw here
  
{
  double amplitudeW, squareplus, squareminus, lambda, mixangle=0;  

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    ///squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2);
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    
    if (oneortwo == 1) {
      mixangle = sin(thetatau);
    }
      else if (oneortwo == 2) {
	mixangle = cos(thetatau);
      }
      else { cout << "Stau must be a stau1 or stau2 - problem!" << endl;}
    
    amplitudeW = pow(g*mixangle,2)*pow(m1,3)/(32*PI*pow(m3,2))*pow(lambda,3);
  }
  return amplitudeW;
}

double stau2amplitudedecaystau1Zboson (double m1, double m2, double m3, double g, double gp, double thetatau) ///m3 must be mz here
  
{
  double amplitudeW, squareplus, squareminus, lambda, mixangle, costhetaW;  

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
    }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    ///squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2);
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    mixangle = pow(cos(thetatau)*sin(thetatau),2);
    costhetaW = g/(pow(pow(g,2)+pow(gp,2),0.5));
    ///cout << "costhetaW= " << costhetaW << endl;
    
    amplitudeW = pow(g,2)*mixangle*pow(m1,3)*pow(lambda,3)/(64*PI*pow(m3*costhetaW,2));
  }
  return amplitudeW;
}

double stau2amplitudedecaystau1phi (double m1, double m2, double m3, double g, double gp, double thetatau, double beta, double alpha, double mWboson, double mtau, double greekmu, double Atau, char phi) {
  double amplitudeW, squareplus, squareminus, lambda, combo1, combo2, combo3, combo4, combo5, combo6, Acoeff;  

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    ///squareratio = 1 - pow(m3/m1,2) - pow(m2/m1,2);
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    combo1 = -1 +3*pow(gp/g,2); /// is just -1 + 3*pow(tanthetaW,2)
    combo2 = g*mWboson/4;
    combo3 = g*mtau/(2*mWboson);
    combo4 = greekmu*cos(alpha) + Atau*sin(alpha);
    combo5 = -greekmu*sin(alpha) + Atau*cos(alpha);
    combo6 = greekmu + Atau*tan(beta);

    if (phi == 'h') {
      Acoeff = -combo2*sin(beta+alpha)*sin(2*thetatau)*combo1 + combo3/(cos(beta))*cos(2*thetatau)*combo4;
    }
    else if (phi == 'H') {
      Acoeff = combo2*cos(beta+alpha)*sin(2*thetatau)*combo1 - combo3/(cos(beta))*cos(2*thetatau)*combo5;
    }
    else if (phi == 'A') {
      Acoeff = combo3*combo6;
    }
    else { cout << "Phi can only be an h, H or A - problem!" << endl; }
    
    amplitudeW = pow(Acoeff,2)*lambda/(16*PI*m1);
  }
  return amplitudeW;
}


double charginoamplitudedecayquarksquarkL (double m1, double m2, double m3, double g, double theta, int chargino) ///quark mass is m2

{
  double amplitudeW, squareplus, squareminus, alteredsquareratio, lambda, scriptA;

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    alteredsquareratio = 1 - pow(m3/m1,2) + pow(m2/m1,2); /// altered as now + quarkmass/initialmass ^2 not minus
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    
    if (chargino == 1) /// chargino1 decaying
      {
	scriptA = g*sin(theta); /// theta is thetaL if sdownL and thetaR if supL
      }
    else if (chargino == 2) ///chargino2 decaying
      {
	scriptA = g*cos(theta); /// theta is thetaL if sdownL and thetaR if supL
      }
    else { cout << "Chargino must be a chargino1 or chargino2 - problem!" << endl;}
    cout << setprecision(8);
    cout << "A = " << scriptA << " for chargino" << chargino << endl;
    amplitudeW = 3*m1*lambda/(32*PI)*(pow(scriptA,2)*alteredsquareratio);
  }
  return amplitudeW;
}

double charginoamplitudedecayquarksquarkmix (double m1, double m2, double m3, double g, double theta, double thetaL, double thetaR, double beta, double runmt, double runmb, double mWboson, int chargino, int upordowntypesquark, int oneortwo) ///quark mass is m2

{
  double amplitudeW, squareplus, squareminus, alteredsquareratio, lambda, combo1=0, combo2=0;
  ///double fu, fd, B, Bprime, scriptA, C=0;
  DoubleVector squarkmixcharginocouplings (double g, double theta, double beta, double gammaL, double gammaR, double runmt, double runmb, double mWboson, int torb);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    //    cout << "Final product states heavier than initial states - decay not allowed" << endl;
    //    cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    alteredsquareratio = 1 - pow(m3/m1,2) + pow(m2/m1,2); ///altered as now + quarkmass/initialmass ^2 not minus
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    /// fu = g*runmt/(pow(2,0.5)*mWboson*sin(beta));
    /// fd = g*runmb/(pow(2,0.5)*mWboson*cos(beta));
    
      
    /// if (chargino == 1) /// chargino1 decaying
    ///  {
    /// 	B = fu*cos(thetaR);
    /// 	Bprime = -fd*cos(thetaL);
    /// 	///cout << "Chargino 1, ";
	
    /// 	if (oneortwo == 1) /// decays into a stop1 or sbottom1
    /// 	  {
	    
    /// 	    if (upordowntypesquark == 1) /// decay to stop1 
    /// 	      {
    /// 		scriptA = g*sin(thetaR)*cos(theta) - B*sin(theta); /// theta will be thetat if get into this loop
    /// 		C = Bprime;
    /// 		///cout << "Stop1" << endl;
    /// 	      }
	    
    /// 	    else if (upordowntypesquark == 2) /// decay to sbottom1 
    /// 	      {
    /// 		scriptA = -g*sin(thetaL)*cos(theta) - Bprime*sin(theta); /// theta will be thetab if get into this loop
    /// 		  C = B;
    /// 		  ///cout << "Sbottom1" << endl;
    /// 	      }
    /// 	    else { cout << "Must decay into a stop or sbottom, see upordowntypesquark - problem!" << endl; }
	    
    /// 	    combo1 = pow(scriptA,2) + pow(C*cos(theta),2);
    /// 	    combo2 = 4*scriptA*C*cos(theta);
	    
    /// 	  }

    /// 	else if (oneortwo ==2) ///decays into a stop2 or sbottom2
    /// 	  {
	         
    /// 	    if (upordowntypesquark == 1) /// decay to stop2 
    /// 	      {
    /// 		scriptA = g*sin(thetaR)*sin(theta) + B*cos(theta); /// theta will be thetat if get into this loop
    /// 		  C = Bprime;
    /// 		  ///cout << "Stop2" << endl;
    /// 		}
	    
    /// 	      else if (upordowntypesquark == 2) /// decay to sbottom2 
    /// 		{
    /// 		  scriptA = -g*sin(thetaL)*sin(theta) + Bprime*cos(theta); /// theta will be thetab if get into this loop
    /// 		    C = B;
    /// 		    ///cout << "Sbottom2" << endl;
    /// 		}
	      
    /// 	      else { cout << "Must decay into a stop or sbottom, see upordowntypesquark - problem!" << endl; }

    /// 	    combo1 = pow(scriptA,2) +pow(C*sin(theta),2);
    /// 	    combo2 = 4*scriptA*C*sin(theta);
    /// 	  }
    ///  }
    /// else if (chargino == 2 ) ///chargino2 decaying
    ///  {
    /// 	B = -fu*sin(thetaR);
    /// 	Bprime = fd*sin(thetaL);
    /// 	///cout << "Chargino2, ";
	
    /// 	if (oneortwo == 1) /// decays into a stop1 or sbottom1
    /// 	  {
	    
    /// 	    if (upordowntypesquark == 1) /// decay to stop1 
    /// 	      {
    /// 		scriptA = g*cos(thetaR)*cos(theta) - B*sin(theta); /// theta will be thetat if get into this loop
    ///		C = Bprime;
    /// 		///cout << "Stop1" << endl;
    /// 	      }
	    
    /// 	    else if (upordowntypesquark == 2) /// decay to sbottom1 
    /// 	      {
    /// 		scriptA = -g*cos(thetaL)*cos(theta) - Bprime*sin(theta); /// theta will be thetab if get into this loop
    /// 		///scriptA = 1.238;
    /// 		C = B;
    /// 		/// cout << "Sbottom1" << endl;
    /// 	      }
    /// 	    else { cout << "Must decay into a stop or sbottom, see upordowntypesquark - problem!" << endl; }
	    
    /// 	    combo1 = pow(scriptA,2) + pow(C*cos(theta),2);
    /// 	    combo2 = 4*scriptA*C*cos(theta);
    /// 	  }
    /// 	else if (oneortwo == 2) /// decays into a stop2 or sbottom2
    /// 	  {
    /// 	    if (upordowntypesquark == 1) /// decay to stop2
    /// 	      {
    /// 		scriptA = g*cos(thetaR)*sin(theta) + B*cos(theta); /// theta will be thetat if get into this loop
    /// 		C = Bprime;
    /// 		///cout << "Stop2" << endl;
    /// 	      }
	    
    /// 	    else if (upordowntypesquark == 2) /// decay to sbottom2
    /// 	      {
    /// 		scriptA = -g*cos(thetaL)*sin(theta) + Bprime*cos(theta); /// theta will be thetab if get into this loop
    /// 		C = B;
    /// 		///cout << "Sbottom2" << endl;
    /// 	      }
    /// 	    else { cout << "Must decay into a stop or sbottom, see upordowntypesquark - problem!" << endl; }
	    
    /// 	    combo1 = pow(scriptA,2) +pow(C*sin(theta),2);
    /// 	    combo2 = 4*scriptA*C*sin(theta);
	    
    /// 	  }     

    /// 	else { cout << "Must decay into a squark1 or squark2 - problem!" << endl;}
    /// }
      
    /// else { cout << "Chargino must be a chargino1 or chargino2 - problem!" << endl;}
    /// ///cout << "combo1= " << combo1 << " combo2 = " << combo2 << endl;
    /// ///cout << "first term= " << 3*m1*lambda/(32*PI)*combo1*alteredsquareratio << endl;
    /// ///cout << "second term= " << 3*m1*lambda/(32*PI)*combo2*m2/m1 << endl;
    /// ///cout << "scriptA = " << scriptA << " Bcos(theta) = " << B*sin(theta) << endl;
    
    int torb = upordowntypesquark;

    if (chargino == 1) {
      if (oneortwo == 1) {
    	combo1 = squarkmixcharginocouplings (g, theta, beta, thetaL, thetaR, runmt, runmb, mWboson, torb)(1);
    	combo2 = -squarkmixcharginocouplings (g, theta, beta, thetaL, thetaR, runmt, runmb, mWboson, torb)(2);
      }
      else if (oneortwo == 2) {
    	combo1 = squarkmixcharginocouplings (g, theta, beta, thetaL, thetaR, runmt, runmb, mWboson, torb)(5);
    	combo2 = -squarkmixcharginocouplings (g, theta, beta, thetaL, thetaR, runmt, runmb, mWboson, torb)(6);
      }
    }
    else if (chargino == 2) {
      if (oneortwo == 1) {
    	combo1 = squarkmixcharginocouplings (g, theta, beta, thetaL, thetaR, runmt, runmb, mWboson, torb)(3);
    	combo2 = -squarkmixcharginocouplings (g, theta, beta, thetaL, thetaR, runmt, runmb, mWboson, torb)(4);
      }
      else if (oneortwo == 2) {
    	combo1 = squarkmixcharginocouplings (g, theta, beta, thetaL, thetaR, runmt, runmb, mWboson, torb)(7);
    	combo2 = -squarkmixcharginocouplings (g, theta, beta, thetaL, thetaR, runmt, runmb, mWboson, torb)(8);
      }
    }
    
    ///cout << "chargino" << chargino << " to squark" << oneortwo << " type " << upordowntypesquark << endl;
    ///cout << "combo1 = "<< combo1 << " combo2 = " << combo2 << endl;
    amplitudeW = 3*m1*lambda/(32*PI)*(combo1*alteredsquareratio + combo2*m2/m1);
    
  }
  return amplitudeW;
}


double charginoamplitudedecayleptonsleptonL (double m1, double m2, double m3, double g, double thetaLorR, int chargino) ///lepton mass is m2, use thetaR for decays to sneutrinos and leptons, use thetaL for decays to sleptons neutrinos

{
  double amplitudeW, squareplus, squareminus, alteredsquareratio, lambda, A=0;

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    alteredsquareratio = 1 - pow(m3/m1,2) + pow(m2/m1,2); /// altered as now + quarkmass/initialmass ^2 not minus
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
      
    if (chargino == 1) { 
      A = -g*sin(thetaLorR);
    }
      else if (chargino == 2) {
	A = -g*cos(thetaLorR);
      }

    amplitudeW = m1*lambda/(32*PI)*pow(A,2)*alteredsquareratio;
  }
  return amplitudeW;
}


double charginoamplitudedecaysnutautau (double m1, double m2, double m3, double g, double thetaL, double thetaR, double beta, double mWboson, int chargino) ///m2 must be tau mass

{
  double amplitudeW, squareplus, squareminus, alteredsquareratio, lambda, ftau, A=0, Bprimeprime=0;

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    alteredsquareratio = 1 - pow(m3/m1,2) + pow(m2/m1,2); /// altered as now + quarkmass/initialmass ^2 not minus
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);	 
    ftau = g*m2/(pow(2,0.5)*mWboson*cos(beta));
    
    if (chargino == 1) {
      A = g*sin(thetaR);
      Bprimeprime = - ftau*cos(thetaL);
    }
    else if (chargino == 2) {
      A = g*cos(thetaR);
      Bprimeprime = ftau*sin(thetaL);
    }
    amplitudeW = m1*lambda/(32*PI)*((pow(A,2)+pow(Bprimeprime,2))*alteredsquareratio + 4*A*Bprimeprime*m2/m1);
  }
  return amplitudeW;
}
      

double charginoamplitudedecaystaunutau (double m1, double m2, double m3, double g, double thetaL, double thetaR, double thetatau, double beta, double mWboson, double mtau, int oneortwo, int chargino) ///m2 must be nutau mass (i.e. 0)

{
  double amplitudeW, squareplus, squareminus, alteredsquareratio, lambda, ftau, A=0, Bprimeprime=0, scriptA=0;

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    alteredsquareratio = 1 - pow(m3/m1,2) + pow(m2/m1,2); /// altered as now + quarkmass/initialmass ^2 not minus
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);	 /// reduces to 1 - pow(m3/m1,2) as m2 = 0
      ftau = g*mtau/(pow(2,0.5)*mWboson*cos(beta));
      
      if (chargino == 1) {
	A = -g*sin(thetaL);
	Bprimeprime = -ftau*cos(thetaL);
	
	if (oneortwo == 1) /// decaying to a stau1
	  {
	    scriptA = A*sin(thetatau) + Bprimeprime*cos(thetatau);
	  }
	else if (oneortwo == 2) /// decaying to a stau2
	  {
	    scriptA = -A*cos(thetatau) + Bprimeprime*sin(thetatau);
	  }
      }
      else if (chargino == 2) {
	A = -g*cos(thetaL);
	Bprimeprime = ftau*sin(thetaL);
	
	if (oneortwo == 1) /// decaying to a stau1
	  {
	    scriptA = A*sin(thetatau) + Bprimeprime*cos(thetatau);
	  }
	else if (oneortwo == 2) /// decaying to a stau2
	  {
	    scriptA= -A*cos(thetatau) + Bprimeprime*sin(thetatau);
	  }
      }
      
      amplitudeW = pow(scriptA,2)*m1*lambda*alteredsquareratio/(32*PI);
  }
  return amplitudeW;
}



double charginoamplitudedecayWbosonneutralino (double m1, double m2, double m3, double g, double thetaL, double thetaR, DoubleMatrix mixNeut, int chargino, int neutralino) ///m2 must be Wboson mass

{
  double amplitudeW, squareplus, squareminus, squarecombo1, squarecombo2, lambda, X=0, Y=0;

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    squarecombo1 = pow(m1,2) + pow(m3,2) - pow(m2,2);
    squarecombo2 = (pow(pow(m1,2) - pow(m3,2),2) - pow(m2,4))/pow(m2,2);
      
    if (chargino == 1) {
      X = 0.5*((cos(thetaR)*mixNeut(neutralino,4)/(pow(2,0.5)) - sin(thetaR)*mixNeut(neutralino,2)) - cos(thetaL)*mixNeut(neutralino,3)/(pow(2,0.5)) - sin(thetaL)*mixNeut(neutralino,2));
      Y = 0.5*(-(cos(thetaR)*mixNeut(neutralino,4)/(pow(2,0.5)) - sin(thetaR)*mixNeut(neutralino,2)) - cos(thetaL)*mixNeut(neutralino,3)/(pow(2,0.5)) - sin(thetaL)*mixNeut(neutralino,2));
    }
      
    else if (chargino == 2) {
      X = 0.5*((-sin(thetaR)*mixNeut(neutralino,4)/(pow(2,0.5)) - cos(thetaR)*mixNeut(neutralino,2)) + sin(thetaL)*mixNeut(neutralino,3)/(pow(2,0.5)) - cos(thetaL)*mixNeut(neutralino,2));
      Y = 0.5*((sin(thetaR)*mixNeut(neutralino,4)/(pow(2,0.5)) + cos(thetaR)*mixNeut(neutralino,2)) + sin(thetaL)*mixNeut(neutralino,3)/(pow(2,0.5)) - cos(thetaL)*mixNeut(neutralino,2));
    }

    amplitudeW = pow(g,2)/(16*PI*fabs(m1))*lambda*((pow(X,2)+pow(Y,2))*(squarecombo1+squarecombo2) - 6*(pow(X,2) - pow(Y,2))*(m1)*(m3));
  }
  return amplitudeW;
}


double charginoamplitudedecayHminusneutralino (double m1, double m2, double m3, double g, double gp, double thetaL, double thetaR, double beta, DoubleMatrix mixNeut, int chargino, int neutralino) ///m2 must be Hminus mass

{
  double amplitudeW, squareplus, squareminus, lambda, squarecombo1, A1=0, A2=0, A3=0, A4=0, a=0, b=0;

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    squarecombo1 = pow(m1,2) + pow(m3,2) - pow(m2,2);
    
    A1 = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*sin(thetaR) - g*mixNeut(neutralino,4)*cos(thetaR);
    A2 = -1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*cos(thetaR) - g*mixNeut(neutralino,4)*sin(thetaR);
    A3 = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*sin(thetaL) + g*mixNeut(neutralino,3)*cos(thetaL);
    A4 = -1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*cos(thetaL) + g*mixNeut(neutralino,3)*sin(thetaL);
    
    if (chargino == 1) {
      a = 0.5*(-cos(beta)*A2 + sin(beta)*A4);
      b = 0.5*(-cos(beta)*A2 - sin(beta)*A4);
    }
      
    else if (chargino == 2) {
      a = 0.5*(-cos(beta)*A1 + sin(beta)*A3);
      b = 0.5*(-cos(beta)*A1 - sin(beta)*A3);
    }

    amplitudeW = lambda/(16*PI*fabs(m1))*((pow(a,2)+pow(b,2))*squarecombo1 + 2*(pow(a,2) - pow(b,2))*m1*m3);
  }
  return amplitudeW;
}



double chargino2amplitudedecaychargino1Zboson (double m1, double m2, double m3, double g, double gp, double thetaL, double thetaR) ///m2 must be Zboson mass

{
  double amplitudeW, squareplus, squareminus, lambda, squarecombo1, squarecombo2, matelem=0, x=0, y=0, e;

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    squarecombo1 = pow(m1,2) + pow(m3,2) - pow(m2,2);
    squarecombo2 = (pow(pow(m1,2) - pow(m3,2),2) - pow(m2,4))/pow(m2,2); 
    e = g*gp/(pow(pow(g,2)+pow(gp,2),0.5));
      
    x = 0.5*(sin(thetaL)*cos(thetaL) - sin(thetaR)*cos(thetaR));
    y = 0.5*(sin(thetaL)*cos(thetaL) + sin(thetaR)*cos(thetaR));
    matelem = (pow(x,2) + pow(y,2))*(squarecombo1 + squarecombo2) + 6*(pow(x,2) - pow(y,2))*m1*m3;
    
    amplitudeW = pow(e,2)*lambda/(64*PI*m1)*pow(g/gp + gp/g,2)*matelem;
  }
  return amplitudeW;
}


double chargino2amplitudedecaychargino1neutHiggs (double m1, double m2, double m3, double g, double gp, double thetaL, double thetaR, double beta, double alpha, char phi) ///m2 must be neutral Higgs mass
  
{
  double amplitudeW, squareplus, squareminus, lambda, squarecombo1, matelem=0, S=0, P=0;
  
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    squarecombo1 = pow(m1,2) - pow(m2,2) + pow(m3,2);
    
    if(phi == 'h') {
      S= 0.5*(-sin(thetaR)*sin(thetaL)*sin(alpha) - cos(thetaL)*cos(thetaR)*cos(alpha) + sin(thetaL)*sin(thetaR)*cos(alpha) + cos(thetaL)*cos(thetaR)*sin(alpha));
      P = 0.5*(sin(thetaR)*sin(thetaL)*sin(alpha) + cos(thetaL)*cos(thetaR)*cos(alpha) + sin(thetaL)*sin(thetaR)*cos(alpha) + cos(thetaL)*cos(thetaR)*sin(alpha));
      /// cout << "DECAY to h" << endl;
	}
    
    else if(phi == 'H') {
      S= 0.5*(sin(thetaR)*sin(thetaL)*cos(alpha) - cos(thetaL)*cos(thetaR)*sin(alpha) + sin(thetaL)*sin(thetaR)*sin(alpha) - cos(thetaL)*cos(thetaR)*cos(alpha));
      P = 0.5*(-sin(thetaR)*sin(thetaL)*cos(alpha) + cos(thetaL)*cos(thetaR)*sin(alpha) + sin(thetaL)*sin(thetaR)*sin(alpha) - cos(thetaL)*cos(thetaR)*cos(alpha));
      /// cout << "DECAY to H" << endl;
    }
      
      else if (phi == 'A') {
	S = 0.5*(sin(thetaR)*sin(thetaL)*sin(beta) - cos(thetaL)*cos(thetaR)*cos(beta) - sin(thetaL)*sin(thetaR)*cos(beta) + cos(thetaL)*cos(thetaR)*sin(beta));
	P = 0.5*(-sin(thetaR)*sin(thetaL)*sin(beta) + cos(thetaL)*cos(thetaR)*cos(beta) - sin(thetaL)*sin(thetaR)*cos(beta) + cos(thetaL)*cos(thetaR)*sin(beta));
	///cout << "DECAY to A" << endl;
      }
    
      else { cout << "char compare problem ... phi must be one of h, H, or A" << endl; }
    
    matelem = (pow(S,2) + pow(P,2))*squarecombo1 + 2*(pow(S,2)-pow(P,2))*m1*m3;

    amplitudeW = pow(g,2)*lambda/(32*PI*m1)*matelem;
  }
  return amplitudeW;
}


double neutralinoamplitudedecayquarksquarkLorR (double m1, double m2, double m3, double g, double gp, DoubleMatrix mixNeut, int uordtype , char LorR, int neutralino) ///m2 must be quark mass

{
  double amplitudeW, squareplus, squareminus, lambda, alteredsquareratio, A=0, B=0, C=0;

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    alteredsquareratio = 1 + pow(m2/m1,2) - pow(m3/m1,2);
    
    if (uordtype == 1) /// up type squark (i.e. u squark or c squark)
      {
	A = 1/(pow(2,0.5))*(-g*mixNeut(neutralino,2) - gp/3*mixNeut(neutralino,1));
	B = -4/(3*pow(2,0.5))*gp*mixNeut(neutralino,1);
      }
    
    else if (uordtype == 2) /// down type squark (i.e. d squark or s squark)
      {
	A = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) - gp/3*mixNeut(neutralino,1));
	B = 2/(3*pow(2,0.5))*gp*mixNeut(neutralino,1);
      }
      
    if(LorR == 'L') /// so get wino and zino couplings as LH squark
      {
	C = A;
      }
    
    else if (LorR == 'R') /// so get only Zino couplings as RH
      {
	C = B;
      }
    
    amplitudeW = 3*pow(C,2)*fabs(m1)*lambda/(32*PI)*alteredsquareratio;
  }
  return amplitudeW;
}

	  

double neutralinoamplitudedecayleptonsleptonLorR (double m1, double m2, double m3, double g, double gp, DoubleMatrix mixNeut, char LorR, int neutralino) ///m2 must be lepton mass
  
{
  double amplitudeW, squareplus, squareminus, lambda, alteredsquareratio, A=0, B=0, C=0;
    
  
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    alteredsquareratio = 1 + pow(m2/m1,2) - pow(m3/m1,2);
    
    A = -1/(pow(2,0.5)) * (g*-mixNeut(neutralino,2) + gp*-mixNeut(neutralino,1));
    B = pow(2,0.5)*gp*mixNeut(neutralino,1);
    
    if(LorR == 'L' ) /// so get wino and zino couplings as LH slepton
      {
	C = A;
      }
    
    else if (LorR == 'R') /// so get only Zino couplings as RH
      {
	C = B;
      }      
    ///cout << "g = "<< g << " gp = " << gp << endl;
    amplitudeW = pow(C,2)*fabs(m1)*lambda*alteredsquareratio/(32*PI);
  }
  return amplitudeW;
}



double neutralinoamplitudedecayneutrinosneutrinoL (double m1, double m2, double m3, double g, double gp, DoubleMatrix mixNeut, int neutralino) ///m2 must be neutrino mass (i.e. 0)

{
  double amplitudeW, squareplus, squareminus, lambda, alteredsquareratio, A=0;
    

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    ///cout << "This is because m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    alteredsquareratio = 1 + pow(m2/m1,2) - pow(m3/m1,2);
    
    A = 1/(pow(2,0.5)) * (g*-mixNeut(neutralino,2) + gp*mixNeut(neutralino,1));
    
    amplitudeW = pow(A,2)*fabs(m1)*lambda*alteredsquareratio/(32*PI);
  }
  return amplitudeW;
}




double neutralinoamplitudedecaysquark3quarkmix (double m1, double m2, double m3, double mWboson, double theta, double beta, DoubleMatrix mixNeut, double g, double gp, double runmq, int squark , int oneortwo,  int neutralino) /// m2 must be quark mass
{
  double amplitudeW, squareplus, squareminus, masscombo1, masscombo2, lambda, fq=0, alphatilda=0, betatilda=0, a=0, b=0;

  //  cout << "masses: " << m1 << " " << m2 << " " << m3 << endl;

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    ///squareratio = 1 - pow(m2/m1,2) - pow(m3/m1,2); ///not used
    lambda = pow(squareplus*squareminus,0.5);
    masscombo1 = pow(1+m2/(m1),2) - pow(m3/m1,2);
    masscombo2 = pow(1-m2/(m1),2) - pow(m3/m1,2);      
    
    
    if (squark == 1) /// we have stops
      {
	fq = g*runmq/(pow(2,0.5)*mWboson*sin(beta));
	if (oneortwo == 1) /// we have stop1s
	  {
	    alphatilda = (cos(theta)*1/(pow(2,0.5))*(-g*mixNeut(neutralino,2) - gp/3*mixNeut(neutralino,1)) - fq*sin(theta)*mixNeut(neutralino,4)); /// this is just simpler (rearranged) form of atopr(1,i) from susyhit *g
	    betatilda = (4/(3*pow(2,0.5))*gp*mixNeut(neutralino,1)*sin(theta) - fq*mixNeut(neutralino,4)*cos(theta)); /// this is just simpler (rearranged) form of btopr(1,i) from susyhit * g
	  }
	
	else if (oneortwo == 2) /// we have stop2s
	  {
	    alphatilda = (sin(theta)*1/(pow(2,0.5))*(-mixNeut(neutralino,1)*gp/3 - mixNeut(neutralino,2)*g) + cos(theta)*fq*mixNeut(neutralino,4)); /// again simplified form of atopr(2,i) * g from susyhit
	    betatilda = 4/(3*pow(2,0.5))*cos(theta)*-mixNeut(neutralino,1)*gp - fq*sin(theta)*mixNeut(neutralino,4); /// again simplified form of btopr(2,i) * g from susyhit
	  }
	
	else { cout << "problem: stop must be stop1 or stop2" << endl; }
      }
    
    else if ( squark ==2) /// we have sbottoms
      {
	///runmq = 2.37728061;
	fq = g*runmq/(pow(2,0.5)*mWboson*cos(beta));
	///fq = 0.13374501;
	
	if ( oneortwo == 1) /// we have sbottom1s
	  {
	    alphatilda = (1/pow(2,0.5))*cos(theta)*(-mixNeut(neutralino,1)*gp/3 + mixNeut(neutralino,2)*g) - sin(theta)*mixNeut(neutralino,3)*fq; /// just simplified form of abot(1,i) * g from susyhit
	    betatilda = sin(theta)*2/(3*pow(2,0.5))*(-mixNeut(neutralino,1)*gp) - cos(theta)*fq*mixNeut(neutralino,3);
	  }
	
	else if (oneortwo == 2) /// we have sbottom2s
	  {
	    alphatilda = sin(theta)*(mixNeut(neutralino,1)*-gp*(1/(3*pow(2,0.5))) + mixNeut(neutralino,2)*g*1/(pow(2,0.5))) + cos(theta)*fq*mixNeut(neutralino,3); /// simplified abot(2,i)*g from susyhit
	    betatilda = cos(theta)*(2/(3*pow(2,0.5)))*gp*(mixNeut(neutralino,1)) - sin(theta)*fq*mixNeut(neutralino,3); /// simplified bbot(2,i)*g from susyhit
	    ///cout << " We're on sbottom2" << endl;
	  }
	  
	else { cout << "problem: must be sbottom1s or sbottom2s" << endl; }
	}
      
    else { cout << "problem: third generation squarks must be stops or sbottoms" << endl;}
    
    a = 0.5*(alphatilda + betatilda);
    b = 0.5*(betatilda - alphatilda);
    ///cout << "!!!!!!!!!fq= " << fq << endl;  
    ///cout << "!!!!!!!!!masscombo1= " << masscombo1 << " masscombo2= " << masscombo2 << endl;
    amplitudeW = 3*lambda*fabs(m1)/(16*PI)*(pow(a,2)*masscombo1 + pow(b,2)*masscombo2);
  }
  return amplitudeW;
}



double neutralinoamplitudedecaystautau (double m1, double m2, double m3, double mWboson, double theta, double beta, DoubleMatrix mixNeut, double g, double gp, int oneortwo,  int neutralino) /// m2 must be tau (i.e. lepton) mass
{

  double amplitudeW, squareplus, squareminus, lambda, ftau=0, alphatilda=0, betatilda=0, a=0, b=0, factor1=0, factor2=0;

  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    
    ftau = g*m2/(pow(2,0.5)*mWboson*cos(beta));
    if (oneortwo == 1) /// we are decaying into a stau1
      {
	alphatilda = 1/(pow(2,0.5))*sin(theta)*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1)) + ftau*mixNeut(neutralino,3)*cos(theta); /// ignored (-i)^thetai factor in front
	betatilda =  pow(2,0.5)*gp*mixNeut(neutralino,1)*-cos(theta) + ftau*mixNeut(neutralino,3)*sin(theta); ///ignored (i)^thetai factor in front/// ignored (i)^thetai factor in front
	///cout << "FIRST LOOP" << endl;
      }
    else if (oneortwo ==2) /// we are decaying into a stau2
      {
	alphatilda = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*-cos(theta) + ftau*mixNeut(neutralino,3)*sin(theta); /// ignored (-i)^thetai factor in front
	betatilda = -pow(2,0.5)*gp*mixNeut(neutralino,1)*sin(theta) - ftau*mixNeut(neutralino,3)*cos(theta); /// ignored (i)^thetai factor in front
	///cout << "SECOND LOOP" << endl;
      }
    else {
      cout << "Stau must be a stau1 or a stau2, hence for int oneortwo 1 or 2 only allowed!" << endl;
    }

    a = 0.5*(alphatilda + betatilda);
    b = 0.5*(betatilda - alphatilda);
    factor1 = (pow(m1+m2,2)-pow(m3,2))/pow(m1,2);
    factor2 = (pow(m1-m2,2)-pow(m3,2))/pow(m1,2);

    cout.precision(7);
    cout << "NEUT -> STAU TAU:" << endl;
    // cout << "mneut = "<< m1 << " mtau = " << m2 << " mstau1 = " << m3 << " thetatau = " << theta << endl;
    // cout << "g = " << g << " gp = " << gp << " mW = " << mWboson << " beta = " << beta << endl;
    // cout << "alphatilda = " << alphatilda << " betatilda = " << betatilda << endl;
    // cout << "alphatilda*g/sqrt(2) = " << alphatilda*g/pow(2,0.5) << " betatilda*g/sqrt(2) = " << betatilda*g/pow(2,0.5) << endl;
    // cout << "alphatilda/g*sqrt(2) = " << alphatilda/g*pow(2,0.5) << " betatilda/g*sqrt(2) = " << betatilda/g*pow(2,0.5) << endl;
    // cout << "(amneut(4)**2-astau1**2+amtau**2) = " << (pow(m1,2)-pow(m3,2)+pow(m2,2)) << endl;
    
    cout << "sin(thetatau) = " << sin(theta) << " cos(thetatau) = " << cos(theta) << endl;
    cout << "ftau = " << ftau << endl;
    cout << "lambda = " << lambda << endl;
    cout << "1/(16*PI*mneut(4) = " << 1/(16*PI*m1) << endl;
    cout << "g2/(2.D0)*(ato(1,i)**2*((amneut(i)+amtau)**2-(astau1**2))) = " << pow(a,2)*factor1 << endl;
    cout << "g2/(2.D0)*(bto(1,i)**2*((amneut(i)-amtau)**2-(astau1**2))) = " << pow(b,2)*factor2 << endl;
    cout << endl;
        

    //amplitudeW = fabs(m1)*lambda/(16*PI)*(pow(a,2)*squareplus + pow(b,2)*squareminus);
    amplitudeW = fabs(m1)*lambda/(16*PI)*(pow(a,2)*factor1 + pow(b,2)*factor2);
  }
  return amplitudeW;
}



double neutralinoamplitudedecaycharginoWboson (double m1, double m2, double m3, double g, double thetaL, double thetaR, DoubleMatrix mixNeut, int neutralino,  int chargino) /// m2 must be W boson mass (expect to be pole mass 80.4...), neutralino is i in T&B whilst chargino is j
{

  double amplitudeW, squareplus, squareminus, squarecombo1=0, squarecombo2=0, lambda, X=0, Y=0;
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    
    lambda = pow(squareplus*squareminus,0.5);
      
    squarecombo1 = pow(m1,2) + pow(m3,2) - pow(m2,2);
    squarecombo2 = (pow(pow(m1,2) - pow(m3,2),2) - pow(m2,4))/pow(m2,2);
    
    if (chargino == 1) {
      X = 0.5*((cos(thetaR)*mixNeut(neutralino,4)/(pow(2,0.5)) - sin(thetaR)*mixNeut(neutralino,2)) - cos(thetaL)*mixNeut(neutralino,3)/(pow(2,0.5)) - sin(thetaL)*mixNeut(neutralino,2));
      Y = 0.5*(-(cos(thetaR)*mixNeut(neutralino,4)/(pow(2,0.5)) - sin(thetaR)*mixNeut(neutralino,2)) - cos(thetaL)*mixNeut(neutralino,3)/(pow(2,0.5)) - sin(thetaL)*mixNeut(neutralino,2));
	}
      
    else if (chargino == 2) {
      X = 0.5*((-sin(thetaR)*mixNeut(neutralino,4)/(pow(2,0.5)) - cos(thetaR)*mixNeut(neutralino,2)) + sin(thetaL)*mixNeut(neutralino,3)/(pow(2,0.5)) - cos(thetaL)*mixNeut(neutralino,2));
      Y = 0.5*((sin(thetaR)*mixNeut(neutralino,4)/(pow(2,0.5)) + cos(thetaR)*mixNeut(neutralino,2)) + sin(thetaL)*mixNeut(neutralino,3)/(pow(2,0.5)) - cos(thetaL)*mixNeut(neutralino,2));
    }

    amplitudeW = pow(g,2)/(16*PI*fabs(m1))*lambda*((pow(X,2)+pow(Y,2))*(squarecombo1+squarecombo2) - 6*(pow(X,2) - pow(Y,2))*m1*m3);
      
  }
  return amplitudeW;
}


double neutralinoamplitudedecaycharginoHplus (double m1, double m2, double m3, double g, double gp, double beta, double thetaL, double thetaR, DoubleMatrix mixNeut, int neutralino,  int chargino) /// m2 must be Hplus mass, neutralino is i in T&B whilst chargino is j
{
  
  double amplitudeW, squareplus, squareminus, squarecombo1=0, lambda, A1=0, A2=0, A3=0, A4=0,a=0, b=0;
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    
    lambda = pow(squareplus*squareminus,0.5);
    
    squarecombo1 = pow(m1,2) + pow(m3,2) - pow(m2,2);
    
    ///A1 = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*sin(thetaR) + g*mixNeut(neutralino,4)*cos(thetaR);
    ///A2 = -1/(pow(2,0.5))*(-g*mixNeut(neutralino,2) - gp*mixNeut(neutralino,1))*cos(thetaR) - g*mixNeut(neutralino,4)*sin(thetaR);
    ///A3 = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*sin(thetaL) - g*mixNeut(neutralino,3)*cos(thetaL);
    ///A4 = -1/(pow(2,0.5))*(-g*mixNeut(neutralino,2) - gp*mixNeut(neutralino,1))*cos(thetaL) + g*mixNeut(neutralino,3)*sin(thetaL);

    A1 = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*sin(thetaR) - g*mixNeut(neutralino,4)*cos(thetaR);
    A2 = -1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*cos(thetaR) - g*mixNeut(neutralino,4)*sin(thetaR);
    A3 = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*sin(thetaL) + g*mixNeut(neutralino,3)*cos(thetaL);
    A4 = -1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*cos(thetaL) + g*mixNeut(neutralino,3)*sin(thetaL);
    
      
    if (chargino == 1) {
      a = 0.5*(-cos(beta)*A2 + sin(beta)*A4);
      b = 0.5*(-cos(beta)*A2 - sin(beta)*A4);
    }
     
    else if (chargino == 2) {
      a = 0.5*(-cos(beta)*A1 + sin(beta)*A3);
      b = 0.5*(-cos(beta)*A1 - sin(beta)*A3);
    }

    amplitudeW = lambda/(16*PI*fabs(m1))*((pow(a,2)+pow(b,2))*squarecombo1 + 2*(pow(a,2) - pow(b,2))*m1*m3);
    ///cout << "cos(beta)*A2= " << cos(beta)*A2 << " sin(beta)*A4= " << sin(beta)*A4 << endl; 
    ///cout << "A2= " << A2 << " A4= " << A4 << endl;
    ///cout << "tanthetaW=gp/g= " << gp/g << endl; 
    cout << m1 << " " << m2 << " " << m3 << endl;
  }
  return amplitudeW;
}


double neutralinoamplitudedecayneutralinoZboson (double m1, double m2, double m3, double g, double gp, DoubleMatrix mixNeut, int ineutralino,  int fneutralino) /// m2 must be Z mass, ineutralino is i in T&B whilst fneutralino is j
{
  
  double amplitudeW, squareplus, squareminus, squarecombo1=0, squarecombo2=0, lambda, Wij=0;
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    //    cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
  }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    
    lambda = pow(squareplus*squareminus,0.5);
    
    squarecombo1 = pow(m1,2) + pow(m3,2) - pow(m2,2);
    squarecombo2 = (pow(pow(m1,2)-pow(m3,2),2) -pow(m2,4))/(pow(m2,2));
    
    Wij = 0.25*pow(pow(g,2)+pow(gp,2),0.5)*(mixNeut(ineutralino,4)*mixNeut(fneutralino,4) - mixNeut(ineutralino,3)*mixNeut(fneutralino,3));
    ///cout.precision(7);
    ///cout << "Wij info: for " << ineutralino << " to " << fneutralino << " Wij = " << Wij << endl;

    amplitudeW = pow(Wij,2)*lambda/(4*PI*fabs(m1))*(squarecombo1 + squarecombo2 +6*m1*m3);
    }
  return amplitudeW;
}

      
double neutralinoamplitudedecayneutralinoneutHiggs (double m1, double m2, double m3, double g, double gp, DoubleMatrix mixNeut, double mixingangle, int ineutralino,  int fneutralino, char phi) /// m2 must be phi mass, ineutralino is i in T&B whilst fneutralino is j
{

  double amplitudeW=0, squareplus, squareminus, squarecombo=0, lambda, Xij=0, Xji=0;
  
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    squarecombo = pow(m1,2) + pow(m3,2) - pow(m2,2);
    
    lambda = pow(squareplus*squareminus,0.5);
    
    if(phi == 'h') /// here mixingangle is alpha
      {
	Xij = -0.5*(mixNeut(ineutralino,3)*-sin(mixingangle) - mixNeut(ineutralino,4)*cos(mixingangle))*(-g*mixNeut(fneutralino,2) + gp*mixNeut(fneutralino,1));
	Xji = -0.5*(mixNeut(fneutralino,3)*-sin(mixingangle) - mixNeut(fneutralino,4)*cos(mixingangle))*(-g*mixNeut(ineutralino,2) + gp*mixNeut(ineutralino,1));	
	amplitudeW = pow(Xij+Xji,2)*lambda/(16*PI*fabs(m1))*(squarecombo + 2*m1*m3);
	//cout << "h: (Xij+Xji)/2g = " << (Xij + Xji)/(2*g) << endl;
	//cout << "h: Xij= " << Xij << " Xji= " << Xji << endl;
	//cout << "h: mixingangle= " << mixingangle << endl;
      }
    
    else if (phi == 'H') /// here mixingangle is alpha
      {
	Xij = -0.5*(mixNeut(ineutralino,3)*cos(mixingangle) - mixNeut(ineutralino,4)*sin(mixingangle))*(-g*mixNeut(fneutralino,2) + gp*mixNeut(fneutralino,1));
	Xji = -0.5*(mixNeut(fneutralino,3)*cos(mixingangle) - mixNeut(fneutralino,4)*sin(mixingangle))*(-g*mixNeut(ineutralino,2) + gp*mixNeut(ineutralino,1));
	amplitudeW = pow(Xij+Xji,2)*lambda/(16*PI*fabs(m1))*(squarecombo + 2*m1*m3);
	//cout << "H: mixingangle= " << mixingangle << endl;
      }
    
    else if (phi == 'A') /// here mixingangle is beta
      {
	Xij = 0.5*(mixNeut(ineutralino,3)*sin(mixingangle) - mixNeut(ineutralino,4)*cos(mixingangle))*(-g*mixNeut(fneutralino,2) + gp*mixNeut(fneutralino,1));
	Xji = 0.5*(mixNeut(fneutralino,3)*sin(mixingangle) - mixNeut(fneutralino,4)*cos(mixingangle))*(-g*mixNeut(ineutralino,2) + gp*mixNeut(ineutralino,1));
	amplitudeW = pow(Xij+Xji,2)*lambda/(16*PI*fabs(m1))*(squarecombo - 2*m1*m3);
	//cout << "A: mixingangle= " << mixingangle << endl;
      }
  }
  return amplitudeW;
}

double higgslorHamplitudedecayquarkantiquark (double m1, double m2, double g, double alpha, double beta, double mWboson, int uord, char lorH) /// uord indicates if it's an up type quark (1) or down type quark (0) to choose which trig functions to act on the mixing angles (which parts of the mixing matrices), and int lorH tells the program if it's a light higgs (l) or heavy higgs (H) decaying in order to change the trig functions acting on the mixing angles; note can also use this formula for decays of higgs to leptons as these are in this sense down-type
{

  double amplitudeW=0, squarecombo1=0, angular=0;
  
  if (fabs(m1) < fabs(m2) +fabs(m2)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
    }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squarecombo1 = 1 - 4*pow(m2/m1,2);
    if (lorH == 'l') {
	if (uord == 1) { 
	  angular = pow(cos(alpha)/sin(beta),2);
	}
	if (uord == 0) {
	  angular = pow(-sin(alpha)/cos(beta),2);
	}
      }
    else if (lorH == 'H') {
	if (uord == 1) {
	  angular = pow(-sin(alpha)/sin(beta),2);
	}
	else if (uord == 0) {
	  angular = pow(cos(alpha)/cos(beta),2);
	}
    }
    ///cout.precision(10);
    ///cout << "Mixing angle!: " << pow(angular,0.5) << endl;
    ///cout << "MHO(2)!!!!!" << m1 << endl;
    ///cout << pow(g,2)/(8*pow(mWboson,2))*pow(2,0.5) << endl;
    ///cout << pow(g,2)*3*m1/(32*PI)*pow(m2/mWboson,2)*pow(squarecombo1,1.5)/3 << endl;
    ///cout << m2 << endl;
    
    amplitudeW = pow(g,2)*3*m1/(32*PI)*pow(m2/mWboson,2)*angular*pow(squarecombo1,1.5);
  }
  return amplitudeW;
}   


double higgsAamplitudedecayquarkantiquark (double m1, double m2, double g, double beta, double mWboson, int uord) /// uord indicates if it's an up type quark (1) or down type quark (0) to choose which trig functions to act on the mixing angles (which parts of the mixing matrices), note can also use this formula for decays of higgs to leptons as these are in this sense down-type
{

  double amplitudeW=0, squarecombo1=0, angular=0;
  
  if (fabs(m1) < fabs(m2) +fabs(m2)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
    }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squarecombo1 = 1 - 4*pow(m2/m1,2);
    
    if (uord == 1) { 
      angular = pow(1/(tan(beta)),2);
    }
    else if (uord == 0) {
      angular = pow(tan(beta),2);
    }

    amplitudeW = 3*pow(g,2)*angular/(32*PI)*(pow(m2/mWboson,2))*m1*pow(squarecombo1,0.5);
  }
  
  return amplitudeW;
}


double higgsphiamplitudedecayneutralinoneutralino (double m1, double m2, double m3, double g, double tanthetaW, double mixingangle, DoubleMatrix mixNeut, int ineutralino, int fneutralino, char phi) /// phi tells it whether a "h", "H" or "A" is decaying 
{

  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, Xij=0, Xji=0;
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
    }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
        
    lambda = pow(squareplus*squareminus,0.5);
    
    if(phi == 'h') /// here mixingangle is alpha
      {
	Xij = -0.5*(mixNeut(ineutralino,3)*-sin(mixingangle) - mixNeut(ineutralino,4)*cos(mixingangle))*(-mixNeut(fneutralino,2) + tanthetaW*mixNeut(fneutralino,1));
	Xji = -0.5*(mixNeut(fneutralino,3)*-sin(mixingangle) - mixNeut(fneutralino,4)*cos(mixingangle))*(-mixNeut(ineutralino,2) + tanthetaW*mixNeut(ineutralino,1)); ///these are actually Xij/g and Xji/g really
	if (ineutralino == fneutralino) {
	  amplitudeW = 0.5*pow(g,2)*fabs(m1)/(8*PI)*(pow(Xij+Xji,2))*squareplus*lambda;
	}
	else 
	  amplitudeW = pow(g,2)*fabs(m1)/(8*PI)*(pow(Xij+Xji,2))*squareplus*lambda;
	//cout << "h: (Xij+Xji)/2g = " << (Xij + Xji)/(2*g) << endl;
	//cout << "h: Xij= " << Xij << " Xji= " << Xji << endl;
	///cout.precision(8);
	///cout << "h: mixingangle= " << mixingangle << endl;
	/// Previous formulae for Xij etc and amplitudes throughout the higgs to neutralino decays were (before writing in terms of g and tanthetaW to allow separate setting of global factor and Xijs:
	///Xij = -0.5*(mixNeut(ineutralino,3)*-sin(mixingangle) - mixNeut(ineutralino,4)*cos(mixingangle))*(-g*mixNeut(fneutralino,2) + gp*mixNeut(fneutralino,1));
	///Xji = -0.5*(mixNeut(fneutralino,3)*-sin(mixingangle) - mixNeut(fneutralino,4)*cos(mixingangle))*(-g*mixNeut(ineutralino,2) + gp*mixNeut(ineutralino,1));
	///amplitudeW = fabs(m1)/(8*PI)*(pow(Xij+Xji,2))*squareplus*lambda;
      }
    
    else if (phi == 'H') /// here mixingangle is alpha
      {
	Xij = -0.5*(mixNeut(ineutralino,3)*cos(mixingangle) - mixNeut(ineutralino,4)*sin(mixingangle))*(-mixNeut(fneutralino,2) + tanthetaW*mixNeut(fneutralino,1));
	Xji = -0.5*(mixNeut(fneutralino,3)*cos(mixingangle) - mixNeut(fneutralino,4)*sin(mixingangle))*(-mixNeut(ineutralino,2) + tanthetaW*mixNeut(ineutralino,1));
	if (ineutralino == fneutralino) {
	  amplitudeW = 0.5*pow(g,2)*fabs(m1)/(8*PI)*(pow(Xij+Xji,2))*squareplus*lambda;
	}
	else 
	  amplitudeW = pow(g,2)*fabs(m1)/(8*PI)*(pow(Xij+Xji,2))*squareplus*lambda;
	///cout.precision(8);
	///cout << "H: mixingangle= " << mixingangle << endl;
      }
    
    else if (phi == 'A') /// here mixingangle is beta
      {
	Xij = 0.5*(mixNeut(ineutralino,3)*sin(mixingangle) - mixNeut(ineutralino,4)*cos(mixingangle))*(-mixNeut(fneutralino,2) + tanthetaW*mixNeut(fneutralino,1));
	Xji = 0.5*(mixNeut(fneutralino,3)*sin(mixingangle) - mixNeut(fneutralino,4)*cos(mixingangle))*(-mixNeut(ineutralino,2) + tanthetaW*mixNeut(ineutralino,1));
	if (ineutralino == fneutralino) {
	  amplitudeW = 0.5*pow(g,2)*fabs(m1)/(8*PI)*(pow(Xij+Xji,2))*squareminus*lambda;
	  ///cout << "AN1= " << (pow(Xij+Xji,2))/pow(g,2) << endl;
	}
	else {
	  amplitudeW = pow(g,2)*fabs(m1)/(8*PI)*(pow(Xij+Xji,2))*squareminus*lambda;
	  ///cout << "AN1= " << (pow(Xij+Xji,2))/pow(g,2) << endl;
	}
	///cout.precision(8);
	///cout << "A: mixingangle= " << mixingangle << endl;
      }
  }
  cout.precision(8);
  ///cout << " AN(I,J)= " << (Xij+Xji)/g << endl;
  ///cout << "abs(m1)= " << fabs(m1) << " squareplus= " << squareplus << " lambda= " << lambda << endl;
  ///cout << endl;
  ///cout << "m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
  ///cout << squareminus << endl;
  ///cout << lambda << endl;
  ///cout << "g = " << g << " gp = " << gp << " alpha = " << mixingangle << endl;
  ///cout << "Mixneut = " << mixNeut << endl;
  ///cout << "(g^2)/8 = " << pow(g,2)/8 << endl;

  return amplitudeW;
}
     

double higgsphiamplitudedecaysamechargino (double m1, double m2, double g, double thetaL, double thetaR, double alpha, double beta, int chargino, char phi) /// phi tells it whether a "h", "H" or "A" is decaying
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, S=0, index=0;
  DoubleVector higgsphisamecharginocouplings(double alpha, double beta, double thetaL, double thetaR);
  
  if (fabs(m1) < fabs(m2) +fabs(m2)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m2)/m1,2);
    squareminus = 1 - pow((m2-m2)/m1,2); /// so ofcourse squarminus is just 1, just keeping link with other amplitudes
    lambda = pow(squareplus*squareminus,0.5);
    
    DoubleVector SWcoupling(6);
     for (int i=1; i<=6; i++) {
     SWcoupling(i) = 0;
   }
     
     SWcoupling = higgsphisamecharginocouplings(alpha, beta, thetaL, thetaR);
     
     if (phi == 'h' && chargino == 1) {
       S = SWcoupling(1);
       index = 3;
     }
     else if (phi == 'h' && chargino == 2) {
       S = SWcoupling(2);
       index = 3;
     }
     else if (phi == 'H' && chargino == 1) {
       S = SWcoupling(3);
       index = 3;
     }
     else if (phi == 'H' && chargino == 2) {
       S = SWcoupling(4);
       index = 3;
     }
     else if (phi == 'A' && chargino == 1) {
       S = SWcoupling(5);
       index = 1;
     }
     else if (phi == 'A' && chargino == 2) {
       S = SWcoupling(6);
       index = 1;
     }
    
    amplitudeW = pow(g,2)/(4*PI)*pow(S,2)*fabs(m1)*pow(lambda,index);
  }  
  ///cout << "Siphi= " << S << endl;
  return amplitudeW; 
};
 

double higgsphiamplitudedecaydifchargino (double m1, double m2, double m3, double g, double thetaL, double thetaR, double alpha, double beta, char phi) /// phi tells it whether a "h", "H" or "A" is decaying
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, S=0, P=0;
  DoubleVector higgsphidifcharginocouplings(double alpha, double beta, double thetaL, double thetaR);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2); 
    lambda = pow(squareplus*squareminus,0.5);
    
    DoubleVector SPWcoupling(6);
     for (int i=1; i<=6; i++) {
     SPWcoupling(i) = 0;
   }
     
     SPWcoupling = higgsphidifcharginocouplings(alpha, beta, thetaL, thetaR);
     
     if (phi == 'h') {
       S = SPWcoupling(1);
       P = SPWcoupling(2);
     }
     else if (phi == 'H') {
       S = SPWcoupling(3);
       P = SPWcoupling(4);
     }
     else if (phi == 'A') {
       S = SPWcoupling(5);
       P = SPWcoupling(6);
     }
    
     amplitudeW = pow(g,2)/(16*PI)*fabs(m1)*lambda*(pow(S,2)*squareplus + pow(P,2)*squareminus);
  }  
  
  return amplitudeW; 
};


double higgshamplitudedecayAA (double m1, double m2, double g, double gp, double alpha, double beta, double mWboson) ///calculates partial width for h->AA
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, costhetaW=0;
  
  if (fabs(m1) < fabs(m2) +fabs(m2)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m2)/m1,2);
    squareminus = 1 - pow((m2-m2)/m1,2); ///obviously 1, just for comparison and consistency with other decay modes
    lambda = pow(squareplus*squareminus,0.5);
    
    costhetaW = g/(pow(pow(g,2)+pow(gp,2),0.5));
    coupling = g*mWboson/(4*pow(costhetaW,2))*sin(beta+alpha)*cos(2*beta);
    
    amplitudeW = pow(coupling,2)/(8*PI*fabs(m1))*lambda;
    cout << endl;
    ///cout << pow(g*mWboson/(4*pow(costhetaW,2)),2)/(8*PI) << endl;
    ///cout << "angular part= " << sin(beta+alpha)*cos(2*beta) << endl;
  }
  return amplitudeW;
}


double higgsHamplitudedecayhh (double m1, double m2, double g, double gp, double alpha, double beta, double mWboson) ///calculates partial width for h->hh
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, costhetaW=0;
  
  if (fabs(m1) < fabs(m2) +fabs(m2)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m2)/m1,2);
    squareminus = 1 - pow((m2-m2)/m1,2); ///obviously 1, just for comparison and consistency with other decay modes
    lambda = pow(squareplus*squareminus,0.5);
    
    costhetaW = g/(pow(pow(g,2)+pow(gp,2),0.5));
    coupling = g*mWboson/(4*pow(costhetaW,2))*(cos(2*alpha)*cos(beta+alpha) - 2*sin(2*alpha)*sin(beta+alpha));
    
    amplitudeW = pow(coupling,2)/(8*PI*fabs(m1))*lambda;
    ///cout << endl;
    ///cout << pow(g*mWboson/(4*pow(costhetaW,2)),2)/(8*PI) << endl;
    ///cout << "angular part= " << cos(2*alpha)*cos(beta+alpha) - 2*sin(2*alpha)*sin(beta+alpha) << endl;
  }
  return amplitudeW;
}


double higgsHamplitudedecayAA (double m1, double m2, double g, double gp, double alpha, double beta, double mWboson) ///calculates partial width for H->AA
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, costhetaW=0;
  
  if (fabs(m1) < fabs(m2) +fabs(m2)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m2)/m1,2);
    squareminus = 1 - pow((m2-m2)/m1,2); ///obviously 1, just for comparison and consistency with other decay modes
    lambda = pow(squareplus*squareminus,0.5);
    
    costhetaW = g/(pow(pow(g,2)+pow(gp,2),0.5));
    coupling = -g*mWboson/(4*pow(costhetaW,2))*(cos(beta+alpha)*cos(2*beta));
    
    amplitudeW = pow(coupling,2)/(8*PI*fabs(m1))*lambda;
    ///cout << endl;
    ///cout << pow(g*mWboson/(4*pow(costhetaW,2)),2)/(8*PI) << endl;
    ///cout << "angular part= " << cos(2*alpha)*cos(beta+alpha) - 2*sin(2*alpha)*sin(beta+alpha) << endl;
  }
  return amplitudeW;
}


double higgsHamplitudedecayHplusHminus (double m1, double m2, double g, double gp, double alpha, double beta, double mWboson) ///calculates partial width for H->H+H-
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, costhetaW=0;
  
  if (fabs(m1) < fabs(m2) +fabs(m2)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m2)/m1,2);
    squareminus = 1 - pow((m2-m2)/m1,2); ///obviously 1, just for comparison and consistency with other decay modes
    lambda = pow(squareplus*squareminus,0.5);
    
    costhetaW = g/(pow(pow(g,2)+pow(gp,2),0.5));
    coupling = g*mWboson*(cos(beta-alpha) - cos(beta+alpha)*cos(2*beta)/(2*pow(costhetaW,2)));
    
    amplitudeW = pow(coupling,2)/(16*PI*fabs(m1))*lambda;
    ///cout << endl;
    ///cout << pow(g*mWboson/(4*pow(costhetaW,2)),2)/(8*PI) << endl;
    ///cout << "angular part= " << cos(2*alpha)*cos(beta+alpha) - 2*sin(2*alpha)*sin(beta+alpha) << endl;
  }
  return amplitudeW;
}


double higgshamplitudedecayhiggsAZboson (double m1, double m2, double m3, double g, double gp, double alpha, double beta) ///calculates partial width for h->AZ, m2 must be Zboson mass
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, costhetaW=0;
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    
    costhetaW = g/(pow(pow(g,2)+pow(gp,2),0.5));
    coupling =(g/(costhetaW))*(cos(beta-alpha));
    
    amplitudeW = pow(coupling,2)*fabs(pow(m1,3))/(64*PI*pow(m2,2))*pow(lambda,3);
    ///cout << endl;
    ///cout << pow(g*mWboson/(4*pow(costhetaW,2)),2)/(8*PI) << endl;
    ///cout << "angular part= " <<  cos(beta-alpha) << endl;
    ///cout << setprecision(12) << pow(g,2)/(8*pow(m2*costhetaW,2)) << endl; 
  }
  return amplitudeW;
}


double higgsHamplitudedecayhiggsAZboson (double m1, double m2, double m3, double g, double gp, double alpha, double beta) ///calculates partial width for H->AZ, m2 must be Zboson mass
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, costhetaW=0;
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    
    costhetaW = g/(pow(pow(g,2)+pow(gp,2),0.5));
    coupling =(g/(costhetaW))*(sin(beta-alpha));
    
    amplitudeW = pow(coupling,2)*fabs(pow(m1,3))/(64*PI*pow(m2,2))*pow(lambda,3);
    ///cout << endl;
    ///cout << pow(g*mWboson/(4*pow(costhetaW,2)),2)/(8*PI) << endl;
    ///cout << "angular part= " <<  sin(beta-alpha) << endl;
    ///cout << setprecision(12) << pow(g,2)/(8*pow(m2*costhetaW,2)) << endl; 
  }
  return amplitudeW;
}



double higgsAamplitudedecayhiggshZboson (double m1, double m2, double m3, double g, double gp, double alpha, double beta) ///calculates partial width for A->hZ, m2 must be Zboson mass
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, costhetaW=0;
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    
    costhetaW = g/(pow(pow(g,2)+pow(gp,2),0.5));
    coupling =(g/(costhetaW))*(cos(beta-alpha));
    
    amplitudeW = pow(coupling,2)*fabs(pow(m1,3))/(64*PI*pow(m2,2))*pow(lambda,3);
    ///cout << endl;
    ///cout << pow(g*mWboson/(4*pow(costhetaW,2)),2)/(8*PI) << endl;
    ///cout << "angular part= " <<  sin(beta-alpha) << endl;
    ///cout << setprecision(12) << pow(g,2)/(8*pow(m2*costhetaW,2)) << endl; 
  }
  return amplitudeW;
}




double higgsAamplitudedecayhiggsHZboson (double m1, double m2, double m3, double g, double gp, double alpha, double beta) ///calculates partial width for A->HZ, m2 must be Zboson mass
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, costhetaW=0;
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    
    costhetaW = g/(pow(pow(g,2)+pow(gp,2),0.5));
    coupling =(g/(costhetaW))*(sin(beta-alpha));
    
    amplitudeW = pow(coupling,2)*fabs(pow(m1,3))/(64*PI*pow(m2,2))*pow(lambda,3);
    ///cout << endl;
    ///cout << pow(g*mWboson/(4*pow(costhetaW,2)),2)/(8*PI) << endl;
    ///cout << "angular part= " <<  sin(beta-alpha) << endl;
    ///cout << setprecision(12) << pow(g,2)/(8*pow(m2*costhetaW,2)) << endl; 
  }
  return amplitudeW;
}



double higgshamplitudedecay2squarksamehand (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson,double mupq, double mdownq, int sq) ///calculates partial width for h->squark squark with no mixing and squarks of same handedness, therefore for first two generations, int sq tells the function which squarks it's decaying into - uL, dL, uR, dR for sq = 1,2,3,4 respectively
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0;
  DoubleVector higgshsquarksamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mupq, double mdownq);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector hsqsqcoupling(4);
     for (int i=1; i<=4; i++) {
     hsqsqcoupling(i) = 0;
     }

     hsqsqcoupling = higgshsquarksamehandcouplings(mWboson, g, gp, alpha, beta, mupq, mdownq);
     ///cout << "HERE! " << hsqsqcoupling << endl;

    if (sq == 1) {
      coupling = hsqsqcoupling(1);
    }
    else if (sq == 2) {
      coupling = hsqsqcoupling(2);
    }
    else if (sq == 3) {
      coupling = hsqsqcoupling(3);
    }
    else if (sq == 4) {
      coupling = hsqsqcoupling(4);
    }    
    
    amplitudeW = 3*pow(coupling,2)/(16*PI*m1)*lambda;
    ///cout << "coupling= " << coupling << endl;
    ///cout << "lambda= " << lambda << endl;
    ///cout << "3/(16*PI*mh) = " << 3/(16*PI*m1) << endl;
    ///cout << "g*mW= " << g*mWboson << endl;
    ///cout << "susyhitcomp = " << pow(0.5 - gp/(6*g),2) << endl;
    ///cout << "ratio = " << pow(1/(2*(pow(g,2)/(pow(g,2)+pow(gp,2)))) - 2*pow(g,2)/(3*pow(gp,2)),2)/(0.5*pow(2-2*pow(g,2)/(3*pow(gp,2)),2))<< endl;
    ///cout << pow(g*mWboson/(4*pow(costhetaW,2)),2)/(8*PI) << endl;
    ///cout << "angular part= " <<  sin(beta-alpha) << endl;
    ///cout << setprecision(12) << pow(g,2)/(8*pow(m2*costhetaW,2)) << endl; 
  }
  return amplitudeW;
}


double higgshamplitudedecay2squarkdiffhand (double m1, double m2, double m3, double g, double alpha, double beta, double mWboson, double mupq, double mdownq, double greekmu, double Aup, double Adown, int sq) ///calculates partial width for h->squark squark with no mixing and squarks of different handedness, therefore for first two generations, int sq tells the function which squarks it's decaying into - uL, dL, uR, dR for sq = 1,2,3,4 respectively
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0;
  DoubleVector higgshsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mupq, double mdownq, double greekmu, double Aup, double Adown);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector hsqsqcoupling(2);
     for (int i=1; i<=2; i++) {
     hsqsqcoupling(i) = 0;
     }

     hsqsqcoupling = higgshsquarkdiffhandcouplings(mWboson, g, alpha, beta, mupq, mdownq, greekmu, Aup, Adown);
   
    if (sq == 1) {
      coupling = hsqsqcoupling(1);
    }
    else if (sq == 2) {
      coupling = hsqsqcoupling(2);
    }
        
    amplitudeW = 3*pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}


double higgsHamplitudedecay2squarksamehand (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson,double mupq, double mdownq, int sq) ///calculates partial width for H->squark squark with no mixing and squarks of same handedness, therefore for first two generations, int sq tells the function which squarks it's decaying into - uL, dL, uR, dR for sq = 1,2,3,4 respectively
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0;
  DoubleVector higgsHsquarksamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mupq, double mdownq);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector Hsqsqcoupling(4);
     for (int i=1; i<=4; i++) {
     Hsqsqcoupling(i) = 0;
     }

     Hsqsqcoupling = higgsHsquarksamehandcouplings(mWboson, g, gp, alpha, beta, mupq, mdownq);
     ///cout << "HERE! " << Hsqsqcoupling << endl;

    if (sq == 1) {
      coupling = Hsqsqcoupling(1);
    }
    else if (sq == 2) {
      coupling = Hsqsqcoupling(2);
    }
    else if (sq == 3) {
      coupling = Hsqsqcoupling(3);
    }
    else if (sq == 4) {
      coupling = Hsqsqcoupling(4);
    }    
    
    amplitudeW = 3*pow(coupling,2)/(16*PI*m1)*lambda;
    ///cout << "coupling= " << coupling << endl;
    ///cout << "lambda= " << lambda << endl;
    ///cout << "3/(16*PI*mh) = " << 3/(16*PI*m1) << endl;
    ///cout << "g*mW= " << g*mWboson << endl;
    ///cout << "susyhitcomp = " << pow(0.5 - gp/(6*g),2) << endl;
    ///cout << "ratio = " << pow(1/(2*(pow(g,2)/(pow(g,2)+pow(gp,2)))) - 2*pow(g,2)/(3*pow(gp,2)),2)/(0.5*pow(2-2*pow(g,2)/(3*pow(gp,2)),2))<< endl;
    ///cout << pow(g*mWboson/(4*pow(costhetaW,2)),2)/(8*PI) << endl;
    ///cout << "angular part= " <<  sin(beta-alpha) << endl;
    ///cout << setprecision(12) << pow(g,2)/(8*pow(m2*costhetaW,2)) << endl; 
  }
  return amplitudeW;
}


double higgsHamplitudedecay2squarkdiffhand (double m1, double m2, double m3, double g, double alpha, double beta, double mWboson, double mupq, double mdownq, double greekmu, double Aup, double Adown, int sq) ///calculates partial width for H->squark squark with no mixing and squarks of different handedness, therefore for first two generations, int sq tells the function which squarks it's decaying into - uL, dL, uR, dR for sq = 1,2,3,4 respectively
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0;
  DoubleVector higgsHsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mupq, double mdownq, double greekmu, double Aup, double Adown);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector Hsqsqcoupling(2);
     for (int i=1; i<=2; i++) {
     Hsqsqcoupling(i) = 0;
     }

     Hsqsqcoupling = higgsHsquarkdiffhandcouplings(mWboson, g, alpha, beta, mupq, mdownq, greekmu, Aup, Adown);
   
    if (sq == 1) {
      coupling = Hsqsqcoupling(1);
    }
    else if (sq == 2) {
      coupling = Hsqsqcoupling(2);
    }
        
    amplitudeW = 3*pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}


double higgshamplitudedecay2sleptonsamehand (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mel, int sl) ///calculates partial width for h->slepton slepton with no mixing and sleptons of same handedness, therefore for first two generations, int sl tells the function which sleptons it's decaying into - nuL, eL, eR for sl = 1,2,3 respectively
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0;
  DoubleVector higgshsleptonsamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mel);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector hslslcoupling(3);
     for (int i=1; i<=3; i++) {
     hslslcoupling(i) = 0;
     }

     hslslcoupling = higgshsleptonsamehandcouplings (mWboson, g, gp, alpha, beta, mel);
     ///cout << "HERE! " << hslslcoupling << endl;

    if (sl == 1) {
      coupling = hslslcoupling(1);
    }
    else if (sl == 2) {
      coupling = hslslcoupling(2);
    }
    else if (sl == 3) {
      coupling = hslslcoupling(3);
    }
        
    amplitudeW = pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}

double higgshamplitudedecay2sleptondiffhand (double m1, double m2, double m3, double g, double alpha, double beta, double mWboson, double mel, double greekmu, double Aelectron, int sl) ///calculates partial width for h->slepton slepton with no mixing and sleptons of different handedness, therefore for first two generations, int sl tells the function which sleptons it's decaying into - nuL, eL, eR for sl = 1,2,3 respectively
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0;
  DoubleVector higgshsleptondiffhandcouplings (double mWboson, double g, double alpha, double beta, double mel, double greekmu, double Ae);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector hslslcoupling(1);
     for (int i=1; i<=1; i++) {
     hslslcoupling(i) = 0;
     }

     hslslcoupling = higgshsleptondiffhandcouplings (mWboson, g, alpha, beta, mel, greekmu, Aelectron);
   
    if (sl == 1) {
      coupling = hslslcoupling(1);
    }
  
    amplitudeW = pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}

double higgsHamplitudedecay2sleptonsamehand (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mel, int sl) ///calculates partial width for H->slepton slepton with no mixing and sleptons of same handedness, therefore for first two generations, int sl tells the function which sleptons it's decaying into - nuL, eL, eR for sl = 1,2,3 respectively
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0;
  DoubleVector higgsHsleptonsamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mel);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector Hslslcoupling(3);
     for (int i=1; i<=3; i++) {
     Hslslcoupling(i) = 0;
     }

     Hslslcoupling = higgsHsleptonsamehandcouplings (mWboson, g, gp, alpha, beta, mel);
     ///cout << "HERE! " << Hslslcoupling << endl;

    if (sl == 1) {
      coupling = Hslslcoupling(1);
    }
    else if (sl == 2) {
      coupling = Hslslcoupling(2);
    }
    else if (sl == 3) {
      coupling = Hslslcoupling(3);
    }
   
    amplitudeW = pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}

double higgsHamplitudedecay2sleptondiffhand (double m1, double m2, double m3, double g, double alpha, double beta, double mWboson, double mel, double greekmu, double Aelectron, int sl) ///calculates partial width for H->slepton slepton with no mixing and sleptons of different handedness, therefore for first two generations, int sl tells the function which sleptons it's decaying into - nuL, eL, eR for sl = 1,2,3 respectively
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0;
  DoubleVector higgsHsleptondiffhandcouplings (double mWboson, double g, double alpha, double beta, double mel, double greekmu, double Ae);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector Hslslcoupling(1);
     for (int i=1; i<=1; i++) {
     Hslslcoupling(i) = 0;
     }

     Hslslcoupling = higgsHsleptondiffhandcouplings (mWboson, g, alpha, beta, mel, greekmu, Aelectron);
   
    if (sl == 1) {
      coupling = Hslslcoupling(1);
    }
        
    amplitudeW = pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}


double higgshamplitudedecaystop1stop1 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta) ///calculates partial width for h->stop1 antistop1
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgshsquarksamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtop, double mbottom);
  DoubleVector higgshsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtop, double mbottom, double greekmu, double Atop, double Abottom);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector hst1st1samehandcoupling(4);
     for (int i=1; i<=4; i++) {
     hst1st1samehandcoupling(i) = 0;
     }

     hst1st1samehandcoupling = higgshsquarksamehandcouplings (mWboson, g, gp, alpha, beta, mtop, mbottom);
     couplingLL = hst1st1samehandcoupling(1);
     couplingRR = hst1st1samehandcoupling(3);

     DoubleVector hst1st1diffhandcoupling(2);
     for (int i=1; i<=2; i++) {
     hst1st1diffhandcoupling(i) = 0;
     }

     hst1st1diffhandcoupling = higgshsquarkdiffhandcouplings (mWboson, g, alpha, beta, mtop, mbottom, greekmu, Atop, Abottom);
     couplingLR = hst1st1diffhandcoupling(1);

     coupling = couplingLL*pow(cos(theta),2) + couplingRR*pow(sin(theta),2) - 2*couplingLR*cos(theta)*sin(theta);
        
    amplitudeW = 3*pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}


double higgshamplitudedecaystop2stop2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta) ///calculates partial width for h->stop2 antistop2
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgshsquarksamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtop, double mbottom);
  DoubleVector higgshsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtop, double mbottom, double greekmu, double Atop, double Abottom);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector hst2st2samehandcoupling(4);
     for (int i=1; i<=4; i++) {
     hst2st2samehandcoupling(i) = 0;
     }

     hst2st2samehandcoupling = higgshsquarksamehandcouplings (mWboson, g, gp, alpha, beta, mtop, mbottom);
     couplingLL = hst2st2samehandcoupling(1);
     couplingRR = hst2st2samehandcoupling(3);

     DoubleVector hst2st2diffhandcoupling(2);
     for (int i=1; i<=2; i++) {
     hst2st2diffhandcoupling(i) = 0;
     }

     hst2st2diffhandcoupling = higgshsquarkdiffhandcouplings (mWboson, g, alpha, beta, mtop, mbottom, greekmu, Atop, Abottom);
     couplingLR = hst2st2diffhandcoupling(1);

     coupling = couplingLL*pow(sin(theta),2) + couplingRR*pow(cos(theta),2) + 2*couplingLR*cos(theta)*sin(theta);
       
    amplitudeW = 3*pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}

double higgshamplitudedecaystop1stop2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta) ///calculates partial width for h->stop1 antistop2 or stop2 antistop1 as they are the same
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgshsquarksamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtop, double mbottom);
  DoubleVector higgshsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtop, double mbottom, double greekmu, double Atop, double Abottom);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector hst1st2samehandcoupling(4);
     for (int i=1; i<=4; i++) {
     hst1st2samehandcoupling(i) = 0;
     }

     hst1st2samehandcoupling = higgshsquarksamehandcouplings (mWboson, g, gp, alpha, beta, mtop, mbottom);
     couplingLL = hst1st2samehandcoupling(1);
     couplingRR = hst1st2samehandcoupling(3);

     DoubleVector hst1st2diffhandcoupling(2);
     for (int i=1; i<=2; i++) {
     hst1st2diffhandcoupling(i) = 0;
     }

     hst1st2diffhandcoupling = higgshsquarkdiffhandcouplings (mWboson, g, alpha, beta, mtop, mbottom, greekmu, Atop, Abottom);
     couplingLR = hst1st2diffhandcoupling(1);

     coupling = couplingLL*sin(theta)*cos(theta) - couplingRR*cos(theta)*sin(theta) + couplingLR*cos(2*theta);
       
    amplitudeW = 3*pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}

double higgshamplitudedecaysbottom1sbottom1 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta) ///calculates partial width for h->sbottom1 antisbottom1
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgshsquarksamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtop, double mbottom);
  DoubleVector higgshsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtop, double mbottom, double greekmu, double Atop, double Abottom);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector hsb1sb1samehandcoupling(4);
     for (int i=1; i<=4; i++) {
     hsb1sb1samehandcoupling(i) = 0;
     }

     hsb1sb1samehandcoupling = higgshsquarksamehandcouplings (mWboson, g, gp, alpha, beta, mtop, mbottom);
     couplingLL = hsb1sb1samehandcoupling(2);
     couplingRR = hsb1sb1samehandcoupling(4);
     ///cout << "couplingLL= " << couplingLL << " couplingRR= " << couplingRR << endl;

     DoubleVector hsb1sb1diffhandcoupling(2);
     for (int i=1; i<=2; i++) {
     hsb1sb1diffhandcoupling(i) = 0;
     }

     hsb1sb1diffhandcoupling = higgshsquarkdiffhandcouplings (mWboson, g, alpha, beta, mtop, mbottom, greekmu, Atop, Abottom);
     couplingLR = hsb1sb1diffhandcoupling(2);

     coupling = couplingLL*pow(cos(theta),2) + couplingRR*pow(sin(theta),2) - 2*couplingLR*cos(theta)*sin(theta);
        
    amplitudeW = 3*pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}

double higgshamplitudedecaysbottom2sbottom2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta) ///calculates partial width for h->sbottom2 antisbottom2
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgshsquarksamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtop, double mbottom);
  DoubleVector higgshsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtop, double mbottom, double greekmu, double Atop, double Abottom);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector hsb2sb2samehandcoupling(4);
     for (int i=1; i<=4; i++) {
     hsb2sb2samehandcoupling(i) = 0;
     }

     hsb2sb2samehandcoupling = higgshsquarksamehandcouplings (mWboson, g, gp, alpha, beta, mtop, mbottom);
     couplingLL = hsb2sb2samehandcoupling(2);
     couplingRR = hsb2sb2samehandcoupling(4);

     DoubleVector hsb2sb2diffhandcoupling(2);
     for (int i=1; i<=2; i++) {
     hsb2sb2diffhandcoupling(i) = 0;
     }

     hsb2sb2diffhandcoupling = higgshsquarkdiffhandcouplings (mWboson, g, alpha, beta, mtop, mbottom, greekmu, Atop, Abottom);
     couplingLR = hsb2sb2diffhandcoupling(2);

     coupling = couplingLL*pow(sin(theta),2) + couplingRR*pow(cos(theta),2) + 2*couplingLR*cos(theta)*sin(theta);
       
    amplitudeW = 3*pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}

double higgshamplitudedecaysbottom1sbottom2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta) ///calculates partial width for h->sbottom1 antisbottom2 or sbottom2 antisbottom1 as they are the same
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgshsquarksamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtop, double mbottom);
  DoubleVector higgshsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtop, double mbottom, double greekmu, double Atop, double Abottom);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector hsb1sb2samehandcoupling(4);
     for (int i=1; i<=4; i++) {
     hsb1sb2samehandcoupling(i) = 0;
     }

     hsb1sb2samehandcoupling = higgshsquarksamehandcouplings (mWboson, g, gp, alpha, beta, mtop, mbottom);
     couplingLL = hsb1sb2samehandcoupling(2);
     couplingRR = hsb1sb2samehandcoupling(4);

     DoubleVector hsb1sb2diffhandcoupling(2);
     for (int i=1; i<=2; i++) {
     hsb1sb2diffhandcoupling(i) = 0;
     }

     hsb1sb2diffhandcoupling = higgshsquarkdiffhandcouplings (mWboson, g, alpha, beta, mtop, mbottom, greekmu, Atop, Abottom);
     couplingLR = hsb1sb2diffhandcoupling(2);

     coupling = couplingLL*sin(theta)*cos(theta) - couplingRR*cos(theta)*sin(theta) + couplingLR*cos(2*theta);
       
    amplitudeW = 3*pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}

double higgsHamplitudedecaystop1stop1 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta) ///calculates partial width for H->stop1 antistop1
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgsHsquarksamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtop, double mbottom);
  DoubleVector higgsHsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtop, double mbottom, double greekmu, double Atop, double Abottom);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector Hst1st1samehandcoupling(4);
     for (int i=1; i<=4; i++) {
     Hst1st1samehandcoupling(i) = 0;
     }

     Hst1st1samehandcoupling = higgsHsquarksamehandcouplings (mWboson, g, gp, alpha, beta, mtop, mbottom);
     couplingLL = Hst1st1samehandcoupling(1);
     couplingRR = Hst1st1samehandcoupling(3);

     DoubleVector Hst1st1diffhandcoupling(2);
     for (int i=1; i<=2; i++) {
     Hst1st1diffhandcoupling(i) = 0;
     }

     Hst1st1diffhandcoupling = higgsHsquarkdiffhandcouplings (mWboson, g, alpha, beta, mtop, mbottom, greekmu, Atop, Abottom);
     couplingLR = Hst1st1diffhandcoupling(1);

     coupling = couplingLL*pow(cos(theta),2) + couplingRR*pow(sin(theta),2) - 2*couplingLR*cos(theta)*sin(theta);
        
    amplitudeW = 3*pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}

double higgsHamplitudedecaystop2stop2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta) ///calculates partial width for H->stop2 antistop2
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgsHsquarksamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtop, double mbottom);
  DoubleVector higgsHsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtop, double mbottom, double greekmu, double Atop, double Abottom);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector Hst2st2samehandcoupling(4);
     for (int i=1; i<=4; i++) {
     Hst2st2samehandcoupling(i) = 0;
     }

     Hst2st2samehandcoupling = higgsHsquarksamehandcouplings (mWboson, g, gp, alpha, beta, mtop, mbottom);
     couplingLL = Hst2st2samehandcoupling(1);
     couplingRR = Hst2st2samehandcoupling(3);

     DoubleVector Hst2st2diffhandcoupling(2);
     for (int i=1; i<=2; i++) {
     Hst2st2diffhandcoupling(i) = 0;
     }

     Hst2st2diffhandcoupling = higgsHsquarkdiffhandcouplings (mWboson, g, alpha, beta, mtop, mbottom, greekmu, Atop, Abottom);
     couplingLR = Hst2st2diffhandcoupling(1);

     coupling = couplingLL*pow(sin(theta),2) + couplingRR*pow(cos(theta),2) + 2*couplingLR*cos(theta)*sin(theta);
       
    amplitudeW = 3*pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}

double higgsHamplitudedecaystop1stop2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta) ///calculates partial width for H->stop1 antistop2 or stop2 antistop1 as they are the same
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgsHsquarksamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtop, double mbottom);
  DoubleVector higgsHsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtop, double mbottom, double greekmu, double Atop, double Abottom);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector Hst1st2samehandcoupling(4);
     for (int i=1; i<=4; i++) {
     Hst1st2samehandcoupling(i) = 0;
     }

     Hst1st2samehandcoupling = higgsHsquarksamehandcouplings (mWboson, g, gp, alpha, beta, mtop, mbottom);
     couplingLL = Hst1st2samehandcoupling(1);
     couplingRR = Hst1st2samehandcoupling(3);

     DoubleVector Hst1st2diffhandcoupling(2);
     for (int i=1; i<=2; i++) {
     Hst1st2diffhandcoupling(i) = 0;
     }

     Hst1st2diffhandcoupling = higgsHsquarkdiffhandcouplings (mWboson, g, alpha, beta, mtop, mbottom, greekmu, Atop, Abottom);
     couplingLR = Hst1st2diffhandcoupling(1);

     coupling = couplingLL*sin(theta)*cos(theta) - couplingRR*cos(theta)*sin(theta) + couplingLR*cos(2*theta);
       
    amplitudeW = 3*pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}

double higgsHamplitudedecaysbottom1sbottom1 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta) ///calculates partial width for H->sbottom1 antisbottom1
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgsHsquarksamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtop, double mbottom);
  DoubleVector higgsHsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtop, double mbottom, double greekmu, double Atop, double Abottom);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector Hsb1sb1samehandcoupling(4);
     for (int i=1; i<=4; i++) {
     Hsb1sb1samehandcoupling(i) = 0;
     }

     Hsb1sb1samehandcoupling = higgsHsquarksamehandcouplings (mWboson, g, gp, alpha, beta, mtop, mbottom);
     couplingLL = Hsb1sb1samehandcoupling(2);
     couplingRR = Hsb1sb1samehandcoupling(4);
     ///cout << "couplingLL= " << couplingLL << " couplingRR= " << couplingRR << endl;

     DoubleVector Hsb1sb1diffhandcoupling(2);
     for (int i=1; i<=2; i++) {
     Hsb1sb1diffhandcoupling(i) = 0;
     }

     Hsb1sb1diffhandcoupling = higgsHsquarkdiffhandcouplings (mWboson, g, alpha, beta, mtop, mbottom, greekmu, Atop, Abottom);
     couplingLR = Hsb1sb1diffhandcoupling(2);

     coupling = couplingLL*pow(cos(theta),2) + couplingRR*pow(sin(theta),2) - 2*couplingLR*cos(theta)*sin(theta);
        
    amplitudeW = 3*pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}

double higgsHamplitudedecaysbottom2sbottom2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta) ///calculates partial width for H->sbottom2 antisbottom2
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgsHsquarksamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtop, double mbottom);
  DoubleVector higgsHsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtop, double mbottom, double greekmu, double Atop, double Abottom);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector Hsb2sb2samehandcoupling(4);
     for (int i=1; i<=4; i++) {
     Hsb2sb2samehandcoupling(i) = 0;
     }

     Hsb2sb2samehandcoupling = higgsHsquarksamehandcouplings (mWboson, g, gp, alpha, beta, mtop, mbottom);
     couplingLL = Hsb2sb2samehandcoupling(2);
     couplingRR = Hsb2sb2samehandcoupling(4);

     DoubleVector Hsb2sb2diffhandcoupling(2);
     for (int i=1; i<=2; i++) {
     Hsb2sb2diffhandcoupling(i) = 0;
     }

     Hsb2sb2diffhandcoupling = higgsHsquarkdiffhandcouplings (mWboson, g, alpha, beta, mtop, mbottom, greekmu, Atop, Abottom);
     couplingLR = Hsb2sb2diffhandcoupling(2);

     coupling = couplingLL*pow(sin(theta),2) + couplingRR*pow(cos(theta),2) + 2*couplingLR*cos(theta)*sin(theta);
       
    amplitudeW = 3*pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}

double higgsHamplitudedecaysbottom1sbottom2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double theta) ///calculates partial width for H->sbottom1 antisbottom2 or sbottom2 antisbottom1 as they are the same
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgsHsquarksamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtop, double mbottom);
  DoubleVector higgsHsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtop, double mbottom, double greekmu, double Atop, double Abottom);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector Hsb1sb2samehandcoupling(4);
     for (int i=1; i<=4; i++) {
     Hsb1sb2samehandcoupling(i) = 0;
     }

     Hsb1sb2samehandcoupling = higgsHsquarksamehandcouplings (mWboson, g, gp, alpha, beta, mtop, mbottom);
     couplingLL = Hsb1sb2samehandcoupling(2);
     couplingRR = Hsb1sb2samehandcoupling(4);

     DoubleVector Hsb1sb2diffhandcoupling(2);
     for (int i=1; i<=2; i++) {
     Hsb1sb2diffhandcoupling(i) = 0;
     }

     Hsb1sb2diffhandcoupling = higgsHsquarkdiffhandcouplings (mWboson, g, alpha, beta, mtop, mbottom, greekmu, Atop, Abottom);
     couplingLR = Hsb1sb2diffhandcoupling(2);

     coupling = couplingLL*sin(theta)*cos(theta) - couplingRR*cos(theta)*sin(theta) + couplingLR*cos(2*theta);
       
    amplitudeW = 3*pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}

double higgshamplitudedecaystau1stau1 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtau, double greekmu, double Atau, double theta) ///calculates partial width for h->stau1 antistau1
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgshsleptonsamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtau); 
  DoubleVector higgshsleptondiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtau, double greekmu, double Atau);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector hstau1stau1samehandcoupling(3);
     for (int i=1; i<=3; i++) {
     hstau1stau1samehandcoupling(i) = 0;
     }

     hstau1stau1samehandcoupling = higgshsleptonsamehandcouplings (mWboson, g, gp, alpha, beta, mtau);
     couplingLL = hstau1stau1samehandcoupling(2);
     couplingRR = hstau1stau1samehandcoupling(3);

     DoubleVector hstau1stau1diffhandcoupling(1);
     for (int i=1; i<=1; i++) {
     hstau1stau1diffhandcoupling(i) = 0;
     }

     hstau1stau1diffhandcoupling = higgshsleptondiffhandcouplings (mWboson, g, alpha, beta, mtau, greekmu, Atau);
     couplingLR = hstau1stau1diffhandcoupling(1);

     coupling = couplingLL*pow(sin(theta),2) + couplingRR*pow(cos(theta),2) + 2*couplingLR*cos(theta)*sin(theta);
     ///coupling = couplingLL*pow(sin(theta),2) + couplingRR*pow(cos(theta),2) - 2*couplingLR*cos(theta)*sin(theta);

    amplitudeW = pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}


double higgshamplitudedecaystau2stau2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtau, double greekmu, double Atau, double theta) ///calculates partial width for h->stau2 antistau2
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgshsleptonsamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtau); 
  DoubleVector higgshsleptondiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtau, double greekmu, double Atau);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector hstau2stau2samehandcoupling(3);
     for (int i=1; i<=3; i++) {
     hstau2stau2samehandcoupling(i) = 0;
     }

     hstau2stau2samehandcoupling = higgshsleptonsamehandcouplings (mWboson, g, gp, alpha, beta, mtau);
     couplingLL = hstau2stau2samehandcoupling(2);
     couplingRR = hstau2stau2samehandcoupling(3);

     DoubleVector hstau2stau2diffhandcoupling(1);
     for (int i=1; i<=1; i++) {
     hstau2stau2diffhandcoupling(i) = 0;
     }

     hstau2stau2diffhandcoupling = higgshsleptondiffhandcouplings (mWboson, g, alpha, beta, mtau, greekmu, Atau);
     couplingLR = hstau2stau2diffhandcoupling(1);

     coupling = couplingLL*pow(cos(theta),2) + couplingRR*pow(sin(theta),2) - 2*couplingLR*cos(theta)*sin(theta);
     ///coupling = couplingLL*pow(cos(theta),2) + couplingRR*pow(sin(theta),2) + 2*couplingLR*cos(theta)*sin(theta);
        
    amplitudeW = pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}

double higgshamplitudedecaystau1stau2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtau, double greekmu, double Atau, double theta) ///calculates partial width for h->stau1 antistau2 or h->stau2 antistau1 as these widths have the same value
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgshsleptonsamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtau); 
  DoubleVector higgshsleptondiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtau, double greekmu, double Atau);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector hstau1stau2samehandcoupling(3);
     for (int i=1; i<=3; i++) {
     hstau1stau2samehandcoupling(i) = 0;
     }

     hstau1stau2samehandcoupling = higgshsleptonsamehandcouplings (mWboson, g, gp, alpha, beta, mtau);
     couplingLL = hstau1stau2samehandcoupling(2);
     couplingRR = hstau1stau2samehandcoupling(3);

     DoubleVector hstau1stau2diffhandcoupling(1);
     for (int i=1; i<=1; i++) {
     hstau1stau2diffhandcoupling(i) = 0;
     }

     hstau1stau2diffhandcoupling = higgshsleptondiffhandcouplings (mWboson, g, alpha, beta, mtau, greekmu, Atau);
     couplingLR = hstau1stau2diffhandcoupling(1);

     coupling = -couplingLL*cos(theta)*sin(theta) + couplingRR*sin(theta)*cos(theta) + couplingLR*cos(2*theta);
     ///coupling = -couplingLL*cos(theta)*sin(theta) + couplingRR*sin(theta)*cos(theta) - couplingLR*cos(2*theta);

    amplitudeW = pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}


double higgshtestamplitudedecaystau1stau1 (double m1, double m2, double thetatau, double g, double gp, double mWboson, double alpha, double beta, double mtau, double greekmu, double Atau) {

  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling;

  if (fabs(m1) < 2*fabs(m2)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m2)/m1,2);
    squareminus = 1 - pow((m2-m2)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

    coupling = pow(sin(thetatau),2)*(g*(mWboson*(-0.5+0.5*pow(gp/g,2))*sin(alpha+beta) + pow(mtau,2)*sin(alpha)/(mWboson*cos(beta)))) + pow(cos(thetatau),2)*(g*(-mWboson*pow(gp/g,2)*sin(alpha+beta) + pow(mtau,2)*sin(alpha)/(mWboson*cos(beta)))) + 2*cos(thetatau)*sin(thetatau)*(g*mtau/(2*mWboson*cos(beta)))*(-greekmu*cos(alpha) - Atau*sin(alpha));

    amplitudeW = pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}


double higgsHamplitudedecaystau1stau1 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtau, double greekmu, double Atau, double theta) ///calculates partial width for H->stau1 antistau1
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgsHsleptonsamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtau); 
  DoubleVector higgsHsleptondiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtau, double greekmu, double Atau);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector Hstau1stau1samehandcoupling(3);
     for (int i=1; i<=3; i++) {
     Hstau1stau1samehandcoupling(i) = 0;
     }

     Hstau1stau1samehandcoupling = higgsHsleptonsamehandcouplings (mWboson, g, gp, alpha, beta, mtau);
     couplingLL = Hstau1stau1samehandcoupling(2);
     couplingRR = Hstau1stau1samehandcoupling(3);

     DoubleVector Hstau1stau1diffhandcoupling(1);
     for (int i=1; i<=1; i++) {
     Hstau1stau1diffhandcoupling(i) = 0;
     }

     Hstau1stau1diffhandcoupling = higgsHsleptondiffhandcouplings (mWboson, g, alpha, beta, mtau, greekmu, Atau);
     couplingLR = Hstau1stau1diffhandcoupling(1);

     coupling = couplingLL*pow(sin(theta),2) + couplingRR*pow(cos(theta),2) + 2*couplingLR*cos(theta)*sin(theta);
     ///coupling = couplingLL*pow(sin(theta),2) + couplingRR*pow(cos(theta),2) - 2*couplingLR*cos(theta)*sin(theta);

    amplitudeW = pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}


double higgsHamplitudedecaystau2stau2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtau, double greekmu, double Atau, double theta) ///calculates partial width for H->stau2 antistau2
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgsHsleptonsamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtau); 
  DoubleVector higgsHsleptondiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtau, double greekmu, double Atau);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector Hstau2stau2samehandcoupling(3);
     for (int i=1; i<=3; i++) {
     Hstau2stau2samehandcoupling(i) = 0;
     }

     Hstau2stau2samehandcoupling = higgsHsleptonsamehandcouplings (mWboson, g, gp, alpha, beta, mtau);
     couplingLL = Hstau2stau2samehandcoupling(2);
     couplingRR = Hstau2stau2samehandcoupling(3);

     DoubleVector Hstau2stau2diffhandcoupling(1);
     for (int i=1; i<=1; i++) {
     Hstau2stau2diffhandcoupling(i) = 0;
     }

     Hstau2stau2diffhandcoupling = higgsHsleptondiffhandcouplings (mWboson, g, alpha, beta, mtau, greekmu, Atau);
     couplingLR = Hstau2stau2diffhandcoupling(1);

     coupling = couplingLL*pow(cos(theta),2) + couplingRR*pow(sin(theta),2) - 2*couplingLR*cos(theta)*sin(theta);
     ///coupling = couplingLL*pow(cos(theta),2) + couplingRR*pow(sin(theta),2) + 2*couplingLR*cos(theta)*sin(theta);
     
     ///cout << "coupling = " << coupling << endl;
     ///cout << "coupling LL = " << couplingLL << " coupling RR = " << couplingRR << " coupling LR = " << couplingLR << endl;
     ///cout << "mW = " << mWboson << " mtau = " << MTAU << " mH = " << m1 << " mstau2 = " << m2 << endl;
     ///cout << "Atau = " << Atau << " thetatau = " << theta << " gp = " << gp << " g = " << g << endl;
     ///cout << "alpha = " << alpha << " beta = " << beta << " mu = " << greekmu << endl;
     ///cout << "lambda = " << lambda << endl;
     ///cout << "coupling^2 = " << pow(coupling,2) << "16*PI*m1 = " << 16*PI*m1 << endl;
    amplitudeW = pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}


double higgsHamplitudedecaystau1stau2 (double m1, double m2, double m3, double g, double gp, double alpha, double beta, double mWboson, double mtau, double greekmu, double Atau, double theta) ///calculates partial width for H->stau1 antistau2 or H->stau2 antistau1 as these widths have the same value
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0, couplingLL=0, couplingRR=0, couplingLR = 0;
  DoubleVector higgsHsleptonsamehandcouplings(double mWboson, double g, double gp, double alpha, double beta, double mtau); 
  DoubleVector higgsHsleptondiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtau, double greekmu, double Atau);
  
  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector Hstau1stau2samehandcoupling(3);
     for (int i=1; i<=3; i++) {
     Hstau1stau2samehandcoupling(i) = 0;
     }

     Hstau1stau2samehandcoupling = higgsHsleptonsamehandcouplings (mWboson, g, gp, alpha, beta, mtau);
     couplingLL = Hstau1stau2samehandcoupling(2);
     couplingRR = Hstau1stau2samehandcoupling(3);

     DoubleVector Hstau1stau2diffhandcoupling(1);
     for (int i=1; i<=1; i++) {
     Hstau1stau2diffhandcoupling(i) = 0;
     }

     Hstau1stau2diffhandcoupling = higgsHsleptondiffhandcouplings (mWboson, g, alpha, beta, mtau, greekmu, Atau);
     couplingLR = Hstau1stau2diffhandcoupling(1);

     coupling = -couplingLL*cos(theta)*sin(theta) + couplingRR*sin(theta)*cos(theta) + couplingLR*cos(2*theta);
     ///coupling = -couplingLL*cos(theta)*sin(theta) + couplingRR*sin(theta)*cos(theta) - couplingLR*cos(2*theta);

    amplitudeW = pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}


double higgsAamplitudedecaysfermions (double m1, double m2, double m3, double g, double mWboson, double mf, double greekmu, double Asf, double beta, char uord) ///calculates partial width for A->sfermion1 sfermion2, these sfermions must be of the same type, note can't have decays to sfermion1 and sfermion 1 or to sfermion2 and sfermion2 by CP conservation, also note there's no dependence on sfermion mixing angle in these decays, mf is the mass of the corresponding fermion. char uord tells it whether we have up type (so Asf*cot(beta)) or down type (so Asf*tan(beta)). Finally note that the extra factor of three from colour for squarks is added above by multiplying the answer this function gives by 3
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, coupling=0;  

  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    
    if(uord == 'u') {
      coupling = g*mf/(2*mWboson)*(greekmu + Asf/(tan(beta)));
    }
    else if (uord == 'd') {
      coupling = g*mf/(2*mWboson)*(greekmu + Asf*tan(beta));
    }
    
    amplitudeW = pow(coupling,2)/(16*PI*m1)*lambda;
  }
  return amplitudeW;
}


double higgsHplusamplitudedecayquarkantiquark (double m1, double m2, double m3, double g, double mWboson, double beta, DoubleMatrix VCKM, int quark, int antiquark) ///calculates partial width for H+ ->quark1 antiquark2, this is the same as H- -> antiquark1 quark2, note the up type quark (quark1) is m2, the down type quark (quark2) is m3, the int quark is 1,2,3 (u,c,t) and int antiquark is 1,2,3 (d,s,b) then this selects VCKM matrix element VCKM(quark, antiquark)
{
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, massbetacombination=0, CKM=0;  

  if (fabs(m1) < fabs(m2) +fabs(m3)){
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
      }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);
    CKM = VCKM(quark,antiquark);
    ///cout << quark << " " << antiquark << " " << CKM << endl;
    
    massbetacombination = (pow(m3*tan(beta),2) + pow(m2/(tan(beta)),2))*(pow(m1,2) - pow(m2,2) - pow(m3,2)) - 4*pow(m2*m3,2);
    
    amplitudeW = 3*pow(g,2)*pow(CKM,2)/(32*PI*pow(mWboson,2)*m1)*massbetacombination*lambda;
  }
  return amplitudeW;
}



double higgsHplusamplitudedecayneutralinochargino (double m1, double m2, double m3, double g, double gp, double beta, double thetaL, double thetaR, DoubleMatrix mixNeut, int neutralino,  int chargino) /// Calculates the partial width for decays of the charged H+ higgs to a neutralino and a chragino Wtilda+ where neutralino is j in T&B whilst chargino is i
{
  
  double amplitudeW, squareplus, squareminus, lambda, A1=0, A2=0, A3=0, A4=0,a=0, b=0;
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    
    lambda = pow(squareplus*squareminus,0.5);
    
    ///A1 = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*sin(thetaR) + g*mixNeut(neutralino,4)*cos(thetaR);
    ///A2 = -1/(pow(2,0.5))*(-g*mixNeut(neutralino,2) - gp*mixNeut(neutralino,1))*cos(thetaR) - g*mixNeut(neutralino,4)*sin(thetaR);
    ///A3 = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*sin(thetaL) - g*mixNeut(neutralino,3)*cos(thetaL);
    ///A4 = -1/(pow(2,0.5))*(-g*mixNeut(neutralino,2) - gp*mixNeut(neutralino,1))*cos(thetaL) + g*mixNeut(neutralino,3)*sin(thetaL);
      
    A1 = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*sin(thetaR) - g*mixNeut(neutralino,4)*cos(thetaR);
    A2 = -1/(pow(2,0.5))*(-g*mixNeut(neutralino,2) - gp*mixNeut(neutralino,1))*-cos(thetaR) - g*mixNeut(neutralino,4)*sin(thetaR);
    A3 = 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*sin(thetaL) + g*mixNeut(neutralino,3)*cos(thetaL);
    A4 = -1/(pow(2,0.5))*(-g*mixNeut(neutralino,2) - gp*mixNeut(neutralino,1))*-cos(thetaL) + g*mixNeut(neutralino,3)*sin(thetaL);

    
    if (chargino == 1) {
      a = 0.5*(-cos(beta)*A2 + sin(beta)*A4);
      b = 0.5*(-cos(beta)*A2 - sin(beta)*A4);
    }
     
    else if (chargino == 2) {
      a = 0.5*(-cos(beta)*A1 + sin(beta)*A3);
      b = 0.5*(-cos(beta)*A1 - sin(beta)*A3);
    }

 
    amplitudeW = 1/(8*PI*fabs(m1))*lambda*((pow(a,2)+pow(b,2))*(pow(m1,2)-pow(m2,2)-pow(m3,2)) - 2*(pow(a,2)-pow(b,2))*m2*m3);
    ///amplitudeW = 100000000000000;
    
    ///cout << setprecision(8) << endl;
    ///cout << "a= " << a << endl;
    ///cout << "b= " << b << endl;
    ///cout << "A21*cosbeta/g= " << A2*cos(beta)/g << endl;
    ///cout << "A41*sinbeta/g= " << A4*sin(beta)/g << endl;
    ///cout << "-2(a^2 + b^2)= " << -2*(pow(a,2)+pow(b,2)) << endl;
    ///cout << "-2(a^2 - b^2)= " << -2*(pow(a,2)-pow(b,2)) << endl;
    ///cout << "(a^2 + b^2)= " << (pow(a,2)+pow(b,2)) << endl;
    ///cout << "(a^2 - b^2)= " << (pow(a,2)-pow(b,2)) << endl;
    ///cout << "(a^2 + b^2)*(m1^2 - m2^2 - m3^2)= " << (pow(a,2) + pow(b,2))*(pow(m1,2)-pow(m2,2)-pow(m3,2)) << endl;
    ///cout << "2(a^2 - b^2)m2m3= " << 2*(pow(a,2)-pow(b,2))*m2*m3 << endl;
    ///cout << "thetaR= " << thetaR << " thetaL= " << thetaL << endl;
    ///cout << "lambda= " << lambda << endl;
    ///cout << "m1 = " << m1 << " m2 = " << m2 << " m3 = " << m3 << endl;

  }
  return amplitudeW;
}



double higgsHplusamplitudedecayneutralinocharginosusyhitway (double m1, double m2, double m3, double g, double gp, double beta, double thetaL, double thetaR, DoubleMatrix mixNeut, int neutralino,  int chargino) /// neutralino is j in T&B whilst chargino is i
{
  
  double amplitudeW, squareplus, squareminus, lambda; ///A1=0, A2=0, A3=0, A4=0,a=0, b=0;
  DoubleMatrix gACNL(2,4), gACNR(2,4);
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    
    lambda = pow(squareplus*squareminus,0.5);
    
    for (int i=1; i<=2; i++) {
      for(int j=1; j<=4; j++) {
	gACNL(i,j)=0;
	gACNR(i,j)=0;
      }
    }

    
    ///gACNL(1,neutralino) = cos(beta)*(-g*mixNeut(neutralino,4)*sin(thetaR) - 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*cos(thetaR));
    ///gACNR(1,neutralino) = sin(beta)*(-g*mixNeut(neutralino,3)*sin(thetaL) + 1/(pow(2,0.5))*cos(thetaL)*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1)));
    ///gACNL(2,neutralino) = cos(beta)*(-g*cos(thetaR)*mixNeut(neutralino,4) + 1/(pow(2,0.5))*sin(thetaR)*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1)));
    ///gACNR(2,neutralino) = sin(beta)*(-g*cos(thetaL)*mixNeut(neutralino,3) - 1/(pow(2,0.5))*sin(thetaL)*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1)));
    gACNL(1,neutralino) = cos(beta)*(-g*mixNeut(neutralino,4)*sin(thetaR) + 1/(pow(2,0.5))*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1))*cos(thetaR));
    gACNR(1,neutralino) = sin(beta)*(-g*mixNeut(neutralino,3)*sin(thetaL) - 1/(pow(2,0.5))*cos(thetaL)*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1)));
    gACNL(2,neutralino) = cos(beta)*(g*cos(thetaR)*mixNeut(neutralino,4) + 1/(pow(2,0.5))*sin(thetaR)*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1)));
    gACNR(2,neutralino) = sin(beta)*(g*cos(thetaL)*mixNeut(neutralino,3) - 1/(pow(2,0.5))*sin(thetaL)*(g*mixNeut(neutralino,2) + gp*mixNeut(neutralino,1)));
       
    amplitudeW = 1/(16*PI*fabs(m1))*lambda*((pow(gACNL(chargino,neutralino),2)+pow(gACNR(chargino,neutralino),2))*(pow(m1,2)-pow(m2,2)-pow(m3,2)) - 4*gACNL(chargino,neutralino)*gACNR(chargino,neutralino)*m2*m3);

  }

  ///cout << setprecision(8) << endl;
  ///cout << "cos(thetaL)= " << cos(thetaL) << " cos(thetaR)= " << cos(thetaR) << " sin(thetaL)= " << sin(thetaL) << " sin(thetaR) = " << sin(thetaR) << endl; 
  
  return amplitudeW;
}


double higgsHplusamplitudedecayWbosonhiggsh (double m1, double m2, double m3, double g, double alpha, double beta) /// Calculates the partial width for a charged Higgs boson H+ to decay to a Wboson and a neutral light scalar higgs (i.e. the SM-like higgs) h, m2 must be the W boson mass
{
  
  double amplitudeW, squareplus, squareminus, lambda;
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    amplitudeW = 0;
  }

  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    
    lambda = pow(squareplus*squareminus,0.5);
    
    amplitudeW = pow(g,2)*pow(cos(beta-alpha),2)*pow(m1,3)/(64*PI*pow(m2,2))*pow(lambda,3);

    ///cout << "my CWH equiv " << pow(lambda,3)*pow(m1/m2,4) << endl;
    ///cout << "cos(beta-alpha)= " << cos(beta-alpha) << endl;
        
  }
  return amplitudeW;
}


DoubleVector higgsHplusamplitudedecaysquarksquark (double m1, double m2, double m3, double g, double beta, double mWboson, double mup, double mdown, double greekmu, double Aup, double Adown) ///calculates partial width for Hplus->squarki antisquarkj where i,j are each L/R so no mixing, i.e. first two generations of squarks
{
  double squareplus=0, squareminus=0, lambda=0; 
  DoubleVector higgsHplussquarkcouplings (double mWboson, double g, double beta, double mup, double mdown, double greekmu, double Au, double Ad);
  DoubleVector amplitudeW(4);
  for (int i=1; i<=4; i++) {
    amplitudeW(i) = 0;
  }    
  
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    for(int i=1; i<=4; i++) {
      amplitudeW(i) = 0;
    }
  }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector Hplussquarksquarkcoupling(4);
     for (int i=1; i<=4; i++) {
     Hplussquarksquarkcoupling(i) = 0;
     }

     Hplussquarksquarkcoupling = higgsHplussquarkcouplings (mWboson, g, beta, mup, mdown, greekmu, Aup, Adown);
     
     amplitudeW(1) = pow(Hplussquarksquarkcoupling(1),2)*3/(16*PI*m1)*lambda;
     amplitudeW(2) = pow(Hplussquarksquarkcoupling(2),2)*3/(16*PI*m1)*lambda;
     amplitudeW(3) = pow(Hplussquarksquarkcoupling(3),2)*3/(16*PI*m1)*lambda;
     amplitudeW(4) = pow(Hplussquarksquarkcoupling(4),2)*3/(16*PI*m1)*lambda;

     ///cout << "g^2 * mW^2 = " << pow(g*mWboson,2) << endl;
  }
  return amplitudeW;
}


DoubleVector higgsHplusamplitudedecaysquarksquarkmix (double m1, double m2, double m3, double g, double beta, double mWboson, double mtop, double mbottom, double greekmu, double Atop, double Abottom, double thetatop, double thetabottom) ///calculates partial width for Hplus->squarki antisquarkj where i,j are each 1/2 so mixing included, i.e. third generations of squarks
{
  double squareplus=0, squareminus=0, lambda=0, coupling11=0, coupling22=0, coupling12=0, coupling21=0; 
  DoubleVector higgsHplussquarkcouplings (double mWboson, double g, double beta, double mtop, double mbottom, double greekmu, double At, double Ab);
  DoubleVector amplitudeW(4);
  for (int i=1; i<=4; i++) {
    amplitudeW(i) = 0;
  }    
  
  if (fabs(m1) < fabs(m2) +fabs(m3)) {
    ///cout << "Final product states heavier than initial states - decay not allowed" << endl;
    for(int i=1; i<=4; i++) {
      amplitudeW(i) = 0;
    }
  }
  
  else { 
    ///cout << "I think m1= " << m1 << " m2= " << m2 << " m3= " << m3 << endl;
    squareplus = 1 - pow((m2+m3)/m1,2);
    squareminus = 1 - pow((m2-m3)/m1,2);
    lambda = pow(squareplus*squareminus,0.5);

     DoubleVector Hplussquarksquarkcoupling(4);
     for (int i=1; i<=4; i++) {
     Hplussquarksquarkcoupling(i) = 0;
     }

     Hplussquarksquarkcoupling = higgsHplussquarkcouplings (mWboson, g, beta, mtop, mbottom, greekmu, Atop, Abottom);
     
     coupling11 = Hplussquarksquarkcoupling(1)*cos(thetatop)*cos(thetabottom) + Hplussquarksquarkcoupling(2)*sin(thetatop)*sin(thetabottom) - Hplussquarksquarkcoupling(3)*cos(thetatop)*sin(thetabottom) - Hplussquarksquarkcoupling(4)*sin(thetatop)*cos(thetabottom);
     coupling22 = Hplussquarksquarkcoupling(1)*sin(thetatop)*sin(thetabottom) + Hplussquarksquarkcoupling(2)*cos(thetatop)*cos(thetabottom) + Hplussquarksquarkcoupling(3)*sin(thetatop)*cos(thetabottom) + Hplussquarksquarkcoupling(4)*cos(thetatop)*sin(thetabottom);
     coupling12 = Hplussquarksquarkcoupling(1)*cos(thetatop)*sin(thetabottom) - Hplussquarksquarkcoupling(2)*sin(thetatop)*cos(thetabottom) + Hplussquarksquarkcoupling(3)*cos(thetatop)*cos(thetabottom) - Hplussquarksquarkcoupling(4)*sin(thetatop)*sin(thetabottom);
     coupling21 = Hplussquarksquarkcoupling(1)*sin(thetatop)*cos(thetabottom) - Hplussquarksquarkcoupling(2)*cos(thetatop)*sin(thetabottom) - Hplussquarksquarkcoupling(3)*sin(thetatop)*sin(thetabottom) + Hplussquarksquarkcoupling(4)*cos(thetatop)*cos(thetabottom);

     amplitudeW(1) = pow(coupling11,2)*3/(16*PI*m1)*lambda;
     amplitudeW(2) = pow(coupling22,2)*3/(16*PI*m1)*lambda;
     amplitudeW(3) = pow(coupling12,2)*3/(16*PI*m1)*lambda;
     amplitudeW(4) = pow(coupling21,2)*3/(16*PI*m1)*lambda;
     
     ///cout << setprecision(8);
     ///cout << "g^2 * mW^2 = " << pow(g*mWboson,2) << endl;
     ///cout << thetabottom << endl;
     ///cout << "lambda = " << lambda << " couplingLL/(g*mW) = " << Hplussquarksquarkcoupling(1)/(g*mWboson) << " couplingLR/(g*mW) = " << Hplussquarksquarkcoupling(3)/(g*mWboson) << endl;
     ///cout << " coupling11/(g*mW) = " << coupling11/(g*mWboson) << " coupling12/(g*mW) = " << coupling12/(g*mWboson) << endl;
     ///cout << "g^2*mW^2/(16*PI*m1) = " << pow(g*mWboson,2)/(16*PI*m1) << endl;
  }
  return amplitudeW;
}

double higgsesamplitudedecaygammagammatotal(double m1, double g, double gprime, double mWboson, double polemw, double alpha, double beta, double mtop, double mbottom, double mcharm, double mtau, double mHpm, double mstop1, double mstop2, double msbottom1, double msbottom2, double mstau1, double mstau2, double mchargino1, double mchargino2, double thetaL, double thetaR, double thetat, double thetab, double thetatau, double greekmu, double Atop, double Abottom, double Atau, char higgstype) /// function that calculates the partial width for h->gamma gamma at 1-loop (forbidden at tree-level)
{
  double prefactor=0, Itr=0, Iti=0, Ist1r=0, Ist1i=0, Ist2r=0, Ist2i=0, Ibr=0, Ibi=0, Isb1r=0, Isb1i=0, Isb2r=0, Isb2i=0, Icr=0, Ici=0, Itaur=0, Itaui=0, Istau1r=0, Istau1i=0, Istau2r=0, Istau2i=0, IWr=0, IWi=0, IHpmr=0, IHpmi=0, Ichar1r=0, Ichar1i=0, Ichar2r=0, Ichar2i=0, matelemmodsquare=0, amplitudeW=0;
  DoubleVector higgsmatrixelementgammagammaviatops (double m1, double mtop, double alpha, double beta, char higgstype);
  DoubleVector higgsmatrixelementgammagammaviastops (double m1, double mstop1, double mstop2, double mtop, double mbottom, double mWboson, double thetat, double g, double gprime, double alpha, double beta, double greekmu, double Atop, double Abottom, char higgstype);
  DoubleVector higgsmatrixelementgammagammaviabottoms (double m1, double mbottom, double alpha, double beta, char higgstype);
  DoubleVector higgsmatrixelementgammagammaviasbottoms (double m1, double msbottom1, double msbottom2, double mbottom, double mtop, double mWboson, double thetab, double g, double gprime, double alpha, double beta, double Atop, double Abottom, double greekmu, char higgstype);
  DoubleVector higgsmatrixelementgammagammaviastaus (double m1, double mstau1, double mstau2, double mtau, double mWboson, double thetatau, double g, double gprime, double alpha, double beta, double greekmu, double Atau, char higgstype);
  DoubleVector higgsmatrixelementgammagammaviaWbosons (double m1, double mWboson, double alpha, double beta, double g, double gprime, char higgstype);
  DoubleVector higgsmatrixelementgammagammaviaHpms (double m1, double mHpm, double mWboson, double alpha, double beta, double g, double gprime, char higgstype);
  DoubleVector higgsmatrixelementgammagammaviachargino1s (double m1, double mchargino1, double mWboson, double alpha, double beta, double thetaL, double thetaR, char higgstype);
  DoubleVector higgsmatrixelementgammagammaviachargino2s (double m1, double mchargino2, double mWboson, double alpha, double beta, double thetaL, double thetaR, char higgstype);
  DoubleVector higgsmatrixelementgammagammaviacharms (double m1, double mcharm, double alpha, double beta, char higgstype);
  DoubleVector higgsmatrixelementgammagammaviataus (double m1, double mtau, double alpha, double beta, char higgstype);

  

  Itr = higgsmatrixelementgammagammaviatops (m1, mtop, alpha, beta, higgstype)(1);
  Iti = higgsmatrixelementgammagammaviatops (m1, mtop, alpha, beta, higgstype)(2);
  Ist1r = higgsmatrixelementgammagammaviastops (m1, mstop1, mstop2, mtop, mbottom, mWboson, thetat, g, gprime, alpha, beta, greekmu, Atop, Abottom, higgstype)(1);
  Ist1i = higgsmatrixelementgammagammaviastops (m1, mstop1, mstop2, mtop, mbottom, mWboson, thetat, g, gprime, alpha, beta, greekmu, Atop, Abottom, higgstype)(2);
  Ist2r = higgsmatrixelementgammagammaviastops (m1, mstop1, mstop2, mtop, mbottom, mWboson, thetat, g, gprime, alpha, beta, greekmu, Atop, Abottom, higgstype)(3);
  Ist2i = higgsmatrixelementgammagammaviastops (m1, mstop1, mstop2, mtop, mbottom, mWboson, thetat, g, gprime, alpha, beta, greekmu, Atop, Abottom, higgstype)(4);
  Ibr = higgsmatrixelementgammagammaviabottoms (m1, mbottom, alpha, beta, higgstype)(1);
  Ibi = higgsmatrixelementgammagammaviabottoms (m1, mbottom, alpha, beta, higgstype)(2);
  Isb1r = higgsmatrixelementgammagammaviasbottoms (m1, msbottom1, msbottom2, mbottom, mtop, mWboson, thetab, g, gprime, alpha, beta, Atop, Abottom, greekmu, higgstype)(1);
  Isb1i = higgsmatrixelementgammagammaviasbottoms (m1, msbottom1, msbottom2, mbottom, mtop, mWboson, thetab, g, gprime, alpha, beta, Atop, Abottom, greekmu, higgstype)(2);
  Isb2r = higgsmatrixelementgammagammaviasbottoms (m1, msbottom1, msbottom2, mbottom, mtop, mWboson, thetab, g, gprime, alpha, beta, Atop, Abottom, greekmu, higgstype)(3);
  Isb2i = higgsmatrixelementgammagammaviasbottoms (m1, msbottom1, msbottom2, mbottom, mtop, mWboson, thetab, g, gprime, alpha, beta, Atop, Abottom, greekmu, higgstype)(4);
  Icr = higgsmatrixelementgammagammaviacharms (m1, mcharm, alpha, beta, higgstype)(1);
  Ici = higgsmatrixelementgammagammaviacharms (m1, mcharm, alpha, beta, higgstype)(2);
  Itaur = higgsmatrixelementgammagammaviataus (m1, mtau, alpha, beta, higgstype)(1);
  Itaui = higgsmatrixelementgammagammaviataus (m1, mtau, alpha, beta, higgstype)(2);
  Istau1r = higgsmatrixelementgammagammaviastaus (m1, mstau1, mstau2, mtau, mWboson, thetatau, g, gprime, alpha, beta, greekmu, Atau, higgstype)(1);
  Istau1i = higgsmatrixelementgammagammaviastaus (m1, mstau1, mstau2, mtau, mWboson, thetatau, g, gprime, alpha, beta, greekmu, Atau, higgstype)(2);
  Istau2r = higgsmatrixelementgammagammaviastaus (m1, mstau1, mstau2, mtau, mWboson, thetatau, g, gprime, alpha, beta, greekmu, Atau, higgstype)(3);
  Istau2i = higgsmatrixelementgammagammaviastaus (m1, mstau1, mstau2, mtau, mWboson, thetatau, g, gprime, alpha, beta, greekmu, Atau, higgstype)(4);
  IWr = higgsmatrixelementgammagammaviaWbosons (m1, polemw, alpha, beta, g, gprime, higgstype)(1);
  IWi = higgsmatrixelementgammagammaviaWbosons (m1, polemw, alpha, beta, g, gprime, higgstype)(2);
  IHpmr = higgsmatrixelementgammagammaviaHpms (m1, mHpm, mWboson, alpha, beta, g, gprime, higgstype)(1);
  IHpmi = higgsmatrixelementgammagammaviaHpms (m1, mHpm, mWboson, alpha, beta, g, gprime, higgstype)(2);
  Ichar1r = higgsmatrixelementgammagammaviachargino1s (m1, mchargino1, mWboson, alpha, beta, thetaL, thetaR, higgstype)(1);
  Ichar1i = higgsmatrixelementgammagammaviachargino1s (m1, mchargino1, mWboson, alpha, beta, thetaL, thetaR, higgstype)(2);
  Ichar2r = higgsmatrixelementgammagammaviachargino2s (m1, mchargino2, mWboson, alpha, beta, thetaL, thetaR, higgstype)(1);
  Ichar2i = higgsmatrixelementgammagammaviachargino2s (m1, mchargino2, mWboson, alpha, beta, thetaL, thetaR, higgstype)(2);

  DoubleVector matelemsum(2);
  matelemsum(1) = Itr + Ist1r + Ist2r + Ibr + Isb1r + Isb2r + Icr + Itaur + Istau1r + Istau2r + IWr + IHpmr + Ichar1r + Ichar2r;
  matelemsum(2) = Iti + Ist1i + Ist2i + Ibi + Isb1i + Isb2i + Ici + Itaui + Istau1i + Istau2i + IWi + IHpmi + Ichar1i + Ichar2i;
  
  // cout << "Itr = " << Itr << " Iti = " << Iti << endl;
  // cout << "IWr = " << IWr << " IWi = " << IWi << endl;

  double alphaEmcalc = pow(g*gprime/(pow(pow(g,2)+pow(gprime,2),0.5)),2)/(4*PI);
  prefactor = (pow(g,2)*pow(alphaEmcalc,2))/(1024*pow(PI,3))*pow(m1,3)/pow(mWboson,2);
  ///cout << alphaEm << endl;
  ///cout << pow(g,2)*pow(alphaEm,2) << " " << 1/(pow(PI,3)*1024)*pow(m1,3)/(pow(mWboson,2)) << endl;
  
  /// cout << "Input parameters!: " << endl;
  /// cout << "mh0(1) = " << m1 << " g= " << g << " gprime= " << gprime << " mWboson= " << mWboson << endl;
  /// cout << "polemw = " << polemw << " alpha = " << alpha << " beta = " << beta << " mtop= " << mtop << " mbottom= " << mbottom << endl;
  /// cout << "mbottom= " << mbottom << " mcharm= " << mcharm << " mtau= " << mtau << " mHpm= " << mHpm << endl;
  /// cout << "mstop1= " << mstop1 << " mstop2= " << mstop2 << " msbottom1= " << msbottom1 << " msbottom2= " << msbottom2 << endl;
  /// cout << "mstau1= " << mstau1 << " mstau2= " << mstau2 << " mchargino1= " << mchargino1 << " mchargino2= " << mchargino2 << endl;
  /// cout << "thetaL= " << thetaL << " thetaR= " << thetaR << " thetat= " << thetat << " thetab= " << thetab << endl;
  /// cout << "thetatau= " << thetatau << " greekmu= " << greekmu << " Atop= " << Atop << " Abottom= " << Abottom << endl;

  ///cout << setprecision(12) << endl;
  ///cout << "alphaEmcalc= " << alphaEmcalc << endl;
  ///cout << "prefactor= " << prefactor << endl;
  ///cout << "Itr= " << Itr << " Iti= " << Iti << " Ist1r= " << Ist1r << " Ist1i= " << Ist1i <<  " Ist2r= " << Ist2r << " Ist2i= " << Ist2i << endl;
  ///cout << "Ibr= " << Ibr << " Ibi= " << Ibi << " Isb1r= " << Isb1r << " Isb1i= " << Isb1i << " Isb2r= " << Isb2r << " Isb2i= " << Isb2i << endl;
  ///cout << "Icr= " << Icr << " Ici= " << Ici << " Itaur= " << Itaur << " Itaui= " << Itaui << endl;
  ///cout << "Istau1r= " << Istau1r << " Istau1i= " << Istau1i << " Istau2r= " << Istau2r << " Istau2i= " << Istau2i << " IWr= " << IWr << " IWi= " << IWi << endl;
  ///cout << "IHpmr= " << IHpmr << " IHpmi= " << IHpmi << " Ichar1r= " << Ichar1r << " Ichar1i= " << Ichar1i << " Ichar2r= " << Ichar2r << " Ichar2i= " << Ichar2i << endl;
  ///cout << "matelemsumr= " << matelemsum(1) << endl;
  ///cout << "matelemsumi= " << matelemsum(2) << endl;
  
  ///cout << setprecision(12) << endl;
  matelemmodsquare = pow(matelemsum(1),2) + pow(matelemsum(2),2);
  amplitudeW = prefactor*matelemmodsquare;
  ///cout << "((alpha/pi)^2)/16= " << pow(pow(gprime,2)/(4*PI),2)/16 << endl;
  ///cout << "alpha= " << pow(gprime,2)/(4*PI) << endl;
  ///double comp1 = pow(mWboson/msbottom1,2)*(pow(cos(thetab),2)*(-0.5-pow(gprime/g,2)/6)*sin(beta+alpha) + pow(sin(thetab),2)*-pow(gprime/g,2)/3*sin(beta+alpha));
  ///double comp2 = pow(mWboson/msbottom1,2)*pow(mbottom/mWboson,2)*sin(alpha)/(cos(beta));
  ///double comp3 = pow(mWboson/msbottom1,2)*(mbottom*sin(thetab)*cos(thetab)/(pow(mWboson,2)*cos(beta))*(greekmu*cos(alpha)+Abottom*sin(alpha)));
  ///cout << "comp1= " << comp1 << endl;
  ///cout << "comp2= " << comp2 << endl;
  ///cout << "comp3= " << comp3 << endl;
  
     
  return amplitudeW;
  
  

}

DoubleVector higgsmatrixelementgammagammaviatops (double m1, double mtop, double alpha, double beta, char higgstype) ///function that calculates the part of the matrix element that differs depending on the loop particles, in this case it calculates it for tops in the loop.
{
  DoubleVector foftau(double mpart, double mcomp);
  DoubleVector f(3), F1over2(2), It(2);
  double Rt=0;
  for (int i=1; i<=3; i++) {
    f(i) = 0;
  }

  for (int j=1; j<=2; j++) {
    F1over2(j) = 0;
    It(j) = 0;
  }
    
  f = foftau(mtop, m1);
  if (higgstype == 'h')
    {
      F1over2(1) = -2*f(3)*(1+(1-f(3))*f(1));
      F1over2(2) = -2*f(3)*((1-f(3))*f(2));
      Rt = cos(alpha)/sin(beta);
    }
  else if (higgstype == 'H')
    {
      F1over2(1) = -2*f(3)*(1+(1-f(3))*f(1));
      F1over2(2) = -2*f(3)*((1-f(3))*f(2));
      Rt = sin(alpha)/sin(beta);
      ///cout << "F1over2 for H to tops= " << F1over2 << endl;
    }
  else if (higgstype == 'A')
    {
      F1over2(1) = -2*f(3)*f(1);
      F1over2(2) = -2*f(3)*f(2);
      Rt = 1/(tan(beta));
      ///cout << "Rt for A= " << Rt << endl;
      ///cout << "F1over2 for A to tops= " << F1over2 << endl;
    }
   
  ///cout << "mtop= " << mtop << endl;
  ///cout << "taufortops= " << f(3) << " therefore f(2)= " << f(2) << endl;
  It(1) = 3*4./9*Rt*F1over2(1);
  It(2) = 3*4./9*Rt*F1over2(2);
  return It;
}

DoubleVector higgsmatrixelementgammagammaviastops (double m1, double mstop1, double mstop2, double mtop, double mbottom, double mWboson, double thetat, double g, double gprime, double alpha, double beta,double greekmu, double Atop, double Abottom, char higgstype) ///function that calculates the part of the matrix element that differs depending on the loop particles, in this case it calculates it for stop1s and for stop2s in the loop.
{
  DoubleVector foftau(double mpart, double mcomp);
  DoubleVector f1(3), f2(3), F01(2), F02(2), Ist1(2), Ist2(2), Istopsboth(4);
  DoubleVector higgshsquarksamehandcouplings(double mWboson, double g, double gprime, double alpha, double beta, double mtop, double mbottom);
  DoubleVector higgshsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtop, double mbottom, double greekmu, double Atop, double Abottom);
  DoubleVector higgsHsquarksamehandcouplings(double mWboson, double g, double gprime, double alpha, double beta, double mtop, double mbottom);
  DoubleVector higgsHsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtop, double mbottom, double greekmu, double Atop, double Abottom);
  double Rst1=0, Rst2=0, RstL=0, RstR=0, RstLR=0, RstL1=0, RstL2=0, RstR1=0, RstR2=0, RstLR1=0, RstLR2=0;

  for (int i=1; i<=3;i++) {
    f1(i) = 0;
    f2(i) = 0;
  }
  for (int j=1; j<=2;j++) {
    F01(j) = 0;
    F02(j) = 0;
    Ist1(j) = 0;
    Ist2(j) = 0;
  }
  for (int k=1; k<=4; k++) {
    Istopsboth(k) = 0;
  }

  DoubleVector ststsamehandcoupling(4);
  for (int i=1; i<=4; i++) {
  ststsamehandcoupling(i) = 0;
  }

  DoubleVector ststdiffhandcoupling(2);
  for (int i=1; i<=2; i++) {
  ststdiffhandcoupling(i) = 0;
  }
  
  f1 = foftau(mstop1, m1);
  f2 = foftau(mstop2, m1);
  if (higgstype == 'h')
    {
      ///Rt = cos(alpha)/sin(beta);
      ///RstL = pow(mtop*costhetaW/mWboson,2)*Rt- (0.5-2*pow(sinthetaW,2)/3)*sin(beta-alpha);
      ///RstR = pow(mtop*costhetaW/mWboson,2)*Rt+ (-2*pow(sinthetaW,2)/3)*sin(beta-alpha);
      ///Rst1 = cos(thetat)*RstL + sin(thetat)*RstR;
      ///Rst2 = -sin(thetat)*RstL + cos(thetat)*RstR;
      ststsamehandcoupling = higgshsquarksamehandcouplings (mWboson, g, gprime, alpha, beta, mtop, mbottom);
      RstL = ststsamehandcoupling(1);
      RstL1 = RstL*mWboson/(g*pow(mstop1,2));
      RstL2 = RstL*mWboson/(g*pow(mstop2,2));
      RstR = ststsamehandcoupling(3);
      RstR1 = RstR*mWboson/(g*pow(mstop1,2));
      RstR2 = RstR*mWboson/(g*pow(mstop2,2));
      ///cout << " greekmu = " << greekmu << " Atop= " << Atop << " Abottom= " << Abottom << endl;
      ststdiffhandcoupling = higgshsquarkdiffhandcouplings (mWboson, g, alpha, beta, mtop, mbottom, greekmu, Atop, Abottom);
      RstLR = ststdiffhandcoupling(1);
      RstLR1 = RstLR*mWboson/(g*pow(mstop1,2));
      RstLR2 = RstLR*mWboson/(g*pow(mstop2,2));
      Rst1 = RstL1*pow(cos(thetat),2) + RstR1*pow(sin(thetat),2) - 2*RstLR1*cos(thetat)*sin(thetat);
      Rst2 = RstL2*pow(sin(thetat),2) + RstR2*pow(cos(thetat),2) + 2*RstLR2*cos(thetat)*sin(thetat);
      ///cout << "RST2= " << Rst2 << endl;
    }
  else if (higgstype == 'H')
    {
      ///Rt = -sin(alpha)/sin(beta);
      ///RstL = pow(mtop*costhetaW/mWboson,2)*Rt+ (0.5-2*pow(sinthetaW,2)/3)*cos(beta-alpha);
      /// RstR = pow(mtop*costhetaW/mWboson,2)*Rt- (-2*pow(sinthetaW,2)/3)*cos(beta-alpha);
      ///Rst1 = cos(thetat)*RstL + sin(thetat)*RstR;
      ///Rst2 = -sin(thetat)*RstL + cos(thetat)*RstR;      
      ststsamehandcoupling = higgsHsquarksamehandcouplings (mWboson, g, gprime, alpha, beta, mtop, mbottom);
      RstL = ststsamehandcoupling(1);
      RstL1 = RstL*mWboson/(g*pow(mstop1,2));
      RstL2 = RstL*mWboson/(g*pow(mstop2,2));
      RstR = ststsamehandcoupling(3);
      RstR1 = RstR*mWboson/(g*pow(mstop1,2));
      RstR2 = RstR*mWboson/(g*pow(mstop2,2));
      ///cout << " greekmu = " << greekmu << " Atop= " << Atop << " Abottom= " << Abottom << endl;
      ststdiffhandcoupling = higgsHsquarkdiffhandcouplings (mWboson, g, alpha, beta, mtop, mbottom, greekmu, Atop, Abottom);
      RstLR = ststdiffhandcoupling(1);
      RstLR1 = RstLR*mWboson/(g*pow(mstop1,2));
      RstLR2 = RstLR*mWboson/(g*pow(mstop2,2));
      Rst1 = RstL1*pow(cos(thetat),2) + RstR1*pow(sin(thetat),2) - 2*RstLR1*cos(thetat)*sin(thetat);
      Rst2 = RstL2*pow(sin(thetat),2) + RstR2*pow(cos(thetat),2) + 2*RstLR2*cos(thetat)*sin(thetat);
      ///cout << "RST1= " << Rst1 << endl;
    }
  else if (higgstype == 'A')
    {
      // Rt = 1/(tan(beta));
      RstL=0;
      RstR=0;
      Rst1 = cos(thetat)*RstL + sin(thetat)*RstR;
      Rst2 = -sin(thetat)*RstL + cos(thetat)*RstR;
    }
  
  F01(1) = f1(3)*(1-f1(3)*f1(1));
  F01(2) = f1(3)*(-f1(3)*f1(2));
  F02(1) = f2(3)*(1-f2(3)*f2(1));
  F02(2) = f2(3)*(-f2(3)*f2(2));

  ///cout << "F02 for stop2s= " << F02 << endl;

  Ist1(1) = 3*4./9*Rst1*F01(1);
  Ist1(2) = 3*4./9*Rst1*F01(2);
  Ist2(1) = 3*4./9*Rst2*F02(1);
  Ist2(2) = 3*4./9*Rst2*F02(2);
  Istopsboth(1) = Ist1(1);
  Istopsboth(2) = Ist1(2);
  Istopsboth(3) = Ist2(1);
  Istopsboth(4) = Ist2(2);
  return Istopsboth;
}  



DoubleVector higgsmatrixelementgammagammaviabottoms (double m1, double mbottom, double alpha, double beta, char higgstype) ///function that calculates the part of the matrix element that differs depending on the loop particles, in this case it calculates it for bottoms in the loop.
{
  DoubleVector foftau(double mpart, double mcomp);
  DoubleVector f(3), F1over2(2), Ib(2);
  double Rb=0;
  for (int i=1; i<=3;i++) {
    f(i) = 0;
  }
  for (int j=1; j<=2;j++) {
    F1over2(j) = 0;
    Ib(j) = 0;
  }
    
  f = foftau(mbottom, m1);
  ///cout << "foftau(bottom) = " << f << endl;
  ///cout << "mbottom= " << mbottom << endl;
  ///cout << "tau should= " << 4*pow(mbottom/m1,2) << endl;
  if (higgstype == 'h')
    {
      F1over2(1) = -2*f(3)*(1+(1-f(3))*f(1));
      F1over2(2) = -2*f(3)*((1-f(3))*f(2));
      Rb = -sin(alpha)/cos(beta);
    }
  else if (higgstype == 'H')
    {
      F1over2(1) = -2*f(3)*(1+(1-f(3))*f(1));
      F1over2(2) = -2*f(3)*((1-f(3))*f(2));
      Rb = cos(alpha)/cos(beta);
    }
  else if (higgstype == 'A')
    {
      F1over2(1) = -2*f(3)*f(1);
      F1over2(2) = -2*f(3)*f(2);
      Rb = tan(beta);
    }
   
  Ib(1) = 3*1./9*Rb*F1over2(1);
  Ib(2) = 3*1./9*Rb*F1over2(2);
  return Ib;
}  


 DoubleVector higgsmatrixelementgammagammaviasbottoms (double m1, double msbottom1, double msbottom2, double mbottom, double mtop, double mWboson, double thetab, double g, double gprime, double alpha, double beta, double Atop, double Abottom, double greekmu, char higgstype) ///function that calculates the part of the matrix element that differs depending on the loop particles, in this case it calculates it for sbottom1s and for sbottom2s in the loop.
{
  DoubleVector foftau(double mpart, double mcomp);
  DoubleVector f1(3), f2(3), F01(2), F02(2), Isb1(2), Isb2(2), Isbottomsboth(4);
  DoubleVector higgshsquarksamehandcouplings(double mWboson, double g, double gprime, double alpha, double beta, double mtop, double mbottom);
  DoubleVector higgshsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtop, double mbottom, double greekmu, double Atop, double Abottom);
  DoubleVector higgsHsquarksamehandcouplings(double mWboson, double g, double gprime, double alpha, double beta, double mtop, double mbottom);
  DoubleVector higgsHsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mtop, double mbottom, double greekmu, double Atop, double Abottom);
  double Rsb1=0, Rsb2=0, RsbL=0, RsbR=0, RsbLR=0, RsbL1=0, RsbL2=0, RsbR1=0, RsbR2=0, RsbLR1=0, RsbLR2=0;
  for (int i=1; i<=3;i++) {
    f1(i) = 0;
    f2(i) = 0;
  }
  for (int j=1; j<=2;j++) {
    F01(j) = 0;
    F02(j) = 0;
    Isb1(j) = 0;
    Isb2(j) = 0;
  }
  for (int k=1; k<=4; k++) {
    Isbottomsboth(k) = 0;
  }

  DoubleVector sbsbsamehandcoupling(4);
  for (int i=1; i<=4; i++) {
  sbsbsamehandcoupling(i) = 0;
  }

  DoubleVector sbsbdiffhandcoupling(2);
  for (int i=1; i<=2; i++) {
  sbsbdiffhandcoupling(i) = 0;
  }
  

  f1 = foftau(msbottom1, m1);
  f2 = foftau(msbottom2, m1);
    
  ///  cout << "foftaureal for sbottomIs= " << f1 << " foftauimag for sbottomIs= " << f2 << endl; 
  if (higgstype == 'h')
    {
      sbsbsamehandcoupling = higgshsquarksamehandcouplings (mWboson, g, gprime, alpha, beta, mtop, mbottom);
      RsbL = sbsbsamehandcoupling(2);
      RsbL1 = RsbL*mWboson/(g*pow(msbottom1,2));
      RsbL2 = RsbL*mWboson/(g*pow(msbottom2,2));
      RsbR = sbsbsamehandcoupling(4);
      RsbR1 = RsbR*mWboson/(g*pow(msbottom1,2));
      RsbR2 = RsbR*mWboson/(g*pow(msbottom2,2));
      ///cout << " greekmu = " << greekmu << " Atop= " << Atop << " Abottom= " << Abottom << endl;
      sbsbdiffhandcoupling = higgshsquarkdiffhandcouplings (mWboson, g, alpha, beta, mtop, mbottom, greekmu, Atop, Abottom);
      RsbLR = sbsbdiffhandcoupling(2);
      RsbLR1 = RsbLR*mWboson/(g*pow(msbottom1,2));
      RsbLR2 = RsbLR*mWboson/(g*pow(msbottom2,2));
      Rsb1 = RsbL1*pow(cos(thetab),2) + RsbR1*pow(sin(thetab),2) - 2*RsbLR1*cos(thetab)*sin(thetab);
      Rsb2 = RsbL2*pow(sin(thetab),2) + RsbR2*pow(cos(thetab),2) + 2*RsbLR2*cos(thetab)*sin(thetab);
      /// cout << "RSbLhere= " << RsbL << endl;
      ///cout << "RSbRhere= " << RsbR << endl;
      ///cout << "RSbLRhere= " << RsbLR << endl;
      ///cout << "Rsb1here= " << Rsb1 << endl;
      ///cout << "RsbL1here= " << RsbL1 << endl;
      ///cout << "RsbR1here= " << RsbR1 << endl;
      ///cout << "RsbLR1here= " << RsbLR1 << endl;
      /// Rb = -sin(alpha)/cos(beta);
      /// RsbL = pow(mbottom*costhetaW/mWboson,2)*Rb- (-0.5+1*pow(sinthetaW,2)/3)*sin(beta-alpha);
      /// RsbR = pow(mbottom*costhetaW/mWboson,2)*Rb+ (1*pow(sinthetaW,2)/3)*sin(beta-alpha);
      /// Rsb1 = cos(thetab)*RsbL + sin(thetab)*RsbR;
      /// Rsb2 = -sin(thetab)*RsbL + cos(thetab)*RsbR;
    }
  else if (higgstype == 'H')
    {
      sbsbsamehandcoupling = higgsHsquarksamehandcouplings (mWboson, g, gprime, alpha, beta, mtop, mbottom);
      RsbL = sbsbsamehandcoupling(2);
      RsbL1 = RsbL*mWboson/(g*pow(msbottom1,2));
      RsbL2 = RsbL*mWboson/(g*pow(msbottom2,2));
      RsbR = sbsbsamehandcoupling(4);
      RsbR1 = RsbR*mWboson/(g*pow(msbottom1,2));
      RsbR2 = RsbR*mWboson/(g*pow(msbottom2,2));
      ///cout << " greekmu = " << greekmu << " Atop= " << Atop << " Abottom= " << Abottom << endl;
      sbsbdiffhandcoupling = higgsHsquarkdiffhandcouplings (mWboson, g, alpha, beta, mtop, mbottom, greekmu, Atop, Abottom);
      RsbLR = sbsbdiffhandcoupling(2);
      RsbLR1 = RsbLR*mWboson/(g*pow(msbottom1,2));
      RsbLR2 = RsbLR*mWboson/(g*pow(msbottom2,2));
      Rsb1 = RsbL1*pow(cos(thetab),2) + RsbR1*pow(sin(thetab),2) - 2*RsbLR1*cos(thetab)*sin(thetab);
      Rsb2 = RsbL2*pow(sin(thetab),2) + RsbR2*pow(cos(thetab),2) + 2*RsbLR2*cos(thetab)*sin(thetab);
      /// Rb = cos(alpha)/cos(beta);
      /// RsbL = pow(mbottom*costhetaW/mWboson,2)*Rb+ (-0.5+1*pow(sinthetaW,2)/3)*cos(beta-alpha);
      /// RsbR = pow(mbottom*costhetaW/mWboson,2)*Rb- (1*pow(sinthetaW,2)/3)*cos(beta-alpha);
      /// Rsb1 = cos(thetab)*RsbL + sin(thetab)*RsbR;
      /// Rsb2 = -sin(thetab)*RsbL + cos(thetab)*RsbR; 
      ///cout << "RSbLhere= " << RsbL << endl;
      ///cout << "RSbRhere= " << RsbR << endl;
      ///cout << "RSbLRhere= " << RsbLR << endl;
      ///cout << "Rsb1here= " << Rsb1 << endl;
      ///cout << "RsbL1here= " << RsbL1 << endl;
      ///cout << "RsbR1here= " << RsbR1 << endl;
      ///cout << "RsbLR1here= " << RsbLR1 << endl;
      ///double compHRsbL = g*(mWboson*(0.5+pow(gprime/g,2)/6)*cos(beta+alpha) - pow(mbottom,2)*cos(alpha)/(mWboson*cos(beta)));
      ///double compHRsbR = g*(mWboson*(pow(gprime/g,2)/3)*cos(beta+alpha) - pow(mbottom,2)*cos(alpha)/(mWboson*cos(beta)));
      ///double compHRsbLR = g*mbottom/(2*mWboson*cos(beta))*(-greekmu*sin(alpha)+Abottom*cos(alpha));
      ///cout << "compHRsbL= " << compHRsbL << endl;
      ///cout << "compHRsbR= " << compHRsbR << endl;
      ///cout << "compHRsbLR= " << compHRsbLR << endl;
      /// cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << endl;
      //cout << "g= " << g << " gprime= " << gprime << " mWboson= " << mWboson << " alpha= " << alpha << " beta= " << beta << endl;
      ///cout << "mtop= " << mtop << " mbottom= " << mbottom << " greekmu= " << greekmu << " At= " << Atop << " Ab= " << Abottom << endl;
      ///cout << "thetab= " << thetab << endl;
      ///double cos2thew = (pow(g,2))/(pow(g,2)+pow(gprime,2));
      ///double sin2thew = (pow(gprime,2))/(pow(g,2)+pow(gprime,2));
      ///cout << -pow(mWboson/msbottom1,2)/cos2thew*(cos(alpha+beta)*(-0.5*pow(cos(thetab),2)+ sin2thew*cos(2*thetab)/3) - pow(mbottom/mWboson,2)*cos2thew*cos(alpha)/cos(beta) - mbottom*sin(thetab)*cos(thetab)*cos2thew/(pow(mWboson,2)*cos(beta))*(Abottom*cos(alpha)-greekmu*sin(alpha))) << endl;
    }
  else if (higgstype == 'A')
    {
      RsbL=0;
      RsbR=0;
      Rsb1 = cos(thetab)*RsbL + sin(thetab)*RsbR;
      Rsb2 = -sin(thetab)*RsbL + cos(thetab)*RsbR;
    }
  
  F01(1) = f1(3)*(1-f1(3)*f1(1));
  F01(2) = f1(3)*(-f1(3)*f1(2));
  F02(1) = f2(3)*(1-f2(3)*f2(1));
  F02(2) = f2(3)*(-f2(3)*f2(2));
  
  ///cout << "F0 for sbottom1s= " << F01 << endl;
  
  Isb1(1) = 3*1./9*Rsb1*F01(1);
  Isb1(2) = 3*1./9*Rsb1*F01(2);
  Isb2(1) = 3*1./9*Rsb2*F02(1);
  Isb2(2) = 3*1./9*Rsb2*F02(2);
  Isbottomsboth(1) = Isb1(1);
  Isbottomsboth(2) = Isb1(2);
  Isbottomsboth(3) = Isb2(1);
  Isbottomsboth(4) = Isb2(2);
  /// cout << "Rsb1= " << Rsb1 << endl;
  ///cout << "F01/3=" << (F01(1))/3 << " " << F01(2)/3 << endl;
  ///cout << "g^2/(8*mW^2)= " << pow(g/mWboson,2)/8 << endl;
  ///double compRsbL1 = pow(mWboson/msbottom1,2)*((-0.5-pow(gprime/g,2)/6)*sin(alpha+beta) + pow(mbottom/mWboson,2)*sin(alpha)/cos(beta));
  ///double compRsbR1 = pow(mWboson/msbottom1,2)*((-pow(gprime/g,2)/3*sin(alpha+beta) + pow(mbottom/mWboson,2)*sin(alpha)/cos(beta)));
  ///double compRsbLR1 = -mbottom*pow(1/msbottom1,2)/(2*cos(beta))*(greekmu*cos(alpha)+Abottom*sin(alpha));
  ///cout << "compRsbL1= " << compRsbL1 << endl;
  ///cout << "compRsbR1= " << compRsbR1 << endl;
  ///cout << "compRsbLR1= " << compRsbLR1 << endl;
  ///cout << "mbottom= " << mbottom << " mWboson= " << mWboson << " msb1= " << msbottom1 << endl;
  ///cout << " alpha= " << alpha << " beta= " << beta << " thetab= " << thetab << endl;
  ///cout << " greekmu= " << greekmu << " Abottom= " << Abottom << " Atop= " << Atop << endl;
  return Isbottomsboth;
}  

DoubleVector higgsmatrixelementgammagammaviacharms (double m1, double mcharm, double alpha, double beta, char higgstype) ///function that calculates the part of the matrix element that differs depending on the loop particles, in this case it calculates it for charms in the loop.
{
  DoubleVector foftau(double mpart, double mcomp);
  DoubleVector f(3), F1over2(2), Ic(2);
  double Rc=0;
  for (int i=1; i<=3; i++) {
    f(i) = 0;
  }

  for (int j=1; j<=2; j++) {
    F1over2(j) = 0;
    Ic(j) = 0;
  }
    
  f = foftau(mcharm, m1);
  if (higgstype == 'h')
    {
      F1over2(1) = -2*f(3)*(1+(1-f(3))*f(1));
      F1over2(2) = -2*f(3)*((1-f(3))*f(2));
      Rc = cos(alpha)/sin(beta);
    }
  else if (higgstype == 'H')
    {
      F1over2(1) = -2*f(3)*(1+(1-f(3))*f(1));
      F1over2(2) = -2*f(3)*((1-f(3))*f(2));
      Rc = sin(alpha)/sin(beta);
    }
  else if (higgstype == 'A')
    {
      F1over2(1) = -2*f(3)*f(1);
      F1over2(2) = -2*f(3)*f(2);
      Rc = 1/(tan(beta));
    }
   
  Ic(1) = 3*4./9*Rc*F1over2(1);
  Ic(2) = 3*4./9*Rc*F1over2(2);
  return Ic;
}

DoubleVector higgsmatrixelementgammagammaviataus (double m1, double mtau, double alpha, double beta, char higgstype) ///function that calculates the part of the matrix element that differs depending on the loop particles, in this case it calculates it for taus in the loop.
{
  DoubleVector foftau(double mpart, double mcomp);
  DoubleVector f(3), F1over2(2), Itau(2);
  double Rtau=0;
  for (int i=1; i<=3;i++) {
    f(i) = 0;
  }
  for (int j=1; j<=2;j++) {
    F1over2(j) = 0;
    Itau(j) = 0;
  }
    
  f = foftau(mtau, m1);
  if (higgstype == 'h')
    {
      F1over2(1) = -2*f(3)*(1+(1-f(3))*f(1));
      F1over2(2) = -2*f(3)*((1-f(3))*f(2));
      Rtau = -sin(alpha)/cos(beta);
    }
  else if (higgstype == 'H')
    {
      F1over2(1) = -2*f(3)*(1+(1-f(3))*f(1));
      F1over2(2) = -2*f(3)*((1-f(3))*f(2));
      Rtau = cos(alpha)/cos(beta);
    }
  else if (higgstype == 'A')
    {
      F1over2(1) = -2*f(3)*f(1);
      F1over2(2) = -2*f(3)*f(2);
      Rtau = tan(beta);
    }
   
  Itau(1) = 1*Rtau*F1over2(1);
  Itau(2) = 1*Rtau*F1over2(2);
  return Itau;
}  

DoubleVector higgsmatrixelementgammagammaviastaus (double m1, double mstau1, double mstau2, double mtau, double mWboson, double thetatau, double g, double gprime, double alpha, double beta, double greekmu, double Atau, char higgstype) ///function that calculates the part of the matrix element that differs depending on the loop particles, in this case it calculates it for stau1s and for stau2s in the loop.
{
  DoubleVector foftau(double mpart, double mcomp);
  DoubleVector f1(3), f2(3), F01(2), F02(2), Istau1(2), Istau2(2), Istausboth(4);
  DoubleVector higgshsleptonsamehandcouplings(double mWboson, double g, double gprime, double alpha, double beta, double mel);
  DoubleVector higgshsleptondiffhandcouplings (double mWboson, double g, double alpha, double beta, double mel, double greekmu, double Ae);
  DoubleVector higgsHsleptonsamehandcouplings(double mWboson, double g, double gprime, double alpha, double beta, double mel);
  DoubleVector higgsHsleptondiffhandcouplings (double mWboson, double g, double alpha, double beta, double mel, double greekmu, double Ae);
  double Rstau1=0, Rstau2=0, RstauL=0, RstauR=0, RstauLR=0, RstauL1=0, RstauL2=0, RstauR1=0, RstauR2=0, RstauLR1=0, RstauLR2=0;
  
  for (int i=1; i<=3;i++) {
    f1(i) = 0;
    f2(i) = 0;
  }
  for (int j=1; j<=2;j++) {
    F01(j) = 0;
    F02(j) = 0;
    Istau1(j) = 0;
    Istau2(j) = 0;
  }
  for (int k=1; k<=4; k++) {
    Istausboth(k) = 0;
  }
  
  DoubleVector staustausamehandcoupling(3);
  for (int i=1; i<=3; i++) {
  staustausamehandcoupling(i) = 0;
  }

  DoubleVector staustaudiffhandcoupling(1);
  for (int i=1; i<=1; i++) {
  staustaudiffhandcoupling(i) = 0;
  }

  f1 = foftau(mstau1, m1);
  f2 = foftau(mstau2, m1);
  if (higgstype == 'h')
    {
      ///RstauL = pow(mtau*costhetaW/mWboson,2)*Rtau- (-0.5+1*pow(sinthetaW,2))*sin(beta-alpha);
      ///RstauR = pow(mtau*costhetaW/mWboson,2)*Rtau+ (1*pow(sinthetaW,2))*sin(beta-alpha);
      ///Rstau1 = sin(thetatau)*RstauL - cos(thetatau)*RstauR;
      ///Rstau2 = cos(thetatau)*RstauL + sin(thetatau)*RstauR;
      staustausamehandcoupling = higgshsleptonsamehandcouplings (mWboson, g, gprime, alpha, beta, mtau);
      RstauL = staustausamehandcoupling(2);
      RstauL1 = RstauL*mWboson/(g*pow(mstau1,2));
      RstauL2 = RstauL*mWboson/(g*pow(mstau2,2));
      RstauR = staustausamehandcoupling(3);
      RstauR1 = RstauR*mWboson/(g*pow(mstau1,2));
      RstauR2 = RstauR*mWboson/(g*pow(mstau2,2));
      ///cout << " greekmu = " << greekmu << " Atau= " << Atau << endl;
      ///cout << "thetatau= " << thetatau << endl;
      ///cout << "mstau1= " << mstau1 << " mstau2= " << mstau2 << endl;
      staustaudiffhandcoupling = higgshsleptondiffhandcouplings (mWboson, g, alpha, beta, mtau, greekmu, Atau);
      RstauLR = staustaudiffhandcoupling(1);
      RstauLR1 = RstauLR*mWboson/(g*pow(mstau1,2));
      RstauLR2 = RstauLR*mWboson/(g*pow(mstau2,2));
      Rstau1 = RstauL1*pow(sin(thetatau),2) + RstauR1*pow(cos(thetatau),2) + 2*RstauLR1*cos(thetatau)*sin(thetatau);
      Rstau2 = RstauL2*pow(cos(thetatau),2) + RstauR2*pow(sin(thetatau),2) - 2*RstauLR2*cos(thetatau)*sin(thetatau);
      ///cout << "RSTAU1= " << Rstau1 << " RSTAU2= " << Rstau2 << endl;
    }
  else if (higgstype == 'H')
    {
      ///RstauL = pow(mtau*costhetaW/mWboson,2)*Rtau+ (-0.5+1*pow(sinthetaW,2))*cos(beta-alpha);
      ///RstauR = pow(mtau*costhetaW/mWboson,2)*Rtau- (1*pow(sinthetaW,2))*cos(beta-alpha);
      ///Rstau1 = sin(thetatau)*RstauL - cos(thetatau)*RstauR;
      ///Rstau2 = cos(thetatau)*RstauL + sin(thetatau)*RstauR;     
      staustausamehandcoupling = higgsHsleptonsamehandcouplings (mWboson, g, gprime, alpha, beta, mtau);
      RstauL = staustausamehandcoupling(2);
      RstauL1 = RstauL*mWboson/(g*pow(mstau1,2));
      RstauL2 = RstauL*mWboson/(g*pow(mstau2,2));
      RstauR = staustausamehandcoupling(3);
      RstauR1 = RstauR*mWboson/(g*pow(mstau1,2));
      RstauR2 = RstauR*mWboson/(g*pow(mstau2,2));
      ///cout << " greekmu = " << greekmu << " Atop= " << Atop << " Abottom= " << Abottom << endl;
      staustaudiffhandcoupling = higgsHsleptondiffhandcouplings (mWboson, g, alpha, beta, mtau, greekmu, Atau);
      RstauLR = staustaudiffhandcoupling(1);
      RstauLR1 = RstauLR*mWboson/(g*pow(mstau1,2));
      RstauLR2 = RstauLR*mWboson/(g*pow(mstau2,2));
      Rstau1 = RstauL1*pow(sin(thetatau),2) + RstauR1*pow(cos(thetatau),2) + 2*RstauLR1*cos(thetatau)*sin(thetatau);
      Rstau2 = RstauL2*pow(cos(thetatau),2) + RstauR2*pow(sin(thetatau),2) - 2*RstauLR2*cos(thetatau)*sin(thetatau);
    }
  else if (higgstype == 'A')
    {
      RstauL=0;
      RstauR=0;
      Rstau1 = sin(thetatau)*RstauL - cos(thetatau)*RstauR;
      Rstau2 = cos(thetatau)*RstauL + sin(thetatau)*RstauR;
    }
  
  F01(1) = f1(3)*(1-f1(3)*f1(1));
  F01(2) = f1(3)*(-f1(3)*f1(2));
  F02(1) = f2(3)*(1-f2(3)*f2(1));
  F02(2) = f2(3)*(-f2(3)*f2(2));

  ///cout << "F0 for stau1s = " << F01 << endl;
  
  ///double part1 = pow(mWboson/mstau2,2)*(pow(sin(thetatau),2)*(-0.5+0.5*pow(gprime/g,2))*sin(alpha+beta) + pow(cos(thetatau),2)*-pow(gprime/g,2)*sin(alpha+beta));
  ///double part2 = pow(mWboson/mstau2,2)*pow(mtau/mWboson,2)*sin(alpha)/cos(beta);
  ///double part3 = pow(mWboson/mstau2,2)*sin(thetatau)*cos(thetatau)*mtau/(pow(mWboson,2)*cos(beta))*(-greekmu*cos(alpha)-Atau*sin(alpha));
  ///cout << " part1 = " << part1 << endl;
  ///cout << " part2 = " << part2 << endl;
  ///cout << " part3 = " << part3 << endl;

  Istau1(1) = 1*Rstau1*F01(1);
  Istau1(2) = 1*Rstau1*F01(2);
  Istau2(1) = 1*Rstau2*F02(1);
  Istau2(2) = 1*Rstau2*F02(2);
  Istausboth(1) = Istau1(1);
  Istausboth(2) = Istau1(2);
  Istausboth(3) = Istau2(1);
  Istausboth(4) = Istau2(2);
  return Istausboth;
} 

DoubleVector higgsmatrixelementgammagammaviaWbosons (double m1, double mWboson, double alpha, double beta, double g, double gprime, char higgstype) ///function that calculates the part of the matrix element that differs depending on the loop particles, in this case it calculates it for W bosons in the loop.
{
  DoubleVector foftau(double mpart, double mcomp);
  DoubleVector f(3), F1(2), IW(2);
  double RW=0;
  for (int i=1; i<=3;i++) {
    f(i) = 0;
  }
  for (int j=1; j<=2;j++) {
    F1(j) = 0;
    IW(j) = 0;
  }
    
  f = foftau(mWboson, m1);
  ///cout << "f(tau) for " << higgstype << " = " << f << endl;
  if (higgstype == 'h')
    {
      RW = sin(beta-alpha);
    }
  else if (higgstype == 'H')
    {
      RW = cos(beta-alpha);
      ///cout << "tau for W from H= " << f(3) << endl;
      ///cout << "RW for H= " << RW << endl;
    }
  else if (higgstype == 'A')
    {
      RW = 0;
    }
  F1(1) = 2 + 3*f(3) + 3*f(3)*(2-f(3))*f(1);
  F1(2) = 3*f(3)*(2-f(3))*f(2);
  ///cout << "F1(tau)= " << F1 << endl;
  
  
  IW(1) = RW*F1(1);
  IW(2) = RW*F1(2);
  return IW;
}  

DoubleVector higgsmatrixelementgammagammaviaHpms (double m1, double mHpm, double mWboson, double alpha, double beta, double g, double gprime, char higgstype) ///function that calculates the part of the matrix element that differs depending on the loop particles, in this case it calculates it for H+-s in the loop.
{
  DoubleVector foftau(double mpart, double mcomp);
  DoubleVector f(3), F0(2), IHpm(2);
  double RHpm=0, costhetaW=0;
  for (int i=1; i<=3;i++) {
    f(i) = 0;
  }
  for (int j=1; j<=2;j++) {
    F0(j) = 0;
    IHpm(j) = 0;
  }
    
  f = foftau(mHpm, m1);

  costhetaW = pow(pow(g,2)/(pow(g,2)+pow(gprime,2)),0.5);
  if (higgstype == 'h')
    {
      RHpm = sin(beta-alpha) + cos(2*beta)*sin(beta+alpha)/(2*pow(costhetaW,2));
      ///cout << "RHPM for h = " << RHpm << endl;
    }
  else if (higgstype == 'H')
    {
      RHpm = cos(beta-alpha) - cos(2*beta)*cos(beta+alpha)/(2*pow(costhetaW,2));
      ///cout << "RHPM for H = " << RHpm << endl;
    }
  else if (higgstype == 'A')
    {
      RHpm = 0;
    }
  F0(1) = f(3)*(1-f(3)*f(1));
  F0(2) = f(3)*(f(3)*f(2));
  ///cout << "F0 for Hpms= " << F0 << endl;
  
  IHpm(1) = RHpm*F0(1)*pow(mWboson/mHpm,2);
  IHpm(2) = RHpm*F0(2)*pow(mWboson/mHpm,2);
  return IHpm;

}


DoubleVector higgsmatrixelementgammagammaviachargino1s (double m1, double mchargino1, double mWboson, double alpha, double beta, double thetaL, double thetaR, char higgstype) ///function that calculates the part of the matrix element that differs depending on the loop particles, in this case it calculates it for chargino1s in the loop.
{
  DoubleVector higgsphisamecharginocouplings (double alpha, double beta, double thetaL, double thetaR);
  DoubleVector foftau(double mpart, double mcomp);
  DoubleVector f(3), F1over2(2), Ichargino1(2), Charcouplings(6);
  double Rchargino1=0;
  for (int i=1; i<=3;i++) {
    f(i) = 0;
  }
  for (int j=1; j<=2;j++) {
    F1over2(j) = 0;
    Ichargino1(j) = 0;
  }
  for (int k=1; k<=6;k++) {
    Charcouplings(k) = 0;
  }
  double thetaL2 = -thetaL + PI/2;
  double thetaR2 = -thetaR + PI/2;
    
  f = foftau(mchargino1, m1);
  ///cout << "foftau for chargino1s= " << f << endl;
  Charcouplings = higgsphisamecharginocouplings (alpha, beta, thetaL2, thetaR2);
  ///cout << Charcouplings << endl;

  if (higgstype == 'h')
    {
      Rchargino1 = pow(2,1.5)*Charcouplings(1);
      ///Rchargino1 = pow(2,0.5)*((cos(thetaL)*sin(thetaR))*cos(alpha) + (sin(thetaL)*cos(thetaR))*sin(alpha));
      F1over2(1) = -2*f(3)*(1+(1-f(3))*f(1));
      F1over2(2) = -2*f(3)*((1-f(3))*f(2));
      ///cout << "Rchargino1 for " << higgstype << "= " << Rchargino1 << endl;
      ///cout << "F1over2 for " << higgstype << "= " << F1over2 << endl;
    }
  else if (higgstype == 'H')
    {
      Rchargino1 = pow(2,1.5)*Charcouplings(3);
      ///Rchargino1 = pow(2,0.5)*((cos(thetaL)*sin(thetaR))*-sin(alpha) + (sin(thetaL)*cos(thetaR))*cos(alpha));
      F1over2(1) = -2*f(3)*(1+(1-f(3))*f(1));
      F1over2(2) = -2*f(3)*((1-f(3))*f(2));
      ///cout << "Rchargino1 for " << higgstype << "= " << Rchargino1 << endl;
      ///cout << "F1over2 for " << higgstype << "= " << F1over2 << endl;
    }
  else if (higgstype == 'A')
    {
      Rchargino1 = pow(2,1.5)*Charcouplings(5);
      ///Rchargino1 = pow(2,0.5)*(-(cos(thetaL)*sin(thetaR))*cos(beta) - (sin(thetaL)*cos(thetaR))*sin(beta));
      F1over2(1) = -2*f(3)*f(1);
      F1over2(2) = -2*f(3)*f(2);
      ///cout << "Rchargino1 for " << higgstype << "= " << Rchargino1 << endl;
      ///cout << "F1over2 for " << higgstype << "= " << F1over2 << endl;
    }
    
  
  Ichargino1(1) = Rchargino1*F1over2(1)*mWboson/mchargino1;
  Ichargino1(2) = Rchargino1*F1over2(2)*mWboson/mchargino1;
  return Ichargino1;

}

DoubleVector higgsmatrixelementgammagammaviachargino2s (double m1, double mchargino2, double mWboson, double alpha, double beta, double thetaL, double thetaR, char higgstype) ///function that calculates the part of the matrix element that differs depending on the loop particles, in this case it calculates it for chargino2s in the loop.
{
  DoubleVector higgsphisamecharginocouplings (double alpha, double beta, double thetaL, double thetaR);
  DoubleVector foftau(double mpart, double mcomp);
  DoubleVector f(3), F1over2(2), Ichargino2(2), Charcouplings(6);
  double Rchargino2=0;
  for (int i=1; i<=3;i++) {
    f(i) = 0;
  }
  for (int j=1; j<=2;j++) {
    F1over2(j) = 0;
    Ichargino2(j) = 0;
  }
  for (int k=1; k<=6;k++) {
    Charcouplings(k) = 0;
  }
  double thetaL2 = -thetaL + PI/2;
  double thetaR2 = -thetaR + PI/2;
    
  f = foftau(mchargino2, m1);
  ///cout << "fchar2(1)= " << f(1) << " fchar2(2)= " << f(2) << " fchar2(3)= " << f(3) << endl;
  ///cout << "mpart= " << mchargino2 << " mcomp= " << m1 << " taushould= " << 4*(pow(mchargino2/m1,2)) << endl;
  Charcouplings = higgsphisamecharginocouplings (alpha, beta, thetaL2, thetaR2);
  ///cout << Charcouplings << endl;

  if (higgstype == 'h')
    {
      Rchargino2 = pow(2,1.5)*Charcouplings(2);
      ///Rchargino2 = pow(2,0.5)*(-sin(thetaL)*cos(thetaR)*cos(alpha) + (-cos(thetaL)*sin(thetaR))*sin(alpha));
      F1over2(1) = -2*f(3)*(1+(1-f(3))*f(1));
      F1over2(2) = -2*f(3)*((1-f(3))*f(2));
      ///cout << "Rchargino2 for h" << Rchargino2 << endl;
    }
  else if (higgstype == 'H')
    {
      Rchargino2 = pow(2,1.5)*Charcouplings(4);
      ///Rchargino2 = pow(2,0.5)*(-sin(thetaL)*cos(thetaR)*-sin(alpha) + (-cos(thetaL)*sin(thetaR))*cos(alpha));
      F1over2(1) = -2*f(3)*(1+(1-f(3))*f(1));
      F1over2(2) = -2*f(3)*((1-f(3))*f(2));
    }
  else if (higgstype == 'A')
    {
      Rchargino2 = pow(2,1.5)*Charcouplings(6);
      ///Rchargino2 = pow(2,0.5)*(-sin(thetaL)*cos(thetaR)*-cos(alpha) - (-cos(thetaL)*sin(thetaR))*sin(beta));
      F1over2(1) = -2*f(3)*f(1);
      F1over2(2) = -2*f(3)*f(2);
      ///cout << "Rchargino2 for A= " << Rchargino2 << endl;
    }
   
 
  ///cout << "F1over2char2(1)= " << F1over2(1) << " F1over2char2(2)= " << F1over2(2) << endl;
  Ichargino2(1) = Rchargino2*F1over2(1)*mWboson/mchargino2;
  Ichargino2(2) = Rchargino2*F1over2(2)*mWboson/mchargino2;
  return Ichargino2;

}



double higgsesamplitudedecaygluongluontotal(double m1, double g, double gs, double gprime, double mWboson, double alpha, double beta, double mtop, double mbottom, double mcharm, double mstop1, double mstop2, double msbottom1, double msbottom2, double thetaL, double thetaR, double thetat, double thetab, double greekmu, double Atop, double Abottom, char higgstype) /// function that calculates the partial width for h->gluon gluon at 1-loop (forbidden at tree-level)
{
  double prefactor=0, Itr=0, Iti=0, Ist1r=0, Ist1i=0, Ist2r=0, Ist2i=0, Ibr=0, Ibi=0, Isb1r=0, Isb1i=0, Isb2r=0, Isb2i=0, Icr=0, Ici=0, matelemmodsquare=0, amplitudeW=0;
  /// Now as the only difference is in the prefactor I can use the same functions for each of the loop contributions as in the higgs to gamma gamma case.
  DoubleVector higgsmatrixelementgammagammaviatops (double m1, double mtop, double alpha, double beta, char higgstype);
  DoubleVector higgsmatrixelementgammagammaviastops (double m1, double mstop1, double mstop2, double mtop, double mbottom, double mWboson, double thetat, double g, double gprime, double alpha, double beta, double greekmu, double Atop, double Abottom, char higgstype);
  DoubleVector higgsmatrixelementgammagammaviabottoms (double m1, double mbottom, double alpha, double beta, char higgstype);
  DoubleVector higgsmatrixelementgammagammaviasbottoms (double m1, double msbottom1, double msbottom2, double mbottom, double mtop, double mWboson, double thetab, double g, double gprime, double alpha, double beta, double Atop, double Abottom, double greekmu, char higgstype);
  DoubleVector higgsmatrixelementgammagammaviacharms (double m1, double mcharm, double alpha, double beta, char higgstype);
  Itr = 1* higgsmatrixelementgammagammaviatops (m1, mtop, alpha, beta, higgstype)(1);
  Iti = 1* higgsmatrixelementgammagammaviatops (m1, mtop, alpha, beta, higgstype)(2);
  Ist1r = higgsmatrixelementgammagammaviastops (m1, mstop1, mstop2, mtop, mbottom, mWboson, thetat, g, gprime, alpha, beta, greekmu, Atop, Abottom, higgstype)(1);
  Ist1i = higgsmatrixelementgammagammaviastops (m1, mstop1, mstop2, mtop, mbottom, mWboson, thetat, g, gprime, alpha, beta, greekmu, Atop, Abottom, higgstype)(2);
  Ist2r = higgsmatrixelementgammagammaviastops (m1, mstop1, mstop2, mtop, mbottom, mWboson, thetat, g, gprime, alpha, beta, greekmu, Atop, Abottom, higgstype)(3);
  Ist2i = higgsmatrixelementgammagammaviastops (m1, mstop1, mstop2, mtop, mbottom, mWboson, thetat, g, gprime, alpha, beta, greekmu, Atop, Abottom, higgstype)(4);
  Ibr = 4*higgsmatrixelementgammagammaviabottoms (m1, mbottom, alpha, beta, higgstype)(1);
  Ibi = 4*higgsmatrixelementgammagammaviabottoms (m1, mbottom, alpha, beta, higgstype)(2);
  Isb1r = 4*higgsmatrixelementgammagammaviasbottoms (m1, msbottom1, msbottom2, mbottom, mtop, mWboson, thetab, g, gprime, alpha, beta, Atop, Abottom, greekmu, higgstype)(1);
  Isb1i = 4*higgsmatrixelementgammagammaviasbottoms (m1, msbottom1, msbottom2, mbottom, mtop, mWboson, thetab, g, gprime, alpha, beta, Atop, Abottom, greekmu, higgstype)(2);
  Isb2r = 4*higgsmatrixelementgammagammaviasbottoms (m1, msbottom1, msbottom2, mbottom, mtop, mWboson, thetab, g, gprime, alpha, beta, Atop, Abottom, greekmu, higgstype)(3);
  Isb2i = 4*higgsmatrixelementgammagammaviasbottoms (m1, msbottom1, msbottom2, mbottom, mtop, mWboson, thetab, g, gprime, alpha, beta, Atop, Abottom, greekmu, higgstype)(4);
  Icr = 1*higgsmatrixelementgammagammaviacharms (m1, mcharm, alpha, beta, higgstype)(1);
  Ici = 1*higgsmatrixelementgammagammaviacharms (m1, mcharm, alpha, beta, higgstype)(2);
  
  DoubleVector matelemsum(2);
  matelemsum(1) = Itr + Ist1r + Ist2r + Ibr + Isb1r + Isb2r + Icr;
  matelemsum(2) = Iti + Ist1i + Ist2i + Ibi + Isb1i + Isb2i + Ici;
  prefactor = (pow(gs,4)*pow(g,2))/(1024*pow(PI,3)*16*pow(PI,2))*pow(m1,3)/pow(mWboson,2)*9/8;
    
  /// cout << "Input parameters!: " << endl;
  /// cout << "mh0(1) = " << m1 << " gs= " << gs << " mWboson= " << mWboson << endl;
  /// cout << " alpha = " << alpha << " beta = " << beta << " mtop= " << mtop << " mbottom= " << mbottom << endl;
  /// cout << "mbottom= " << mbottom << " mcharm= " << mcharm << " mtau= " << mtau << endl;
  /// cout << "mstop1= " << mstop1 << " mstop2= " << mstop2 << " msbottom1= " << msbottom1 << " msbottom2= " << msbottom2 << endl;
  /// cout << "mstau1= " << mstau1 << " mstau2= " << mstau2 << endl;
  /// cout << "thetaL= " << thetaL << " thetaR= " << thetaR << " thetat= " << thetat << " thetab= " << thetab << endl;
  /// cout << "thetatau= " << thetatau << " greekmu= " << greekmu << " Atop= " << Atop << " Abottom= " << Abottom << endl;
  ///cout << "GLUONS" << endl;
  ///cout << setprecision(12) << endl;
  ///cout << "prefactor= " << prefactor << endl;
  ///cout << "Itr= " << Itr << " Iti= " << Iti << " Ist1r= " << Ist1r << " Ist1i= " << Ist1i <<  " Ist2r= " << Ist2r << " Ist2i= " << Ist2i << endl;
  ///cout << "Ibr= " << Ibr << " Ibi= " << Ibi << " Isb1r= " << Isb1r << " Isb1i= " << Isb1i << " Isb2r= " << Isb2r << " Isb2i= " << Isb2i << endl;
  ///cout << "Icr= " << Icr << " Ici= " << Ici << endl;
  ///cout << "matelemsumr= " << matelemsum(1) << endl;
  ///cout << "matelemsumi= " << matelemsum(2) << endl;
  ///cout << "m1 = " << m1 << endl;
  ///cout << "g^2/(8*mW^2)= " << pow(g,2)/(8*pow(mWboson,2)) << endl;
  ///cout << "prefactor without 9/8 = " << (pow(gs,4)*pow(g,2))/(1024*pow(PI,3)*16*pow(PI,2))*pow(m1,3)/pow(mWboson,2) << endl;
  ///cout << "cf with A -> gg prefactor: " << (pow(gs,4)*pow(g,2))/(2048*pow(PI,5))*pow(m1,3)/pow(mWboson,2) << endl;
  ///cout << "gs = " << gs << endl;
  ///cout << "prefactor*Ist1^2 = " << prefactor*(pow(Ist1r,2)+pow(Ist1i,2)) << endl;
  /// cout << "9/16*Ist1^2 = " << 9./16*(pow(Ist1r,2)+pow(Ist1i,2)) << endl;
  /// cout << "9/16*Ist2^2 = " << 9./16*(pow(Ist2r,2)+pow(Ist2i,2)) << endl;
  /// cout << "9/16*Isb1^2 = " << 9./16*(pow(Isb1r,2)+pow(Isb1i,2)) << endl;
  /// cout << "9/16*Isb2^2 = " << 9./16*(pow(Isb2r,2)+pow(Isb2i,2)) << endl;
  ///cout << "9/16*It^2 = " << 9./16*(pow(Itr,2)+pow(Iti,2)) << endl;
  ///cout << "9/16*Ib^2 = " << 9./16*(pow(Ibr,2)+pow(Ibi,2)) << endl;
  ///cout << "9/16*Ic^2 = " << 9./16*(pow(Icr,2)+pow(Ici,2)) << endl;
  ///cout << "9/64*It^2 = " << 9./64*(pow(Itr,2)+pow(Iti,2)) << endl;
  ///cout << "9/64*Ib^2 = " << 9./64*(pow(Ibr,2)+pow(Ibi,2)) << endl;
  ///cout << "9/64*Ic^2 = " << 9./64*(pow(Icr,2)+pow(Ici,2)) << endl;

  
  ///cout << setprecision(12) << endl;
  matelemmodsquare = pow(matelemsum(1),2) + pow(matelemsum(2),2);
  ///cout << "matelemmodsquare*9/16= " << matelemmodsquare*9./16 << endl;
  amplitudeW = prefactor*matelemmodsquare;
  ///double comp1 = pow(mWboson/msbottom1,2)*(pow(cos(thetab),2)*(-0.5-pow(gprime/g,2)/6)*sin(beta+alpha) + pow(sin(thetab),2)*-pow(gprime/g,2)/3*sin(beta+alpha));
  ///double comp2 = pow(mWboson/msbottom1,2)*pow(mbottom/mWboson,2)*sin(alpha)/(cos(beta));
  ///double comp3 = pow(mWboson/msbottom1,2)*(mbottom*sin(thetab)*cos(thetab)/(pow(mWboson,2)*cos(beta))*(greekmu*cos(alpha)+Abottom*sin(alpha)));
  ///cout << "comp1= " << comp1 << endl;
  ///cout << "comp2= " << comp2 << endl;
  ///cout << "comp3= " << comp3 << endl;
      
  return amplitudeW;

}


double higgsamplitudedecayVVstar (double m1, double mboson, double g, double gp, double beta, double alpha, char Vtype) ///Function that calculates higgs to VV* to Vff'bar. Formula derived as in Marciano and Keung, massless fermion limit and zero W width considered.
{
  double prefactor=0, epsilon=0, integrals=0, a=0, b=0, c=0, amplitudeW=0;
  double sin2thetaW = pow(gp,2)/(pow(g,2)+pow(gp,2));
  double cos2thetaW = pow(g,2)/(pow(g,2)+pow(gp,2));
  if(m1 < 2*mboson && m1 > mboson) {
    if (Vtype == 'W') {
      prefactor = 3*pow(g,4)*m1/(512*pow(PI,3))*pow(sin(beta-alpha),2);
    }
    else if (Vtype == 'Z') {
      prefactor = pow(g,4)*m1/(2048*pow(PI,3)*pow(cos2thetaW,2))*(7 - 40*sin2thetaW/3 + 160*pow(sin2thetaW,2)/9)*pow(sin(beta-alpha),2);
    }
  epsilon = mboson/m1;
  a = 3*(1-8*pow(epsilon,2)+20*pow(epsilon,4))/(pow(4*pow(epsilon,2)-1,0.5))*acos((3*pow(epsilon,2)-1)/(2*pow(epsilon,3)));
  b = (1-pow(epsilon,2))*(47./2*pow(epsilon,2)-13./2+1/(pow(epsilon,2)));
  c = 3*(1-6*pow(epsilon,2)+4*pow(epsilon,4))*log(epsilon);
  integrals = a - b - c;
  amplitudeW = prefactor*integrals;
  ///cout << "epsilon for " << Vtype << " = " << epsilon << endl;
  ///cout << "prefactor for " << Vtype << " = " << prefactor << endl;
  ///cout << Vtype << ": a = " << a << " b = " << b << " c = " << c << endl;
  ///cout << "integral for " << Vtype << " = " << integrals << endl;
  ///cout << (pow(g,2)*pow(m1,4))/(32*pow(PI*mboson,2)) << endl;
  ///cout << "for cf with HTWW in hdecay: HTWW equiv here = " << (pow(g,2)*pow(m1,4))/(32*pow(PI*mboson,2))*integrals << endl;
  ///cout << "prefactor equiv to hdecay's for W  = " << prefactor*(32*pow(PI*mboson,2))/(pow(g,2)*pow(m1,4)) << endl;
  ///cout << "prefactor equiv to hdecay's for Z  = " << prefactor/(7 - 40*(sin2thetaW)/3 + 160*pow(sin2thetaW,2)/9)*(192*pow(PI,2)*pow(mboson,2)*cos2thetaW)/(pow(g,2)*pow(m1,4)) << endl;
  ///cout << "their prefactor I'd get = " << 3*pow(g,2)*pow(mboson,2)*pow(sin(beta-alpha),2)/(32*PI*pow(m1,3)*cos2thetaW) << endl;
  ///cout << "g^2*mW^2 = " << pow(g,2)*pow(mboson,2) << endl;
  ///cout.precision(15);
  ///cout << "(g^2/8mW^2)^2 = " << pow(pow(g,2)/(8*pow(mboson,2)),2) << endl;
  ///cout << "g^4 / (64*cos^4 thetaW) = " << pow(g,4)/(64*pow(cos2thetaW,2)) << endl;
  ///cout << "(7 - 40*sin2thetaW/3 + 160*pow(sin2thetaW,2)/9)*pow(sin(beta-alpha),2)= " << (7 - 40*sin2thetaW/3 + 160*pow(sin2thetaW,2)/9)*pow(sin(beta-alpha),2) << endl;
  }
  else if(m1> 2*mboson || m1< mboson) {
    cout << "m1 either greater than 2*mboson so both on-shell, or m1 less than mboson so both off-shell, this formula is for one on-shell vector boson and one off-shell vector boson (of the same type of course)" << endl;
  }
  return amplitudeW;
}

DoubleVector higgshamplitudedecayVV(double m1, double mWboson, double mZboson, double g, double gp, double alpha, double beta, char Vtype) ///Function that calculates the Heavy Higgs decays to two vector bosons, assuming both are on-shell.
{
  DoubleVector Returns(2);
  for (int i=1; i<=2; i++) {
    Returns(i) = 0;
  }
  double higgsamplitudedecayVVstar (double m1, double mboson, double g, double gp, double beta, double alpha, char Vtype);
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, prefactor=0, m2=0, m3=0, massratio=0;
  if (Vtype == 'W')
    {
      if (fabs(m1) < fabs(mWboson)) {
	amplitudeW = 0;
      }
      else if (fabs(m1) < 2*fabs(mWboson)) {
	amplitudeW = higgsamplitudedecayVVstar (m1, mWboson, g, gp, beta, alpha, 'W');
	  Returns(2) = 1;
	}
      else if (fabs(m1) >= 2*fabs(mWboson)) {
	m2 = mWboson, m3 = mWboson;
	squareplus = 1 - pow(m3/m1+m2/m1,2);
	squareminus = 1 - pow(m3/m1-m2/m1,2);
	lambda = pow(squareplus*squareminus,0.5);
	prefactor = pow(g,2)*pow(m1,3)/(64*PI*pow(mWboson,2));
	massratio = 4*pow(mWboson/m1,2);
	amplitudeW = lambda*prefactor*(1-massratio + 3./4*pow(massratio,2))*pow(sin(beta-alpha),2);
	Returns(2) = 2;
      }
      ///cout << "cos(beta-alpha)^2 = " << pow(cos(beta-alpha),2) << endl;
    }
    else if (Vtype == 'Z') {
      if (fabs(m1) < fabs(mZboson)) {
	amplitudeW = 0;
      }
      else if (fabs(m1) < 2*fabs(mZboson)) {
	amplitudeW = higgsamplitudedecayVVstar (m1, mZboson, g, gp, beta, alpha, 'Z');
	Returns(2) = 1;
      }
      else if (fabs(m1) >= 2*fabs(mZboson)) {
	m2 = mZboson, m3 = mZboson;
	squareplus = 1 - pow(m3/m1+m2/m1,2);
	squareminus = 1 - pow(m3/m1-m2/m1,2);
	lambda = pow(squareplus*squareminus,0.5);
	prefactor = pow(g,2)*pow(m1,3)/(128*PI*pow(mWboson,2));	
	massratio = 4*pow(mZboson/m1,2);
	amplitudeW = lambda*prefactor*(1-massratio + 3./4*pow(massratio,2))*pow(sin(beta-alpha),2);
	Returns(2) = 2;
      }
      ///cout << "cos(beta-alpha)^2 = " << pow(cos(beta-alpha),2) << endl;
    }
  Returns(1) = amplitudeW;
  return Returns;
}
 

DoubleVector higgsHamplitudedecayVV(double m1, double mWboson, double mZboson, double g, double gp, double alpha, double beta, char Vtype) ///Function that calculates the Heavy Higgs decays to two vector bosons, assuming both are on-shell.
{
  DoubleVector Returns(2);
  for (int i=1; i<=2; i++) {
    Returns(i) = 0;
  }
  double higgsamplitudedecayVVstar (double m1, double mboson, double g, double gp, double beta, double alpha, char Vtype);
  double amplitudeW=0, squareplus=0, squareminus=0, lambda=0, prefactor=0, m2=0, m3=0, massratio=0;
  if (Vtype == 'W')
    {
      if (fabs(m1) < fabs(mWboson)) {
	amplitudeW = 0;
      }
      else if (fabs(m1) < 2*fabs(mWboson)) {
	amplitudeW = higgsamplitudedecayVVstar (m1, mWboson, g, gp, beta, alpha, 'W')*pow(cos(beta-alpha),2)/pow(sin(beta-alpha),2);
	  Returns(2) = 1;
	}
      else if (fabs(m1) >= 2*fabs(mWboson)) {
	m2 = mWboson, m3 = mWboson;
	squareplus = 1 - pow(m3/m1+m2/m1,2);
	squareminus = 1 - pow(m3/m1-m2/m1,2);
	lambda = pow(squareplus*squareminus,0.5);
	prefactor = pow(g,2)*pow(m1,3)/(64*PI*pow(mWboson,2));
	massratio = 4*pow(mWboson/m1,2);
	amplitudeW = lambda*prefactor*(1-massratio + 3./4*pow(massratio,2))*pow(cos(beta-alpha),2);
	Returns(2) = 2;
      }
      ///cout << "cos(beta-alpha)^2 = " << pow(cos(beta-alpha),2) << endl;
    }
    else if (Vtype == 'Z') {
      if (fabs(m1) < fabs(mZboson)) {
	amplitudeW = 0;
      }
      else if (fabs(m1) < 2*fabs(mZboson)) {
	amplitudeW = higgsamplitudedecayVVstar (m1, mZboson, g, gp, beta, alpha, 'Z')*pow(cos(beta-alpha),2)/pow(sin(beta-alpha),2);;
	Returns(2) = 1;
      }
      else if (fabs(m1) >= 2*fabs(mZboson)) {
	m2 = mZboson, m3 = mZboson;
	squareplus = 1 - pow(m3/m1+m2/m1,2);
	squareminus = 1 - pow(m3/m1-m2/m1,2);
	lambda = pow(squareplus*squareminus,0.5);
	prefactor = pow(g,2)*pow(m1,3)/(128*PI*pow(mWboson,2));	
	massratio = 4*pow(mZboson/m1,2);
	amplitudeW = lambda*prefactor*(1-massratio + 3./4*pow(massratio,2))*pow(cos(beta-alpha),2);
	Returns(2) = 2;
      }
      ///cout << "cos(beta-alpha)^2 = " << pow(cos(beta-alpha),2) << endl;
    }
  Returns(1) = amplitudeW;
  return Returns;
}


double higgsesamplitudedecayZbosonphotontotal(double m1, double mZboson, double g, double gprime, double polemw, double runmw, double alpha, double beta, double mtop, double mbottom, double mcharm, double mstrange, double mstop1, double mstop2, double msbottom1, double msbottom2, double mHplus, double thetaL, double thetaR, double thetat, double thetab, double greekmu, double Atop, double Abottom, char higgstype) /// function that calculates the partial width for h->Z gamma at 1-loop (forbidden at tree-level)
{
  double prefactor=0, sinthetaW=0, Itr=0, Iti=0, Ibr=0, Ibi=0, Icr=0, Ici=0, Isr=0, Isi=0, IWr=0, IWi=0, IHpr=0, IHpi=0, matelemmodsquare=0, amplitudeW=0;
  /// Isb1r=0, Isb1i=0, Isb2r=0, Isb2i=0, Ich11r=0, Ich11i=0, Ich12r=0, Ich12i=0, Ich22r=0, Ich22i=0,  Ist1r=0, Ist1i=0, Ist2r=0, Ist2i=0;
  if (m1 < mZboson) {
    amplitudeW = 0;
  }
  else {
     DoubleVector higgsmatrixelementZgammaviafermions (double m1, double mferm, double mZboson, double mWboson, double alpha, double beta, double g, double gprime, double Qferm, double I3ferm, char fermtype, char higgstype);
     ///DoubleVector higgsmatrixelementZgammaviasfermions (double m1, double msferm, double msferm2, double mtop, double mbottom, double mWboson, double thetat, double g, double gprime, double alpha, double beta, double greekmu, double Atop, double Abottom, char higgstype);
     DoubleVector higgsmatrixelementZgammaviaWbosons (double m1, double mWboson, double mZboson, double alpha, double beta, double g, double gprime, char higgstype);
     DoubleVector higgsmatrixelementZgammaviaHplus (double m1, double mWboson, double mZboson, double mHplus, double alpha, double beta, double g, double gprime, char higgstype);
     ///DoubleVector higgsmatrixelementZgammaviacharginos (double m1, double mchar1, double mchar2, double alpha, double beta, char higgstype);
     Itr = 1* higgsmatrixelementZgammaviafermions (m1, mtop, mZboson, polemw, alpha, beta, g, gprime, 2./3, 1./2, 'u', higgstype)(1);
     Iti = 1* higgsmatrixelementZgammaviafermions (m1, mtop, mZboson, polemw, alpha, beta, g, gprime, 2./3, 1./2, 'u', higgstype)(2);
     /// Ist1r = higgsmatrixelementZgammaviasfermions (m1, mstop1, mstop2, mtop, mbottom, mWboson, thetat, g, gprime, alpha, beta, greekmu, Atop, Abottom, higgstype)(1);
     /// Ist1i = higgsmatrixelementgammagammaviastops (m1, mstop1, mstop2, mtop, mbottom, mWboson, thetat, g, gprime, alpha, beta, greekmu, Atop, Abottom, higgstype)(2);
     /// Ist2r = higgsmatrixelementgammagammaviastops (m1, mstop1, mstop2, mtop, mbottom, mWboson, thetat, g, gprime, alpha, beta, greekmu, Atop, Abottom, higgstype)(3);
     /// Ist2i = higgsmatrixelementgammagammaviastops (m1, mstop1, mstop2, mtop, mbottom, mWboson, thetat, g, gprime, alpha, beta, greekmu, Atop, Abottom, higgstype)(4);
     Ibr = 1* higgsmatrixelementZgammaviafermions (m1, mbottom, mZboson, polemw, alpha, beta, g, gprime, -1./3, -1./2, 'd', higgstype)(1);
     Ibi = 1* higgsmatrixelementZgammaviafermions (m1, mbottom, mZboson, polemw, alpha, beta, g, gprime, -1./3, -1./2, 'd', higgstype)(2);
     /// Isb1r = 4*higgsmatrixelementgammagammaviasbottoms (m1, msbottom1, msbottom2, mbottom, mtop, mWboson, thetab, g, gprime, alpha, beta, Atop, Abottom, greekmu, higgstype)(1);
     /// Isb1i = 4*higgsmatrixelementgammagammaviasbottoms (m1, msbottom1, msbottom2, mbottom, mtop, mWboson, thetab, g, gprime, alpha, beta, Atop, Abottom, greekmu, higgstype)(2);
     /// Isb2r = 4*higgsmatrixelementgammagammaviasbottoms (m1, msbottom1, msbottom2, mbottom, mtop, mWboson, thetab, g, gprime, alpha, beta, Atop, Abottom, greekmu, higgstype)(3);
     /// Isb2i = 4*higgsmatrixelementgammagammaviasbottoms (m1, msbottom1, msbottom2, mbottom, mtop, mWboson, thetab, g, gprime, alpha, beta, Atop, Abottom, greekmu, higgstype)(4);
     Icr = 1* higgsmatrixelementZgammaviafermions (m1, mcharm, mZboson, polemw, alpha, beta, g, gprime, 2./3, 1./2, 'u', higgstype)(1);
     Ici = 1* higgsmatrixelementZgammaviafermions (m1, mcharm, mZboson, polemw, alpha, beta, g, gprime, 2./3, 1./2, 'u', higgstype)(2);
     Isr = 1* higgsmatrixelementZgammaviafermions (m1, mstrange, mZboson, polemw, alpha, beta, g, gprime, -1./3, -1./2, 'd', higgstype)(1);
     Isi = 1* higgsmatrixelementZgammaviafermions (m1, mstrange, mZboson, polemw, alpha, beta, g, gprime, -1./3, -1./2, 'd', higgstype)(2);
     IWr = higgsmatrixelementZgammaviaWbosons (m1, polemw, mZboson, alpha, beta, g, gprime, higgstype)(1);
     IWi = higgsmatrixelementZgammaviaWbosons (m1, polemw, mZboson, alpha, beta, g, gprime, higgstype)(2);
     IHpr = higgsmatrixelementZgammaviaHplus (m1, polemw, mZboson, mHplus, alpha, beta, g, gprime, higgstype)(1);
     IHpi = higgsmatrixelementZgammaviaHplus (m1, polemw, mZboson, mHplus, alpha, beta, g, gprime, higgstype)(2);  

     ///cout << "H Z GAMMA INFO:" << endl;
     ///cout << endl;
     ///cout << "Itr= " << Itr << " Iti= " << Iti << " Ibr= " << Ibr << " Ibi= " << Ibi << " Icr= " << Icr << " Ici= " << Ici << endl;
     ///cout << "Isr= " << Isr << " Isi= " << Isi << " IWr= " << IWr << " IWi= " << IWi << " IHpr= " << IHpr << " IHpi= " << IHpi << endl;
     ///cout << endl;
    
     DoubleVector matelemsum(2);
     matelemsum(1) = Itr + Ibr + Icr + Isr + IWr + IHpr;
     matelemsum(2) = Iti + Ibi + Ici + Isi + IWi + IHpi;
     sinthetaW = pow(pow(gprime,2)/(pow(g,2)+pow(gprime,2)),0.5);
     prefactor = pow(m1,3)*pow(1-pow(mZboson/m1,2),3)/(32*PI)*pow(g,6)*pow(sinthetaW,4)/(16*pow(PI*polemw,2)*16*pow(PI,2));
     ///cout << "prefactor= " << prefactor << endl;
     ///cout << endl; 
     ///cout << "taub= " << 4*pow(mbottom/m1,2) << endl;
     ///cout << "lambdab= " << 4*pow(mbottom/mZboson,2) << endl;
     ///cout << "matelemsum(1)= " << matelemsum(1) << " matelemsum(2)= " << matelemsum(2) << endl;
         
     matelemmodsquare = pow(matelemsum(1),2) + pow(matelemsum(2),2);
     ///cout << "matelemmodsquare= " << matelemmodsquare << endl;
     ///cout << "prefactor= " << prefactor << endl;
     
     amplitudeW = prefactor*matelemmodsquare;
     
  }
  return amplitudeW;
}

DoubleVector higgsmatrixelementZgammaviafermions (double m1, double mferm, double mZboson, double mWboson, double alpha, double beta, double g, double gprime, double Qferm, double I3ferm, char fermtype, char higgstype) ///Calculates contribution of fermion loop to higgs to Z gamma decay
{
  double sinthetaW=0, costhetaW=0, Rhf=0, factor1=0, Integral1r=0, Integral1i=0, Integral2r=0, Integral2i=0;
  DoubleVector amplitude(2);
  DoubleVector foftau(double mpart, double mcomp);
  DoubleVector goftau(double mpart, double mcomp);
  DoubleVector ftau(3), flambda(3), gtau(3), glambda(3);
  for (int i=1; i<=3;i++) {
    ftau(i) = 0;
    flambda(i) = 0;
    gtau(i) = 0;
    glambda(i) = 0;
  }
  for (int i=1; i<=2;i++) {
    amplitude(i) = 0;
  }
  ///costhetaW = pow(pow(g,2)/(pow(g,2)+pow(gprime,2)),0.5);
  ///sinthetaW = pow(pow(gprime,2)/(pow(g,2)+pow(gprime,2)),0.5);
  costhetaW = mWboson/mZboson;
  sinthetaW = pow(1 - pow(costhetaW,2),0.5);
  factor1 = -2*Qferm*(I3ferm-2*Qferm*pow(sinthetaW,2));
  if (higgstype == 'h') {
    if (fermtype == 'u') {
      Rhf = cos(alpha)/(sin(beta));
    }
    else if (fermtype == 'd') {
      Rhf = -sin(alpha)/cos(beta);
      }
  }
  else if (higgstype == 'H') {
    if (fermtype == 'u') {
      Rhf = -sin(alpha)/(cos(beta));
    }
    else if (fermtype == 'd') {
      Rhf = cos(alpha)/(cos(beta));
    }
  }
  else if (higgstype == 'A') {
    if (fermtype == 'u') {
      Rhf = 1/tan(beta);
    }
    else if (fermtype == 'd') {
      Rhf = tan(beta);
    }
  }
  ftau = foftau(mferm, m1);
  flambda = foftau(mferm, mZboson);
  gtau = goftau(mferm, m1);
  glambda = goftau (mferm, mZboson); 
  Integral1r = ftau(3)*flambda(3)/(2*(ftau(3)-flambda(3))) + pow(ftau(3)*flambda(3),2)/(2*pow((ftau(3)-flambda(3)),2))*(ftau(1)-flambda(1)) + pow(ftau(3),2)*flambda(3)/(pow(ftau(3)-flambda(3),2))*(gtau(1)-glambda(1));
  Integral1i = pow(ftau(3)*flambda(3),2)/(2*pow((ftau(3)-flambda(3)),2))*(ftau(2)-flambda(2)) + pow(ftau(3),2)*flambda(3)/(pow(ftau(3)-flambda(3),2))*(gtau(2)-glambda(2));
  Integral2r = -ftau(3)*flambda(3)/(2*(ftau(3)-flambda(3)))*(ftau(1)-flambda(1));
  Integral2i = -ftau(3)*flambda(3)/(2*(ftau(3)-flambda(3)))*(ftau(2)-flambda(2));  
  /// cout << "Z gamma via FERMIONS: " << endl;
  /// cout << endl;
  /// cout << "Integral1r = " << Integral1r << " Integral1i = " << Integral1i << endl;
  /// cout << "Integral2r = " << Integral2r << " Integral2i = " << Integral2i << endl;
  /// cout << "real(f(tau)) = " << ftau(1) << " imag(f(tau)) = " << ftau(2) << endl;
  /// cout << "real(f(lambda)) = " << flambda(1) << " imag(f(lambda)) = " << flambda(2) << endl;
  /// cout << "real(g(tau)) = " << gtau(1) << " imag(g(tau)) = " << gtau(2) << endl;
  /// cout << "real(g(lambda)) = " << glambda(1) << " imag(g(lambda)) = " << glambda(2) << endl;
  /// cout << "FTequiv = " << 3*Rhf*factor1/(sinthetaW*costhetaW) << endl;
  /// cout << "sinthetaW = " << sinthetaW << " costhetaW = " << costhetaW << endl;
  /// cout << "Rhf = " << Rhf << " factor1 = " << factor1 << endl;
  /// cout << "tau = " << ftau(3) << " lambda = " << flambda(3) << endl;
  
  amplitude(1) = 3*Rhf*factor1/(sinthetaW*costhetaW)*(Integral1r-Integral2r);
  amplitude(2) = 3*Rhf*factor1/(sinthetaW*costhetaW)*(Integral1i-Integral2i);
  ///cout << endl;
  ///cout << "At= " << amplitude(1) << "+" << amplitude(2) << "i" << endl;

  return amplitude;
}

DoubleVector higgsmatrixelementZgammaviaWbosons (double m1, double mWboson, double mZboson, double alpha, double beta, double g, double gprime, char higgstype) ///Calculates contribution of W boson loop to higgs to Z gamma decay
{
  double tanthetaW=0, RhW=0, factor1=0, factor2=0, Integral1r=0, Integral1i=0, Integral2r=0, Integral2i=0;
  DoubleVector amplitude(2);
  DoubleVector foftau(double mpart, double mcomp);
  DoubleVector goftau(double mpart, double mcomp);
  DoubleVector ftau(3), flambda(3), gtau(3), glambda(3);
  for (int i=1; i<=3;i++) {
    ftau(i) = 0;
    flambda(i) = 0;
    gtau(i) = 0;
    glambda(i) = 0;
  }
  for (int i=1; i<=2;i++) {
    amplitude(i) = 0;
  }
  ///tanthetaW = pow(pow(gprime,2)/(pow(g,2)),0.5);
  tanthetaW = pow((1-pow((mWboson/mZboson),2))/(pow(mWboson/mZboson,2)),0.5);
  if (higgstype == 'h') {
    RhW = sin(beta-alpha);
    }
  else if (higgstype == 'H') {
    RhW = cos(beta-alpha);
  }
  else if (higgstype == 'A') {
    RhW = 0;
  }
  ftau = foftau(mWboson, m1);
  flambda = foftau(mWboson, mZboson);
  gtau = goftau(mWboson, m1);
  glambda = goftau (mWboson, mZboson); 
  
  factor1 = 4*(3-pow(tanthetaW,2));
  factor2 = (1+2/ftau(3))*pow(tanthetaW,2) - (5+2/ftau(3));

  Integral1r = ftau(3)*flambda(3)/(2*(ftau(3)-flambda(3))) + pow(ftau(3)*flambda(3),2)/(2*pow((ftau(3)-flambda(3)),2))*(ftau(1)-flambda(1)) + pow(ftau(3),2)*flambda(3)/(pow(ftau(3)-flambda(3),2))*(gtau(1)-glambda(1));
  Integral1i =pow(ftau(3)*flambda(3),2)/(2*pow((ftau(3)-flambda(3)),2))*(ftau(2)-flambda(2)) + pow(ftau(3),2)*flambda(3)/(pow(ftau(3)-flambda(3),2))*(gtau(2)-glambda(2));
  Integral2r = -ftau(3)*flambda(3)/(2*(ftau(3)-flambda(3)))*(ftau(1)-flambda(1));
  Integral2i = -ftau(3)*flambda(3)/(2*(ftau(3)-flambda(3)))*(ftau(2)-flambda(2));
  /// cout << "Z GAMMA VIA WS:" << endl;
  /// cout << endl;
  /// cout << "RhW = " << RhW << " tauW = " << ftau(3) << " lambdaW = " << flambda(3) << endl;
  /// cout << "Integral1r = " << Integral1r << " Integral1i = " << Integral1i << endl;
  /// cout << "Integral2r = " << Integral2r << " Integral2i = " << Integral2i << endl;
  /// cout << "ftaur = " << ftau(1) << " ftaui = " << ftau(2) << endl;
  /// cout << "flambdar = " << flambda(1) << " flambdai = " << flambda(2) << endl;
  /// cout << "gtaur = " << gtau(1) << " gtaui = " << gtau(2) << endl;
  /// cout << "glambdar = " << glambda(1) << " glambdai = " << glambda(2) << endl;
  /// cout << "tanthetaW = " << tanthetaW << endl;

  amplitude(1) = -RhW*1/tanthetaW*(factor1*Integral2r + factor2*Integral1r);
  amplitude(2) = -RhW*1/tanthetaW*(factor1*Integral2i + factor2*Integral1i);

  return amplitude;
}

DoubleVector higgsmatrixelementZgammaviaHplus (double m1, double mWboson, double mZboson, double mHplus, double alpha, double beta, double g, double gprime, char higgstype) ///Calculates contribution of charged higgs boson loop to higgs to Z gamma decay
{
  double sinthetaW=0, costhetaW=0, RhHplus=0, factor1=0, Integral1r=0, Integral1i=0;
  DoubleVector amplitude(2);
  DoubleVector foftau(double mpart, double mcomp);
  DoubleVector goftau(double mpart, double mcomp);
  DoubleVector ftau(3), flambda(3), gtau(3), glambda(3);
  for (int i=1; i<=3;i++) {
    ftau(i) = 0;
    flambda(i) = 0;
    gtau(i) = 0;
    glambda(i) = 0;
  }
  for (int i=1; i<=2;i++) {
    amplitude(i) = 0;
  }
  ///costhetaW = pow(pow(g,2)/(pow(g,2)+pow(gprime,2)),0.5);
  ///sinthetaW = pow(pow(gprime,2)/(pow(g,2)+pow(gprime,2)),0.5);
  costhetaW = mWboson/mZboson;
  sinthetaW = pow(1 - pow(costhetaW,2),0.5);
  if (higgstype == 'h') {
    RhHplus = sin(beta-alpha) + cos(2*beta)*sin(beta+alpha)/(2*pow(costhetaW,2));
    }
  else if (higgstype == 'H') {
    RhHplus = cos(beta-alpha) - cos(2*beta)*cos(beta+alpha)/(2*pow(costhetaW,2));
  }
  else if (higgstype == 'A') {
    RhHplus =0;
  }
  ftau = foftau(mHplus, m1);
  flambda = foftau(mHplus, mZboson);
  gtau = goftau(mHplus, m1);
  glambda = goftau (mHplus, mZboson); 
  
  factor1 = 1 - 2*pow(sinthetaW,2);

  Integral1r = ftau(3)*flambda(3)/(2*(ftau(3)-flambda(3))) + pow(ftau(3)*flambda(3),2)/(2*pow((ftau(3)-flambda(3)),2))*(ftau(1)-flambda(1)) + pow(ftau(3),2)*flambda(3)/(pow(ftau(3)-flambda(3),2))*(gtau(1)-glambda(1));
  Integral1i = pow(ftau(3)*flambda(3),2)/(2*pow((ftau(3)-flambda(3)),2))*(ftau(2)-flambda(2)) + pow(ftau(3),2)*flambda(3)/(pow(ftau(3)-flambda(3),2))*(gtau(2)-glambda(2));

  /// cout << "Z GAMMA VIA H+s:" << endl;
  /// cout << endl;
  /// cout << "RhHplus = " << RhHplus << " tauH+ = " << ftau(3) << " lambdaH+ = " << flambda(3) << endl;
  /// cout << "Integral1r = " << Integral1r << " Integral1i = " << Integral1i << endl;
  /// cout << "ftaur = " << ftau(1) << " ftaui = " << ftau(2) << endl;
  /// cout << "flambdar = " << flambda(1) << " flambdai = " << flambda(2) << endl;
  /// cout << "gtaur = " << gtau(1) << " gtaui = " << gtau(2) << endl;
  /// cout << "glambdar = " << glambda(1) << " glambdai = " << glambda(2) << endl;
  /// cout << "sinthetaW = " << sinthetaW << endl;
  /// cout << "factor1 = " << factor1 << endl;
  /// cout << "pow(mWboson/mHplus,2) = " << pow(mWboson/mHplus,2) << endl;
  /// cout << "RhHplus*mW^2 = " << RhHplus*pow(mWboson,2) << endl; 
  
  amplitude(1) = RhHplus*factor1/(costhetaW*sinthetaW)*Integral1r*pow(mWboson/mHplus,2);
  amplitude(2) = RhHplus*factor1/(costhetaW*sinthetaW)*Integral1i*pow(mWboson/mHplus,2);
  
  return amplitude;
}


double gluinoamplitudedecay1to3neutfirsttwogen (double m1, double m2, double m3, double m4, double m5, double g, double gp, DoubleMatrix mixNeut, double alphas, char uord, int neut, int Nsteps, int adaptive, int onetothree, double approx)/// m1 is mgluino, m2 is neutralinoi mass, m3 is sqL mass, m4 is sqR mass, m5 is quark mass but assumed zero in calculation here, just used to check allowed for now; char uord tells us if the quark is u type 'u' or d type 'd', int neut tells us which neutralino it is
{
  double amplitudeW=0, phiL=0, phiR=0, psiL=0, psiR=0, A = 0, B = 0, from = 0, to = 0;
  double phitildaintegralsum(double mass1, double mass2, double mass3, double mass4, double mass5, double from, double to, double Nsteps, int adaptive, double approx);
  double psitildaintegralsum(double mass1, double mass2, double mass3, double mass4, double mass5, double from, double to, double Nsteps, int adaptive, double approx);
  int i = neut;
  from = 0;
  to = (pow(m1,2)-pow(m2,2))/(2*m1);
  
  if(onetothree == 0)
    {
      amplitudeW = 0;
    }
  else if (onetothree == 1)
    {  
      if(fabs(m1) < m2 + 2*m5) {
	amplitudeW =0; 
      }
      else if (fabs(m1) > m3 + m5 || fabs(m1) > m4 + m5) {
	amplitudeW = 0; /// 1->3 decay not relevant here if one to two decay open
      }
      else {
	if ( uord == 'u') {
	  A = 1/(pow(2,0.5))*(g*-mixNeut(i,2)+gp/3*-mixNeut(i,1));
	  B = 4/(3*pow(2,0.5))*gp*-mixNeut(i,1);
	}
	else if (uord == 'd') {
	  A = 1/(pow(2,0.5))*(-g*-mixNeut(i,2) + gp/3*-mixNeut(i,1));
	  B = -2/(3*pow(2,0.5))*gp*-mixNeut(i,1);
	}
	
	psiL = psitildaintegralsum(m1,m3,m3,m2,0,from,to,Nsteps,adaptive,approx)*1/(pow(PI,2)*m1);
	psiR = psitildaintegralsum(m1,m4,m4,m2,0,from,to,Nsteps,adaptive,approx)*1/(pow(PI,2)*m1);
	phiL = phitildaintegralsum(m1,m3,m3,m2,0,from,to,Nsteps,adaptive,approx)*1/(pow(PI,2)*m1);
	phiR = phitildaintegralsum(m1,m4,m4,m2,0,from,to,Nsteps,adaptive,approx)*1/(pow(PI,2)*m1);
	cout << "psiL = " << psiL << " psiR = " << psiR << " phiL = " << phiL << " phiR = " << phiR << endl;
	amplitudeW = alphas/(8*pow(PI,2))*(pow(A,2)*(psiL + phiL) + pow(B,2)*(psiR + phiR));

	// cout << "!!!" << endl;
	// cout << "Neutralino" << neut << endl;
	// cout << "Gammast1equiv = " << pow(A,2)*(psiL + phiL)*pow(PI,2)*m1 << endl;
	// cout << "Gammast2equiv = " << pow(B,2)*(psiR + phiR)*pow(PI,2)*m1 << endl;
	// cout << "alphast1 = " << A << endl;
	// cout << "alphast2 = " << B << endl;
	// cout << "psitilda(mg,mqL,mZi) = " << psiL << endl;
	// cout << "phitilda(mg,mqL,mZi) = " << phiL << endl;
	// cout << "psitilda(mg,mqR,mZi) = " << psiR << endl;
	// cout << "phitilda(mg,mqR,mZi) = " << phiR << endl;
	// cout << "prefactor = " << alphas/(8*pow(PI,2)) << endl;
	// cout << "!!!" << endl;

	// if (neut == 3 && uord == 'u') {
	//   cout << "GammaLLst1equiv = " << pow(A,2)*(psiL + phiL)*pow(PI,2)*m1 << endl;
	//   cout << "GammaRRst2equiv = " << pow(B,2)*(psiR + phiR)*pow(PI,2)*m1 << endl;
	//   cout << "Sum of equivs = " << pow(A,2)*(psiL + phiL)*pow(PI,2)*m1 + pow(B,2)*(psiR + phiR)*pow(PI,2)*m1 << endl;
	//   cout << "Difference of equivs = " << pow(A,2)*(psiL + phiL)*pow(PI,2)*m1 - pow(B,2)*(psiR + phiR)*pow(PI,2)*m1 << endl;
	// }
	// else if (neut == 3 && uord == 'd') {
	//   cout << "GammaLLsb1equiv = " << pow(A,2)*(psiL + phiL)*pow(PI,2)*m1 << endl;
	//   cout << "GammaRRsb2equiv = " << pow(B,2)*(psiR + phiR)*pow(PI,2)*m1 << endl;
	//   cout << "Sum of equivs = " << pow(A,2)*(psiL + phiL)*pow(PI,2)*m1 + pow(B,2)*(psiR + phiR)*pow(PI,2)*m1 << endl;
	//   cout << "Difference of equivs = " << pow(A,2)*(psiL + phiL)*pow(PI,2)*m1 - pow(B,2)*(psiR + phiR)*pow(PI,2)*m1 << endl;
	// }
	///cout << "alphas = " << alphas << endl;
      }
    }
  return amplitudeW;
}
 

double gluinoamplitudedecay1to3charfirsttwogen (double m1, double m2, double m3, double m4, double m5, double m6, double g, double thetaL, double thetaR, double alphas, int charg, int Nsteps, int adaptive, int onetothree, double approx) /// calculates the 1->3 decay PW for gluino to chargino and a quark and antiquark of the first two generations, m1 is gluino mass, m2 is up squark mass, m3 is down squark mass, m4 is chargino mass. We take the two quarks to be massless for simplicity in the calculation (therefore first two generations), m5 and m6 are their actual masses but these are just used to check the decay is allowed. int charg indicates if it's a chargino1 (charg = 1) or a chargino2 (charg = 2)
{
  double amplitudeW=0, Au=0, Ad=0, psiu=0, psid=0, phiI=0, from = 0, to = 0;
  to = (pow(m1,2) - pow(m4,2))/(2*m1);
  
  double phitildaintegralsum(double mass1, double mass2, double mass3, double mass4, double mass5, double from, double to, double Nsteps, int adaptive, double approx);
  double psitildaintegralsum(double mass1, double mass2, double mass3, double mass4, double mass5, double from, double to, double Nsteps, int adaptive, double approx);

  if (onetothree == 0) {
    amplitudeW = 0;
  }
  else if (onetothree == 1) {
    
    if(m1 < m4+m5+m6) {
      amplitudeW = 0;
    }
    else if (m1 > m2 + m5 || m1 > m3 + m6) {
	amplitudeW = 0; /// 1->3 decay not relevant here if one to two decay open
      }
    else {

      if (charg == 1) /// chargino1 decaying
      {
	Ad = g*sin(thetaR); 
	Au = g*sin(thetaL);
      }
    else if (charg == 2) ///chargino2 decaying
      {
	Ad = g*cos(thetaR);
	Au = g*cos(thetaL);
      }
      
      phiI = phitildaintegralsum(m1,m2,m3,m4,0,from,to,Nsteps,adaptive,approx)*1/(pow(PI,2)*m1);
      psiu = psitildaintegralsum(m1,m2,m2,m4,0,from,to,Nsteps,adaptive,approx)*1/(pow(PI,2)*m1);
      psid = psitildaintegralsum(m1,m3,m3,m4,0,from,to,Nsteps,adaptive,approx)*1/(pow(PI,2)*m1);
      
      amplitudeW = alphas/(16*pow(PI,2))*(pow(Ad,2)*psiu + pow(Au,2)*psid + 2*Au*Ad*phiI);
      ///cout << "Au = " << Au << " Ad = " << Ad << endl;
      ///cout << "alphas = " << alphas << endl;
      cout << "phiI = " << phiI << " psiu = " << psiu << " psid = " << psid << endl;
	
	}
  }
  return amplitudeW;
}


double gluinoamplitudedecay1to3neutttbar (double m1, double m2, double m3, double m4, double m5, double mw, double g, double gp, double thetat, double beta, double alphas, DoubleMatrix mixNeut, double runmq, int neutralino, int Nsteps, int adaptive, int onetothree, double approx) ///calculates PW for gluino -> neutralino + q qbar pair where q are t or b so third gen
{
  double phitildaintegralsum(double mass1, double mass2, double mass3, double mass4, double mass5, double from, double to, double Nsteps, int adaptive, double approx);
  double psitildaintegralsum(double mass1, double mass2, double mass3, double mass4, double mass5, double from, double to, double Nsteps, int adaptive, double approx);
  double xsiintegralsum(double mass1, double mass2, double mass3, double mass4, double massq, double from, double to, double Nsteps, int adaptive, double approx);
  double rhointegralsum(double mass1, double mass2, double mass3, double mass4, double massq, double from, double to, double Nsteps, int adaptive, double approx);
  double chiintegralsum(double mass1, double mass2, double mass3, double mass4, double massq, double from, double to, double Nsteps, int adaptive, double approx);
  double zetaintegralsum(double mass1, double mass2, double mass3, double mass4, double massq, double from, double to, double Nsteps, int adaptive, double approx);
  double Xintegralsum(double mass1, double mass2, double mass3, double mass4, double massq, double from, double to, double Nsteps, int adaptive, double approx);
  double Yintegralsum(double mass1, double mass2, double mass3, double mass4, double massq, double from, double to, double Nsteps, int adaptive, double approx);
  double chiprimeintegralsum(double mass1, double mass2, double mass3, double mass4, double massq, double from, double to, double Nsteps, int adaptive, double approx);
  double amplitudeW=0, Gammast1=0, Gammast2=0, Gammast1st2=0, GammaLLst1=0, GammaRRst1=0, GammaL1R1st1=0, GammaL1R2st1=0, GammaLLst2=0, GammaRRst2=0, GammaL1R1st2=0, GammaLLst1st2=0, GammaRRst1st2=0, GammaRLst1st2=0, GammaL2R2st1=0, GammaL2R1st1=0, GammaL2R2st2=0, GammaL2R1st2=0, GammaL1R2st2=0, GammaLRst1st2=0;
  double AtZ=0, BtZ=0, st1alpha1=0, st1beta1=0, st1alpha2=0, st1beta2=0, st2alpha1=0, st2alpha2=0, st2beta1=0, st2beta2=0, ft=0, from=0, to=0;
  if (fabs(m1) < fabs(m4) + 2*m5 || fabs(m1)> m2 + m5 || fabs(m1) > m3 + m5 || onetothree ==0) { amplitudeW = 0;}
  else {
    
    from = m5;
    to = (pow(m1,2)-2*m5*fabs(m4)-pow(m4,2))/(2*m1);
    ft = g*runmq/(pow(2,0.5)*mw*sin(beta));
    AtZ = g/(pow(2,0.5))*(-mixNeut(neutralino,2)) + gp/(3*pow(2,0.5))*(-mixNeut(neutralino,1));
    BtZ = (4./3)*gp/(pow(2,0.5))*(-mixNeut(neutralino,1));
    st1alpha1 = AtZ*cos(thetat) - ft*mixNeut(neutralino,4)*sin(thetat);
    st1beta1 = ft*mixNeut(neutralino,4)*cos(thetat) + BtZ*sin(thetat);
    st1alpha2 = BtZ*sin(thetat)+ft*mixNeut(neutralino,4)*cos(thetat);
    st1beta2 = -ft*mixNeut(neutralino,4)*sin(thetat)+AtZ*cos(thetat);
    st2alpha1 = AtZ*sin(thetat)+ft*mixNeut(neutralino,4)*cos(thetat);
    st2beta1 = ft*mixNeut(neutralino,4)*sin(thetat)-BtZ*cos(thetat);
    st2alpha2 = -BtZ*cos(thetat) + ft*mixNeut(neutralino,4)*sin(thetat);
    st2beta2 = ft*mixNeut(neutralino,4)*cos(thetat) + AtZ*sin(thetat);

    cout << "NEXT NEUTRALINO " << neutralino << endl;
    

  
    ///stop1 bits
    GammaLLst1 = (pow(st1alpha1,2)+pow(st1beta1,2))*psitildaintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx) - 4*m5*fabs(m4)*st1alpha1*st1beta1*chiintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx) + fabs(m1)*(fabs(m4)*((pow(st1alpha1,2))/(m1*m4)*phitildaintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)+pow(st1beta1,2)*pow(m5,2)*rhointegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)) - st1alpha1*st1beta1*m5*(xsiintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)-pow(m4,2)*rhointegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)));
    GammaRRst1 = (pow(st1alpha2,2)+pow(st1beta2,2))*psitildaintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx) - 4*m5*fabs(m4)*st1alpha2*st1beta2*chiintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx) + fabs(m1)*(fabs(m4)*((pow(st1alpha2,2))/(m1*m4)*phitildaintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)+pow(st1beta2,2)*pow(m5,2)*rhointegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)) - st1alpha2*st1beta2*m5*(xsiintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)-pow(m4,2)*rhointegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)));
    
    GammaL1R1st1 = 2*fabs(m1)*m5*((st1alpha1*st1alpha2+st1beta1*st1beta2)*m5*fabs(m4)*zetaintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx) - (st1alpha2*st1beta1+st1alpha1*st1beta2)*Xintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx));
    GammaL2R2st1 = GammaL1R1st1;
  
    GammaL1R2st1 = st1beta1*st1beta2*Yintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)+st1alpha1*st1alpha2*pow(m5,2)*xsiintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)-m5*fabs(m4)*(st1alpha1*st1beta2+st1alpha2*st1beta1)*chiprimeintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx);
    GammaL2R1st1= GammaL1R2st1;
    ///now stop2 bits
    GammaLLst2= (pow(st2alpha1,2)+pow(st2beta1,2))*psitildaintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx) - 4*m5*fabs(m4)*st2alpha1*st2beta1*chiintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx) + fabs(m1)*(fabs(m4)*((pow(st2alpha1,2))/(m1*m4)*phitildaintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)+pow(st2beta1,2)*pow(m5,2)*rhointegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)) - st2alpha1*st2beta1*m5*(xsiintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)-pow(m4,2)*rhointegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)));

    GammaRRst2 = (pow(st2alpha2,2)+pow(st2beta2,2))*psitildaintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx) - 4*m5*fabs(m4)*st2alpha2*st2beta2*chiintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx) + fabs(m1)*(fabs(m4)*((pow(st2alpha2,2))/(m1*m4)*phitildaintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)+pow(st2beta2,2)*pow(m5,2)*rhointegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)) - st2alpha2*st2beta2*m5*(xsiintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)-pow(m4,2)*rhointegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)));
  
    GammaL1R1st2 = 2*fabs(m1)*m5*((st2alpha1*st2alpha2+st2beta1*st2beta2)*m5*fabs(m4)*zetaintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx) - (st2alpha2*st2beta1+st2alpha1*st2beta2)*Xintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx));
    GammaL2R2st2 = GammaL1R1st2;
  
    GammaL1R2st2 = st2beta1*st2beta2*Yintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)+st2alpha1*st2alpha2*pow(m5,2)*xsiintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)-m5*fabs(m4)*(st2alpha1*st2beta2+st2alpha2*st2beta1)*chiprimeintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx);
    GammaL2R1st2= GammaL1R2st2;

    ///stop1 and stop2 bits

    double a1=0, a2=0, b1=0, b2=0, c1=0, c2=0, d1=0, d2=0, e1=0, e2=0, f1=0, f2=0, g1=0, g2=0, h1=0, h2=0;
    a1 = AtZ*cos(thetat)-ft*mixNeut(neutralino,4)*sin(thetat);
    a2 = AtZ*sin(thetat) + ft*mixNeut(neutralino,4)*cos(thetat);
    b1 = ft*mixNeut(neutralino,4)*cos(thetat)+BtZ*sin(thetat);
    b2 = ft*mixNeut(neutralino,4)*sin(thetat)-BtZ*cos(thetat);
    c1 = -BtZ*sin(thetat)-ft*mixNeut(neutralino,4)*cos(thetat);
    c2 = BtZ*cos(thetat)-ft*mixNeut(neutralino,4)*sin(thetat);
    d1 = -ft*mixNeut(neutralino,4)*sin(thetat) + AtZ*cos(thetat);
    d2 = ft*mixNeut(neutralino,4)*cos(thetat) + AtZ*sin(thetat);
    e1 = AtZ*cos(thetat) - ft*mixNeut(neutralino,4)*sin(thetat);
    e2 = BtZ*cos(thetat) - ft*mixNeut(neutralino,4)*sin(thetat);
    f1 = ft*mixNeut(neutralino,4)*cos(thetat) + BtZ*sin(thetat);
    f2 = ft*mixNeut(neutralino,4)*cos(thetat) + AtZ*sin(thetat);
    g1 = AtZ*sin(thetat) + ft*mixNeut(neutralino,4)*cos(thetat);
    g2 = -BtZ*sin(thetat) - ft*mixNeut(neutralino,4)*cos(thetat);
    h1 = ft*mixNeut(neutralino,4)*sin(thetat) - BtZ*cos(thetat);
    h2 = -ft*mixNeut(neutralino,4)*sin(thetat) + AtZ*cos(thetat);

    GammaLLst1st2 = 2*(a1*a2+b1*b2)*psitildaintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) - 4*m5*fabs(m4)*(a1*b2+a2*b1)*chiintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) - m1*(-2*m4*(a1*a2/(m1*fabs(m4))*phitildaintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) + b1*b2*pow(m5,2)*rhointegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx)) + (a1*b2+a2*b1)*m5*(xsiintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx)-pow(m4,2)*rhointegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx)));

    GammaRRst1st2 = -2*(c1*c2+d1*d2)*psitildaintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) - 4*fabs(m4)*m5*(c1*d2+d1*c2)*chiintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) + fabs(m1)*(-2*fabs(m4)*(c1*c2/(m1*m4)*phitildaintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) + d1*d2*pow(m5,2)*rhointegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx)) - (c1*d2+c2*d1)*m5*(xsiintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) - pow(m4,2)*rhointegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx)));
    
    GammaLRst1st2 = 4*fabs(m1)*m5*((-e1*e2+f1*f2)*m5*fabs(m4)*zetaintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) + (e2*f1-e1*f2)*Xintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx)) + 2*f1*f2*Yintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) + 2*m5*fabs(m4)*(f1*e2-e1*f2)*chiprimeintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) - 2*e1*e2*pow(m5,2)*xsiintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx);

    GammaRLst1st2 = -(4*fabs(m1)*m5*((-g1*g2+h1*h2)*m5*fabs(m4)*zetaintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) + (g2*h1-g1*h2)*Xintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx)) + 2*h1*h2*Yintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) + 2*m5*fabs(m4)*(h1*g2-g1*h2)*chiprimeintegralsum(m1,m3,m2,m4,m5,from,to,Nsteps,adaptive,approx) - 2*g1*g2*pow(m5,2)*xsiintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx));


    Gammast1 = GammaLLst1*pow(cos(thetat),2) + GammaRRst1*pow(sin(thetat),2) - sin(thetat)*cos(thetat)*(GammaL1R1st1 + GammaL1R2st1 + GammaL2R1st1 + GammaL2R2st1);
    Gammast2 = GammaLLst2*pow(sin(thetat),2) + GammaRRst2*pow(cos(thetat),2) + sin(thetat)*cos(thetat)*(GammaL1R1st2 + GammaL1R2st2 + GammaL2R1st2 + GammaL2R2st2);
    Gammast1st2 = (GammaLLst1st2 + GammaRRst1st2)*sin(thetat)*cos(thetat) + GammaLRst1st2*pow(cos(thetat),2) + GammaRLst1st2*pow(sin(thetat),2);
    cout << "In Gammast1st2: " << endl;
    cout << "GammaLLst1st2 = " << GammaLLst1st2 << " GammaRRst1st2 = " << GammaRRst1st2 << endl;
    cout << "GammaLRst1st2 = " << GammaLRst1st2 << " GammaRLst1st2 = " << GammaRLst1st2 << endl;
    cout << "g1 = " << g1 << " g2 = "<< g2 << " h1 = " << h1 << " h2 = " << h2 << endl;
    cout << 4*fabs(m1)*m5*((-g1*g2+h1*h2)*m5*fabs(m4)*zetaintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx)) << endl;
    cout <<  4*fabs(m1)*m5*(g2*h1-g1*h2)*Xintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) << endl;
    cout << 2*h1*h2*Yintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) << endl;
    cout << 2*m5*fabs(m4)*(h1*g2-g1*h2)*chiprimeintegralsum(m1,m3,m2,m4,m5,from,to,Nsteps,adaptive,approx) << endl;
    cout << - 2*g1*g2*pow(m5,2)*xsiintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) << endl;
    cout << "GammaRLst1st2 should = " << 4*fabs(m1)*m5*((-g1*g2+h1*h2)*m5*fabs(m4)*zetaintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx)) + 4*fabs(m1)*m5*(g2*h1-g1*h2)*Xintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) + 2*h1*h2*Yintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) + 2*m5*fabs(m4)*(h1*g2-g1*h2)*chiprimeintegralsum(m1,m3,m2,m4,m5,from,to,Nsteps,adaptive,approx) - 2*g1*g2*pow(m5,2)*xsiintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) << endl;


    amplitudeW = alphas/(8*pow(PI,4)*m1)*(Gammast1 + Gammast2 + Gammast1st2);
    ///cout << endl;
    ///cout << "GLUINO TO NEUT AND T TBAR INFO for neutralino" << neutralino << ": " << endl;
    ///cout << "prefactors = " << alphas/(8*pow(PI,4)*m1) << endl;
    cout << "Gammast1 = " << Gammast1 << " Gammast2 = " << Gammast2 << " Gammast1st2 = " << Gammast1st2 << endl;
    cout << "GammaLLst1 = " << GammaLLst1 << " GammaRRst1 = " << GammaRRst1 << " GammaL1R1st1 = " << GammaL1R1st1 << " GammaL1R2st1 = " << GammaL1R2st1 << endl;
    cout << "GammaL2R1st1 = " << GammaL2R1st1 << " GammaL2R2st1 = " << GammaL2R2st1 << endl;
    cout << "GammaLLst2 = " << GammaLLst2 << " GammaRRst2 = " << GammaRRst2 << " GammaL1R1st2 = " << GammaL1R1st2 << endl;
    cout << "GammaL1R2st2 = " << GammaL1R2st2 << " GammaL2R1st2= " << GammaL2R1st2 << " GammaL2R2st2 = " << GammaL2R2st2 << endl;
    cout << "GammaLLst1st2 = " << GammaLLst1st2 << " GammaRRst1st2 = " << GammaRRst1st2 << endl;
    cout << "GammaLRst1st2 = " << GammaLRst1st2 << " GammaRLst1st2 = " << GammaRLst1st2 << endl;

 

  }
  return amplitudeW;
}

double gluinoamplitudedecay1to3neutbbbar (double m1, double m2, double m3, double m4, double m5, double mw, double g, double gp, double thetab, double beta,double alphas, DoubleMatrix mixNeut, double runmq, int neutralino, int Nsteps, int adaptive, int onetothree, double approx) ///funtion for evaluating gluinos 1->3 decays to neutralino and a b bbar pair, this is done via a number of 1D numerical integrations
{
  double phitildaintegralsum(double mass1, double mass2, double mass3, double mass4, double mass5, double from, double to, double Nsteps, int adaptive, double approx);
  double psitildaintegralsum(double mass1, double mass2, double mass3, double mass4, double mass5, double from, double to, double Nsteps, int adaptive, double approx);
  double xsiintegralsum(double mass1, double mass2, double mass3, double mass4, double massq, double from, double to, double Nsteps, int adaptive, double approx);
  double rhointegralsum(double mass1, double mass2, double mass3, double mass4, double massq, double from, double to, double Nsteps, int adaptive, double approx);
  double chiintegralsum(double mass1, double mass2, double mass3, double mass4, double massq, double from, double to, double Nsteps, int adaptive, double approx);
  double zetaintegralsum(double mass1, double mass2, double mass3, double mass4, double massq, double from, double to, double Nsteps, int adaptive, double approx);
  double Xintegralsum(double mass1, double mass2, double mass3, double mass4, double massq, double from, double to, double Nsteps, int adaptive, double approx);
  double Yintegralsum(double mass1, double mass2, double mass3, double mass4, double massq, double from, double to, double Nsteps, int adaptive, double approx);
  double chiprimeintegralsum(double mass1, double mass2, double mass3, double mass4, double massq, double from, double to, double Nsteps, int adaptive, double approx);
  double amplitudeW=0, Gammasb1=0, Gammasb2=0, Gammasb1sb2=0, GammaLLsb1=0, GammaRRsb1=0, GammaL1R1sb1=0, GammaL1R2sb1=0, GammaLLsb2=0, GammaRRsb2=0, GammaL1R1sb2=0, GammaLLsb1sb2=0, GammaRRsb1sb2=0, GammaRLsb1sb2=0, GammaL2R2sb1=0, GammaL2R1sb1=0, GammaL2R2sb2=0, GammaL2R1sb2=0, GammaL1R2sb2=0, GammaLRsb1sb2=0;
  double AbZ=0, BbZ=0, sb1alpha1=0, sb1beta1=0, sb1alpha2=0, sb1beta2=0, sb2alpha1=0, sb2alpha2=0, sb2beta1=0, sb2beta2=0, fb=0, from=0, to=0;
  if (m1 < m4 + 2*m5 || m1 > m2 + m5 || m1 > m3 + m5 || onetothree == 0) { amplitudeW = 0;}
  else {
    from = m5;
    to = (pow(m1,2)-2*m5*fabs(m4)-pow(m4,2))/(2*m1);
    fb = g*runmq/(pow(2,0.5)*mw*cos(beta));
    AbZ = -g/(pow(2,0.5))*(-mixNeut(neutralino,2)) + gp/(3*pow(2,0.5))*(-mixNeut(neutralino,1));
    BbZ = (-2./3)*gp/(pow(2,0.5))*(-mixNeut(neutralino,1));
    sb1alpha1 = AbZ*cos(thetab) - fb*mixNeut(neutralino,3)*sin(thetab);
    sb1beta1 = fb*mixNeut(neutralino,3)*cos(thetab) + BbZ*sin(thetab);
    sb1alpha2 = BbZ*sin(thetab)+fb*mixNeut(neutralino,3)*cos(thetab);
    sb1beta2 = -fb*mixNeut(neutralino,3)*sin(thetab)+AbZ*cos(thetab);
    sb2alpha1 = AbZ*sin(thetab)+fb*mixNeut(neutralino,3)*cos(thetab);
    sb2beta1 = fb*mixNeut(neutralino,3)*sin(thetab)-BbZ*cos(thetab);
    sb2alpha2 = -BbZ*cos(thetab) + fb*mixNeut(neutralino,3)*sin(thetab);
    sb2beta2 = fb*mixNeut(neutralino,3) + AbZ*sin(thetab);


    ///sbottom1 bits
    GammaLLsb1 = (pow(sb1alpha1,2)+pow(sb1beta1,2))*psitildaintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx) - 4*m5*fabs(m4)*sb1alpha1*sb1beta1*chiintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx) + fabs(m1)*(fabs(m4)*((pow(sb1alpha1,2))/(m1*m4)*phitildaintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)+pow(sb1beta1,2)*pow(m5,2)*rhointegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)) - sb1alpha1*sb1beta1*m5*(xsiintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)-pow(m4,2)*rhointegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)));
    GammaRRsb1 = (pow(sb1alpha2,2)+pow(sb1beta2,2))*psitildaintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx) - 4*m5*fabs(m4)*sb1alpha2*sb1beta2*chiintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx) + fabs(m1)*(fabs(m4)*((pow(sb1alpha2,2))/(m1*m4)*phitildaintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)+pow(sb1beta2,2)*pow(m5,2)*rhointegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)) - sb1alpha2*sb1beta2*m5*(xsiintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)-pow(m4,2)*rhointegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)));

    GammaL1R1sb1 = 2*fabs(m1)*m5*((sb1alpha1*sb1alpha2+sb1beta1*sb1beta2)*m5*fabs(m4)*zetaintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx) - (sb1alpha2*sb1beta1+sb1alpha1*sb1beta2)*Xintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx));
    GammaL2R2sb1 = GammaL1R1sb1;
  
    GammaL1R2sb1 = sb1beta1*sb1beta2*Yintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)+sb1alpha1*sb1alpha2*pow(m5,2)*xsiintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx)-m5*fabs(m4)*(sb1alpha1*sb1beta2+sb1alpha2*sb1beta1)*chiprimeintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx);
    GammaL2R1sb1= GammaL1R2sb1;
    ///now stop2 bits
    GammaLLsb2= (pow(sb2alpha1,2)+pow(sb2beta1,2))*psitildaintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx) - 4*m5*fabs(m4)*sb2alpha1*sb2beta1*chiintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx) + fabs(m1)*(fabs(m4)*((pow(sb2alpha1,2))/(m1*m4)*phitildaintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)+pow(sb2beta1,2)*pow(m5,2)*rhointegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)) - sb2alpha1*sb2beta1*m5*(xsiintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)-pow(m4,2)*rhointegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)));
    GammaRRsb2 = (pow(sb2alpha2,2)+pow(sb2beta2,2))*psitildaintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx) - 4*m5*fabs(m4)*sb2alpha2*sb2beta2*chiintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx) + fabs(m1)*(fabs(m4)*((pow(sb2alpha2,2))/(m1*m4)*phitildaintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)+pow(sb2beta2,2)*pow(m5,2)*rhointegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)) - sb2alpha2*sb2beta2*m5*(xsiintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)-pow(m4,2)*rhointegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)));
  
    GammaL1R1sb2 = 2*fabs(m1)*m5*((sb2alpha1*sb2alpha2+sb2beta1*sb2beta2)*m5*fabs(m4)*zetaintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx) - (sb2alpha2*sb2beta1+sb2alpha1*sb2beta2)*Xintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx));
    GammaL2R2sb2 = GammaL1R1sb2;
  
    GammaL1R2sb2 = sb2beta1*sb2beta2*Yintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)+sb2alpha1*sb2alpha2*pow(m5,2)*xsiintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx)-m5*fabs(m4)*(sb2alpha1*sb2beta2+sb2alpha2*sb2beta1)*chiprimeintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx);
    GammaL2R1sb2= GammaL1R2sb2;

    ///sbottom1 and sbottom2 bits

    double a1=0, a2=0, b1=0, b2=0, c1=0, c2=0, d1=0, d2=0, e1=0, e2=0, f1=0, f2=0, g1=0, g2=0, h1=0, h2=0;
    a1 = AbZ*cos(thetab)-fb*mixNeut(neutralino,3)*sin(thetab);
    a2 = AbZ*sin(thetab) + fb*mixNeut(neutralino,3)*cos(thetab);
    b1 = fb*mixNeut(neutralino,3)*cos(thetab)+BbZ*sin(thetab);
    b2 = fb*mixNeut(neutralino,3)*sin(thetab)-BbZ*cos(thetab);
    c1 = -BbZ*sin(thetab)-fb*mixNeut(neutralino,3)*cos(thetab);
    c2 = BbZ*cos(thetab)-fb*mixNeut(neutralino,3)*sin(thetab);
    d1 = -fb*mixNeut(neutralino,3)*sin(thetab) + AbZ*cos(thetab);
    d2 = fb*mixNeut(neutralino,3)*cos(thetab) + AbZ*sin(thetab);
    e1 = AbZ*cos(thetab) - fb*mixNeut(neutralino,3)*sin(thetab);
    e2 = BbZ*cos(thetab) - fb*mixNeut(neutralino,3)*sin(thetab);
    f1 = fb*mixNeut(neutralino,3)*cos(thetab) + BbZ*sin(thetab);
    f2 = fb*mixNeut(neutralino,3)*cos(thetab) + AbZ*sin(thetab);
    g1 = AbZ*sin(thetab) + fb*mixNeut(neutralino,3)*cos(thetab);
    g2 = -BbZ*sin(thetab) - fb*mixNeut(neutralino,3)*cos(thetab);
    h1 = fb*mixNeut(neutralino,3)*sin(thetab) - BbZ*cos(thetab);
    h2 = -fb*mixNeut(neutralino,3)*sin(thetab) + AbZ*cos(thetab);

    GammaLLsb1sb2 = 2*(a1*a2+b1*b2)*psitildaintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) - 4*m5*fabs(m4)*(a1*b2+a2*b1)*chiintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) - m1*(-2*m4*(a1*a2/(m1*fabs(m4))*phitildaintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) + b1*b2*pow(m5,2)*rhointegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx)) + (a1*b2+a2*b1)*m5*(xsiintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx)-pow(m4,2)*rhointegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx)));

    GammaRRsb1sb2 = -2*(c1*c2+d1*d2)*psitildaintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) - 4*fabs(m4)*m5*(c1*d2+d1*c2)*chiintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) + fabs(m1)*(-2*fabs(m4)*(c1*c2/(m1*m4)*phitildaintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) + d1*d2*pow(m5,2)*rhointegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx)) - (c1*d2+c2*d1)*m5*(xsiintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) - pow(m4,2)*rhointegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx)));
    
    GammaLRsb1sb2 = 4*fabs(m1)*m5*((-e1*e2+f1*f2)*m5*fabs(m4)*zetaintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) + (e2*f1-e1*f2)*Xintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx)) + 2*f1*f2*Yintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) + 2*m5*fabs(m4)*(f1*e2-e1*f2)*chiprimeintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) - 2*e1*e2*pow(m5,2)*xsiintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx);

    GammaRLsb1sb2 = -4*fabs(m1)*m5*((-g1*g2+h1*h2)*m5*fabs(m4)*zetaintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) + (g2*h1-g1*h2)*Xintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx)) + 2*h1*h2*Yintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx) + 2*m5*fabs(m4)*(h1*g2-g1*h2)*chiprimeintegralsum(m1,m3,m2,m4,m5,from,to,Nsteps,adaptive,approx) - 2*g1*g2*pow(m5,2)*xsiintegralsum(m1,m2,m3,m4,m5,from,to,Nsteps,adaptive,approx);


    Gammasb1 = GammaLLsb1*pow(cos(thetab),2) + GammaRRsb1*pow(sin(thetab),2) - sin(thetab)*cos(thetab)*(GammaL1R1sb1 + GammaL1R2sb1 + GammaL2R1sb1 + GammaL2R2sb1);
    Gammasb2 = GammaLLsb2*pow(sin(thetab),2) + GammaRRsb2*pow(cos(thetab),2) + sin(thetab)*cos(thetab)*(GammaL1R1sb2 + GammaL1R2sb2 + GammaL2R1sb2 + GammaL2R2sb2);
    Gammasb1sb2 = (GammaLLsb1sb2 + GammaRRsb1sb2)*sin(thetab)*cos(thetab) + GammaLRsb1sb2*pow(cos(thetab),2) + GammaRLsb1sb2*pow(sin(thetab),2);

    cout << "!!!!!!!!" << endl;
    cout << "Neutralino" << neutralino << endl;
    cout << "Gammasb1 = " << Gammasb1 << " Should be approx GammaLLsb1" << endl;
    cout << "Gammasb2 = " << Gammasb2 << " Should be GammaRRsb2" << endl;
    cout << "alpha1 = " << sb1alpha1 << endl;
    cout << "alpha2 = " << sb2alpha2 << endl;
    cout << "psitilda(mg,mb1,mZi) = " << psitildaintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx) << endl;
    cout << "phitilda(mg,mb1,mZi) = " << phitildaintegralsum(m1,m2,m2,m4,m5,from,to,Nsteps,adaptive,approx) << endl;
    cout << "psitilda(mg,mb2,mZi) = " << psitildaintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx) << endl;
    cout << "phitilda(mg,mb2,mZi) = " << phitildaintegralsum(m1,m3,m3,m4,m5,from,to,Nsteps,adaptive,approx) << endl;
    ///cout << "Sum of these = " << Gammasb1 + Gammasb2 << endl;
    ///cout << "Difference of these = " << Gammasb1 - Gammasb2 << endl;
    ///cout << "Gammasb1sb2 = " << Gammasb1sb2 << " Should be GammaLRsb1sb2" << endl;
    ///cout << "GammaLLsb1 = " << GammaLLsb1 << " Should be (alpha1^2)psi + mglu[abs(mZi)(alpha1^2/(mglu*mZi)*phi" << endl;
    ///cout << "GammaRRsb2 = " << GammaRRsb2 << " Should be (alpha2^2)psi + mglu[abs(mZi)(alpha2^2/(mglu*mZi)*phi" << endl;
    ///cout << "GammaLRsb1sb2 = " << GammaLRsb1sb2 << " Should be approx 0" << endl;
    cout << "prefactor = " << alphas/(8*pow(PI,4)*m1) << endl;
    cout << "!!!!!!!!" << endl;

    amplitudeW = alphas/(8*pow(PI,4)*m1)*(Gammasb1 + Gammasb2 + Gammasb1sb2);
    
    if (mq < 0.001 && neutralino == 1) {
      cout << endl;
      /// IN HERE ONLY SCALE ALL BY 3.90625*10^5 TO COMPARE WITH SPHENO - IMPORTANT ONLY SCALED IN HERE AS THIS SCALING WILL CHANGE PREFACTOR REQUIRED IN AMPLITUDEW TO 1/(256*PI^3*MGLUINO^3)!
      
      cout << "Gammasb1 = "<< Gammasb1*390625 << " Gammasb2 = " << Gammasb2*390625 << " Gammasb1sb2 = " << Gammasb1sb2*390625 << endl;
      cout << "GammaLLsb1*cos^2(thetab) = " << GammaLLsb1*pow(cos(thetab),2)*390625 << " GammaRRsb1*sin^2(thetab) = " << GammaRRsb1*pow(sin(thetab),2)*390625 << endl;
      cout << "GammaLLsb1 = " << GammaLLsb1*390625 << endl;
      cout << "-sin(thetab)*cos(thetab)*(GammaL1R1sb1+GammaL1R2sb1+GammaL2R1sb1+GammaL2R2sb1) = " << -sin(thetab)*cos(thetab)*(GammaL1R1sb1+GammaL1R2sb1+GammaL2R1sb1+GammaL2R2sb1)*390625 << endl;
      cout << "GammaLLsb2*sin^2(thetab) = " << GammaLLsb2*pow(sin(thetab),2)*390625 << " GammaRRsb2*cos^2(thetab) = " << GammaRRsb2*pow(cos(thetab),2)*390625 << endl;
      cout << "GammaRRsb2 = " << GammaRRsb2*390625 << endl;
      cout << "sin(thetab)*cos(thetab)*(GammaL1R1sb2+GammaL1R2sb2+GammaL2R1sb2+GammaL2R2sb2) = " << sin(thetab)*cos(thetab)*(GammaL1R1sb2+GammaL1R2sb2+GammaL2R1sb2+GammaL2R2sb2)*390625 << endl;
      cout << "(GammaLLsb1sb2+GammaRRsb1sb2)*sin(thetab)*cos(thetab) = " << (GammaLLsb1sb2+GammaRRsb1sb2)*sin(thetab)*cos(thetab)*390625 << endl;
      cout << "GammaLRsb1sb2*cos^2(thetab) + GammaRLsb1sb2*sin^2(thetab) = " << (GammaLRsb1sb2*pow(cos(thetab),2)+GammaRLsb1sb2*pow(sin(thetab),2))*390625 << endl;
      cout << "GammaLRsb1sb2 = " << GammaLRsb1sb2*390625 << " GammaRLsb1sb2 = " << GammaRLsb1sb2*390625 << endl;
      cout << endl;
    }

  }
  return amplitudeW;
}


double gluinoamplitudedecaychartbbar (double m1, double m2, double m3, double m4, double m5, double m6, double m7, double m8, double alphas, double thetat, double thetab, double mw, double g, double gp, double gammaL, double gammaR, double beta, double runmt, double runmb, int chargino, int Nsteps, int adaptive, int onetothree, double approx) ///Calculates PW for gluino 1->3 decays to chargino and a q q'bar pair, m2 is st1 mass, m3 is st2 mass, m4 is sb1 mass, m5 is sb2 mass, m6 is top mass, m7 is bottom mass, m8 is chargino mass
{
  double Gammast1 = 0, Gammast2 = 0, Gammast1st2 = 0 , Gammasb1 =0, Gammasb2 = 0, Gammast1sb1 = 0, Gammast1sb2 = 0, Gammast2sb1 = 0, Gammast2sb2 = 0, alphast1char = 0, betast1char = 0, alphasb1char = 0, betasb1char = 0, alphast2char = 0, betast2char = 0, alphasb2char = 0, betasb2char = 0, ft = 0, fb = 0, from = 0, to = 0, fromb = 0, tob = 0, amplitudeW = 0;
  double G1integralsum(double mass1, double mass2, double mass3, double massq, double from, double to, double Nsteps, int adaptive, double approx);
  double G2integralsum(double mass1, double mass2, double mass3, double masst, double massb, double from, double to, double Nsteps, int adaptive, double approx);
  double G3integralsum(double mass1, double mass2, double mass3, double masst, double massb, double from, double to, double Nsteps, int adaptive, double approx);
  double G4integralsum(double mass1, double mass2, double mass3, double mass4, double masst, double massb, double from, double to, double Nsteps, int adaptive, double approx);
  double G5integralsum(double mass1, double mass2, double mass3, double mass4, double masst, double massb, double from, double to, double Nsteps, int adaptive, double approx);
  double G6integralsum(double mass1, double mass2, double mass3, double mass4, double masst, double massb, double from, double to, double Nsteps, int adaptive, double approx);
  double G7integralsum(double mass1, double mass2, double mass3, double mass4, double masst, double massb, double from, double to, double Nsteps, int adaptive, double approx);
  double G8integralsum(double mass1, double mass2, double mass3, double mass4, double masst, double massb, double from, double to, double Nsteps, int adaptive, double approx);
  if (m1 > m7 + m4 || m1 > m7 + m5 || m1 > m6 + m2 || m1 > m6 + m3 || m1 < m6 + m7 + m8) {amplitudeW = 0;}
  else {
    from = m6;
    to = (pow(m1,2)+pow(m6,2)-pow(m8+m7,2))/(2*m1);
    fromb = m7;
    tob = (pow(m1,2)-pow(m6+m8,2))/(2*m1);
    ft = g*runmt/(pow(2,0.5)*mw*sin(beta));
    fb = g*runmb/(pow(2,0.5)*mw*cos(beta));
    if (chargino == 1) {
      alphast1char = -g*sin(gammaR)*cos(thetat)+ft*cos(gammaR)*sin(thetat);
      betast1char = -fb*cos(gammaL)*cos(thetat);
      alphasb1char = -g*sin(gammaL)*cos(thetab)+fb*cos(gammaL)*sin(thetab);
      betasb1char = -ft*cos(gammaR)*cos(thetab);
      alphast2char = -g*sin(gammaR)*sin(thetat)+ft*cos(gammaR)*-cos(thetat);
      betast2char = -fb*cos(gammaL)*sin(thetat);
      alphasb2char = -g*sin(gammaL)*sin(thetab)-fb*cos(gammaL)*cos(thetab);
      betasb2char = -ft*cos(gammaR)*sin(thetab);
    }
    else if (chargino == 2) {
      alphast1char = -g*cos(gammaR)*cos(thetat)-ft*sin(gammaR)*sin(thetat);
      betast1char = fb*sin(gammaL)*cos(thetat);
      alphasb1char = -g*cos(gammaL)*cos(thetab)-fb*sin(gammaL)*sin(thetab);
      betasb1char = ft*sin(gammaR)*cos(thetab);
      alphast2char = -g*cos(gammaR)*sin(thetat)-ft*sin(gammaR)*-cos(thetat);
      betast2char = fb*sin(gammaL)*sin(thetat);
      alphasb2char = -g*cos(gammaL)*sin(thetab)+fb*sin(gammaL)*cos(thetab);
      betasb2char = ft*sin(gammaR)*sin(thetab);
    }
    
    
    Gammast1 = (pow(alphast1char,2)+pow(betast1char,2))*(G1integralsum(m1,m2,m8,m6,from,to,Nsteps,adaptive,approx) + sin(2*thetat)*G8integralsum(m1,m2,m2,m8,m6,m7,from,to,Nsteps,adaptive,approx));
    Gammast2 = (pow(alphast2char,2)+pow(betast2char,2))*(G1integralsum(m1,m3,m8,m6,from,to,Nsteps,adaptive,approx) - sin(2*thetat)*G8integralsum(m1,m3,m3,m8,m6,m7,from,to,Nsteps,adaptive,approx));
    Gammast1st2 = -2*(alphast1char*alphast2char+betast1char*betast2char)*cos(2*thetat)*G8integralsum(m1,m2,m3,m8,m6,m7,from,to,Nsteps,adaptive,approx);
    Gammasb1 = (pow(alphasb1char,2)+pow(betasb1char,2))*G2integralsum(m1,m4,m8,m6,m7,fromb,tob,Nsteps,adaptive,approx) - alphasb1char*betasb1char*G3integralsum(m1,m4,m8,m6,m7,fromb,tob,Nsteps,adaptive,approx);
    Gammasb2 = (pow(alphasb2char,2)+pow(betasb2char,2))*G2integralsum(m1,m5,m8,m6,m7,fromb,tob,Nsteps,adaptive,approx) - alphasb2char*betasb2char*G3integralsum(m1,m5,m8,m6,m7,fromb,tob,Nsteps,adaptive,approx);
    Gammast1sb1 = (cos(thetat)*sin(thetab)*alphasb1char*betast1char+sin(thetat)*cos(thetab)*betasb1char*alphast1char)*G6integralsum(m1,m2,m4,m8,m6,m7,from,to,Nsteps,adaptive,approx) - (cos(thetat)*cos(thetab)*alphasb1char*alphast1char + sin(thetat)*sin(thetab)*betasb1char*betast1char)*G4integralsum(m1,m2,m4,m8,m6,m7,from,to,Nsteps,adaptive,approx) + (cos(thetat)*cos(thetab)*betasb1char*alphast1char + sin(thetat)*sin(thetab)*alphasb1char*betast1char)*G5integralsum(m1,m2,m4,m8,m6,m7,from,to,Nsteps,adaptive,approx) - (cos(thetat)*sin(thetab)*betasb1char*betast1char + sin(thetat)*cos(thetab)*alphasb1char*alphast1char)*G7integralsum(m1,m2,m4,m8,m6,m7,from,to,Nsteps,adaptive,approx);
    Gammast2sb1 = (sin(thetat)*sin(thetab)*alphasb1char*betast2char-cos(thetat)*cos(thetab)*betasb1char*alphast2char)*G6integralsum(m1,m3,m4,m8,m6,m7,from,to,Nsteps,adaptive,approx) - (sin(thetat)*cos(thetab)*alphasb1char*alphast2char - cos(thetat)*sin(thetab)*betasb1char*betast2char)*G4integralsum(m1,m3,m4,m8,m6,m7,from,to,Nsteps,adaptive,approx) + (sin(thetat)*cos(thetab)*betasb1char*alphast2char - cos(thetat)*sin(thetab)*alphasb1char*betast2char)*G5integralsum(m1,m3,m4,m8,m6,m7,from,to,Nsteps,adaptive,approx) - (sin(thetat)*sin(thetab)*betasb1char*betast2char - cos(thetat)*cos(thetab)*alphasb1char*alphast2char)*G7integralsum(m1,m3,m4,m8,m6,m7,from,to,Nsteps,adaptive,approx);
    Gammast1sb2 = (cos(thetat)*-cos(thetab)*alphasb2char*betast1char+sin(thetat)*sin(thetab)*betasb2char*alphast1char)*G6integralsum(m1,m2,m5,m8,m6,m7,from,to,Nsteps,adaptive,approx) - (cos(thetat)*sin(thetab)*alphasb2char*alphast1char - sin(thetat)*cos(thetab)*betasb2char*betast1char)*G4integralsum(m1,m2,m5,m8,m6,m7,from,to,Nsteps,adaptive,approx) + (cos(thetat)*sin(thetab)*betasb2char*alphast1char - sin(thetat)*cos(thetab)*alphasb2char*betast1char)*G5integralsum(m1,m2,m5,m8,m6,m7,from,to,Nsteps,adaptive,approx) - (cos(thetat)*-cos(thetab)*betasb2char*betast1char + sin(thetat)*sin(thetab)*alphasb2char*alphast1char)*G7integralsum(m1,m2,m5,m8,m6,m7,from,to,Nsteps,adaptive,approx);
    Gammast2sb2 = (sin(thetat)*-cos(thetab)*alphasb2char*betast2char-cos(thetat)*sin(thetab)*betasb2char*alphast2char)*G6integralsum(m1,m3,m5,m8,m6,m7,from,to,Nsteps,adaptive,approx) - (sin(thetat)*sin(thetab)*alphasb2char*alphast2char + cos(thetat)*cos(thetab)*betasb2char*betast2char)*G4integralsum(m1,m3,m5,m8,m6,m7,from,to,Nsteps,adaptive,approx) + (sin(thetat)*sin(thetab)*betasb2char*alphast2char + cos(thetat)*cos(thetab)*alphasb2char*betast2char)*G5integralsum(m1,m3,m5,m8,m6,m7,from,to,Nsteps,adaptive,approx) - (sin(thetat)*-cos(thetab)*betasb2char*betast2char - cos(thetat)*sin(thetab)*alphasb2char*alphast2char)*G7integralsum(m1,m3,m5,m8,m6,m7,from,to,Nsteps,adaptive,approx);

    double gG1(double Et, double mass1, double mass2, double mass3, double massq, double Etmax, double Etmin);
    double gG2(double Ebbar, double mass1, double mass2, double mass3, double masst, double massb, double Ebbarmax, double Ebbarmin);
    double gG3(double Ebbar, double mass1, double mass2, double mass3, double masst, double massb, double Ebbarmax, double Ebbarmin);
    double gG4(double Et, double mass1, double mass2, double mass3, double mass4, double masst, double massb, double Etmax, double Etmin);
    double gG5(double Et, double mass1, double mass2, double mass3, double mass4, double masst, double massb, double Etmax, double Etmin);
    double gG6(double Et, double mass1, double mass2, double mass3, double mass4, double masst, double massb, double Etmax, double Etmin);
    double gG7(double Et, double mass1, double mass2, double mass3, double mass4, double masst, double massb, double Etmax, double Etmin);
    double gG8(double Et, double mass1, double mass2, double mass3, double mass4, double masst, double massb, double Etmax, double Etmin);

    /// cout << endl;
    /// cout << "GLUINO TO CHARGINO + 3RD GEN QUARKS INFO: " << endl;
    /// cout << "gluinoamplitudedecaychartbbar: " << endl;
    /// cout << "Gammast1 = " << Gammast1 << " Gammast2 = " << Gammast2 << " Gammast1st2 = " << Gammast1st2 << endl;
    /// cout << "Gammasb1 = " << Gammasb1 << " Gammasb2 = " << Gammasb2 << " Gammast1sb1 = " << Gammast1sb1 << endl;
    /// cout << "Gammast2sb1 = " << Gammast2sb1 << " Gammast1sb2 = " << Gammast1sb2 << " Gammast2sb2 = " << Gammast2sb2 << endl;
    /// cout << "m1 = " << m1 << " m2 = " << m2 << " m3 = " << m3 << " m4 = " << m4 << endl;
    /// cout << "m5 = " << m5 << " m6 = " << m6 << " m7 = " << m7 << " m8 = " << m8 << endl;
    /// cout << "A = " << pow(m1,2)+pow(m6,2)-2*250*m1 << endl;
    /// cout << "pt = " << pow(pow(250,2)-pow(m6,2),0.5) << endl;
    /// ///cout << "mg*pt*Et = " << m1*250*pow(pow(250,2)-pow(m6,2),0.5) << endl;
    /// ///cout << "(A-mchar^2)^2 = " << pow(pow(m1,2)+pow(m6,2)-2*250*m1-pow(m8,2),2) << endl;
    /// ///cout << "denom = " << pow(pow(m1,2)+pow(m6,2)-2*250*m1-pow(m2,2),2)*(pow(m1,2)+pow(m6,2)-2*250*m1) << endl;
    /// cout << "gG1 at Et=250 is: " << gG1(250,m1,m2,m8,m6,to,from) << endl;
    /// cout << "gG2 at Ebbar=250 is: " << gG2(250,m1,m4,m8,m6,m7,tob,fromb) << endl;
    /// cout << "gG3 at Ebbar=250 is: " << gG3(250,m1,m4,m8,m6,m7,tob,fromb) << endl;
    /// cout << "gG4 at Et=250 is: " << gG4(250,m1,m2,m4,m8,m6,m7,to,from) << endl;
    /// DoubleVector Ebbarmaxmin (double mass1, double mass2, double mass3, double mass4, double Et);
    /// cout << "Ebbarmax = " << Ebbarmaxmin(m1, m6, m7, m8, 250)(1) << endl;
    /// cout << "Ebbarmin = " << Ebbarmaxmin(m1, m6, m7, m8, 250)(2) << endl;
    /// double Xfunc (double mass1, double mass2, double mass3, double mass4, double mass5, double Et);
    /// cout << " Xfunc = " << Xfunc(m1, m6, m7, m8, m4, 250) << endl;
    /// cout << "gG5 at Et=250 is: " << gG5(250,m1,m2,m4,m8,m6,m7,to,from) << endl;
    /// cout << "gG6 at Et=250 is: " << gG6(250,m1,m2,m4,m8,m6,m7,to,from) << endl;
    /// cout << "gG7 at Et=250 is: " << gG7(250,m1,m2,m4,m8,m6,m7,to,from) << endl;
    /// cout << "gG8 at Et=250 is: " << gG8(250,m1,m2,m3,m8,m6,m7,to,from) << endl;

    amplitudeW = alphas/(16*pow(PI,2)*m1)*(Gammast1+Gammast2+Gammast1st2+Gammasb1+Gammasb2+Gammast1sb1+Gammast1sb2+Gammast2sb1+Gammast2sb2);
    cout << "Gammast1 = " << Gammast1 << " Gammast2 = " << Gammast2 << " Gammast1st2 = " << Gammast1st2 << " Gammasb1 = " << Gammasb1 << " Gammasb2 = " << Gammasb2 << endl;
    cout << "Gammast1sb1 = " << Gammast1sb1 << " Gammast1sb2 = " << Gammast1sb2 << " Gammast2sb1 = " << Gammast2sb1 << " Gammast2sb2 = "<< Gammast2sb2 << endl;
    cout << endl;
    
  }
  return amplitudeW;
}




double neutralinoamplitudedecayneutffbar (double m1, double m2, double mf, double msf1, double msf2, double mz, double mh, double mH, double mA, double runmf, double mw, double thetaf, double beta, double alpha, double g, double gp, DoubleMatrix mixNeut, int neutralinoj, int neutralinoi, char qorl, char uord, int Nsteps, int adaptive, int onetothree, double approx) ///function that calcultes the PW for the neutralinoj -> neutralinoi f fbar 1->3 decay, m1 is mass of neutralinoj (initial neutralino) and m2 is mass of neutralinoi (final state neutralino), neutralinoj gives the index of the initial neutralino (1->4), neutralinoi gives the index of the final neutralino, char qorl gives whether the fermions are quarks or leptons, char uord gives whether the fermions are "up" type i.e. up -type quarks or neutrinos or "down" type o.e. down -type quarks or charged leptons.
{
  double amplitudeW = 0;
  if (onetothree == 0) {amplitudeW=0;}
  else if (onetothree == 1) {
    double prefactor=0, Gammasf=0, GammaZ=0, GammahH=0, GammaA=0, GammaZsf=0, Gammaphisf=0, Gammasf1=0, Gammasf2=0, Gammasf12=0, Gammasf1LL=0, Gammasf2LL=0, Gammasf1RR=0, Gammasf2RR=0, Gammasf1LR=0, Gammasf2LR=0, Gammasf1LGammasf2L=0, Gammasf1RGammasf2R=0, Gammasf1LGammasf2R=0, Gammasf2LGammasf1R=0, alphaneutjsf1=0, alphaneutjsf2=0, betaneutjsf1=0, betaneutjsf2=0, alphaneutisf1=0, alphaneutisf2=0, betaneutisf1=0, betaneutisf2=0, Ai=0, Bi=0, Aj=0, Bj=0, C=0, GammaZsf1=0, GammaZsf2=0, Gammahsf1=0, Gammahsf2=0, GammaHsf1=0, GammaHsf2=0, GammaAsf1=0, GammaAsf2=0, from=0, to=0, fromE=0, toE=0, stepE=0, froms=0, tos=0, Wij=0, Wijtilda=0, alphaf=0, betaf=0, ff=0, sintW=0, Xijh=0, Xjih=0, XjiH=0, XijH=0,XijA=0, XjiA=0, Nc=0;
    double psitildaintegralsum(double mass1, double mass2, double mass3, double mass4, double mass5, double from, double to, double Nsteps, int adaptive, double approx);
    double phitildaintegralsum(double mass1, double mass2, double mass3, double mass4, double mass5, double from, double to, double Nsteps, int adaptive, double approx);
    double Yintegralsum(double mass1, double mass2, double mass3, double mass4, double massq, double from, double to, double Nsteps, int adaptive, double approx);
    double Zintegralsum (double m1, double m2, double mz, double mf, double fromE, double toE, double Nsteps, int adaptive, double approx);
    double hHintegral(double m1, double m2, double mf, double mh, double mH, double fromE, double toE, double stepE, double g, double gp, double alpha, DoubleMatrix mixNeut, int neutralinoi, int neutralinoj);
    double Aintegralsum (double m1, double m2, double mz, double mA, double mf, double fromE, double toE, double Nsteps, int adaptive, double approx);
    double Zsfintegralsum (double m1, double m2, double msf, double mf, double mz, double froms, double tos, double Nsteps, int adaptive, double approx);
    double Jintegralsum (double m1, double m2, double msf, double mphi, double mf, double froms, double tos, double Nsteps, int adaptive, double approx, int AorhorH);

    ///if (m1 < m2 + mf*2 || m1 > msf1 + mf || m1 > msf2 + mf || m1 > m2 + mh || m1 > m2 + mH || m1 > m2 + mA || m1 > m2 + mz) { amplitudeW=0;}
    if (m1 < m2 + mf*2) { amplitudeW = 0;}
    ///if (m1 < m2 + 2*mf || m1 > m2 + mz) {amplitudeW = 0;}
    else if (m1 > m2 + 2*mf) {
      
      sintW = gp/(pow(pow(g,2)+pow(gp,2),0.5));

      from = mf;
      to = (pow(m1,2)-2*mf*m2-pow(m2,2))/(2*m1);
      cout.precision(7);
      ///if ( neutralinoj == 4 && neutralinoi == 3 && qorl == 'q' && uord == 'u') {cout << "from = " << from << " to = " << to << " step = " << step << endl;}

      fromE = m2;
      toE = (pow(m1,2)+pow(m2,2)-4*pow(mf,2))/(2*m1);
      stepE = (toE-fromE)/Nsteps; 

      froms = 4*pow(mf,2);
      tos = pow(m1-m2,2);

      if (qorl == 'q' && uord == 'u') /// so we have up-type quarks as the fermions
	{
	  Ai = g/(pow(2,0.5))*-mixNeut(neutralinoi,2)+gp/(3*pow(2,0.5))*-mixNeut(neutralinoi,1);
	  Bi = 4./3*gp/(pow(2,0.5))*-mixNeut(neutralinoi,1);
	  Aj = g/(pow(2,0.5))*-mixNeut(neutralinoj,2)+gp/(3*pow(2,0.5))*-mixNeut(neutralinoj,1);
	  Bj = 4./3*gp/(pow(2,0.5))*-mixNeut(neutralinoj,1);
	  C = 4; /// C picks out the right component of mixNeut to multiply by the yukawa coupling - 4th column if u type, 3rd if d type
	  alphaf = -5./12*gp/g+0.25*g/gp;
	  betaf = -0.25*(gp/g+g/gp);
	  ff = g*runmf/(pow(2,0.5)*mw*sin(beta));
	}
      else if (qorl == 'q' && uord == 'd') /// so we have down-type quarks as the fermions
	{
	  Ai = -g/(pow(2,0.5))*-mixNeut(neutralinoi,2) + gp/(3*pow(2,0.5))*-mixNeut(neutralinoi,1);
	  Bi = -2./3*gp/(pow(2,0.5))*-mixNeut(neutralinoi,1);
	  Aj = -g/(pow(2,0.5))*-mixNeut(neutralinoj,2) + gp/(3*pow(2,0.5))*-mixNeut(neutralinoj,1);
	  Bj = -2./3*gp/(pow(2,0.5))*-mixNeut(neutralinoj,1);
	  C = 3;
	  alphaf = 1./12*gp/g-0.25*g/gp;
	  betaf = 0.25*(gp/g+g/gp);
	  
	  ff = g*runmf/(pow(2,0.5)*mw*cos(beta));
	}
      else if (qorl == 'l' && uord == 'u') /// so we have neutrinos as the fermions
	{
	  Ai = g/(pow(2,0.5))*-mixNeut(neutralinoi,2) - gp/(pow(2,0.5))*-mixNeut(neutralinoi,1);
	  Bi = 0;
	  Aj = g/(pow(2,0.5))*-mixNeut(neutralinoj,2) - gp/(pow(2,0.5))*-mixNeut(neutralinoj,1);
	  Bj = 0;
	  C = 4;
	  alphaf = 0.25*(gp/g+g/gp);
	  betaf = -0.25*(gp/g+g/gp);
	  ff = g*runmf/(pow(2,0.5)*mw*sin(beta));
	}
      else if (qorl == 'l' && uord == 'd') /// so we have charged leptons as the fermions
	{
	  Ai = -g/(pow(2,0.5))*-mixNeut(neutralinoi,2) - gp/(pow(2,0.5))*-mixNeut(neutralinoi,1);
	  Bi = -pow(2,0.5)*gp*-mixNeut(neutralinoi,1);
	  Aj = -g/(pow(2,0.5))*-mixNeut(neutralinoj,2) - gp/(pow(2,0.5))*-mixNeut(neutralinoj,1);
	  Bj = -pow(2,0.5)*gp*-mixNeut(neutralinoj,1);
	  C = 3;
	  alphaf = 0.25*(3*gp/g-g/gp);
	  betaf = 0.25*(gp/g+g/gp);
	  ff = g*runmf/(pow(2,0.5)*mw*cos(beta));
	}
	
	else {cout << "Problem with qorl or uord, fermion must be quark or lepton like and must be u or d type" << endl;}
	
	alphaneutjsf1 = Aj*cos(thetaf)-ff*mixNeut(neutralinoj,C)*sin(thetaf);
	///betaneutjsf1 = Bj*sin(thetaf) + ff*mixNeut(neutralinoj,C)*cos(thetaf);
	betaneutjsf1 = -(Bj*sin(thetaf) + ff*mixNeut(neutralinoj,C)*cos(thetaf));
	alphaneutjsf2 = Aj*sin(thetaf)+ff*mixNeut(neutralinoj,C)*cos(thetaf);
	///betaneutjsf2 = -Bj*cos(thetaf) + ff*mixNeut(neutralinoj,C)*sin(thetaf);
	betaneutjsf2 = -(-Bj*cos(thetaf) + ff*mixNeut(neutralinoj,C)*sin(thetaf));
	alphaneutisf1 = Ai*cos(thetaf)-ff*mixNeut(neutralinoi,C)*sin(thetaf);
	///betaneutisf1 = Bi*sin(thetaf) + ff*mixNeut(neutralinoi,C)*cos(thetaf);
	betaneutisf1 = -(Bi*sin(thetaf) + ff*mixNeut(neutralinoi,C)*cos(thetaf));
	alphaneutisf2 = Ai*sin(thetaf)+ff*mixNeut(neutralinoi,C)*cos(thetaf);
	///betaneutisf2 = -Bi*cos(thetaf) + ff*mixNeut(neutralinoi,C)*sin(thetaf);
	betaneutisf2 = -(-Bi*cos(thetaf) + ff*mixNeut(neutralinoi,C)*sin(thetaf));
    
	Gammasf1LL = 4*pow(alphaneutjsf1,2)*((pow(alphaneutisf1,2)+pow(betaneutisf1,2))*psitildaintegralsum(m1,msf1,msf1,m2,mf,from,to,Nsteps,adaptive,approx) + (fabs(m1)/m1)*(fabs(m2)/m2)*pow(alphaneutisf1,2)*phitildaintegralsum(m1,msf1,msf1,m2,mf,from,to,Nsteps,adaptive,approx));
	Gammasf2LL = 4*pow(alphaneutjsf2,2)*((pow(alphaneutisf2,2)+pow(betaneutisf2,2))*psitildaintegralsum(m1,msf2,msf2,m2,mf,from,to,Nsteps,adaptive,approx) + (fabs(m1)/m1)*(fabs(m2)/m2)*pow(alphaneutisf2,2)*phitildaintegralsum(m1,msf2,msf2,m2,mf,from,to,Nsteps,adaptive,approx));
	Gammasf1RR = 4*pow(betaneutjsf1,2)*((pow(alphaneutisf1,2)+pow(betaneutisf1,2))*psitildaintegralsum(m1,msf1,msf1,m2,mf,from,to,Nsteps,adaptive,approx) + (fabs(m1)/m1)*(fabs(m2)/m2)*pow(betaneutisf1,2)*phitildaintegralsum(m1,msf1,msf1,m2,mf,from,to,Nsteps,adaptive,approx));
	Gammasf2RR = 4*pow(betaneutjsf2,2)*((pow(alphaneutisf2,2)+pow(betaneutisf2,2))*psitildaintegralsum(m1,msf2,msf2,m2,mf,from,to,Nsteps,adaptive,approx) + (fabs(m1)/m1)*(fabs(m2)/m2)*pow(betaneutisf2,2)*phitildaintegralsum(m1,msf2,msf2,m2,mf,from,to,Nsteps,adaptive,approx));
	    
	Gammasf1LR = -8*alphaneutisf1*betaneutisf1*alphaneutjsf1*betaneutjsf1*Yintegralsum(m1,msf1,msf1,m2,mf,from,to,Nsteps,adaptive,approx);
	Gammasf2LR = -8*alphaneutisf2*betaneutisf2*alphaneutjsf2*betaneutjsf2*Yintegralsum(m1,msf2,msf2,m2,mf,from,to,Nsteps,adaptive,approx);
	Gammasf1LGammasf2L = 8*alphaneutjsf1*alphaneutjsf2*((alphaneutisf1*alphaneutisf2+betaneutisf1*betaneutisf2)*psitildaintegralsum(m1,msf1,msf2,m2,mf,from,to,Nsteps,adaptive,approx) + (fabs(m1)/m1)*(fabs(m2)/m2)*alphaneutisf1*alphaneutisf2*phitildaintegralsum(m1,msf1,msf2,m2,mf,from,to,Nsteps,adaptive,approx));
	Gammasf1RGammasf2R = 8*betaneutjsf1*betaneutjsf2*((alphaneutisf1*alphaneutisf2+betaneutisf1*betaneutisf2)*psitildaintegralsum(m1,msf1,msf2,m2,mf,from,to,Nsteps,adaptive,approx) + (fabs(m1)/m1)*(fabs(m2)/m2)*betaneutisf1*betaneutisf2*phitildaintegralsum(m1,msf1,msf2,m2,mf,from,to,Nsteps,adaptive,approx));
	
	Gammasf1LGammasf2R = -8*alphaneutjsf1*betaneutjsf2*alphaneutisf2*betaneutisf1*Yintegralsum(m1,msf1,msf2,m2,mf,from,to,Nsteps,adaptive,approx);
	Gammasf2LGammasf1R = -8*alphaneutjsf2*betaneutjsf1*alphaneutisf1*betaneutisf2*Yintegralsum(m1,msf1,msf2,m2,mf,from,to,Nsteps,adaptive,approx);

	
	Gammasf1 = Gammasf1LL + Gammasf1RR + Gammasf1LR;
	Gammasf2 = Gammasf2LL + Gammasf2RR + Gammasf2LR;
	Gammasf12 = Gammasf1LGammasf2L+Gammasf1LGammasf2R + Gammasf2LGammasf1R + Gammasf1RGammasf2R;
	Gammasf = Gammasf1 + Gammasf2 + Gammasf12;
	
	/// cout << "alphaneutjsf1 = " <<alphaneutjsf1 << " alphaneutisf1 = " << alphaneutisf1 << " betaneutjsf1 = " << betaneutjsf1 << " betaneutisf1 = " << betaneutisf1 << endl;
	/// cout << "alphaneutjsf2 = " <<alphaneutjsf2 << " alphaneutisf2 = " << alphaneutisf2 << " betaneutjsf2 = " << betaneutjsf2 << " betaneutisf2 = " << betaneutisf2 << endl;
	/// cout << "Y1 = " << Yintegralsum(m1,msf1,msf1,m2,mf,from,to,Nsteps,adaptive,approx) << " Y2 = " << Yintegralsum(m1,msf2,msf2,m2,mf,from,to,Nsteps,adaptive,approx) << endl;
	/// cout << "psitilda12 = " << psitildaintegralsum(m1,msf1,msf2,m2,mf,from,to,Nsteps,adaptive,approx) << " phitilda12 = " << phitildaintegralsum(m1,msf1,msf2,m2,mf,from,to,Nsteps,adaptive,approx) <<endl;
	/// cout << "Y12 = " << Yintegralsum(m1,msf1,msf2,m2,mf,from,to,Nsteps,adaptive,approx) << endl;
	/// cout << "Gammasf = " << Gammasf << " Gammasf1 = " << Gammasf1 << " Gammasf2 = " << Gammasf2 << " Gammasf12 = " << Gammasf12 << endl;
	/// cout << "Gammasf1LL = " << Gammasf1LL << " Gammasf2LL = " << Gammasf2LL << " Gammasf1RR = " << Gammasf1RR << " Gammasf2RR = " << Gammasf2RR << endl;
	/// cout << "Gammasf1LR = " << Gammasf1LR << " Gammasf2LR = " << Gammasf2LR << " Gammasf1LGammasf2L = " << Gammasf1LGammasf2L << " Gammasf1RGammasf2R = " << Gammasf1RGammasf2R << endl;
	/// cout << "Gammasf1LGammasf2R = " << Gammasf1LGammasf2R << " Gammasf2LGammasf1R = " << Gammasf2LGammasf1R << endl;
	/// cout << endl;

	Wij = 0.25*pow(pow(g,2)+pow(gp,2),0.5)*(mixNeut(neutralinoj,4)*mixNeut(neutralinoi,4)-mixNeut(neutralinoj,3)*mixNeut(neutralinoi,3));
	Wijtilda = (fabs(m1)/m1)*(fabs(m2)/m2)*Wij;

	GammaZ = 64*pow(g*sintW,2)*(fabs(m1)/m1)*(fabs(m2)/m2)*pow(Wij,2)*(pow(alphaf,2)+pow(betaf,2))*m1*pow(PI,2)*Zintegralsum(m1, m2, mz, mf, fromE, toE, Nsteps,adaptive, approx);
	///cout << "sintW = " << sintW << endl;
	cout << "GammaZ info: GammaZ = " << GammaZ << " Wij = " << Wij << " alphaf = " << alphaf << " betaf = " << betaf << " Zintegral  = " << Zintegralsum(m1, m2, mz, mf, fromE, toE, Nsteps,adaptive, approx) << endl;
	
	GammahH = 2*pow(PI,2)*pow(g*runmf/(mw*cos(beta)),2)*m1*hHintegral(m1,m2,mf,mh,mH,fromE,toE,stepE,g,gp,alpha,mixNeut,neutralinoi,neutralinoj);
	
	

	XjiA = 0.5*(fabs(m1)/m1)*(fabs(m2)/m2)*(mixNeut(neutralinoj,3)*sin(beta)-mixNeut(neutralinoj,4)*cos(beta))*(g*-mixNeut(neutralinoi,2)-gp*-mixNeut(neutralinoi,1));
	XijA = 0.5*(fabs(m1)/m1)*(fabs(m2)/m2)*(mixNeut(neutralinoi,3)*sin(beta)-mixNeut(neutralinoi,4)*cos(beta))*(g*-mixNeut(neutralinoj,2)-gp*-mixNeut(neutralinoj,1));

	GammaA = 2*pow(PI,2)*pow(g*runmf*tan(beta)/mw*(XijA+XjiA),2)*m1*Aintegralsum(m1,m2,mz,mA,mf,fromE,toE,Nsteps,adaptive,approx);
	
	if (mf ==0 ) { 
	  double mtinytinymass = 1e-15; ///set mf to tiny non-zero mass as mf=0 gives smin = 0 and Qprime = sqrt(1-4mf^2/s) = sqrt(1-0/0) = nan! This problem occurs via the Qprime variable in the Zsf and phisf interference terms.
	  mf = mtinytinymass;
	  froms = 4*pow(mtinytinymass,2);
	}
	GammaZsf1 = 32*g*sintW*Wijtilda*(alphaneutjsf1*alphaneutisf1*(alphaf-betaf)-betaneutjsf1*betaneutisf1*(alphaf+betaf))*pow(PI,2)/(2*m1)*Zsfintegralsum(m1,m2,msf1,mf,mz,froms,tos,Nsteps,adaptive,approx);
	GammaZsf2 = 32*g*sintW*Wijtilda*(alphaneutjsf2*alphaneutisf2*(alphaf-betaf)-betaneutjsf2*betaneutisf2*(alphaf+betaf))*pow(PI,2)/(2*m1)*Zsfintegralsum(m1,m2,msf2,mf,mz,froms,tos,Nsteps,adaptive,approx);
	///cout << "mf = "<< mf << endl;
	///cout << "GammaZsf = " << GammaZsf << " GammaZsf1 = " << GammaZsf1 << " GammaZsf2 = " << GammaZsf2 << endl;
	///cout << "Zsfintegral here for msf1 = " << Zsfintegral(m1,m2,msf1,mf,mz,froms,tos,Nsteps,adaptive,approx) << endl;
	///cout << "Zsfintegral here for msf2 = " << Zsfintegral(m1,m2,msf2,mf,mz,froms,tos,Nsteps,adaptive,approx) << endl;
	///cout << "e = " << g*sintW << endl;
	GammaZsf = GammaZsf1 + GammaZsf2;
	
	Xjih = -0.5*(fabs(m1)/m1)*(fabs(m2)/m2)*(mixNeut(neutralinoj,3)*-sin(alpha)-mixNeut(neutralinoj,4)*cos(alpha))*(g*-mixNeut(neutralinoi,2)-gp*-mixNeut(neutralinoi,1));
	XjiH = -0.5*(fabs(m1)/m1)*(fabs(m2)/m2)*(mixNeut(neutralinoj,3)*-cos(alpha)-mixNeut(neutralinoj,4)*-sin(alpha))*(g*-mixNeut(neutralinoi,2)-gp*-mixNeut(neutralinoi,1));
	Xijh = -0.5*(fabs(m1)/m1)*(fabs(m2)/m2)*(mixNeut(neutralinoi,3)*-sin(alpha)-mixNeut(neutralinoi,4)*cos(alpha))*(g*-mixNeut(neutralinoj,2)-gp*-mixNeut(neutralinoj,1));
	XijH = -0.5*(fabs(m1)/m1)*(fabs(m2)/m2)*(mixNeut(neutralinoi,3)*-cos(alpha)-mixNeut(neutralinoi,4)*-sin(alpha))*(g*-mixNeut(neutralinoj,2)-gp*-mixNeut(neutralinoj,1));

	
	Gammahsf1 = 2*pow(PI,2)/m1*g*runmf/mw*-sin(alpha)/cos(beta)*(Xijh+Xjih)*(alphaneutjsf1*betaneutisf1+alphaneutisf1*betaneutjsf1)*(fabs(m1)/m1)*(fabs(m2)/m2)*Jintegralsum(m1,m2,msf1,mh,mf,froms,tos,Nsteps,adaptive,approx,0);
	Gammahsf2 = 2*pow(PI,2)/m1*g*runmf/mw*-sin(alpha)/cos(beta)*(Xijh+Xjih)*(alphaneutjsf2*betaneutisf2+alphaneutisf2*betaneutjsf2)*(fabs(m1)/m1)*(fabs(m2)/m2)*Jintegralsum(m1,m2,msf2,mh,mf,froms,tos,Nsteps,adaptive,approx,0);
	GammaHsf1 = 2*pow(PI,2)/m1*g*runmf/mw*cos(alpha)/cos(beta)*(XijH+XjiH)*(alphaneutjsf1*betaneutisf1+alphaneutisf1*betaneutjsf1)*(fabs(m1)/m1)*(fabs(m2)/m2)*Jintegralsum(m1,m2,msf1,mH,mf,froms,tos,Nsteps,adaptive,approx,0);
	GammaHsf2 = 2*pow(PI,2)/m1*g*runmf/mw*cos(alpha)/cos(beta)*(XijH+XjiH)*(alphaneutjsf2*betaneutisf2+alphaneutisf2*betaneutjsf2)*(fabs(m1)/m1)*(fabs(m2)/m2)*Jintegralsum(m1,m2,msf2,mH,mf,froms,tos,Nsteps,adaptive,approx,0);
	GammaAsf1 = 2*pow(PI,2)/m1*g*runmf*tan(beta)/mw*(XijA+XjiA)*(alphaneutjsf1*betaneutisf1+alphaneutisf1*betaneutjsf1)*(-1)*fabs(m1)/m1*fabs(m2)/m2*Jintegralsum(m1,m2,msf1,mA,mf,froms,tos,Nsteps,adaptive,approx,1);
	GammaAsf2 = 2*pow(PI,2)/m1*g*runmf*tan(beta)/mw*(XijA+XjiA)*(alphaneutjsf2*betaneutisf2+alphaneutisf2*betaneutjsf2)*(-1)*fabs(m1)/m1*fabs(m2)/m2*Jintegralsum(m1,m2,msf2,mA,mf,froms,tos,Nsteps,adaptive,approx,1);
	Gammaphisf = Gammahsf1 + Gammahsf2 + GammaHsf1 + GammaHsf2 + GammaAsf1 + GammaAsf2;

	if (qorl =='q') { Nc = 3;}
	else if (qorl =='l') {Nc = 1;}

	///prefactor = 0.5*Nc*1/(pow(2*PI,5)*2*m2);
	prefactor = 0.5*Nc*1/(pow(2*PI,5)*2*m1);
	cout.precision(15);
	cout << "Gammasf = " << Gammasf << " GammaZ = " << GammaZ << " GammahH = " << GammahH << endl;
	cout << "GammaA = " << GammaA << " GammaZsf = " << GammaZsf << " Gammaphisf = " << Gammaphisf << endl;
	cout << "GammaZsf1 = " << GammaZsf1 << " GammaZsf2 = " << GammaZsf2 << endl;
	cout << "prefactor = " << prefactor << endl;
	
	amplitudeW = prefactor*(Gammasf+GammaZ+GammahH+GammaA+GammaZsf+Gammaphisf);

	///double gZintegral(double m1, double m2, double mz, double mf, double E, double from, double to); ///the integrand in the Zintegral integral
	///cout << "gZintegral at E = 2500 is: " << gZintegral(m1,m2,mz,mf,2500,fromE,toE) << endl;
	///double ghHintegral(double m1, double m2, double mz, double mh, double mH, double mf, double E, double from, double to, double g, double gp, double alpha, DoubleMatrix mixNeut, int neutralinoi, int neutralinoj);
	///cout << "ghHintegral at E = 2500 is: " << ghHintegral(m1,m2,mz,mh,mH,mf,2500,fromE,toE,g,gp,alpha,mixNeut,2,1) << endl;
	///double gAintegral(double m1, double m2, double mz, double mA, double mf, double E, double from, double to);
	///cout << "gAintegral at E = 2500 is: " << gAintegral(m1,m2,mz,mA,mf,2500,fromE,toE) << endl;
	///double gZsfintegral(double m1, double m2, double msf, double mf, double mz, double s, double froms, double tos);
	///cout << "gZsfintegral at s = 1000 is: " << gZsfintegral(m1,m2,msf1,mf,mz,1000,froms,tos) << endl;
	///cout << "msf1 = " << msf1 << endl;
	///double gJintegral(double m1, double m2, double msf, double mphi, double mf, double s, double froms, double tos,int AorhorH);
	///cout << "gJintegral at s = 1000 is: " << gJintegral (m1,m2,msf1,mh,mf,1000,froms,tos,0) << endl;
	  
	}
     }
 return amplitudeW;
}

	  
/// Decays to gravitinos

double gluinoamplitudedecaygravitino (double m1, double mgrav, double MPlreduced, int gravonoff, int gluNLSP) /// Function that calculates the decays to gravitinos of gluinos if int gravonoff == 1, otherwise decays to gravitinos are off
{
  double amplitudeW = 0;
  if (gluNLSP == 0) { amplitudeW = 0;}
  else if (gluNLSP == 1) {
    if(gravonoff == 0) { amplitudeW=0;}
    else if (gravonoff == 1 && fabs(m1) > mgrav) { ///Comment this line, last line and line 3 below this out if always want decays to gravitinos output
      ///cout << "mgluino = " << m1 << " mgravitino = " << mgrav << " MPlreduced = " << MPlreduced << endl;
      ///cout << "mgluino = " << m1 << " mgrav = " << mgrav << " MPlreduced = " << MPlreduced << endl;
    
      amplitudeW =  pow(fabs(m1),5)/(48*PI*pow(mgrav*MPlreduced,2));
    }
  }
  return amplitudeW;
}

double squarkamplitudedecaygravitino(double m1, double mgrav, double mquark, double MPlreduced, int gravonoff, int squNLSP) /// Function that calculates the decays to gravitinos of squark if int gravonoff == 1, otherwise decays to gravitinos are off
{
  double amplitudeW = 0;
  //  cout << "squNLSP = " << squNLSP << endl;
  if (squNLSP == 0) { amplitudeW = 0;}
  else if (squNLSP == 1) {
    if(gravonoff == 0) { amplitudeW=0;}
    else if (gravonoff == 1 && fabs(m1) > mgrav) { ///Comment this line, last line and line 3 below this out if always want decays to gravitinos output
      ///cout.precision(12);
      ///cout << "m1 = " << m1 << " mquark = " << mquark << " mgrav = " << mgrav << " MPlreduced = " << MPlreduced << endl;
      amplitudeW =  pow(pow(m1,2)-pow(mquark,2),4)/(48*PI*pow(m1,3)*pow(MPlreduced*mgrav,2));
    }
  }
  return amplitudeW;
}

double neutralinoamplitudedecayphotongravitino(double m1, double mgrav, double MPlreduced, DoubleMatrix mixNeut, double g, double gp, int neutralino, int gravonoff, int neutNLSP)  /// Function that calculates the decays to gravitino and photon of a neutralino if int gravonoff == 1, otherwise decays to gravitinos are off
{
  double amplitudeW = 0, coupling = 0, costhetaW = 0, sinthetaW = 0;
  if (neutNLSP == 0) { amplitudeW =0;}
  else if (neutNLSP == 1) {
    if(gravonoff == 0) { amplitudeW=0;}
    else if (gravonoff == 1 && fabs(m1) > mgrav) { ///Comment this line, last line and line 3 below this out if always want decays to gravitinos output
      ///cout << scientific;
      ///cout.precision(4);
      ///cout << "mneutralino = " << m1 << " mgravitino = " << mgrav << " MPlreduced = " << MPlreduced << endl;
    costhetaW = g/(pow(pow(g,2)+pow(gp,2),0.5));
    sinthetaW = gp/(pow(pow(g,2)+pow(gp,2),0.5));
    coupling = mixNeut(neutralino,1)*costhetaW + mixNeut(neutralino,2)*sinthetaW;
    ///cout << fixed;
    ///cout.precision(7);
    ///cout << "v11 = " << mixNeut(neutralino,1) << " v12 = " << mixNeut(neutralino,2) << " costhetaW = " << costhetaW << " sinthetaW = " << sinthetaW << endl;
    ///cout << "m1 = " << m1 << " MPlreduced = " << MPlreduced << " mgrav = " << mgrav << endl;
    ///cout << "coupling = " << coupling << " coupling^2 = " << pow(coupling,2) << endl;
    amplitudeW =  pow(coupling,2)*pow(fabs(m1),5)/(48*PI*pow(MPlreduced*mgrav,2));
    }
  }
  return amplitudeW;
}

double neutralinoamplitudedecayZgravitino(double m1, double mZ, double mgrav, double MPlreduced, DoubleMatrix mixNeut, double g, double gp, double beta, int neutralino, int gravonoff, int neutNLSP)  /// Function that calculates the decays to gravitino and Z boson of a neutralino if int gravonoff == 1, otherwise decays to gravitinos are off
{
  double amplitudeW = 0, coupling = 0, costhetaW = 0, sinthetaW = 0;
  if (neutNLSP == 0 || fabs(m1) < mZ + mgrav) { amplitudeW = 0;}
  else if (neutNLSP == 1) {
    if(gravonoff == 0) { amplitudeW=0;}
    else if (gravonoff == 1) { ///Comment this line, last line and line 3 below this out if always want decays to gravitinos output
      ///cout << "mneutralino = " << m1 << " mZ = " << mZ << " mgravitino = " << mgrav << " MPlreduced = " << MPlreduced << endl;
    costhetaW = g/(pow(pow(g,2)+pow(gp,2),0.5));
    sinthetaW = gp/(pow(pow(g,2)+pow(gp,2),0.5));
    coupling = 2*pow((mixNeut(neutralino,1)*sinthetaW - mixNeut(neutralino,2)*costhetaW),2) + pow((mixNeut(neutralino,4)*sin(beta) - mixNeut(neutralino,3)*cos(beta)),2);
    ///cout << scientific;
    ///cout.precision(3);
    ///cout << "pow(pow(m1,2)-pow(mZ,2),4) = " << pow(pow(m1,2)-pow(mZ,2),4) << endl;
    ///cout << "coupling = " << coupling << endl;
    ///cout << "1/(48*PI*pow(MPlreduced*mgrav,2)*pow(fabs(m1),3)) = " << 1/(48*PI*pow(MPlreduced*mgrav,2)*pow(fabs(m1),3)) << endl;
    ///cout << "pow(fabs(m1),3) = " << pow(fabs(m1),3) << endl;
    ///cout << "1/(48*PI*pow(MPlreduced*mgrav,2)) = " << 1/(48*PI*pow(MPlreduced*mgrav,2)) << endl;
    ///    cout << "everything except coupling * 2 = " << pow(pow(m1,2)-pow(mZ,2),4)/(96*PI*pow(MPlreduced*mgrav,2)*pow(fabs(m1),3))*2 << endl;
    amplitudeW =  coupling*pow(pow(m1,2)-pow(mZ,2),4)/(96*PI*pow(MPlreduced*mgrav,2)*pow(fabs(m1),3));
    }
  }
  return amplitudeW;
}

double neutralinoamplitudedecayphigravitino(double m1, double mphi, double mgrav, double MPlreduced, DoubleMatrix mixNeut, double alpha, double beta, int neutralino, int gravonoff, char phi, int neutNLSP)  /// Function that calculates the decays to gravitino and Z boson of a neutralino if int gravonoff == 1, otherwise decays to gravitinos are off
{
  double amplitudeW = 0, coupling = 0;
  if (neutNLSP == 0 || fabs(m1) < mphi) { amplitudeW = 0;}
  else if (neutNLSP == 1) {
    if(gravonoff == 0) { amplitudeW=0;}
    else if (gravonoff == 1 && fabs(m1) > mgrav) { ///Comment this line, last line and line 3 below this out if always want decays to gravitinos output
      ///cout << "mneutralino = " << m1 << " mphi = "<< mphi << " mgravitino = " << mgrav << " MPlreduced = " << MPlreduced << endl;
    if (phi =='h') {
      coupling = 1/(pow(6,0.5)*MPlreduced*mgrav)*(mixNeut(neutralino,4)*cos(alpha) - mixNeut(neutralino,3)*sin(alpha));
    }
    else if (phi =='H') {
      coupling = 1/(pow(6,0.5)*MPlreduced*mgrav)*(mixNeut(neutralino,4)*sin(alpha)+mixNeut(neutralino,3)*cos(alpha));
    }
    else if (phi == 'A') {
      coupling = 1/(pow(6,0.5)*MPlreduced*mgrav)*(mixNeut(neutralino,4)*cos(beta)+mixNeut(neutralino,3)*sin(beta));
    }
    ///cout << "mphi = " << mphi << endl;
    ///cout << "coupling = " << coupling << endl;
    amplitudeW =  pow(coupling,2)/(16*PI*pow(fabs(m1),3))*pow((pow(m1,2)-pow(mphi,2)),4);
    }
  }
  return amplitudeW;
}






///Functions that calculate the couplings:

DoubleVector squarkmixcharginocouplings (double g, double theta, double beta, double gammaL, double gammaR, double runmt, double runmb, double mWboson, int torb)
{
  DoubleVector couplings(16);
  for (int i=1; i<=16; i++) { couplings(i) = 0;}

  double fu=0, fd=0, AprimeuW1=0, AprimedW1=0, BW1=0, BprimeW1=0, sq1AprimeW1=0, sq1ch1B1=0, sq1ch1combo=0, sq1ch1angular1=0, sq1ch1angular2=0, sq1ch1B2=0, AprimeuW2=0, AprimedW2=0, BW2=0, BprimeW2=0, sq1AprimeW2=0, sq1ch2B1=0, sq1ch2B2=0, sq1ch2combo=0, sq1ch2angular1=0, sq1ch2angular2=0, sq2AprimeW1=0, sq2ch1B1=0, sq2ch1B2=0, sq2ch1combo=0, sq2ch1angular1=0, sq2ch1angular2=0, sq2AprimeW2=0, sq2ch2B1=0, sq2ch2B2=0, sq2ch2combo=0, sq2ch2angular1=0, sq2ch2angular2=0;
  
  fu = g*runmt/(pow(2,0.5)*mWboson*sin(beta));
  fd = g*runmb/(pow(2,0.5)*mWboson*cos(beta));
  AprimeuW1 = -g*sin(gammaL);
  AprimedW1 = -g*sin(gammaR);
  BW1 = -fu*cos(gammaR);
  BprimeW1 = -fd*cos(gammaL);

  
    if (torb == 1 ) {
      sq1AprimeW1 = AprimedW1;
      sq1ch1B1 = BW1;
      sq1ch1B2 = BprimeW1;
    }
    else if (torb == 2) {
      sq1AprimeW1 = AprimeuW1;
      sq1ch1B1 = BprimeW1;
      sq1ch1B2 = BW1;
      ///cout << "torb is 2" << endl;
    }

    AprimeuW2 = -g*cos(gammaL);
    AprimedW2 = -g*cos(gammaR);
    BW2 = fu*sin(gammaR);
    BprimeW2 = fd*sin(gammaL);
    if (torb == 1 ) {
      sq1AprimeW2 = AprimedW2;
      sq1ch2B1 = BW2;
      sq1ch2B2 = BprimeW2;
    }
    else if (torb == 2) {
      sq1AprimeW2 = AprimeuW2;
      sq1ch2B1 = BprimeW2;
      sq1ch2B2 = BW2;
    }

    
    if (torb == 1 ) {
      sq2AprimeW1 = AprimedW1;
      sq2ch1B1 = BW1;
      sq2ch1B2 = BprimeW1;
    }
    else if (torb == 2) {
      sq2AprimeW1 = AprimeuW1;
      sq2ch1B1 = BprimeW1;
      sq2ch1B2 = BW1;
    }

    if (torb == 1 ) {
      sq2AprimeW2 = AprimedW2;
      sq2ch2B1 = BW2;
      sq2ch2B2 = BprimeW2;
    }
    else if (torb == 2) {
      sq2AprimeW2 = AprimeuW2;
      sq2ch2B1 = BprimeW2;
      sq2ch2B2 = BW2;
    }
		
    sq1ch1combo = sq1AprimeW1*cos(theta)-sq1ch1B1*sin(theta);
    sq1ch1angular1 = pow(sq1ch1combo,2) + pow(sq1ch1B2*cos(theta),2);
    sq1ch1angular2 = 4*sq1ch1combo*sq1ch1B2*cos(theta);

    sq1ch2combo = sq1AprimeW2*cos(theta)-sq1ch2B1*sin(theta);
    sq1ch2angular1 = pow(sq1ch2combo,2) + pow(sq1ch2B2*cos(theta),2);
    sq1ch2angular2 = 4*sq1ch2combo*sq1ch2B2*cos(theta);

    sq2ch1combo = sq2AprimeW1*sin(theta)+sq2ch1B1*cos(theta);
    sq2ch1angular1 = pow(sq2ch1combo,2) + pow(sq2ch1B2*sin(theta),2);
    sq2ch1angular2 = 4*sq2ch1combo*sq2ch1B2*sin(theta);

    sq2ch2combo = sq2AprimeW2*sin(theta) + sq2ch2B1*cos(theta);
    sq2ch2angular1 = pow(sq2ch2combo,2) + pow(sq2ch2B2*sin(theta),2);
    sq2ch2angular2 = 4*sq2ch2combo*sq2ch2B2*sin(theta);

    couplings(1) = sq1ch1angular1; couplings(2) = sq1ch1angular2; couplings(3) = sq1ch2angular1; couplings(4) = sq1ch2angular2; couplings(5) = sq2ch1angular1; couplings(6) = sq2ch1angular2; couplings(7) = sq2ch2angular1; couplings(8) = sq2ch2angular2; couplings(9) = sq1ch1combo; couplings(10) = sq1ch2combo; couplings(11) = sq1ch1B2*cos(theta); couplings(12) = sq1ch2B2*cos(theta); couplings(13) = sq2ch1combo; couplings(14) = sq2ch2combo; couplings(15) = sq2ch1B2*sin(theta); couplings(16) = sq2ch2B2*sin(theta);
    return couplings;
}

DoubleVector higgsphisamecharginocouplings (double alpha, double beta, double thetaL, double thetaR) /// calculates the couplings of a neutral higgs (h,H,A) to Wtildai Wtildai - i.e. to two charginos of the same type (mass)
{
  DoubleVector Scoupling(6);
  for (int i=1; i<=6; i++) {
    Scoupling(i) = 0;
  }
  DoubleVector Sih(2), SiH(2), SiA(2);
  for (int i=1; i<=2; i++) {
    Scoupling(i) = 0;
  }

  Sih(1) = 0.5*(-sin(alpha)*sin(thetaR)*cos(thetaL) + cos(alpha)*sin(thetaL)*cos(thetaR));
  Sih(2) = 0.5*(sin(alpha)*cos(thetaR)*sin(thetaL) - cos(alpha)*cos(thetaL)*sin(thetaR));
  SiH(1) = 0.5*(cos(alpha)*sin(thetaR)*cos(thetaL) + sin(alpha)*sin(thetaL)*cos(thetaR));
  SiH(2) = -0.5*(cos(alpha)*cos(thetaR)*sin(thetaL) + sin(alpha)*cos(thetaL)*sin(thetaR));
  SiA(1) = 0.5*(sin(thetaR)*cos(thetaL)*sin(beta) + sin(thetaL)*cos(thetaR)*cos(beta));
  SiA(2) = -0.5*(cos(thetaR)*sin(thetaL)*sin(beta) + cos(thetaL)*sin(thetaR)*cos(beta));
 
  Scoupling(1) = Sih(1); Scoupling(2) = Sih(2); Scoupling(3) = SiH(1); Scoupling(4) = SiH(2); Scoupling(5) = SiA(1); Scoupling(6) = SiA(2);
  return Scoupling;
}

DoubleVector higgsphidifcharginocouplings (double alpha, double beta, double thetaL, double thetaR) /// calculates the couplings of a netural higgs (h,H,A) to Wtildai Wtildaj - i.e. to two charginos of different type (mass)
{
  DoubleVector SPcoupling(6);
  for (int i=1; i<=6; i++) {
    SPcoupling(i) = 0;
  }
  double Sh=0, Ph=0, SH=0, PH=0, SA=0, PA=0;  

  Sh = 0.5*(sin(thetaR)*sin(thetaL)*sin(alpha) + cos(thetaL)*cos(thetaR)*cos(alpha) - sin(thetaL)*sin(thetaR)*cos(alpha) - cos(thetaL)*cos(thetaR)*sin(alpha ));
  Ph = 0.5*(-sin(thetaR)*sin(thetaL)*sin(alpha) - cos(thetaL)*cos(thetaR)*cos(alpha) - sin(thetaL)*sin(thetaR)*cos(alpha) - cos(thetaL)*cos(thetaR)*sin(alpha ));
  SH = 0.5*(-sin(thetaR)*sin(thetaL)*cos(alpha) + cos(thetaL)*cos(thetaR)*sin(alpha) - sin(thetaL)*sin(thetaR)*sin(alpha) + cos(thetaL)*cos(thetaR)*cos(alpha));
  PH = 0.5*(sin(thetaR)*sin(thetaL)*cos(alpha) - cos(thetaL)*cos(thetaR)*sin(alpha) - sin(thetaL)*sin(thetaR)*sin(alpha) + cos(thetaL)*cos(thetaR)*cos(alpha));
  SA = 0.5*(-sin(thetaR)*sin(thetaL)*sin(beta) + cos(thetaL)*cos(thetaR)*cos(beta) + sin(thetaL)*sin(thetaR)*cos(beta) - cos(thetaL)*cos(thetaR)*sin(beta));
  PA = 0.5*(sin(thetaR)*sin(thetaL)*sin(beta) - cos(thetaL)*cos(thetaR)*cos(beta) + sin(thetaL)*sin(thetaR)*cos(beta) - cos(thetaL)*cos(thetaR)*sin(beta));
 
  SPcoupling(1) = Sh; SPcoupling(2) = Ph; SPcoupling(3) = SH; SPcoupling(4) = PH; SPcoupling(5) = SA; SPcoupling(6) = PA;
  return SPcoupling;
}
     



DoubleVector higgshsquarksamehandcouplings (double mWboson, double g, double gp, double alpha, double beta, double mupq, double mdownq) /// calculates the couplings of light scalar higgs h to two squarks of same handedness
{
  DoubleVector hsqsqcoupling(4);
  for (int i=1; i<=4; i++) {
    hsqsqcoupling(i) = 0;
  }
  double huLuL=0, huRuR=0, hdLdL=0, hdRdR=0;  
  huLuL = g*(mWboson*(0.5 - pow(gp/g,2)/6)*sin(alpha+beta) - pow(mupq,2)*cos(alpha)/(mWboson*sin(beta)));
  ///huLuL = g*(mWboson*(0.5 - pow(gp/g,2)/6)*sin(alpha+beta));
  ///huLuL = g/mWboson*pow(mZ,2)*sin(alpha+beta)*(0.5-2*(sin2tW)/3); 
  ///huLuL = pow(32,0.25)*pow(GMU,0.5)*pow(mZ,2)*sin(alpha+beta)*(0.5-2*sin2tW/3);
  hdLdL = g*(mWboson*(-0.5 - pow(gp/g,2)/6)*sin(alpha+beta) + pow(mdownq,2)*sin(alpha)/(mWboson*cos(beta)));
  huRuR = g*(2*mWboson/3*pow(gp/g,2)*sin(alpha+beta) - pow(mupq,2)*cos(alpha)/(mWboson*sin(beta)));
  hdRdR = g*(-mWboson/3*pow(gp/g,2)*sin(alpha+beta) + pow(mdownq,2)*sin(alpha)/(mWboson*cos(beta)));
  ///cout << "I multiply by " << g << endl;
  hsqsqcoupling(1) = huLuL; hsqsqcoupling(2) = hdLdL; hsqsqcoupling(3) = huRuR; hsqsqcoupling(4) = hdRdR; 
  return hsqsqcoupling;
}    

DoubleVector higgshsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mupq, double mdownq, double greekmu, double Aup, double Adown) /// calculates the couplings of light scalar higgs h to two squarks of different handedness
{
  DoubleVector hsqsqcoupling(2);
  for (int i=1; i<=2; i++) {
    hsqsqcoupling(i) = 0;
  }
  double huLuR=0, hdLdR=0;
  huLuR = g*mupq/(2*mWboson*sin(beta))*(greekmu*sin(alpha) + Aup*cos(alpha));
  hdLdR = g*mdownq/(2*mWboson*cos(beta))*(-greekmu*cos(alpha) - Adown*sin(alpha));
  
  hsqsqcoupling(1) = huLuR; hsqsqcoupling(2) = hdLdR; 
  return hsqsqcoupling;
}    

DoubleVector higgsHsquarksamehandcouplings (double mWboson, double g, double gp, double alpha, double beta, double mupq, double mdownq) /// calculates the couplings of heavy scalar higgs H to two squarks of same handedness
{
  DoubleVector Hsqsqcoupling(4);
  for (int i=1; i<=4; i++) {
    Hsqsqcoupling(i) = 0;
  }
  double HuLuL=0, HuRuR=0, HdLdL=0, HdRdR=0;  
  HuLuL = g*(-mWboson*(0.5 - pow(gp/g,2)/6)*cos(alpha+beta) - pow(mupq,2)*sin(alpha)/(mWboson*sin(beta)));
  HdLdL = g*(mWboson*(0.5 + pow(gp/g,2)/6)*cos(alpha+beta) - pow(mdownq,2)*cos(alpha)/(mWboson*cos(beta)));
  HuRuR = g*(-2*mWboson/3*pow(gp/g,2)*cos(alpha+beta) - pow(mupq,2)*sin(alpha)/(mWboson*sin(beta)));
  HdRdR = g*(mWboson/3*pow(gp/g,2)*cos(alpha+beta) - pow(mdownq,2)*cos(alpha)/(mWboson*cos(beta)));
 
  Hsqsqcoupling(1) = HuLuL; Hsqsqcoupling(2) = HdLdL; Hsqsqcoupling(3) = HuRuR; Hsqsqcoupling(4) = HdRdR; 
  return Hsqsqcoupling;
}    

DoubleVector higgsHsquarkdiffhandcouplings (double mWboson, double g, double alpha, double beta, double mupq, double mdownq, double greekmu, double Aup, double Adown) /// calculates the couplings of heavy scalar higgs H to two squarks of different handedness
{
  DoubleVector Hsqsqcoupling(2);
  for (int i=1; i<=2; i++) {
    Hsqsqcoupling(2) = 0;
  }
  double HuLuR=0, HdLdR=0;
  HuLuR = g*mupq/(2*mWboson*sin(beta))*(-greekmu*cos(alpha) + Aup*sin(alpha));
  HdLdR = g*mdownq/(2*mWboson*cos(beta))*(-greekmu*sin(alpha) + Adown*cos(alpha));
  
  Hsqsqcoupling(1) = HuLuR; Hsqsqcoupling(2) = HdLdR; 
  return Hsqsqcoupling;
}    

DoubleVector higgshsleptonsamehandcouplings (double mWboson, double g, double gp, double alpha, double beta, double mel) /// calculates the couplings of light scalar higgs h to two sleptons of same handedness
{
  DoubleVector hslslcoupling(3);
  for (int i=1; i<=3; i++) {
    hslslcoupling(3) = 0;
  }
  double hnuLnuL=0, heLeL=0, heReR=0;  
  hnuLnuL = g*(mWboson*(0.5 + pow(gp/g,2)/2)*sin(alpha+beta));
  heLeL = g*(mWboson*(-0.5 + pow(gp/g,2)/2)*sin(alpha+beta) + pow(mel,2)*sin(alpha)/(mWboson*cos(beta)));
  heReR = g*(-mWboson*pow(gp/g,2)*sin(alpha+beta) + pow(mel,2)*sin(alpha)/(mWboson*cos(beta)));
 
  hslslcoupling(1) = hnuLnuL; hslslcoupling(2) = heLeL; hslslcoupling(3) = heReR; 
  return hslslcoupling;
}    
  
DoubleVector higgshsleptondiffhandcouplings (double mWboson, double g, double alpha, double beta, double mel, double greekmu, double Ae) /// calculates the couplings of light scalar higgs h to two sleptons of different handedness
{
  DoubleVector hslslcoupling(1);
  for (int i=1; i<=1; i++) {
    hslslcoupling(1) = 0;
  }
  double heLeR=0;
  heLeR = g*mel/(2*mWboson*cos(beta))*(-greekmu*cos(alpha) - Ae*sin(alpha));
  
  hslslcoupling(1) = heLeR;
  return hslslcoupling;
}    

DoubleVector higgsHsleptonsamehandcouplings (double mWboson, double g, double gp, double alpha, double beta, double mel) /// calculates the couplings of heavy scalar higgs H to two sleptons of same handedness
{
  DoubleVector Hslslcoupling(3);
  for (int i=1; i<=3; i++) {
    Hslslcoupling(3) = 0;
  }
  double HnuLnuL=0, HeLeL=0, HeReR=0;  
  HnuLnuL = g*(-mWboson*(0.5 + pow(gp/g,2)/2)*cos(alpha+beta));
  HeLeL = g*(mWboson*(0.5 - pow(gp/g,2)/2)*cos(alpha+beta) - pow(mel,2)*cos(alpha)/(mWboson*cos(beta)));
  HeReR = g*(mWboson*pow(gp/g,2)*cos(alpha+beta) - pow(mel,2)*cos(alpha)/(mWboson*cos(beta)));
 
  Hslslcoupling(1) = HnuLnuL; Hslslcoupling(2) = HeLeL; Hslslcoupling(3) = HeReR; 
  return Hslslcoupling;
}    

DoubleVector higgsHsleptondiffhandcouplings (double mWboson, double g, double alpha, double beta, double mel, double greekmu, double Ae) /// calculates the couplings of heavy scalar higgs H to two sleptons of different handedness
{
  DoubleVector Hslslcoupling(1);
  for (int i=1; i<=1; i++) {
    Hslslcoupling(i) = 0;
  }
  double HeLeR=0;
  HeLeR = g*mel/(2*mWboson*cos(beta))*(-greekmu*sin(alpha) + Ae*cos(alpha));
  
  Hslslcoupling(1) = HeLeR;
  return Hslslcoupling;
}  

DoubleVector higgsHplussquarkcouplings (double mWboson, double g, double beta, double mup, double mdown, double greekmu, double Au, double Ad) /// calculates the couplings of charged scalar higgs H+ to two squarks
{
  DoubleVector Hplussqsqcoupling(4);
  for (int i=1; i<=4; i++) {
    Hplussqsqcoupling(i) = 0;
  }
  double HplusuLdL=0, HplusuRdR=0, HplusuLdR=0, HplusuRdL=0; 
  HplusuLdL = g/(pow(2,0.5))*(-mWboson*sin(2*beta) + (pow(mdown,2)*tan(beta)+pow(mup,2)/(tan(beta)))/mWboson);
  HplusuRdR = (g*mup*mdown*(tan(beta) + 1/(tan(beta))))/(pow(2,0.5)*mWboson);
  HplusuLdR = -g*mdown/(pow(2,0.5)*mWboson)*(Ad*tan(beta) + greekmu);
  HplusuRdL = -g*mup/(pow(2,0.5)*mWboson)*(Au/(tan(beta)) + greekmu);
  
  Hplussqsqcoupling(1) = HplusuLdL;
  Hplussqsqcoupling(2) = HplusuRdR;
  Hplussqsqcoupling(3) = HplusuLdR;
  Hplussqsqcoupling(4) = HplusuRdL;
  
  return Hplussqsqcoupling;
}      


DoubleVector foftau(double mpart, double mcomp) ///f(tau) function for use in h->gamma gamma
{
  double tau=0, fr=0, fi=0, etap=0, etam=0;
  DoubleVector f(3);
  for (int i=1; i<=3; i++) {
    f(i) =0;
  }
  tau = 4*pow(mpart/mcomp,2);
  if (tau >=1) {
    fr = pow((asin(1/pow(tau,0.5))),2);
    fi = 0;
  }
  else if (tau<1) {
    etap = 1 + pow(1-tau,0.5);
    etam = 1 - pow(1-tau,0.5);
    fr = -0.25*pow(log(etap/etam),2)+0.25*pow(PI,2);
    fi = 0.5*PI*log(etap/etam);
  }
  f(1)=fr;
  f(2)=fi;
  f(3)=tau;
  return f;
}

DoubleVector goftau(double mpart, double mcomp) ///g(tau) function for use in h->Z gamma
{
  double tau=0, gr=0, gi=0, etap=0, etam=0;
  DoubleVector g(3);
  for (int i=1; i<=3; i++) {
    g(i) =0;
  }
  tau = 4*pow(mpart/mcomp,2);
  if (tau >=1) {
    gr = pow(tau-1,0.5)*((asin(1/pow(tau,0.5))));
    gi = 0;
  }
  else if (tau<1) {
    etap = 1 + pow(1-tau,0.5);
    etam = 1 - pow(1-tau,0.5);
    gr = 0.5*pow(1-tau,0.5)*(log(etap/etam));
    gi = 0.5*pow(1-tau,0.5)*-PI;
  }
  g(1)=gr;
  g(2)=gi;
  g(3)=tau;
  return g;
}



///Integrand functions for 1->3 decays

double gpsitilda(double mass1, double mass2, double mass3, double mass4, double massq, double Et) ///the integrand in the psitilda integral
 {
   double gpsitilda = 0, pt = 0, squareplus = 0, squareminus = 0, lambda = 0, A = 0;
   A = pow(mass1,2)+pow(massq,2)-2*fabs(mass1)*Et;
   pt = pow(pow(Et,2)-pow(massq,2),0.5);
   squareplus = A - pow(mass4 + massq,2);
   squareminus = A - pow(mass4 - massq,2);
   if (squareplus <0) ///this can happen erronesouly at very end of range due to finite precision used, squareplus should actually then be very very small and +ve
     { squareplus = 0;} /// set to zero to avoid nan problem in lambda, note that given squareplus very very very small anyway here this should not affect the accuracy of the integral
   lambda = pow(squareplus*squareminus,0.5);
   gpsitilda = pow(PI,2)*fabs(mass1)*pt*Et*lambda/(A)*(pow(mass1,2)-pow(mass4,2)-2*fabs(mass1)*Et)/((A-pow(mass2,2))*(A-pow(mass3,2)));
   ///cout << "gpsitilda = " << gpsitilda << " at Et = " << Et << endl; 
   ///if (Et > 5.29e+02) { cout << "squareplus = " << squareplus << " squareminus = " << squareminus <<  " lambda = " << lambda << " A = " << A << " pt = " << pt << endl;}
   ///if (squareplus <0 || squareminus <0) {
   ///  cout << "AT E = " << Et << endl;
   ///  cout << "squareplus = " << squareplus << " squareminus = " << squareminus <<  " lambda = " << lambda << " A = " << A << " pt = " << pt << endl;
   ///  cout << "mass1 = " << mass1 << " mass2 = "<< mass2 << " mass3 = " << mass3 << " mass4 = "<< mass4 << " massq = " << massq << endl;
   ///   cout.precision(26);
   ///  cout << "A = " << A << endl;
   ///  cout << "Et = " << Et << endl;
   ///  cout << "Ashould = " << pow(220,2) + pow(0.104,2) -2*18.996363636363636363636363636363636363*220 << endl;
   ///  cout << "Atest = " << pow(220,2)+pow(0.104,2)-2*220*Et << endl;
   ///  cout << "Atest2 = " << pow(mass1,2)+pow(0.104,2)-2*mass1*Et << endl;
   ///  cout << "(mass4+massq)^2 = " << pow(mass4+massq,2) << endl;
///}
   return gpsitilda;
 }

double gphitilda(double mass1, double mass2, double mass3, double mass4, double massq, double Et) ///the integrand in the phitilda integral
 {
   double gphitilda = 0, A = 0, Z=0;
   DoubleVector Etbarmaxmin (double m1, double m2, double massq, double Et);
   double Zfunc(double m1, double mq, double m, double Etbarmax, double Etbarmin);
   DoubleVector Etbar(2);
   for (int i=1; i<=2; i++) { Etbar(i) = 0;}
   Etbar = Etbarmaxmin(mass1, mass4, massq, Et);
   Z = Zfunc(mass1,massq,mass3,Etbar(1),Etbar(2));
   A = pow(mass1,2)+pow(massq,2)-2*fabs(mass1)*Et;
   gphitilda = 0.5*pow(PI,2)*fabs(mass1)*fabs(mass4)/(A-pow(mass2,2))*(-(Etbar(1)-Etbar(2)) - (pow(mass4,2)-pow(massq,2)+2*Et*fabs(mass1)-pow(mass3,2))/(2*fabs(mass1))*log(Z));
   return gphitilda;
 }

double gxsi(double mass1, double mass2, double mass3, double mass4, double massq, double Et) ///the integrand in the xsi integral
{
  double gxsi = 0, Z=0, A=0;
  double Zfunc(double m1, double mq, double m, double Etbarmax, double Etbarmin);
  DoubleVector Etbarmaxmin (double m1, double m2, double massq, double Et);
  DoubleVector Etbar(2);
  for (int i=1; i<=2; i++) { Etbar(i) = 0;}
  Etbar = Etbarmaxmin(mass1, mass4, massq, Et);
  Z = Zfunc(mass1,massq,mass3,Etbar(1),Etbar(2));
  A = pow(mass1,2)+pow(massq,2)-2*fabs(mass1)*Et;
  gxsi = 0.5*pow(PI,2)/(A-pow(mass2,2))*((Etbar(1)-Etbar(2))-(pow(mass1,2)-pow(massq,2)-2*fabs(mass1)*Et+pow(mass3,2))/(2*fabs(mass1))*log(Z));
  ///gxsi = pow(Et,2);
  ///cout << "mass1 = " << mass1 << " mass2 = " << mass2 << " mass 3 = " << mass3 << " mass4 = " << mass4 << " massq = " << massq << endl;
  return gxsi;
}

double Zfunc(double m1, double mq, double m, double Etbarmax, double Etbarmin) ///required in many of the 1->3 integrals
{
  double Z = 0;
  Z = (pow(m1,2)+pow(mq,2)-2*fabs(m1)*Etbarmax - pow(m,2))/(pow(m1,2)+pow(mq,2)-2*fabs(m1)*Etbarmin-pow(m,2));
  ///cout << "m1 = " << m1 << " mq = " << mq << " m = " << m << " Etbarmax = " << Etbarmax << " Etbarmin = " << Etbarmin << endl;
  if (Z <=0) {
    cout << "May have nan issue if do log(Z) as Z<=0 !    ";
    cout << "numerator of Z = " << (pow(m1,2)+pow(mq,2)-2*fabs(m1)*Etbarmax - pow(m,2)) << " denominator of Z = " << (pow(m1,2)+pow(mq,2)-2*fabs(m1)*Etbarmin-pow(m,2)) << endl;
  }
  return Z;
}

DoubleVector Etbarmaxmin (double m1, double m2, double massq, double Et) ///required for many of the 1->3 integrals, this gives E max and min of t bar for given Et therefore different to overall limits of integration on Et which are Etmax, Etmin
{
  DoubleVector Etbarsupremum(2);
  double pt=0, zet=0, A=0, B=0;
  pt = pow(pow(Et,2)-pow(massq,2),0.5);
  zet = 2*pow(massq,2)+pow(m1,2)-pow(m2,2)-2*fabs(m1)*Et;
  A = pow(m1,2)+pow(massq,2)-2*fabs(m1)*Et;
  B = (pow(pt*zet,2)-4*pow(pt*massq,2)*A);
  if ( B < 0) {
    ///  cout << endl;
    ///cout << "Etbar problem!:" << endl;
    ///cout << "At Et = " << Et << endl;
    ///cout << "pt = " << pt << " zet = " << zet << " A = " << A << endl;
    ///cout << "Therefore:" << endl;
    ///cout << "pow(pt*zet,2)-4*pow(pt*massq,2)*A = " << pow(pt*zet,2)-4*pow(pt*massq,2)*A << " < 0! so sqrt gives nan " << endl;
    ///cout << "Etbarmax = " << Etbarsupremum(1) << " Etbarmin = " << Etbarsupremum(2) << endl;
    ///cout << endl;
    B = 0; /// B may become very very small and negative at the tails of this squareroot, this causes problems as we get sqrt(-ve) therefore set B to 0 here as it's very small anyway so has negligible effect on the overall answer.
  }
 
  Etbarsupremum(1) = (zet*(fabs(m1)-Et)+pow(B,0.5))/(2*A); ///Etbarmax
  Etbarsupremum(2) = (zet*(fabs(m1)-Et)-pow(B,0.5))/(2*A); ///Etbarmin
  if (Etbarsupremum(1) != Etbarsupremum(1) || Etbarsupremum(2) != Etbarsupremum(2)) {
    cout << "Etbar nan problem! " << endl;
    // cout << "B= " << B << " A = " << A << " Et = " << Et << endl;
  }
    return Etbarsupremum;
}


double grho(double mass1, double mass2, double mass3, double mass4, double massq, double Et) ///the integrand in the rho integral
{
  double grho = 0, Z=0;
  double Zfunc(double m1, double mq, double m, double Etbarmax, double Etbarmin);
  DoubleVector Etbar(2);
  for (int i=1; i<=2; i++) { Etbar(i) = 0;}
  DoubleVector Etbarmaxmin (double m1, double m2, double massq, double Et);
  Etbar = Etbarmaxmin(mass1, mass4, massq, Et);
  Z = Zfunc(mass1,massq,mass3,Etbar(1),Etbar(2));
  ///grho = -0.5*pow(PI,2)/(mass1)*1/(pow(mass1,2)+pow(massq,2)-2*mass1*Et-pow(mass2,2))*log(Z);
  ///cout << "mass1 = " << mass1 << " mass2 = " << mass2 << " mass3= " << mass3 << " mass4 = " << mass4 << " massq = " << massq << endl;
  grho =  -pow(PI,2)/(2*fabs(mass1))*1/(pow(mass1,2)+pow(massq,2)-2*fabs(mass1)*Et-pow(mass2,2))*log(Z);
  return grho;
}

double gchi(double mass1, double mass2, double mass3, double mass4, double massq, double Et) ///the integrand in the chi integral
{
  double gchi = 0, pt=0, A=0, squareplus=0, squareminus=0, lambda=0;
  A = pow(mass1,2)+pow(massq,2)-2*fabs(mass1)*Et;
  squareplus = A - pow((mass4 + massq),2);
  squareminus = A - pow((mass4 - massq),2);
  lambda = pow(squareplus*squareminus,0.5);
  pt = pow(pow(Et,2) - pow(massq,2),0.5);
  gchi = pow(PI,2)*fabs(mass1)*pt*Et*lambda/(A)*1/((pow(mass1,2)+pow(massq,2)-2*fabs(mass1)*Et-pow(mass2,2))*(pow(mass1,2)+pow(massq,2)-2*fabs(mass1)*Et-pow(mass3,2)));
  if (gchi > 1e16) { cout << "gchi = " << gchi << " at Et = " << Et << " A= " << A << endl;}
  ///gxsi = pow(Et,2);
  return gchi;
}


double gzeta(double mass1, double mass2, double mass3, double mass4, double massq, double Et) ///the integrand in the zeta integral
{
  double gzeta = 0, A=0;
  DoubleVector Etbar(2);
  for (int i=1; i<=2; i++) { Etbar(i) = 0;}
  DoubleVector Etbarmaxmin (double m1, double m2, double massq, double Et);
  Etbar = Etbarmaxmin(mass1, mass4, massq, Et);
  A = pow(mass1,2)+pow(massq,2)-2*fabs(mass1)*Et;
  gzeta = pow(PI,2)*(Etbar(1)-Etbar(2))/((A-pow(mass2,2))*(A-pow(mass3,2)));
  return gzeta;
}


double gX(double mass1, double mass2, double mass3, double mass4, double massq, double Et) ///the integrand in the X integral
{
  double gX = 0, pt=0, A=0, B=0, squareplus=0, squareminus=0, lambda=0;
  A = pow(mass1,2)+pow(massq,2)-2*fabs(mass1)*Et;
  B = pow(mass1,2)-pow(mass4,2)-2*fabs(mass1)*Et;
  pt = pow(pow(Et,2) - pow(massq,2),0.5);
  squareplus = A - pow((mass4 + massq),2);
  squareminus = A - pow((mass4 - massq),2);
  lambda = pow(squareplus*squareminus,0.5);
  gX = 0.5*pow(PI,2)*pt*B/A*lambda*1/((pow(mass1,2)+pow(massq,2)-2*fabs(mass1)*Et-pow(mass2,2))*(pow(mass1,2)+pow(massq,2)-2*fabs(mass1)*Et-pow(mass3,2)));
  return gX;
}


double gY(double mass1, double mass2, double mass3, double mass4, double massq, double Et) ///the integrand in the Y integral
{
  double gY = 0, A=0, Z=0;
  double Zfunc(double m1, double mq, double m, double Etbarmax, double Etbarmin);
  DoubleVector Etbar(2);
  for (int i=1; i<=2; i++) { Etbar(i) = 0;}
  DoubleVector Etbarmaxmin(double m1, double m2, double massq, double Et);
  Etbar = Etbarmaxmin(mass1, mass4, massq, Et);
  Z = Zfunc(mass1,massq,mass3,Etbar(1),Etbar(2));
  if (Z<0 ) {
    ///  cout << "Z = " << Z << " Etbarmax = " << Etbar(1) << " Etbarmin = " << Etbar(2) << endl;
  }
  A = pow(mass1,2)+pow(massq,2)-2*fabs(mass1)*Et;
  gY = 0.5*pow(PI,2)*1/(A-pow(mass2,2))*((Etbar(1)-Etbar(2))*A + 1/(2*fabs(mass1))*(pow(mass1,2)*pow(mass4,2)-pow(mass1,2)*pow(mass3,2)+pow(massq,4)+2*fabs(mass1)*Et*pow(mass3,2)-pow(mass3,2)*pow(massq,2))*log(Z));
  return gY;
}


double gchiprime(double mass1, double mass2, double mass3, double mass4, double massq, double Et) ///the integrand in the chiprime integral
{
  double gchiprime = 0, A=0, Z=0;
  DoubleVector Etbar(2);
  for (int i=1; i<=2; i++) { Etbar(i) = 0;}
  DoubleVector Etbarmaxmin(double m1, double m2, double massq, double Et);
  Etbar = Etbarmaxmin(mass1, mass4, massq, Et);
  double Zfunc(double m1, double mq, double m, double Etbarmax, double Etbarmin);
  Z = Zfunc(mass1,massq,mass2,Etbar(1),Etbar(2));
  A = pow(mass1,2)+pow(massq,2)-2*fabs(mass1)*Et;
  gchiprime = -0.5*pow(PI,2)*Et/(A-pow(mass3,2))*log(Z);
  return gchiprime;
}


double gG1(double mass1, double mass2, double mass3, double massq, double Et) ///the integrand in the G1 integral
{
  double gG1 = 0, A=0, pt=0;
  pt = pow(pow(Et,2)-pow(massq,2),0.5);
  A = pow(mass1,2)+pow(massq,2)-2*fabs(mass1)*Et;
  gG1 = fabs(mass1)*pt*Et*pow((A-pow(mass3,2)),2)/(pow(A-pow(mass2,2),2)*A);
  return gG1;
}


double gG2(double mass1, double mass2, double mass3, double masst, double massb, double Ebbar) ///the integrand in the G2 integral
{
  double gG2 = 0, A=0, squareplus=0, squareminus=0, lambda=0;
  A = pow(mass1,2)+pow(massb,2)-2*fabs(mass1)*Ebbar;
  squareplus = A - pow(mass3+masst,2);
  squareminus = A - pow(mass3-masst,2);
  lambda = pow(squareplus*squareminus,0.5);
  gG2 = fabs(mass1)*pow(Ebbar,2)*lambda*(A-pow(masst,2)-pow(mass3,2))/(pow(A-pow(mass2,2),2)*A);
  return gG2;
}


double gG3(double mass1, double mass2, double mass3, double masst, double massb, double Ebbar) ///the integrand in the G3 integral
{
  double gG3 = 0, A=0, squareplus=0, squareminus=0, lambda=0;
  A = pow(mass1,2)+pow(massb,2)-2*fabs(mass1)*Ebbar;
  squareplus = A - pow(mass3+masst,2);
  squareminus = A - pow(mass3-masst,2);
  lambda = pow(squareplus*squareminus,0.5);
  gG3 = pow(Ebbar,2)*lambda*4*fabs(mass1)*fabs(mass3)*masst/(pow(A-pow(mass2,2),2)*A);
  return gG3;
}


double gG4(double mass1, double mass2, double mass3, double mass4, double masst, double massb, double Et) ///the integrand in the G4 integral
{
  double gG4 = 0, A=0, X=0, Ebbarmax=0, Ebbarmin=0;
  DoubleVector Ebbarmaxmin (double mass1, double mass2, double mass3, double mass4, double Et);
  double Xfunc (double mass1, double mass2, double mass3, double mass4, double mass5, double Et);
  Ebbarmax = Ebbarmaxmin (mass1, masst, massb, mass4, Et)(1);
  Ebbarmin = Ebbarmaxmin (mass1, masst, massb, mass4, Et)(2);
  X = Xfunc(mass1, masst, massb, mass4, mass3, Et);
  A = pow(mass1,2)+pow(masst,2)-2*fabs(mass1)*Et;
  gG4 = fabs(mass1)*fabs(mass4)*1/(A-pow(mass2,2))*((Ebbarmax-Ebbarmin) - (pow(mass3,2)+pow(masst,2)-2*Et*mass1-pow(mass4,2))/(2*fabs(mass1))*log(X));
  return gG4;
}


double gG5(double mass1, double mass2, double mass3, double mass4, double masst, double massb, double Et) ///the integrand in the G5 integral
{
  double gG5 = 0, A=0, X=0;
  DoubleVector Ebbarmaxmin (double mass1, double mass2, double mass3, double mass4, double Et);
  double Xfunc (double mass1, double mass2, double mass3, double mass4, double mass5, double Et);
  X = Xfunc(mass1, masst, massb, mass4, mass3, Et);
  A = pow(mass1,2)+pow(masst,2)-2*fabs(mass1)*Et;
  gG5 = (fabs(mass1)/mass1)*masst/2*(A-pow(mass4,2))/(A-pow(mass2,2))*log(X);
  return gG5;
}


double gG6(double mass1, double mass2, double mass3, double mass4, double masst, double massb, double Et) ///the integrand in the G6 integral
{
  double gG6 = 0, A=0, X=0, Ebbarmax=0, Ebbarmin=0;
  DoubleVector Ebbarmaxmin (double mass1, double mass2, double mass3, double mass4, double Et);
  double Xfunc (double mass1, double mass2, double mass3, double mass4, double mass5, double Et);
  Ebbarmax = Ebbarmaxmin (mass1, masst, massb, mass4, Et)(1);
  Ebbarmin = Ebbarmaxmin (mass1, masst, massb, mass4, Et)(2);
  X = Xfunc(mass1, masst, massb, mass4, mass3, Et);
  A = pow(mass1,2)+pow(masst,2)-2*fabs(mass1)*Et;
  gG6 = 0.5/(A-pow(mass2,2))*((fabs(mass1)*(pow(mass1,2)+pow(masst,2)-2*Et*fabs(mass1)-pow(mass4,2))-(pow(mass3,2)-pow(mass1,2))/fabs(mass1)*-A)*log(X) + 2*(-A)*(Ebbarmax-Ebbarmin));
  return gG6;
}


double gG7(double mass1, double mass2, double mass3, double mass4, double masst, double massb, double Et) ///the integrand in the G7 integral
{
  double gG7 = 0, A=0, X=0, Ebbarmax=0, Ebbarmin=0;
  DoubleVector Ebbarmaxmin (double mass1, double mass2, double mass3, double mass4, double Et);
  double Xfunc (double mass1, double mass2, double mass3, double mass4, double mass5, double Et);
  Ebbarmax = Ebbarmaxmin (mass1, masst, massb, mass4, Et)(1);
  Ebbarmin = Ebbarmaxmin (mass1, masst, massb, mass4, Et)(2);
  X = Xfunc(mass1, masst, massb, mass4, mass3, Et);
  A = pow(mass1,2)+pow(masst,2)-2*mass1*Et;
  gG7 = 0.5*fabs(mass4)*masst*1/(A-pow(mass2,2))*(2*(Ebbarmax-Ebbarmin)-(pow(mass3,2)-pow(mass1,2))/mass1*log(X));
  return gG7;
}


double gG8(double mass1, double mass2, double mass3, double mass4, double masst, double massb, double Et) ///the integrand in the G8 integral
{
  double gG8 = 0, A=0, Ebbarmax=0, Ebbarmin=0;
  DoubleVector Ebbarmaxmin (double mass1, double mass2, double mass3, double mass4, double Et);
  Ebbarmax = Ebbarmaxmin (mass1, masst, massb, mass4, Et)(1);
  Ebbarmin = Ebbarmaxmin (mass1, masst, massb, mass4, Et)(2);
  A = pow(mass1,2)+pow(masst,2)-2*fabs(mass1)*Et;
  gG8 = fabs(mass1)*masst*(A-pow(mass4,2))*(Ebbarmax-Ebbarmin)/((A-pow(mass2,2))*(A-pow(mass3,2)));
  return gG8;
}


DoubleVector Ebbarmaxmin (double mass1, double mass2, double mass3, double mass4, double Et) ///function required for gluino 3 body decays to chargino and q q'bar, mass1 is gluino mass, mass2 is top mass, mass3 is bottom mass, mass4 is chargino mass
{
  DoubleVector Ebbar(2);
  for (int i=1; i<=2; i++) { Ebbar(i)=0;}
  double pt = 0, squareplus = 0, squareminus = 0, lambda = 0, A = 0;
  pt = pow(pow(Et,2)-pow(mass2,2),0.5);
  A = pow(mass1,2)+pow(mass2,2)-2*Et*fabs(mass1);
  squareplus = A - pow(mass3+mass4,2);
  squareminus = A - pow(mass3-mass4,2);

  if (squareplus < 0 && fabs(squareplus) < 1e-8) {
    squareplus = 0; ///Avoid issues of finite precision meaning you get a very small negative squareplus at Amin (smin) rather than 0, this can cause issues when you take the squareroot of lambda, giving a nan
  }

  lambda = pow(squareplus*squareminus,0.5);
  Ebbar(1) = ((pow(mass1,2)+pow(mass2,2)-2*fabs(mass1)*Et-pow(mass3,2)-pow(mass4,2))*(fabs(mass1)-Et) + pt*lambda)/(2*(pow(mass1,2)+pow(mass2,2)-2*Et*fabs(mass1))); ///I have -pow(mass3,2) here whereas T&B have + pow(mass3,2), I have changed the sign to agree with SPheno, note however this actually makes negligible difference due to the smallness of the b mass
  Ebbar(2) = ((pow(mass1,2)+pow(mass2,2)-2*fabs(mass1)*Et-pow(mass3,2)-pow(mass4,2))*(fabs(mass1)-Et) - pt*lambda)/(2*(pow(mass1,2)+pow(mass2,2)-2*Et*fabs(mass1))); ///I have -pow(mass3,2) here whereas T&B have + pow(mass3,2), I have changed the sign to agree with SPheno, note however this actually makes negligible difference due to the smallness of the b mass

  // if (Ebbar(1) != Ebbar(1) || Ebbar(2) != Ebbar(2)) {
  //   cout << "Ebbar nan issue: " << endl;
  //   cout << "lambda = " << lambda << endl;
  //   cout << "squareplus = " << squareplus << " squareminus = " << squareminus << endl;
  //   cout << "Et = " << Et << endl;
  //   cout << "s = " << A << endl;
  //   cout << "pow(mass3+mass4,2) = " << pow(mass3+mass4,2) << endl;
  //   cout << "s - pow(mass3+mass4,2) = " << A - pow(mass3+mass4,2) << endl;
  // }
  
  return Ebbar;
}

 double Xfunc (double mass1, double mass2, double mass3, double mass4, double mass5, double Et) ///required for gluino 3 body decays to chargino and q q'bar, mass1 is gluino mass, mass2 is top mass, mass3 is bottom mass, mass4 is chargino mass, mass5 is the sbottom mass
{
  double X=0;
  DoubleVector Ebbarmaxmin (double mass1, double mass2, double mass3, double mass4, double Et);
  DoubleVector Ebbar(2);
  for (int i=1; i<=2; i++) { Ebbar(i)=0;}
  Ebbar = Ebbarmaxmin (mass1, mass2, mass3, mass4, Et);
  X = (pow(mass5,2)+2*Ebbar(1)*fabs(mass1)-pow(mass1,2))/(pow(mass5,2)+2*Ebbar(2)*fabs(mass1)-pow(mass1,2));
  
  if (log(X) > 0.19 && log(X) < 0.20) {
    cout << "Log(X) = " << log(X) << endl;
  }

  return X;
}

double gZintegral(double m1, double m2, double mz, double mf, double E) ///the integrand in the Zintegral integral
{
  double gZintegral = 0, Bf=0, D=0, F=0, G=0, H=0;
  ///Bf = pow(1-4*pow(mf,2)/(pow(m1,2)+pow(m2,2)-2*E*m2),0.5);
  Bf = pow(1-4*pow(mf,2)/(pow(m1,2)+pow(m2,2)-2*E*fabs(m1)),0.5);
  D = pow(m1,2)+pow(m2,2)-pow(mz,2)-2*E*fabs(m1);
  F = pow(m1,2)+pow(m2,2)-2*fabs(m1)*fabs(m2);
  G = pow(E,2)+pow(m2,2) + Bf/3*(pow(E,2)-pow(m2,2));
  H = fabs(m2)*(fabs(m1)/m1)*(pow(m1,2)+pow(m2,2)-2*pow(mf,2));
  gZintegral = Bf*pow(pow(E,2)-pow(m2,2),0.5)/(pow(D,2))*(E*F-fabs(m1)*G+H);
  return gZintegral;
}

double hHintegral (double m1, double m2, double mf, double mh, double mH, double fromE, double toE, double stepE, double g, double gp, double alpha, DoubleMatrix mixNeut, int neutralinoi, int neutralinoj) ///integral required for the squared hH exchange contribution to the neutralinoj -> neutralinoi + f + fbar 1->3 decay
 {
   double f=0, Area=0, E=0;
   double mid=0, end=0;
   double fmid=0, fend=0;
   double ghHintegral(double m1, double m2, double mf, double mh, double mH, double g, double gp, double alpha, int neutralinoi, int neutralinoj, DoubleMatrix mixNeut, double E);
   for(E=fromE; E+stepE<toE; E= E+stepE) {
     f = ghHintegral(m1, m2, mf, mh, mH, g, gp, alpha, neutralinoi, neutralinoj, mixNeut, E);
     end = E + stepE;
     mid = (E+end)/2;
     fmid = ghHintegral(m1, m2, mf, mh, mH, g, gp, alpha, neutralinoi, neutralinoj, mixNeut, mid);
     fend = ghHintegral(m1, m2, mf, mh, mH, g, gp, alpha, neutralinoi, neutralinoj, mixNeut, end);
     Area = Area + (end-E)/6 * (f + 4*fmid + fend);
     ///cout << "step = " << step << endl;
   }
   return Area;
 }

double ghHintegral(double m1, double m2, double mf, double mh, double mH, double g, double gp, double alpha, int neutralinoi, int neutralinoj, DoubleMatrix mixNeut, double E) ///the integrand in the hHintegral integral
 {
   double ghHintegral = 0, B=0, Bf=0, D=0, F=0, G=0, Xijh=0, XijH=0, Xjih=0, XjiH=0, H=0;
   ///B = 4*pow(mf,2)/(pow(m1,2)+pow(m2,2)-2*E*m2);
   B = 4*pow(mf,2)/(pow(m1,2)+pow(m2,2)-2*E*fabs(m1));
   Bf = pow(1-B,0.5);
   D = pow(m1,2)+pow(m2,2)-2*E*fabs(m1)-2*pow(mf,2);
   F = pow(m1,2)+pow(m2,2)-2*fabs(m1)*E-pow(mh,2);
   G = pow(m1,2)+pow(m2,2)-2*fabs(m1)*E-pow(mH,2);
   H = pow(E,2) - pow(m2,2);
   
   Xjih = -0.5*(fabs(m1)/m1)*(fabs(m2)/m2)*(mixNeut(neutralinoj,3)*-sin(alpha)-mixNeut(neutralinoj,4)*cos(alpha))*(g*-mixNeut(neutralinoi,2)-gp*-mixNeut(neutralinoi,1));
   XjiH = -0.5*(fabs(m1)/m1)*(fabs(m2)/m2)*(mixNeut(neutralinoj,3)*cos(alpha)-mixNeut(neutralinoj,4)*sin(alpha))*(g*-mixNeut(neutralinoi,2)-gp*-mixNeut(neutralinoi,1));
   Xijh = -0.5*(fabs(m1)/m1)*(fabs(m2)/m2)*(mixNeut(neutralinoi,3)*-sin(alpha)-mixNeut(neutralinoi,4)*cos(alpha))*(g*-mixNeut(neutralinoj,2)-gp*-mixNeut(neutralinoj,1));
   XijH = -0.5*(fabs(m1)/m1)*(fabs(m2)/m2)*(mixNeut(neutralinoi,3)*cos(alpha)-mixNeut(neutralinoi,4)*sin(alpha))*(g*-mixNeut(neutralinoj,2)-gp*-mixNeut(neutralinoj,1));
   ghHintegral = Bf*pow(H,0.5)*D*(E+fabs(m2)*(fabs(m1)/m1))*pow(((-sin(alpha)*(Xjih+Xijh))/F + cos(alpha)*(XjiH+XijH)/G),2);


   ///cout << "Xijh = " << Xijh << " Xjih = " << Xjih << " XijH = " << XijH << " XjiH = " << XjiH << endl;
  ///cout << "Bf = " << Bf << " D = " << D << " F = " << F << " G = " << G << " H = " << H << endl;
   ///cout << "H = " << H << endl;
   ///cout.precision(7);
   ///cout << "Xjih = " << Xjih << " XjiH = " << XjiH << " Xijh = " << Xijh << " XijH = " << XijH << endl;
   ///cout << "E = " << E << " B = " << B << " Bf = " << Bf << endl;
   
   return ghHintegral;
}

double gAintegral(double m1, double m2, double mz, double mA, double mf, double E) ///the integrand in the Aintegral integral
{
  double gAintegral = 0, Bf=0, D=0, F=0;
  ///Bf = pow(1-4*pow(mf,2)/(pow(m1,2)+pow(m2,2)-2*E*m2),0.5);
  Bf = pow(1-4*pow(mf,2)/(pow(m1,2)+pow(m2,2)-2*E*fabs(m1)),0.5);
  D = pow(m1,2)+pow(m2,2)-2*E*fabs(m1)-2*pow(mf,2);
  F = pow(m1,2)+pow(m2,2)-2*fabs(m1)*E-pow(mA,2);
  gAintegral = Bf*pow(pow(E,2)-pow(m2,2),0.5)*D*(E-fabs(m2)*(fabs(m1)/m1))/pow(F,2);
  return gAintegral;
}


double gZsfintegral(double m1, double m2, double msf, double mf, double mz, double s) ///the integrand in the Zsfintegral integral
{
  double gZsfintegral = 0, EQ=0, Q=0, Qprime=0, musquared=0, B=0, C=0, D=0, F=0, G=0, H=0;
  EQ = (s + pow(m1,2)-pow(m2,2))/(2*m1);
  if (fabs(pow(EQ,2) - s)<1e-12) {s = pow(EQ,2);}
  Q = pow(pow(EQ,2)-s,0.5);
  Qprime = Q*pow(1-4*pow(mf,2)/s,0.5);
  musquared = s + pow(msf,2) - pow(m2,2)- pow(mf,2);
  B = m1*EQ+pow(msf,2)-pow(m1,2)-s-pow(mf,2);
  C = pow(msf,2)-pow(m2,2)-pow(mf,2);
  D = pow(msf,2)-pow(m1,2)-pow(mf,2);
  F = fabs(m1)*fabs(m2)*(s-2*pow(mf,2));
  G = fabs(m1)*(EQ+Qprime)-musquared;
  H = fabs(m1)*(EQ-Qprime)-musquared;
  gZsfintegral = 1/(s-pow(mz,2))*(-0.5*Qprime*B-1/(4*fabs(m1))*(C*D + F)*log(G/H));
  ///cout << "EQ = " << EQ << " Q = " << Q << " Qprime = " << Qprime << " musquared = " << musquared << " s = " << s <<  " EQ^2 - s = " << pow(EQ,2) - s << endl;
  ///cout << "B = " << B << " C= " << C << " D = " << D << " F = " << F << " G/H = " << G/H <<endl;
  ///cout << "m1 = "<< m1 << " m2 = " << m2 << " msf = " << msf << " mf = " << mf << " mz = " << mz << endl;
  ///cout << "s = " << s << " froms = " << 4*pow(mf,2) << " tos = " << pow((m1-m2),2) << endl;
  ///cout << "EQ = " << EQ << " Q = " << Q << " Qprime = " << Qprime << endl;
  ///cout << "G = " << G << " H = " << H << " log(G/H) = " << log(G/H) << endl;
  return gZsfintegral;
}


double gJintegral(double m1, double m2, double msf, double mphi, double mf, double s, int AorhorH) ///the integrand in the Jintegral integral, int AorhorH changes sign of one of the terms in the integrand for A (int AorhorH = 1) relative to h or H (int AorhorH = 0)
{
  double gJintegral = 0, EQ=0, Q=0, Qprime=0, musquared=0, B=0, G=0, H=0;
  EQ = (s + pow(m1,2)-pow(m2,2))/(2*fabs(m1));
  Q = pow(pow(EQ,2)-s,0.5);
  Qprime = Q*pow(1-4*pow(mf,2)/s,0.5);
  musquared = s + pow(msf,2) - pow(m2,2)- pow(mf,2);
  B = s*pow(msf,2)-pow(mf,2)*(pow(m1,2)+pow(m2,2))+pow(-1,AorhorH)*fabs(m1)*fabs(m2)*(s-2*pow(mf,2));
  G = fabs(m1)*(EQ+Qprime)-musquared;
  H = fabs(m1)*(EQ-Qprime)-musquared;
  gJintegral = 1/(s-pow(mphi,2))*(0.5*s*Qprime + B/(4*fabs(m1))*log(G/H));
  ///cout << "B = " << B << " G/H = " << G/H << endl;
  ///cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  ///cout << "G = " << G << " H = " << H << endl;
  return gJintegral;
}	


  

///Function that runs alphas to desired scale using 1-loop renormalisation group equations:
double alphasrun (double mu, double mu0, double alphasmu0) {
  double alphasmu = (2*PI/3)/(2*PI/(3*alphasmu0) + log(mu/mu0));
  return alphasmu;
}


// Outputs a space before if greater than zero, a minus otherwise, also outputs spaces after depending on no. of digits in PDG code
// Useful for outputting negative numbers in rows, Tom Cridge added to output PDG codes with no. of space depending on length of PDG (usually 1 or 2 for SM particles whereas 7 for SUSY particles -  therefore output 5 extra spaces for SM)
void printRowPDG(ostream & cout, double x) {

  /// make it return a character when you've worked out the equivalent of printf

  double underflow = 1.0e-120;
  if (fabs(x) < underflow) x = 0.0; /// Traps -0.0
  if (x >= 0.0) cout << " " << x;
  else cout << x;
  if (fabs(x)<10) cout << "      ";
  else if (fabs(x)<100) cout << "     ";
  else {}
}

// GammahH = 2*pow(PI,2)*pow(g*runmf/(mW*cos(beta)))^2*m1*hHintegral;


//  double hHintegral(double m1, double m2, double mf, double mh, double mH, double runmf, double mw, double g, double gp, double alpha, double beta, DoubleMatrix mixNeut, int ineutralino, int fneutralino) {
//    double f=0, Area=0, E=0;
//    double mid=0, end=0;
//    double fmid=0, fend=0;
//    double fromE=0, toE=0, stepE=0;
//    double ghHintegral(double m1, double m2, double mf, double mh, double mH, double E, double alpha, double g, double gp, DoubleMatrix mixNeut, int ineutralino, int fneutralino);
//    fromE =  m2;
//    toE = 1/(2*m1)*(pow(m1,2)=pow(m2,2)-4*pow(mf,2));
//    stepE = (toE-fromE)/101;
//    for(E=fromE; E+stepE<toE; E= E+stepE) {
//      f = ghHintegral(m1, m2, mf, mh, mH, E, alpha, g, gp, mixNeut, ineutralino, fneutralino);
//      end = E + stepE;
//      mid = (E+end)/2;
//      fmid = ghHintegral(m1, m2, mf, mh, mH, mid, alpha, g, gp, mixNeut, ineutralino, fneutralino);
//      fend = ghHintegral(m1, m2, mf, mh, mH, end, alpha, g, gp, mixNeut, ineutralino, fneutralino);
//      Area = Area + (end-E)/6 * (f + 4*fmid + fend);
//      ///cout << "step = " << step << endl;
//    }
//    return Area;
//  }
 
// double ghHintegral(double m1, double m2, double mf, double mh, double mH, double E, double alpha, double g, double gp, DoubleMatrix mixNeut, int ineutralino, int fneutralino) {
//    Bf = pow(1-(4*pow(mf,2))/(pow(m1,2)+pow(m2,2)-2*E*m2),0.5);
//    B = pow(pow(E,2)-pow(m2,2),0.5);
//    C = pow(m1,2) + pow(m2,2) - 2*m1*E - 2*pow(mf,2);
//    D = E +m2;

//   Xijh = -0.5*(mixNeut(ineutralino,3)*-sin(alpha) - mixNeut(ineutralino,4)*cos(alpha))*(-g*mixNeut(fneutralino,2) + gp*mixNeut(fneutralino,1));
//   Xjih = -0.5*(mixNeut(fneutralino,3)*-sin(alpha) - mixNeut(fneutralino,4)*cos(alpha))*(-g*mixNeut(ineutralino,2) + gp*mixNeut(ineutralino,1));	
  
//   XijH = -0.5*(mixNeut(ineutralino,3)*cos(alpha) - mixNeut(ineutralino,4)*sin(alpha))*(-g*mixNeut(fneutralino,2) + gp*mixNeut(fneutralino,1));
//   XjiH = -0.5*(mixNeut(fneutralino,3)*cos(alpha) - mixNeut(fneutralino,4)*sin(alpha))*(-g*mixNeut(ineutralino,2) + gp*mixNeut(ineutralino,1));

//   F = sin(-alpha)*(Xijh+Xjih)/(pow(m1,2)+pow(m2,2)-2*m1*E-pow(mh,2));
//   G = cos(alpha)*(XijH+XjiH)/(pow(m1,2)+pow(m2,2)-2*m1*E-pow(mH,2));

//   ghHintegral = Bf*B*C*D*(F+G);
//   return ghHintegral;
// }


///Code for 1D integral calculator via simpson's algorithm
double compute_area6(double (*funcp)(double, double, double, double, double), double lo, double hi, double Nsteps, int adaptive, double approx, double m1, double m2, double m3, double m4) ///approx is loosely a percentage error maximum(although it cannot be guaranteed we are more accurate than this, just use it as an order of magnitude percentage error to aim for
{
    double area = 0;
    double s = 0;
    double f = 0;
    double smid = 0, send = 0;
    double fmid = 0, fend = 0;
    double grad = 0;
    double normalstep = 0;
    normalstep = (hi-lo)/Nsteps;
    double stepuse = 0;
    stepuse = normalstep;
    //cout << "For this mode                   normalstep = " << normalstep << endl;
    for(s=lo; s+stepuse<hi; s= s+stepuse) {
      f = (*funcp)(m1,m2,m3,m4,s);
      send = s + stepuse;
      smid = (s+send)/2;
      fmid = (*funcp)(m1,m2,m3,m4,smid);
      fend = (*funcp)(m1,m2,m3,m4,send);
      grad = (fend-f)/stepuse;
      //if (s==lo) { cout << "grad = " << grad << " stepuse = " << stepuse << " approx = " << approx << " f = " << f << endl;}
      // cout << "grad*stepuse/f = " << grad*stepuse/f << endl;
      //cout << "new stepuse = approx*f/grad = " << approx*f/grad << endl; 
      //if (approx != 1) { cout << "APPROX NOT 1 FOR FUNCTION " << funcp << endl;}
      if ( f!=f) {
	cout << "f nan problem in 1 to 3 decays" << endl;
	s = hi; ///To exit for loop
      }
      else if (f!=0 && (grad*stepuse/f)>approx && adaptive == 1) ///very approximate error estimation -> error over a step can be expected to be very loosely related to the gradient multiplied by the step width, this is case for linear interpolation, actually Simpson's rule is quadratic interpolation so it's better than this on the whole), then as we want the error across the whole integral to be less than the % value approx we compare grad*step/f with approx, if grad*step/f > approx we reduce step such that grad*step/f=approx then proceed, given therefore this ensures grad*step/f <= approx over the entire region we might expect approximate % error less than approx
	{
	  //cout << "f not 0" << endl;
	stepuse = (approx*f/grad);
	//cout << "changing step at ---- " << "grad = " << grad << " stepuse = " << stepuse << " approx = " << approx << " f = " << f << endl; 
	send = s + stepuse;
	smid = (s+send)/2;
	fmid = (*funcp)(m1,m2,m3,m4,smid);
	fend = (*funcp)(m1,m2,m3,m4,send);
      	}
      // else { cout << "step size fine" << endl;}
      area  = area + (send-s)/6 * (f + 4*fmid + fend);;
    }
    
    return area;
}

double compute_area7(double (*funcp)(double, double, double, double, double, double), double lo, double hi, double Nsteps, int adaptive, double approx, double m1, double m2, double m3, double m4, double m5) {
    double  area = 0;
    double s = 0;
    double f = 0;
    double smid = 0, send = 0;
    double fmid = 0, fend = 0;
    double grad = 0;
    double normalstep = 0;
    normalstep = (hi-lo)/Nsteps;
    double stepuse = 0;
    stepuse = normalstep;
    //cout << "For this mode                   normalstep = " << normalstep << endl;
    for(s=lo; s+stepuse<hi; s= s+stepuse) {
      f = (*funcp)(m1,m2,m3,m4,m5,s);
      send = s + stepuse;
      smid = (s+send)/2;
      fmid = (*funcp)(m1,m2,m3,m4,m5,smid);
      fend = (*funcp)(m1,m2,m3,m4,m5,send);
      grad = (fend-f)/stepuse;
      //if (s==lo) { cout << "grad = " << grad << " stepuse = " << stepuse << " approx = " << approx << " f = " << f << endl;}
      // cout << "grad*stepuse/f = " << grad*stepuse/f << endl;
      //cout << "new stepuse = approx*f/grad = " << approx*f/grad << endl; 
      if ( f!=f) {
	cout << "f nan problem in 1 to 3 decays" << endl;
	s = hi; ///To exit for loop
      }
      else if (f!=0 && (grad*stepuse/f)>approx && adaptive == 1) ///very approximate error estimation -> error over a step can be expected to be very loosely related to the gradient multiplied by the step width, this is case for linear interpolation, actually Simpson's rule is quadratic interpolation so it's better than this on the whole), then as we want the error across the whole integral to be less than the % value approx we compare grad*step/f with approx, if grad*step/f > approx we reduce step such that grad*step/f=approx then proceed, given therefore this ensures grad*step/f <= approx over the entire region we might expect approximate % error less than approx
	{
	  //cout << "f not 0" << endl;
	stepuse = (approx*f/grad);
	//cout << "changing step at ---- " << "grad = " << grad << " stepuse = " << stepuse << " approx = " << approx << " f = " << f << endl; 
	send = s + stepuse;
	smid = (s+send)/2;
	fmid = (*funcp)(m1,m2,m3,m4,m5,smid);
	fend = (*funcp)(m1,m2,m3,m4,m5,send);
      	}
      area  = area + (send-s)/6 * (f + 4*fmid + fend);;
    }
    
    return area;
}

double compute_area8(double (*funcp)(double, double, double, double, double, double, double), double lo, double hi, double Nsteps, int adaptive, double approx, double m1, double m2, double m3, double m4, double m5, double m6) {
    double  area = 0;
    double s = 0;
    double f = 0;
    double smid = 0, send = 0;
    double fmid = 0, fend = 0;
    double grad = 0;
    double normalstep = 0;
    normalstep = (hi-lo)/Nsteps;
    double stepuse = 0;
    stepuse = normalstep;
    //cout << "For this mode                   normalstep = " << normalstep << endl;
    for(s=lo; s+stepuse<hi; s= s+stepuse) {
      f = (*funcp)(m1,m2,m3,m4,m5,m6,s);
      send = s + stepuse;
      smid = (s+send)/2;
      fmid = (*funcp)(m1,m2,m3,m4,m5,m6,smid);
      fend = (*funcp)(m1,m2,m3,m4,m5,m6,send);
      grad = (fend-f)/stepuse;
      //if (s==lo) { cout << "grad = " << grad << " stepuse = " << stepuse << " approx = " << approx << " f = " << f << endl;}
      // cout << "grad*stepuse/f = " << grad*stepuse/f << endl;
      //cout << "new stepuse = approx*f/grad = " << approx*f/grad << endl; 
      if ( f!=f) {
	cout << "f nan problem in 1 to 3 decays" << endl;
	s = hi; ///To exit for loop
      }
      else if (f!=0 && (grad*stepuse/f)>approx && adaptive == 1) ///very approximate error estimation -> error over a step can be expected to be very loosely related to the gradient multiplied by the step width, this is case for linear interpolation, actually Simpson's rule is quadratic interpolation so it's better than this on the whole), then as we want the error across the whole integral to be less than the % value approx we compare grad*step/f with approx, if grad*step/f > approx we reduce step such that grad*step/f=approx then proceed, given therefore this ensures grad*step/f <= approx over the entire region we might expect approximate % error less than approx
	{
	  //cout << "f not 0" << endl;
	stepuse = (approx*f/grad);
	//cout << "changing step at ---- " << "grad = " << grad << " stepuse = " << stepuse << " approx = " << approx << " f = " << f << endl; 
	send = s + stepuse;
	smid = (s+send)/2;
	fmid = (*funcp)(m1,m2,m3,m4,m5,m6,smid);
	fend = (*funcp)(m1,m2,m3,m4,m5,m6,send);
      	}
      area  = area + (send-s)/6 * (f + 4*fmid + fend);;
    }
    
    return area;
}

double compute_area71(double (*funcp)(double, double, double, double, double, double, int), double lo, double hi, double Nsteps, int adaptive, double approx, double m1, double m2, double m3, double m4, double m5, int AorhorH) {
  double area = 0;
  double s = 0;
  double f = 0;
  double smid = 0, send = 0;
  double fmid = 0, fend = 0;
  double grad = 0;
  double normalstep = 0;
  normalstep = (hi-lo)/Nsteps;
  double stepuse = 0;
  stepuse = normalstep;
  //cout << "For this mode                   normalstep = " << normalstep << endl;
  for(s=lo; s+stepuse<hi; s = s + stepuse) {
    f = (*funcp)(m1,m2,m3,m4,m5,s, AorhorH);
    send = s + stepuse;
    smid = (s+send)/2;
    fmid = (*funcp)(m1,m2,m3,m4,m5,smid, AorhorH);
    fend = (*funcp)(m1,m2,m3,m4,m5,send, AorhorH);
    grad = (fend-f)/stepuse;
    //if (s==lo) { cout << "grad = " << grad << " stepuse = " << stepuse << " approx = " << approx << " f = " << f << endl;}
      // cout << "grad*stepuse/f = " << grad*stepuse/f << endl;
      //cout << "new stepuse = approx*f/grad = " << approx*f/grad << endl; 
      if ( f!=f) {
	cout << "f nan problem in 1 to 3 decays" << endl;
	s = hi; ///To exit for loop
      }
      else if (f!=0 && (grad*stepuse/f)>approx && adaptive == 1) ///very approximate error estimation -> error over a step can be expected to be very loosely related to the gradient multiplied by the step width, this is case for linear interpolation, actually Simpson's rule is quadratic interpolation so it's better than this on the whole), then as we want the error across the whole integral to be less than the % value approx we compare grad*step/f with approx, if grad*step/f > approx we reduce step such that grad*step/f=approx then proceed, given therefore this ensures grad*step/f <= approx over the entire region we might expect approximate % error less than approx
	{
	  //cout << "f not 0" << endl;
	stepuse = (approx*f/grad);
	//cout << "changing step at ---- " << "grad = " << grad << " stepuse = " << stepuse << " approx = " << approx << " f = " << f << endl; 
	send = s + stepuse;
	smid = (s+send)/2;
	fmid = (*funcp)(m1,m2,m3,m4,m5,smid, AorhorH);
	fend = (*funcp)(m1,m2,m3,m4,m5,send, AorhorH);
      	}
    area  = area + (send-s)/6 * (f + 4*fmid + fend);;
    }
    
    return area;
}

///Note hHintegral still done as before as can't pass a DoubleMatrix in a function pointer

double Jintegralsum(double m1, double m2, double msf, double mphi, double mf, double min, double max, double Nsteps, int adaptive, double approx, int AorhorH) {
  double (*fp)(double, double, double, double, double, double, int);
  double area = 0;
  fp = gJintegral;
  area = compute_area71(fp, min, max, Nsteps, adaptive, approx, m1, m2, msf, mphi, mf, AorhorH);
  return area;
}


double G4integralsum(double m1, double m2, double m3, double m4, double mt, double mb, double min, double max, double Nsteps, int adaptive, double approx) {
  double (*fp)(double, double, double, double, double, double, double);
  double area = 0;
  fp = gG4;
  area = compute_area8(fp, min, max, Nsteps, adaptive, approx, m1, m2, m3, m4, mt, mb);
  return area;
}

double G5integralsum(double m1, double m2, double m3, double m4, double mt, double mb, double min, double max, double Nsteps, int adaptive, double approx) {
  double (*fp)(double, double, double, double, double, double, double);
  double area = 0;
  fp = gG5;
  area = compute_area8(fp, min, max, Nsteps, adaptive, approx, m1, m2, m3, m4, mt, mb);
  return area;
}

double G6integralsum(double m1, double m2, double m3, double m4, double mt, double mb, double min, double max, double Nsteps, int adaptive, double approx) {
  double (*fp)(double, double, double, double, double, double, double);
  double area = 0;
  fp = gG6;
  area = compute_area8(fp, min, max, Nsteps, adaptive, approx, m1, m2, m3, m4, mt, mb);
  return area;
}

double G7integralsum(double m1, double m2, double m3, double m4, double mt, double mb, double min, double max, double Nsteps, int adaptive, double approx) {
  double (*fp)(double, double, double, double, double, double, double);
  double area = 0;
  fp = gG7;
  area = compute_area8(fp, min, max, Nsteps, adaptive, approx, m1, m2, m3, m4, mt, mb);
  return area;
}

double G8integralsum(double m1, double m2, double m3, double m4, double mt, double mb, double min, double max, double Nsteps, int adaptive, double approx) {
  double (*fp)(double, double, double, double, double, double, double);
  double area = 0;
  fp = gG8;
  area = compute_area8(fp, min, max, Nsteps, adaptive, approx, m1, m2, m3, m4, mt, mb);
  return area;
}


double G1integralsum(double m1, double m2, double m3, double mq, double min, double max, double Nsteps, int adaptive, double approx) {
 double (*fp)(double, double, double, double, double);
 double area = 0;
 fp = gG1;
 area = compute_area6(fp, min, max, Nsteps, adaptive, approx, m1, m2, m3, mq);
 return area;
} 

double Zintegralsum(double m1, double m2, double mz, double mf, double min, double max, double Nsteps, int adaptive, double approx) {
  double (*fp)(double, double, double, double, double);
  double area = 0;
  fp = gZintegral;
  area = compute_area6(fp, min, max, Nsteps, adaptive, approx, m1, m2, mz, mf);
  return area;
}

double Zsfintegralsum(double m1, double m2, double msf, double mf, double mz, double min, double max, double Nsteps, int adaptive, double approx) {
  double  (*fp)(double, double, double, double, double, double);      // Function pointer
  double  area = 0;
  fp = gZsfintegral;
  area = compute_area7(fp, min, max, Nsteps, adaptive, approx, m1, m2, msf, mf, mz);
  return area;
}

double Aintegralsum(double m1, double m2, double mz, double mA, double mf, double min, double max, double Nsteps, int adaptive, double approx) {
  double (*fp)(double, double, double, double, double, double);
  double area = 0;
  fp = gAintegral;
  area = compute_area7(fp, min, max, Nsteps, adaptive, approx, m1, m2, mz, mA, mf);
  return area;
}

double G3integralsum(double m1, double m2, double m3, double mt, double mb, double min, double max, double Nsteps, int adaptive, double approx)  {
  double (*fp)(double, double, double, double, double, double);
  double area = 0;
  fp = gG3;
  area = compute_area7(fp, min, max, Nsteps, adaptive, approx, m1, m2, m3, mt, mb);
  return area;
}

double G2integralsum(double m1, double m2, double m3, double mt, double mb, double min, double max, double Nsteps, int adaptive, double approx) {
  double (*fp) (double, double, double, double, double, double);
  double area = 0;
  fp = gG2;
  area = compute_area7(fp, min, max, Nsteps, adaptive, approx, m1, m2, m3, mt, mb);
  return area;
}

double chiprimeintegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx) {
 double (*fp) (double, double, double, double, double, double);
 double area = 0;
 fp = gchiprime;
 area = compute_area7(fp, min, max, Nsteps, adaptive, approx, m1, m2, m3, m4, mq);
 return area;
}

double Yintegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx) {
  double (*fp) (double, double, double, double, double, double);
  double area = 0;
  fp = gY;
  area = compute_area7(fp, min, max, Nsteps, adaptive, approx, m1, m2, m3, m4, mq);
  return area;
} 

double Xintegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx) {
  double (*fp) (double, double, double, double, double, double);
  double area = 0;
  fp = gX;
  area = compute_area7(fp, min, max, Nsteps, adaptive, approx, m1, m2, m3, m4, mq);
  return area;
}

double zetaintegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx) {
  double (*fp) (double, double, double, double, double, double);
  double area = 0;
  fp = gzeta;
  area = compute_area7(fp, min, max, Nsteps, adaptive, approx, m1, m2, m3, m4, mq);
  return area;
}

double chiintegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx) {
  double (*fp) (double, double, double, double, double, double);
  double area = 0;
  fp = gchi;
  area = compute_area7(fp, min, max, Nsteps, adaptive, approx, m1, m2, m3, m4, mq);
  return area;
}

double rhointegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx) {
  double (*fp) (double, double, double, double, double, double);
  double area = 0;
  fp = grho;
  area = compute_area7(fp, min, max, Nsteps, adaptive, approx, m1, m2, m3, m4, mq);
  return area;
}

double xsiintegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx) {
  double (*fp) (double, double, double, double, double, double);
  double area = 0;
  fp = gxsi;
  area = compute_area7(fp, min, max, Nsteps, adaptive, approx, m1, m2, m3, m4, mq);
  return area;
}

double phitildaintegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx) {
  double (*fp) (double, double, double, double, double, double);
  double area = 0;
  fp = gphitilda;
  area = compute_area7(fp, min, max, Nsteps, approx, adaptive, m1, m2, m3, m4, mq);
  return area;
}

double psitildaintegralsum(double m1, double m2, double m3, double m4, double mq, double min, double max, double Nsteps, int adaptive, double approx) {
  double (*fp) (double, double, double, double, double, double);
  double area = 0;
  fp = gpsitilda;
  area = compute_area7(fp, min, max, Nsteps, approx, adaptive, m1, m2, m3, m4, mq);
  //cout << "USEINDGAUSS" << useInDGauss->displayPhys().mGluino << endl;
  return area;
}





///dgauss integrands for numerical integration of phase space in 1->3 decays

/// Make sure you have set useInDGauss before calling this function
double fdgauss(double x) {
  //cout << "USEINDGAUSS" << useInDGauss->displayPhys().mGluino << endl;
  return x * x;
}

double gpsitildadgauss(double Et) {
  double gpsitildadgauss = 0, pt = 0, squareplus = 0, squareminus = 0, lambda = 0, A = 0;
  ///cout << "m1 = " << m1 << " m2 = " << m2 << " m3 = " << m3 << " m4 = " << m4 << " mq = " << mq << endl;
  A = pow(m1,2)+pow(mq,2)-2*fabs(m1)*Et;
  pt = pow(pow(Et,2)-pow(mq,2),0.5);
  squareplus = A - pow(fabs(m4)+mq,2);
  squareminus = A - pow(fabs(m4)-mq,2);
  if (squareplus <0) ///this can happen erronesouly at very end of range due to finite precision used, squareplus should actually then be very very small and +ve
    { squareplus = 0;} /// set to zero to avoid nan problem in lambda, note that given squareplus very very very small anyway here this should not affect the accuracy of the integral
  lambda = pow(squareplus*squareminus,0.5);
  ///cout << " Et = " << Et << "A = " << A << " lambda = " << lambda << endl;
  gpsitildadgauss = pow(PI,2)*fabs(m1)*pt*Et*lambda/(A)*(pow(m1,2)-pow(m4,2)-2*fabs(m1)*Et)/((A-pow(m2,2))*(A-pow(m3,2)));
  // if (m1 > 726 && fabs(m4) > 705 && m1 < 728) {
  //   cout.precision(7);
  //   cout << "gpsitildadgauss at Et = " << Et << " is: " << gpsitildadgauss << endl;
  //   cout << "squareplus = " << squareplus << " squareminus = " << squareminus << endl;
  //   cout << "lambda = " << lambda << " pt = " << pt << endl;
  //   cout << "mq = " << mq << " pt^2 = " << pow(Et,2)-pow(mq,2) << endl;
  // }
  ///cout << "gpsitildadgauss = " << gpsitildadgauss << endl;
  return gpsitildadgauss;
}


double gphitildadgauss(double Et) {
  double gphitildadgauss = 0, A = 0, Z=0;
  DoubleVector Etbarmaxmin (double m1, double m2, double massq, double Et);
  double Zfunc(double m1, double mq, double m, double Etbarmax, double Etbarmin);
  DoubleVector Etbar(2);
  ///cout << "m1 = " << m1 << " m2 = " << m2 << " m3 = " << m3 << " m4 = " << m4 << " mq = " << mq << endl;
  for (int i=1; i<=2; i++) { Etbar(i) = 0;}
  Etbar = Etbarmaxmin(m1, m4, mq, Et);
  Z = Zfunc(m1, mq, m3, Etbar(1), Etbar(2));
  A = pow(m1,2)+pow(mq,2)-2*fabs(m1)*Et;
  ///cout << " IN GPHITILDADGAUSS: Et = " << Et << " A = " << A << endl;
  ///cout << "Z = " << Z << " Etbarmax = " << Etbar(1) << " Etbarmin = " << Etbar(2) << " A = " << A << endl;
  gphitildadgauss = 0.5*pow(PI,2)*fabs(m1)*fabs(m4)/(A-pow(m2,2))*(-(Etbar(1)-Etbar(2)) - (pow(m4,2)-pow(mq,2)+2*Et*fabs(m1)-pow(m3,2))/(2*fabs(m1))*log(Z));
  return gphitildadgauss;
}


double gxsidgauss (double Et)
{
  double gxsidgauss = 0, Z=0, A=0;
  double Zfunc(double m1, double mq, double m, double Etbarmax, double Etbarmin);
  DoubleVector Etbarmaxmin (double m1, double m2, double massq, double Et);
  DoubleVector Etbar(2);
  //cout << "m1 = " << m1 << " m2 = " << m2 << " m3 = " << m3 << " m4 = " << m4 << " mq = " << mq << endl;
  for (int i=1; i<=2; i++) { Etbar(i) = 0;}
  Etbar = Etbarmaxmin(m1, m4, mq, Et);
  Z = Zfunc(m1,mq,m3,Etbar(1),Etbar(2));
  A = pow(m1,2)+pow(mq,2)-2*fabs(m1)*Et;
  //cout << "Z = " << Z << " Etbarmax = " << Etbar(1) << " Etbarmin = " << Etbar(2) << " A = " << A << " log(Z) = " << log(Z) << endl;
  gxsidgauss = 0.5*pow(PI,2)/(A-pow(m2,2))*((Etbar(1)-Etbar(2))-(pow(m1,2)-pow(mq,2)-2*fabs(m1)*Et+pow(m3,2))/(2*m1)*log(Z));
  //cout << "A-pow(m2,2) = " << (A-pow(m2,2)) << " (Etbar(1)-Etbar(2)) = " << (Etbar(1)-Etbar(2)) << endl;
  return gxsidgauss;
}


double grhodgauss (double Et)
{
  double grhodgauss = 0, Z=0;
  double Zfunc(double m1, double mq, double m, double Etbarmax, double Etbarmin);
  DoubleVector Etbar(2);
  //cout << "m1 = " << m1 << " m2 = " << m2 << " m3 = " << m3 << " m4 = " << m4 << " mq = " << mq << endl;
  for (int i=1; i<=2; i++) { Etbar(i) = 0;}
  DoubleVector Etbarmaxmin (double m1, double m2, double massq, double Et);
  Etbar = Etbarmaxmin(m1, m4, mq, Et);
  Z = Zfunc(m1,mq,m3,Etbar(1),Etbar(2));
  //cout << "Z = " << Z << " Etbarmax = " << Etbar(1) << " Etbarmin = " << Etbar(2) << " log(Z) = " << log(Z) << endl;
  grhodgauss = -pow(PI,2)/(2*fabs(m1))*1/(pow(m1,2)+pow(mq,2)-2*fabs(m1)*Et-pow(m2,2))*log(Z);
  return grhodgauss;
}


double gchidgauss (double Et)
{
  double gchidgauss = 0, pt=0, A=0, squareplus=0, squareminus=0, lambda=0;
  A = pow(m1,2)+pow(mq,2)-2*fabs(m1)*Et;
  squareplus = A - pow((m4 + mq),2);
  squareminus = A - pow((m4 - mq),2);
  if (squareplus < 0 && fabs(squareplus) < 1e-10) {
    squareplus = 0; ///avoid numerical error giving a negative and hence a nan for lambda at upper boundary of integration range
  }
  lambda = pow(squareplus*squareminus,0.5);
  if (lambda != lambda) {
    cout << "nan in lambda in gchidgauss" <<endl;
    cout << "Et = " << Et << " squareplus = " << squareplus << " squareminus = " << squareminus << endl;
  }
  pt = pow(pow(Et,2) - pow(mq,2),0.5);
  if (pt != pt) { cout << "nan in pt in gchidgauss" <<endl;}
  gchidgauss = pow(PI,2)*fabs(m1)*pt*Et*lambda/A*1/((pow(m1,2)+pow(mq,2)-2*fabs(m1)*Et-pow(m2,2))*(pow(m1,2)+pow(mq,2)-2*fabs(m1)*Et-pow(m3,2)));
  return gchidgauss;
}


double gzetadgauss (double Et)
{
  double gzetadgauss = 0, A=0;
  DoubleVector Etbar(2);
  for (int i=1; i<=2; i++) { Etbar(i) = 0;}
  DoubleVector Etbarmaxmin (double m1, double m2, double massq, double Et);
  Etbar = Etbarmaxmin(m1, m4, mq, Et);
  A = pow(m1,2)+pow(mq,2)-2*fabs(m1)*Et;
  gzetadgauss = pow(PI,2)*(Etbar(1)-Etbar(2))/((A-pow(m2,2))*(A-pow(m3,2)));
  return gzetadgauss;
}


double gXdgauss (double Et)
{
  double gXdgauss = 0, pt=0, A=0, B=0, squareplus=0, squareminus=0, lambda=0;
  A = pow(m1,2)+pow(mq,2)-2*fabs(m1)*Et;
  B = pow(m1,2)-pow(m4,2)-2*fabs(m1)*Et;
  pt = pow(pow(Et,2) - pow(mq,2),0.5);
  squareplus = A - pow((m4 + mq),2);
  squareminus = A - pow((m4 - mq),2);
  if (squareplus < 0 && fabs(squareplus) < 1e-10) {
    squareplus = 0; ///avoid numerical error giving a negative and hence a nan for lambda at upper boundary of integration range
  }
  lambda = pow(squareplus*squareminus,0.5);
  gXdgauss = 0.5*pow(PI,2)*pt*B/A*lambda*1/((pow(m1,2)+pow(mq,2)-2*fabs(m1)*Et-pow(m2,2))*(pow(m1,2)+pow(mq,2)-2*fabs(m1)*Et-pow(m3,2)));
  return gXdgauss;
}


double gYdgauss (double Et)
{
  double gYdgauss = 0, A=0, Z=0;
  double Zfunc(double m1, double mq, double m, double Etbarmax, double Etbarmin);
  DoubleVector Etbar(2);
  for (int i=1; i<=2; i++) { Etbar(i) = 0;}
  DoubleVector Etbarmaxmin(double m1, double m2, double massq, double Et);
  Etbar = Etbarmaxmin(m1, m4, mq, Et);
  Z = Zfunc(m1,mq,m3,Etbar(1),Etbar(2));
  A = pow(m1,2)+pow(mq,2)-2*fabs(m1)*Et;
  gYdgauss = 0.5*pow(PI,2)*1/(A-pow(m2,2))*((Etbar(1)-Etbar(2))*A + 1/(2*fabs(m1))*(pow(m1,2)*pow(m4,2)-pow(m1,2)*pow(m3,2)+pow(mq,4)+2*fabs(m1)*Et*pow(m3,2)-pow(m3,2)*pow(mq,2))*log(Z));
  return gYdgauss;
}


double gchiprimedgauss (double Et)
{
  double gchiprimedgauss = 0, A=0, Z=0;
  DoubleVector Etbar(2);
  for (int i=1; i<=2; i++) { Etbar(i) = 0;}
  DoubleVector Etbarmaxmin(double m1, double m2, double massq, double Et);
  Etbar = Etbarmaxmin(m1, m4, mq, Et);
  double Zfunc(double m1, double mq, double m, double Etbarmax, double Etbarmin);
  Z = Zfunc(m1,mq,m2,Etbar(1),Etbar(2));
  A = pow(m1,2)+pow(mq,2)-2*fabs(m1)*Et;
  gchiprimedgauss = -0.5*pow(PI,2)*Et/(A-pow(m3,2))*log(Z);
  ///cout << "Etbarmax = " << Etbar(1) << " Etbarmin = " << Etbar(2) << " Z = " << Z << endl;
  return gchiprimedgauss;
}



double gG1dgauss(double Et) ///m1 = mgluino, m2 = mstopi, m6 = mtop, m8 = mcharginoj
{
  double gG1dgauss = 0, A=0, pt=0;
  pt = pow(pow(Et,2)-pow(m6,2),0.5);
  A = pow(m1,2)+pow(m6,2)-2*fabs(m1)*Et;
  ///cout << "m1 = " << m1 << " m2 = " << m2 << " m6 = " << m6 << " m8 = " << m8 << endl;
  gG1dgauss = fabs(m1)*pt*Et*pow((A-pow(m8,2)),2)/(pow(A-pow(m2,2),2)*A);
  return gG1dgauss;
}


double gG4dgauss(double Et) ///m1 = mgluino, m2 = mstopi, m4 = msbottomi, m6 = mtop, m7 = mbottom , m8 = mcharginoj
{
  double gG4dgauss = 0, A=0, X=0, Ebbarmax=0, Ebbarmin=0;
  DoubleVector Ebbarmaxmin (double mass1, double mass2, double mass3, double mass4, double Et);
  double Xfunc (double mass1, double mass2, double mass3, double mass4, double mass5, double Et);
  Ebbarmax = Ebbarmaxmin (m1, m6, m7, m8, Et)(1);
  Ebbarmin = Ebbarmaxmin (m1, m6, m7, m8, Et)(2);
  X = Xfunc(m1, m6, m7, m8, m4, Et);
  // cout << "X in gG4dgauss = " << X << " Ebbarmax = " << Ebbarmax << " Ebbarmin = " << Ebbarmin << endl;
  A = pow(m1,2)+pow(m6,2)-2*fabs(m1)*Et;
  /// cout << "X = " << X << endl;
  /// cout << "((Ebbarmax-Ebbarmin) - (pow(m4,2)+pow(m6,2)-2*Et*m1-pow(m8,2))/(2*m1)*log(X))= " << ((Ebbarmaxmin(m1, m6, m7, m8, 200)(1)-Ebbarmaxmin(m1, m6, m7, m8, 200)(2)) - (pow(m4,2)+pow(m6,2)-2*200*m1-pow(m8,2))/(2*m1)*log(Xfunc(m1,m6,m7,m8,m4,200))) << endl;
  /// cout << "fabs(m1)*fabs(m8)*1/(A-pow(m2,2))= " << fabs(m1)*fabs(m8)*1/(pow(m1,2)+pow(m6,2)-2*m1*200-pow(m2,2)) << endl;
  /// cout << "Ebbarmax at Et = 200: " << Ebbarmaxmin(m1, m6, m7, m8, 200)(1) << " Ebbarmin at Et = 200: " << Ebbarmaxmin(m1, m6, m7, m8, 200)(2) << endl;
  /// cout << "Log(X) coefficient: " << (pow(m4,2)+pow(m6,2)-2*200*m1-pow(m8,2))/(2*m1) << " Log(X)= " << log(X) << endl;
  gG4dgauss = (fabs(m1))*(m8)*1/(A-pow(m2,2))*((Ebbarmax-Ebbarmin) - (pow(m4,2)+pow(m6,2)-2*Et*fabs(m1)-pow(m8,2))/(2*fabs(m1))*log(X));
  return gG4dgauss;
}


double gG5dgauss(double Et) ///m1 = mgluino, m2 = mstopi, m4 = msbottomi, m6 = mtop, m7 = mbottom , m8 = mcharginoj
{
  double gG5dgauss = 0, A=0, X=0;
  DoubleVector Ebbarmaxmin (double mass1, double mass2, double mass3, double mass4, double Et);
  double Xfunc (double mass1, double mass2, double mass3, double mass4, double mass5, double Et);
  X = Xfunc(m1, m6, m7, m8, m4, Et);
  A = pow(m1,2)+pow(m6,2)-2*fabs(m1)*Et;
  gG5dgauss = (fabs(m1)/m1)*m6/2*(A-pow(m8,2))/(A-pow(m2,2))*log(X);
  return gG5dgauss;
}


double gG6dgauss(double Et) ///m1 = mgluino, m2 = mstopi, m4 = msbottomi, m6 = mtop, m7 = mbottom , m8 = mcharginoj
{
  double gG6dgauss = 0, A=0, X=0, Ebbarmax=0, Ebbarmin=0;
  DoubleVector Ebbarmaxmin (double mass1, double mass2, double mass3, double mass4, double Et);
  double Xfunc (double mass1, double mass2, double mass3, double mass4, double mass5, double Et);
  Ebbarmax = Ebbarmaxmin (m1, m6, m7, m8, Et)(1);
  Ebbarmin = Ebbarmaxmin (m1, m6, m7, m8, Et)(2);
  X = Xfunc(m1, m6, m7, m8, m4, Et);
  A = pow(m1,2)+pow(m6,2)-2*fabs(m1)*Et;
  gG6dgauss = 0.5/(A-pow(m2,2))*((fabs(m1)*(A-pow(m8,2))-(pow(m4,2)-pow(m1,2))/fabs(m1)*-A)*log(X) + 2*(-A)*(Ebbarmax-Ebbarmin));
  return gG6dgauss;
}


double gG7dgauss(double Et)
{
  double gG7dgauss = 0, A=0, X=0, Ebbarmax=0, Ebbarmin=0;
  DoubleVector Ebbarmaxmin (double mass1, double mass2, double mass3, double mass4, double Et);
  double Xfunc (double mass1, double mass2, double mass3, double mass4, double mass5, double Et);
  Ebbarmax = Ebbarmaxmin (m1, m6, m7, m8, Et)(1);
  Ebbarmin = Ebbarmaxmin (m1, m6, m7, m8, Et)(2);
  X = Xfunc(m1, m6, m7, m8, m4, Et);
  A = pow(m1,2)+pow(m6,2)-2*fabs(m1)*Et;
  gG7dgauss = 0.5*(m8)*m6*1/(A-pow(m2,2))*(2*(Ebbarmax-Ebbarmin)-(pow(m4,2)-pow(m1,2))/fabs(m1)*log(X));
  return gG7dgauss;
}


double gG8dgauss(double Et)
{
  double gG8dgauss = 0, A=0, Ebbarmax=0, Ebbarmin=0;
  DoubleVector Ebbarmaxmin (double mass1, double mass2, double mass3, double mass4, double Et);
  Ebbarmax = Ebbarmaxmin (m1, m6, m7, m8, Et)(1);
  Ebbarmin = Ebbarmaxmin (m1, m6, m7, m8, Et)(2);
  A = pow(m1,2)+pow(m6,2)-2*fabs(m1)*Et;
  gG8dgauss = (fabs(m1))*m6*(A-pow(m8,2))*(Ebbarmax-Ebbarmin)/((A-pow(m2,2))*(A-pow(m3,2)));
  return gG8dgauss;
}


double gG2dgauss(double Ebbar)
{ 
  double gG2dgauss = 0, A=0, squareplus=0, squareminus=0, lambda=0;
  A = pow(m1,2)+pow(m7,2)-2*fabs(m1)*Ebbar;
  squareplus = A - pow((m8)+m6,2);
  squareminus = A - pow((m8)-m6,2);
  lambda = pow(squareplus*squareminus,0.5);
  // cout << "squareminus = " << squareminus << endl;
  // if (lambda != lambda) {
  //   cout << "gG2dgauss: " << endl;
  //   cout << "m1 = " << m1 << " m2 = " << m2 << " m3 = " << m3 << " m4 = " << m4 << endl;
  //   cout << "m5 = " << m5 << " m6 = " << m6 << " m7 = " << m7 << " m8 = " << m8 << endl;
  //   cout << "At Ebbar = " << Ebbar << " lambda = " << lambda << endl;
  //   cout << "squareplus = " << squareplus << " squareminus = " << squareminus << endl;
  // }
  gG2dgauss = fabs(m1)*pow(Ebbar,2)*lambda*(A-pow(m6,2)-pow(m8,2))/(pow(A-pow(m4,2),2)*A);
  return gG2dgauss;
}


double gG3dgauss(double Ebbar)
{
  double gG3dgauss = 0, A=0, squareplus=0, squareminus=0, lambda=0;
  A = pow(m1,2)+pow(m7,2)-2*fabs(m1)*Ebbar;
  squareplus = A - pow((m8)+m6,2);
  squareminus = A - pow((m8)-m6,2);
  lambda = pow(squareplus*squareminus,0.5);
  // if (lambda != lambda) {
  //   cout << "gG3dgauss: " << endl;
  //   cout << "m1 = " << m1 << " m2 = " << m2 << " m3 = " << m3 << " m4 = " << m4 << endl;
  //   cout << "m5 = " << m5 << " m6 = " << m6 << " m7 = " << m7 << " m8 = " << m8 << endl;
  //   cout << "At Ebbar = " << Ebbar << " lambda = " << lambda << endl;  
  //   cout << "squareplus = " << squareplus << " squareminus = " << squareminus << endl;
  // }
  gG3dgauss = pow(Ebbar,2)*lambda*4*fabs(m1)*fabs(m8)*fabs(m6)/(pow(A-pow(m4,2),2)*A);
  return gG3dgauss;
}


double gZdgauss(double E) ///m1 = mZi, m4 = mZj, m2 = mstop1, m3 = mstop2, mq = mt, MZboson = mz
{
  double gZdgauss = 0, Bf=0, D=0, F=0, G=0, H=0;
  ///Bf = pow(1-4*pow(mf,2)/(pow(m1,2)+pow(m2,2)-2*E*m2),0.5);
  Bf = pow(1-4*pow(mq,2)/(pow(m1,2)+pow(m4,2)-2*E*fabs(m1)),0.5);
  D = pow(m1,2)+pow(m4,2)-pow(MZboson,2)-2*E*fabs(m1);
  F = pow(m1,2)+pow(m4,2)-2*fabs(m1)*fabs(m4);
  G = pow(E,2)+pow(m4,2) + Bf/3*(pow(E,2)-pow(m4,2));
  H = fabs(m4)*(fabs(m1)/m1)*(pow(m1,2)+pow(m4,2)-2*pow(mq,2));
  gZdgauss = Bf*pow(pow(E,2)-pow(m4,2),0.5)/(pow(D,2))*(E*F-fabs(m1)*G+H);
  // cout << "gZdgauss at E = " << E << " is: " << gZdgauss << endl;
  // cout << "Bf = " << Bf << endl;
  // cout << "D = "<< D << endl;
  // cout << "F = "<< F << endl;
  // cout << "G = "<< G << endl;
  // cout << "H = "<< H << endl;
  // cout << "E^2 - m4^2 = " << pow(E,2) - pow(m4,2) << endl;
  // cout << "Bf = " <<  pow(1-4*pow(mq,2)/(pow(m1,2)+pow(m4,2)-2*150*m1),0.5) << " D = " << pow(m1,2)+pow(m4,2)-pow(MZboson,2)-2*150*m1 << " F = " << F << " G = " <<  pow(150,2)+pow(m4,2) + pow(1-4*pow(mq,2)/(pow(m1,2)+pow(m4,2)-2*150*m1),0.5)/3*(pow(150,2)-pow(m4,2)) << " H = " << H << endl;
  return gZdgauss;
}


double ghHdgauss (double E) ///m1 = mZi, m4 = mZj, m2 = mstop1, m3 = mstop2, mq = mt, MZboson = mz
{
   double ghHdgauss = 0, Bf=0, D=0, F=0, G=0, Xijh=0, XijH=0, Xjih=0, XjiH=0, H=0;
   Bf = pow(1-4*pow(mq,2)/(pow(m1,2)+pow(m4,2)-2*E*m1),0.5);
   D = pow(m1,2)+pow(m4,2)-2*E*m1-2*pow(mq,2);
   F = pow(m1,2)+pow(m4,2)-2*m1*E-pow(mh,2);
   G = pow(m1,2)+pow(m4,2)-2*m1*E-pow(mH,2);
   H = pow(E,2) - pow(m4,2);
   
   Xjih = -0.5*(fabs(m1)/m1)*(fabs(m4)/m4)*(NeutMIX(neutralinoj,3)*-sin(alphamix)-NeutMIX(neutralinoj,4)*cos(alphamix))*(g1*-NeutMIX(neutralinoi,2)-g2*-NeutMIX(neutralinoi,1));
   XjiH = -0.5*(fabs(m1)/m1)*(fabs(m4)/m4)*(NeutMIX(neutralinoj,3)*cos(alphamix)-NeutMIX(neutralinoj,4)*sin(alphamix))*(g1*-NeutMIX(neutralinoi,2)-g2*-NeutMIX(neutralinoi,1));
   Xijh = -0.5*(fabs(m1)/m1)*(fabs(m4)/m4)*(NeutMIX(neutralinoi,3)*-sin(alphamix)-NeutMIX(neutralinoi,4)*cos(alphamix))*(g1*-NeutMIX(neutralinoj,2)-g2*-NeutMIX(neutralinoj,1));
   XijH = -0.5*(fabs(m1)/m1)*(fabs(m4)/m4)*(NeutMIX(neutralinoi,3)*cos(alphamix)-NeutMIX(neutralinoi,4)*sin(alphamix))*(g1*-NeutMIX(neutralinoj,2)-g2*-NeutMIX(neutralinoj,1));
   ghHdgauss = fabs(m1)*Bf*pow(H,0.5)*D*(E+fabs(m4)*(fabs(m1)/m1))*pow(((-sin(alphamix)*(Xjih+Xijh))/F + cos(alphamix)*(XjiH+XijH)/G),2);

   // cout << "m1 = " << m1 << " m4 = " << m4 << endl;
   // cout << "mh = " << mh << " mH = " << mH << endl;
   //cout << "alpha = " << alphamix << " beta = " << betavac << endl;
   // cout << "NeutMIX(1,1) = " << NeutMIX(1,1) << " NeutMIX(1,2) = " << NeutMIX(1,2) << " NeutMIX(1,3) = " << NeutMIX(1,3) << " NeutMIX(1,4) = " << NeutMIX(1,4) << " NeutMIX(4,1) = " << NeutMIX(4,1) << " NeutMIX(4,2) = " << NeutMIX(4,2) << " NeutMIX(4,3) = " << NeutMIX(4,3) << " NeutMIX(4,4) " << NeutMIX(4,4) << endl;
   // cout << "Xijh = " << Xijh << " Xjih = " << Xjih << " XijH = " << XijH << " XjiH = " << XjiH << endl;
   // cout << "Bf = " << pow(1-4*pow(mq,2)/(pow(m1,2)+pow(m4,2)-2*110*m1),0.5) << " D = " << pow(m1,2)+pow(m4,2)-2*110*m1-2*pow(mq,2) << " F = " << pow(m1,2)+pow(m4,2)-2*m1*110-pow(mh,2) << " G = " << pow(m1,2)+pow(m4,2)-2*m1*110-pow(mH,2) << " H = " << pow(110,2) - pow(m4,2) << endl;
   // cout << "(-sin(alphamix)*(Xjih+Xijh))/F + cos(alphamix)*(XjiH+XijH)/G  = " << (-sin(alphamix)*(Xjih+Xijh))/F + cos(alphamix)*(XjiH+XijH)/G << endl;  
   
   return ghHdgauss;
}


double gAdgauss(double E) ///m1 = mZi, m4 = mZj, m2 = mstop1, m3 = mstop2, mq = mt
{
  double gAdgauss = 0, Bf=0, D=0, F=0;
  Bf = pow(1-4*pow(mq,2)/(pow(m1,2)+pow(m4,2)-2*E*m1),0.5);
  D = pow(m1,2)+pow(m4,2)-2*E*m1-2*pow(mq,2);
  F = pow(m1,2)+pow(m4,2)-2*m1*E-pow(mA,2);
  gAdgauss = fabs(m1)*Bf*pow(pow(E,2)-pow(m4,2),0.5)*D*(E-fabs(m4)*(fabs(m1)/m1))/pow(F,2);
  return gAdgauss;
}


double gZsfdgauss(double s) ///m2 = msfi where i is the sfermion contribution interference with Z you are considering
{
  double gZsfintegral = 0, EQ=0, Q=0, Qprime=0, musquared=0, B=0, C=0, D=0, F=0, G=0, H=0;
  EQ = (s + pow(m1,2)-pow(m4,2))/(2*m1);
  //if (fabs(pow(EQ,2) - s)<1e-12) {s = pow(EQ,2);}
  Q = pow(pow(EQ,2)-s,0.5);
  Qprime = Q*pow(1-4*pow(mq,2)/s,0.5);
  musquared = s + pow(m2,2) - pow(m4,2)- pow(mq,2);
  B = m1*EQ+pow(m2,2)-pow(m1,2)-s-pow(mq,2);
  C = pow(m2,2)-pow(m4,2)-pow(mq,2);
  D = pow(m2,2)-pow(m1,2)-pow(mq,2);
  F = fabs(m1)*fabs(m4)*(s-2*pow(mq,2));
  G = m1*(EQ+Qprime)-musquared;
  H = m1*(EQ-Qprime)-musquared;
  gZsfintegral = pow(PI,2)/2*1/fabs(m1)*1/(s-pow(MZboson,2))*(-0.5*Qprime*B-1/(4*m1)*(C*D + F)*log(G/H));
  ///cout << "EQ = " << (1000 + pow(m1,2)-pow(m4,2))/(2*m1) << " Q = " << pow(pow((1000 + pow(m1,2)-pow(m4,2))/(2*m1),2)-1000,0.5) << " Qprime = " << pow(pow((1000 + pow(m1,2)-pow(m4,2))/(2*m1),2)-1000,0.5)*pow(1-4*pow(mq,2)/1000,0.5) << " musquared = " << 1000 + pow(m2,2) - pow(m4,2)- pow(mq,2) << endl;
  ///cout << " s = " << s <<  " EQ^2 - s = " << pow(EQ,2) - s << endl;
  /// cout << "B = " << m1*EQ+pow(m2,2)-pow(m1,2)-1000-pow(mq,2) << " C= " << C << " D = " << D << " F = " <<  fabs(m1)*fabs(m4)*(1000-2*pow(mq,2)) << " G = " << m1*((1000 + pow(m1,2)-pow(m4,2))/(2*m1)+pow(pow((1000 + pow(m1,2)-pow(m4,2))/(2*m1),2)-1000,0.5)*pow(1-4*pow(mq,2)/1000,0.5))-1000 + pow(m2,2) - pow(m4,2)- pow(mq,2) << " H = " << m1*((1000 + pow(m1,2)-pow(m4,2))/(2*m1)-pow(pow((1000 + pow(m1,2)-pow(m4,2))/(2*m1),2)-1000,0.5)*pow(1-4*pow(mq,2)/1000,0.5))-1000 + pow(m2,2) - pow(m4,2)- pow(mq,2) <<endl;
  // cout << "m1 = "<< m1 << " m2 = " << m2 << " m4 = " << m4 << " mq = " << mq << " mz = " << MZboson << endl;
  ///cout << "s = " << s << " froms = " << 4*pow(mf,2) << " tos = " << pow((m1-m2),2) << endl;
  ///cout << "EQ = " << EQ << " Q = " << Q << " Qprime = " << Qprime << endl;
  ///cout << "G = " << G << " H = " << H << " log(G/H) = " << log(G/H) << endl;
  return gZsfintegral;
}


double gJdgauss (double s)
{
  double gJdgauss = 0, EQ=0, Q=0, Qprime=0, musquared=0, B=0, G=0, H=0;
  EQ = (s + pow(m1,2)-pow(m4,2))/(2*m1);
  Q = pow(pow(EQ,2)-s,0.5);
  Qprime = Q*pow(1-4*pow(mq,2)/s,0.5);
  musquared = s + pow(m2,2) - pow(m4,2)- pow(mq,2);
  B = s*pow(m2,2)-pow(mq,2)*(pow(m1,2)+pow(m4,2))+pow(-1,AorhorH)*fabs(m1)*fabs(m4)*(s-2*pow(mq,2));
  G = m1*(EQ+Qprime)-musquared;
  H = m1*(EQ-Qprime)-musquared;
  gJdgauss = 1/(s-pow(mphi,2))*(0.5*s*Qprime + B/(4*m1)*log(G/H));
  ///cout << "B = " << B << " G/H = " << G/H << endl;
  ///cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  ///cout << "G = " << G << " H = " << H << endl;
  return gJdgauss;
}	



double gneutineutjffZ1dgauss(double s) ///m1 = mneuti, m4 = mneutj, mq = mf, MZboson = mZboson
{
  double Z1dgauss = 0, lambda1 = 0, lambda2 = 0, squareplus1 = 0, squareminus1 = 0;
  squareplus1 = s - pow(fabs(m1)+fabs(m4),2);
  if (squareplus1 != squareplus1) 
    {
      cout << "s = " << s << " squareplus1 = " << squareplus1 << endl;
    }
  squareminus1 = s - pow(fabs(m1)-fabs(m4),2);
  lambda1 = pow(squareplus1*squareminus1,0.5);
  lambda2 = pow(s*(s-4*pow(mq,2)),0.5);    
  Z1dgauss = 1/(3*pow(s,2)*pow(s-pow(MZboson,2),2))*(-2*pow(s,4) + (pow(m1,2) + pow(m4,2) + 2*pow(mq,2))*pow(s,3) + (pow(pow(m1,2)-pow(m4,2),2) - 2*(pow(m1,2)+pow(m4,2))*2*pow(mq,2))*pow(s,2) + 2*pow(mq,2)*pow(pow(m1,2)-pow(m4,2),2)*s)*1/s*lambda1*lambda2;
  return Z1dgauss;
}

double gneutineutjffZ2dgauss(double s)
{
  double Z2dgauss = 0, lambda1 = 0, lambda2 = 0, squareplus1 = 0, squareminus1 = 0;
  squareplus1 = s - pow(fabs(m1)+fabs(m4),2);
  squareminus1 = s - pow(fabs(m1)-fabs(m4),2);
  lambda1 = pow(squareplus1*squareminus1,0.5);
  lambda2 = pow(s*(s-4*pow(mq,2)),0.5);    
  Z2dgauss = 1/(s*pow(s-pow(MZboson,2),2))*lambda1*lambda2*(s-2*pow(mq,2));
  return Z2dgauss;
}

double gneutineutjffZ3dgauss(double s)
{
  double Z3dgauss = 0, lambda1 = 0, lambda2 = 0, squareplus1 = 0, squareminus1 = 0;
  squareplus1 = s - pow(fabs(m1)+fabs(m4),2);
  squareminus1 = s - pow(fabs(m1)-fabs(m4),2);
  lambda1 = pow(squareplus1*squareminus1,0.5);
  lambda2 = pow(s*(s-4*pow(mq,2)),0.5);    
  Z3dgauss = 1/(s*pow(s-pow(MZboson,2),2))*lambda1*lambda2*(-s+pow(m1,2)+pow(m4,2));
  return Z3dgauss;
}

double gneutineutjffZ4dgauss(double s)
{
  double Z4dgauss = 0, lambda1 = 0, lambda2 = 0, squareplus1 = 0, squareminus1 = 0;
  squareplus1 = s - pow(fabs(m1)+fabs(m4),2);
  squareminus1 = s - pow(fabs(m1)-fabs(m4),2);
  lambda1 = pow(squareplus1*squareminus1,0.5);
  lambda2 = pow(s*(s-4*pow(mq,2)),0.5);    
  Z4dgauss = 1/(s*pow(s-pow(MZboson,2),2))*lambda1*lambda2;
  return Z4dgauss;
}


double gintegralhdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mh = mhiggsl
{
  double gintegralhdgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*m1*E;

  gintegralhdgauss = (pow(pow(E,2)-pow(m4,2),0.5)*pow(s-4*pow(mq,2),0.5))/(pow(s,0.5)*pow(s-pow(mh,2),2))*(E-fabs(m4))*(s-4*pow(mq,2));

  return gintegralhdgauss;
}

double gintegralHdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mH = mhiggsH
{
  double gintegralHdgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*m1*E;
  
   
  gintegralHdgauss = (pow(pow(E,2)-pow(m4,2),0.5)*pow(s-4*pow(mq,2),0.5))/(pow(s,0.5)*pow(s-pow(mH,2),2))*(E-fabs(m4))*(s-4*pow(mq,2));
   
  return gintegralHdgauss;
}


double gintegralh1dgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mh = mhiggsl
{
  double gintegralh1dgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gintegralh1dgauss = 2*fabs(m1)*pow(s-4*pow(mq,2),0.5)*pow(pow(E,2)-pow(m4,2),0.5)*2*fabs(m1)/(pow(s,0.5)*pow(s-pow(mh,2),2));
   
  return gintegralh1dgauss;
}

double gintegralh2dgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mh = mhiggsl
{
  double gintegralh2dgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
   
  gintegralh2dgauss = 2*fabs(m1)*pow(s-4*pow(mq,2),0.5)*pow(pow(E,2)-pow(m4,2),0.5)*2*fabs(m1)*(s-2*pow(mq,2))/(pow(s,0.5)*pow(s-pow(mh,2),2));

  return gintegralh2dgauss;
}


double gintegralh3dgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mh = mhiggsl
{
  double gintegralh3dgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
   
  gintegralh3dgauss = 2*fabs(m1)*pow(s-4*pow(mq,2),0.5)*pow(pow(E,2)-pow(m4,2),0.5)*2*fabs(m1)*2*fabs(m1)*E/(pow(s,0.5)*pow(s-pow(mh,2),2));

   
   return gintegralh3dgauss;
}


double gintegralh4dgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mh = mhiggsl
{
  double gintegralh4dgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;

  gintegralh4dgauss = 2*fabs(m1)*pow(s-4*pow(mq,2),0.5)*pow(pow(E,2)-pow(m4,2),0.5)*2*fabs(m1)*2*fabs(m1)*E*(s-2*pow(mq,2))/(pow(s,0.5)*pow(s-pow(mh,2),2));

   
   return gintegralh4dgauss;
}

double gintegralH1dgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mH = mhiggsH
{
  double gintegralH1dgauss = 0, s=0;
  
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
 
  gintegralH1dgauss = 2*fabs(m1)*pow(s-4*pow(mq,2),0.5)*pow(pow(E,2)-pow(m4,2),0.5)*2*fabs(m1)/(pow(s,0.5)*pow(s-pow(mH,2),2));
   
   return gintegralH1dgauss;
}

double gintegralH2dgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mH = mhiggsH
{
  double gintegralH2dgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gintegralH2dgauss = 2*fabs(m1)*pow(s-4*pow(mq,2),0.5)*pow(pow(E,2)-pow(m4,2),0.5)*2*fabs(m1)*(s-2*pow(mq,2))/(pow(s,0.5)*pow(s-pow(mH,2),2));

  return gintegralH2dgauss;
}


double gintegralH3dgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mH = mhiggsH
{
  double gintegralH3dgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gintegralH3dgauss = 2*fabs(m1)*pow(s-4*pow(mq,2),0.5)*pow(pow(E,2)-pow(m4,2),0.5)*2*fabs(m1)*2*fabs(m1)*E/(pow(s,0.5)*pow(s-pow(mH,2),2));

   return gintegralH3dgauss;
}


double gintegralH4dgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mh = mhiggsl
{
  double gintegralH4dgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
   
  gintegralH4dgauss = 2*fabs(m1)*pow(s-4*pow(mq,2),0.5)*pow(pow(E,2)-pow(m4,2),0.5)*2*fabs(m1)*2*fabs(m1)*E*(s-2*pow(mq,2))/(pow(s,0.5)*pow(s-pow(mH,2),2));

   
   return gintegralH4dgauss;
}


double gintegralhH1dgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mh = mhiggsl, mH = mhiggsH
{
  double gintegralhH1dgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gintegralhH1dgauss = 2*fabs(m1)*pow(s-4*pow(mq,2),0.5)*pow(pow(E,2)-pow(m4,2),0.5)*2*fabs(m1)/(pow(s,0.5)*(s-pow(mh,2))*(s-pow(mH,2)));

   
   return gintegralhH1dgauss;
}

double gintegralhH2dgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mh = mhiggsl, mH = mhiggsH
{
  double gintegralhH2dgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gintegralhH2dgauss = 2*fabs(m1)*pow(s-4*pow(mq,2),0.5)*pow(pow(E,2)-pow(m4,2),0.5)*2*fabs(m1)*(s-2*pow(mq,2))/(pow(s,0.5)*(s-pow(mh,2))*(s-pow(mH,2)));

   
   return gintegralhH2dgauss;
}


double gintegralhH3dgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mh = mhiggsl, mH = mhiggsH
{
  double gintegralhH3dgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gintegralhH3dgauss = 2*fabs(m1)*pow(s-4*pow(mq,2),0.5)*pow(pow(E,2)-pow(m4,2),0.5)*2*fabs(m1)*2*fabs(m1)*E/(pow(s,0.5)*(s-pow(mh,2))*(s-pow(mH,2)));

   
   return gintegralhH3dgauss;
}


double gintegralhH4dgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mh = mhiggsl, mH = mhiggsH
{
  double gintegralhH4dgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
 gintegralhH4dgauss = 2*fabs(m1)*pow(s-4*pow(mq,2),0.5)*pow(pow(E,2)-pow(m4,2),0.5)*2*fabs(m1)*2*fabs(m1)*E*(s-2*pow(mq,2))/(pow(s,0.5)*(s-pow(mh,2))*(s-pow(mH,2)));

    
   return gintegralhH4dgauss;
}

double gintegralA1dgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mA = mhiggsA
{
  double gintegralA1dgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gintegralA1dgauss = 4*pow(m1,2)*pow(pow(E,2)-pow(m4,2),0.5)*pow(s-4*pow(mq,2),0.5)/(pow(s,0.5)*pow(s-pow(mA,2),2));
   
   return gintegralA1dgauss;
}


double gintegralA2dgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mA = mhiggsA
{
  double gintegralA2dgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gintegralA2dgauss = 4*pow(m1,2)*pow(pow(E,2)-pow(m4,2),0.5)*pow(s-4*pow(mq,2),0.5)*(s-2*pow(mq,2))/(pow(s,0.5)*pow(s-pow(mA,2),2));
   
   return gintegralA2dgauss;
}


double gintegralA3dgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mA = mhiggsA
{
  double gintegralA3dgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gintegralA3dgauss = 4*pow(m1,2)*pow(pow(E,2)-pow(m4,2),0.5)*pow(s-4*pow(mq,2),0.5)*2*fabs(m1)*E/(pow(s,0.5)*pow(s-pow(mA,2),2));
   
  return gintegralA3dgauss;
}


double gintegralA4dgauss (double E) ///m1 = mZi, m4 = mZj, mq = mt, MZboson = mz, mA = mhiggsA
{
  double gintegralA4dgauss = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gintegralA4dgauss = 4*pow(m1,2)*pow(pow(E,2)-pow(m4,2),0.5)*pow(s-4*pow(mq,2),0.5)*2*fabs(m1)*E*(s-2*pow(mq,2))/(pow(s,0.5)*pow(s-pow(mA,2),2));
   
   return gintegralA4dgauss;
}

double gintegral1Zsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, MZboson = mz, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral1Zsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral1Zsfdgauss = 1/(s-pow(MZboson,2))*(-2*fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(E,2)-pow(m4,2),0.5) - (pow(m2,2)-pow(mq,2)+pow(m4,2) - 2*fabs(m1)*E)*log(logarg));

  if (gintegral1Zsfdgauss != gintegral1Zsfdgauss) {
    cout << "pow(1-4*pow(mq,2)/s,0.5) = " << pow(1-4*pow(mq,2)/s,0.5) << endl;
    cout << "pow(pow(E,2)-pow(m4,2),0.5) = " << pow(pow(E,2)-pow(m4,2),0.5) << endl;
  }
   
   return gintegral1Zsfdgauss;
}

double gintegral2Zsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, MZboson = mz, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral2Zsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log
  
  gintegral2Zsfdgauss = 1/(s-pow(MZboson,2))*(2*fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(E,2)-pow(m4,2),0.5) + (pow(m2,2)+pow(m1,2)- 2*fabs(m1)*E - pow(mq,2))*log(logarg));
   
   return gintegral2Zsfdgauss;
}

double gintegral3Zsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, MZboson = mz, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral3Zsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log
  
  // gintegral3Zsfdgauss = 1/(s-pow(MZboson,2))*((pow(m1,2) + 2*pow(mq,2) + pow(m4,2) -1.5*pow(m2,2) - 0.5*(pow(mq,2) + fabs(m1)*E + fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(E,2)-pow(m4,2),0.5)))*(pow(mq,2) + fabs(m1)*E + fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(E,2)-pow(m4,2),0.5)) - (pow(m1,2) + 2*pow(mq,2) + pow(m4,2) -1.5*pow(m2,2) - 0.5*(pow(mq,2) + fabs(m1)*E - fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(E,2)-pow(m4,2),0.5)))*(pow(mq,2) + fabs(m1)*E - fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(E,2)-pow(m4,2),0.5)) + (pow(m1,2) + pow(mq,2) - pow(m2,2))*(pow(m2,2)-pow(mq,2)-pow(m4,2))*log(logarg));

  // double templogarg = 0, Etemp = 0;
  // // s = 100.36612187684142;
  // // Etemp = 706.4498189;
  // s = 300.66768158759544;
  // Etemp = 706.3120487;
  // musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  // EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  // Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  // templogarg = (m1*(EQ + Qprime)-musquared)/(m1*(EQ - Qprime) - musquared);
  // cout << "s = " << s << " E = " << Etemp << endl;
  // cout << "Reprop = " << 1/(s-pow(MZboson,2)) << endl;
  // cout << "first term = " << (pow(m1,2) + 2*pow(mq,2) + pow(m4,2) -1.5*pow(m2,2) - 0.5*(pow(mq,2) + fabs(m1)*Etemp + fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(Etemp,2)-pow(m4,2),0.5)))*(pow(mq,2) + fabs(m1)*Etemp + fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(Etemp,2)-pow(m4,2),0.5) - pow(m2,2)) << endl; 
  // cout << "second term = " << - (pow(m1,2) + 2*pow(mq,2) + pow(m4,2) -1.5*pow(m2,2) - 0.5*(pow(mq,2) + fabs(m1)*Etemp - fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(Etemp,2)-pow(m4,2),0.5)))*(pow(mq,2) + fabs(m1)*Etemp - fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(Etemp,2)-pow(m4,2),0.5)-pow(m2,2)) << endl;
  // cout << "third term = " << + (pow(m1,2) + pow(mq,2) - pow(m2,2))*(pow(m2,2)-pow(mq,2)-pow(m4,2))*log(templogarg) << endl;
  // cout << "Overall = Reprop*(first term + second term + third term) = " << 1/(s-pow(MZboson,2))*((pow(m1,2) + 2*pow(mq,2) + pow(m4,2) -1.5*pow(m2,2) - 0.5*(pow(mq,2) + fabs(m1)*Etemp + fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(Etemp,2)-pow(m4,2),0.5)))*(pow(mq,2) + fabs(m1)*Etemp + fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(Etemp,2)-pow(m4,2),0.5)-pow(m2,2)) - (pow(m1,2) + 2*pow(mq,2) + pow(m4,2) -1.5*pow(m2,2) - 0.5*(pow(mq,2) + fabs(m1)*Etemp - fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(Etemp,2)-pow(m4,2),0.5)))*(pow(mq,2) + fabs(m1)*Etemp - fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(Etemp,2)-pow(m4,2),0.5)-pow(m2,2)) + (pow(m1,2) + pow(mq,2) - pow(m2,2))*(pow(m2,2)-pow(mq,2)-pow(m4,2))*log(templogarg)) << endl;
  // cout << "My tmax = " << (pow(mq,2) + fabs(m1)*Etemp + fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(Etemp,2)-pow(m4,2),0.5)) << endl;
  // cout << "tmax = " << fabs(m1)*Etemp + pow(mq,2) + fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(Etemp,2)-pow(m4,2),0.5) << endl;
  // cout << "tmin = " << fabs(m1)*Etemp + pow(mq,2) - fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(Etemp,2)-pow(m4,2),0.5) << endl;
  // cout << "first term should = " << (pow(m1,2) + pow(m4,2) + 2*pow(mq,2) - 1.5*pow(m2,2) - 0.5*(fabs(m1)*Etemp + pow(mq,2) + fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(Etemp,2)-pow(m4,2),0.5)))*(fabs(m1)*Etemp + pow(mq,2) + fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(Etemp,2)-pow(m4,2),0.5) - pow(m2,2)) << endl;
  // cout << "sumI = " << 2*fabs(m1)*Etemp + 2*pow(mq,2) << endl;
  // cout << "diff = " << 2*fabs(m1)*pow(pow(Etemp,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5) << endl;

  gintegral3Zsfdgauss = 1/(s-pow(MZboson,2))*((pow(m1,2) + 2*pow(mq,2) + pow(m4,2) -1.5*pow(m2,2) - 0.5*(pow(mq,2) + fabs(m1)*E + fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(E,2)-pow(m4,2),0.5)))*(pow(mq,2) + fabs(m1)*E + fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(E,2)-pow(m4,2),0.5)-pow(m2,2)) - (pow(m1,2) + 2*pow(mq,2) + pow(m4,2) -1.5*pow(m2,2) - 0.5*(pow(mq,2) + fabs(m1)*E - fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(E,2)-pow(m4,2),0.5)))*(pow(mq,2) + fabs(m1)*E - fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(E,2)-pow(m4,2),0.5)-pow(m2,2)) + (pow(m1,2) + pow(mq,2) - pow(m2,2))*(pow(m2,2)-pow(mq,2)-pow(m4,2))*log(logarg));

   
   return gintegral3Zsfdgauss;
}

double gintegral4Zsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, MZboson = mz, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral4Zsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log
  
  gintegral4Zsfdgauss = 1/(s-pow(MZboson,2))*(2*fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(E,2)-pow(m4,2),0.5) + (pow(m2,2)-pow(mq,2)-pow(m4,2))*log(logarg));
   
   return gintegral4Zsfdgauss;
}    

double gintegral5Zsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, MZboson = mz, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral5Zsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log
  
  gintegral5Zsfdgauss = -1/(s-pow(MZboson,2))*(2*fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(E,2)-pow(m4,2),0.5) + (pow(m2,2)-pow(mq,2)-pow(m1,2))*log(logarg));

  // double templogarg = 0, Etemp = 0;
  // s = 100.36612187684142;
  // Etemp = 706.4498189;
  // musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  // EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  // Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  // templogarg = (m1*(EQ + Qprime)-musquared)/(m1*(EQ - Qprime) - musquared);
  // cout << "s = " << s << " E = " << Etemp << endl;
  // cout << "diff = " << 2*fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(Etemp,2)-pow(m4,2),0.5) << endl;
  // cout << "(msf^2 - mZi^2 - mf^2)*Log(...) = " <<  (pow(m2,2)-pow(m1,2) - pow(mq,2))*log(templogarg) << endl;
  // cout << "Reprop = " << 1/(s-pow(MZboson,2)) << endl;
  // cout << "-(diff + (msf^2 - mZi^2 - mf^2)*Log(...))/(s-mZ^2) = " << -(2*fabs(m1)*pow(1-4*pow(mq,2)/s,0.5)*pow(pow(Etemp,2)-pow(m4,2),0.5) + (pow(m2,2)-pow(m1,2) - pow(mq,2))*log(templogarg))/(s-pow(MZboson,2)) << endl;  
   
   return gintegral5Zsfdgauss;
}

double gintegral6Zsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, MZboson = mz, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral6Zsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log
  
  gintegral6Zsfdgauss = 1/(s-pow(MZboson,2))*(s- 2*pow(mq,2))*log(logarg);
   
   return gintegral6Zsfdgauss;
}

double gintegral7Zsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, MZboson = mz, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral7Zsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log
  
  gintegral7Zsfdgauss = 1/(s-pow(MZboson,2))*(2*fabs(m1)*E)*log(logarg);
   
   return gintegral7Zsfdgauss;
}

double gintegral8Zsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, MZboson = mz, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral8Zsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  gintegral8Zsfdgauss = 1/(s-pow(MZboson,2))*log(logarg);

  // double templogarg = 0, Etemp = 0;
  // s = 100.36612187684142;
  // Etemp = 706.4498189;
  // musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  // EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  // Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  // templogarg = (m1*(EQ + Qprime)-musquared)/(m1*(EQ - Qprime) - musquared);
  // cout << "s = " << s << " E = " << Etemp << " templogarg = " << templogarg << " log(templogarg) = " << log(templogarg) << endl;
  // cout << "numerator = " << (m1*(EQ + Qprime)-musquared) << " denominator = " << (m1*(EQ - Qprime)-musquared) << endl;
   
   return gintegral8Zsfdgauss;
}



double gintegral1hsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, mhiggsl = mh, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral1hsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral1hsfdgauss = 2/(s-pow(mh,2))*(2*s*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5) + (pow(m2,2)*s - pow(mq,2)*(pow(m1,2)+pow(m4,2)))*log(logarg));

  if (gintegral1hsfdgauss != gintegral1hsfdgauss) {
    cout << "pow(1-4*pow(mq,2)/s,0.5) = " << pow(1-4*pow(mq,2)/s,0.5) << endl;
    cout << "pow(pow(E,2)-pow(m4,2),0.5) = " << pow(pow(E,2)-pow(m4,2),0.5) << endl;
  }
   
   return gintegral1hsfdgauss;
}


double gintegral2hsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, mhiggsl = mh, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral2hsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral2hsfdgauss = -1/(s-pow(mh,2))*(2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5) + (pow(m2,2) + pow(m4,2) -2*fabs(m1)*E - pow(mq,2))*log(logarg));
     
  return gintegral2hsfdgauss;
}



double gintegral3hsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, mhiggsl = mh, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral3hsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral3hsfdgauss = 1/(s-pow(mh,2))*(2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5) + (pow(m2,2) + pow(m1,2) -2*fabs(m1)*E - pow(mq,2))*log(logarg));
     
  return gintegral3hsfdgauss;
}



double gintegral4hsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, mhiggsl = mh, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral4hsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral4hsfdgauss = 1/(s-pow(mh,2))*(2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5) + (pow(m2,2) - pow(mq,2) - pow(m4,2))*log(logarg));
     
  return gintegral4hsfdgauss;
}


double gintegral5hsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, mhiggsl = mh, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral5hsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral5hsfdgauss = -1/(s-pow(mh,2))*(2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5) + (pow(m2,2) - pow(mq,2) - pow(m1,2))*log(logarg));
     
  return gintegral5hsfdgauss;
}


double gintegral6hsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, mhiggsl = mh, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral6hsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral6hsfdgauss = 1/(s-pow(mh,2))*(s-2*pow(mq,2))*log(logarg);
     
  return gintegral6hsfdgauss;
}


double gintegral7hsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, mhiggsl = mh, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral7hsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral7hsfdgauss = 1/(s-pow(mh,2))*(2*fabs(m1)*E)*log(logarg);
     
  return gintegral7hsfdgauss;
}


double gintegral8hsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, mhiggsl = mh, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral8hsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral8hsfdgauss = 1/(s-pow(mh,2))*log(logarg);
     
  return gintegral8hsfdgauss;
}


double gintegral1Hsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, mhiggsl = mh, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral1Hsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral1Hsfdgauss = 2/(s-pow(mH,2))*(2*s*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5) + (pow(m2,2)*s - pow(mq,2)*(pow(m1,2)+pow(m4,2)))*log(logarg));

  if (gintegral1Hsfdgauss != gintegral1Hsfdgauss) {
    cout << "pow(1-4*pow(mq,2)/s,0.5) = " << pow(1-4*pow(mq,2)/s,0.5) << endl;
    cout << "pow(pow(E,2)-pow(m4,2),0.5) = " << pow(pow(E,2)-pow(m4,2),0.5) << endl;
  }
   
   return gintegral1Hsfdgauss;
}


double gintegral2Hsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, mhiggsl = mh, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral2Hsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral2Hsfdgauss = -1/(s-pow(mH,2))*(2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5) + (pow(m2,2) + pow(m4,2) -2*fabs(m1)*E - pow(mq,2))*log(logarg));
     
  return gintegral2Hsfdgauss;
}



double gintegral3Hsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, mhiggsl = mh, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral3Hsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral3Hsfdgauss = 1/(s-pow(mH,2))*(2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5) + (pow(m2,2) + pow(m1,2) -2*fabs(m1)*E - pow(mq,2))*log(logarg));
     
  return gintegral3Hsfdgauss;
}



double gintegral4Hsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, mhiggsl = mh, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral4Hsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral4Hsfdgauss = 1/(s-pow(mH,2))*(2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5) + (pow(m2,2) - pow(mq,2) - pow(m4,2))*log(logarg));
     
  return gintegral4Hsfdgauss;
}


double gintegral5Hsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, mhiggsl = mh, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral5Hsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral5Hsfdgauss = -1/(s-pow(mH,2))*(2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5) + (pow(m2,2) - pow(mq,2) - pow(m1,2))*log(logarg));
     
  return gintegral5Hsfdgauss;
}


double gintegral6Hsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, mhiggsl = mh, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral6Hsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral6Hsfdgauss = 1/(s-pow(mH,2))*(s-2*pow(mq,2))*log(logarg);
     
  return gintegral6Hsfdgauss;
}


double gintegral7Hsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, mhiggsl = mh, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral7Hsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral7Hsfdgauss = 1/(s-pow(mH,2))*(2*fabs(m1)*E)*log(logarg);
     
  return gintegral7Hsfdgauss;
}


double gintegral8Hsfdgauss (double E) ///m1 = mZi, m4 = mZj, mq = mf, mhiggsl = mh, m2 = msfi where i is the sfermion index you're considering for that interference (i = 1,2)
{
  double gintegral8Hsfdgauss = 0, logarg=0, EQ = 0, Qprime = 0, musquared = 0, s=0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  musquared = s + pow(m2,2) - pow(m4,2) - pow(mq,2);
  EQ = (s+pow(m1,2) - pow(m4,2))/(2*fabs(m1));
  Qprime = pow(pow(EQ,2) - s,0.5)*pow(1 - 4*pow(mq,2)/s,0.5);
  logarg = (fabs(m1)*(EQ + Qprime)-musquared)/(fabs(m1)*(EQ - Qprime) - musquared); ///argument of the log

  if (logarg < 0) {
    cout << "Problem -> will get nan as logarg < 0" << endl;
    cout << "logarg = " << logarg << endl;
    cout << "numerator = " << (fabs(m1)*(EQ + Qprime)-musquared) << endl;
    cout << "denominator = " << (fabs(m1)*(EQ - Qprime)-musquared) << endl;
    cout << "EQ = " << EQ << " Qprime = " << Qprime << " musquared = " << musquared << endl;
  }

  gintegral8Hsfdgauss = 1/(s-pow(mH,2))*log(logarg);
     
  return gintegral8Hsfdgauss;
}


double gintegral1ZAdgauss(double E) /// m1 = mZi, m4 = mZj, mq = mf, mA = mhiggsA, m2 = msfi, MZboson = mz
{
  double gintegral1ZAdgauss = 0, s = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gintegral1ZAdgauss = 1/((s-pow(MZboson,2))*(s-pow(mA,2)))*2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5)*(pow(m1,2) - fabs(m1)*E);

  return gintegral1ZAdgauss;
}

double gintegral2ZAdgauss(double E) /// m1 = mZi, m4 = mZj, mq = mf, mA = mhiggsA, m2 = msfi, MZboson = mz
{
  double gintegral2ZAdgauss = 0, s = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gintegral2ZAdgauss = -1/((s-pow(MZboson,2))*(s-pow(mA,2)))*2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5)*(pow(m4,2) - fabs(m1)*E);

  return gintegral2ZAdgauss;
}

double gintegral3ZAdgauss(double E) /// m1 = mZi, m4 = mZj, mq = mf, mA = mhiggsA, m2 = msfi, MZboson = mz
{
  double gintegral3ZAdgauss = 0, s = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gintegral3ZAdgauss = 1/((s-pow(MZboson,2))*(s-pow(mA,2)))*2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5)*(pow(m1,2)-fabs(m1)*E);

  return gintegral3ZAdgauss;
}

double gintegral4ZAdgauss(double E) /// m1 = mZi, m4 = mZj, mq = mf, mA = mhiggsA, m2 = msfi, MZboson = mz
{
  double gintegral4ZAdgauss = 0, s = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gintegral4ZAdgauss = -1/((s-pow(MZboson,2))*(s-pow(mA,2)))*2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5)*(pow(m4,2) - fabs(m1)*E);

  return gintegral4ZAdgauss;
}

double gneutineutjffgA1dgauss(double E) /// m1 = mZi, m4 = mZj, mq = mf, mA = mhiggsA, MZboson = mz
{
  double gneutineutjffgA1dgauss = 0, s = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gneutineutjffgA1dgauss = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5)/((s-pow(MZboson,2))*(s-pow(mA,2)));
  
  return gneutineutjffgA1dgauss;
}

double gneutineutjffgA2dgauss(double E) /// m1 = mZi, m4 = mZj, mq = mf, mA = mhiggsA, MZboson = mz
{
  double gneutineutjffgA2dgauss = 0, s = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gneutineutjffgA2dgauss = 2*fabs(m1)*(s-2*pow(mq,2))*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5)/((s-pow(MZboson,2))*(s-pow(mA,2)));
  
  return gneutineutjffgA2dgauss;
}

double gneutineutjffgA3dgauss(double E) /// m1 = mZi, m4 = mZj, mq = mf, mA = mhiggsA, MZboson = mz
{
  double gneutineutjffgA3dgauss = 0, s = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gneutineutjffgA3dgauss = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5)*2*fabs(m1)*E/((s-pow(MZboson,2))*(s-pow(mA,2)));
  
  return gneutineutjffgA3dgauss;
}

double gneutineutjffgA4dgauss(double E) /// m1 = mZi, m4 = mZj, mq = mf, mA = mhiggsA, MZboson = mz
{
  double gneutineutjffgA4dgauss = 0, s = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  
  gneutineutjffgA4dgauss = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(1-4*pow(mq,2)/s,0.5)*(s-2*pow(mq,2))*2*fabs(m1)*E/((s-pow(MZboson,2))*(s-pow(mA,2)));
  
  return gneutineutjffgA4dgauss;
}


double gneuticharjffpW1dgauss(double E) ///m1 = mZi, m2 = mWj, m3 = mf, m4 = mfp, MWboson = mw
{
  double gneuticharjffpW1dgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);

  // cout << "masses in integrand: " << m1 << " " << m2 << " " << m3 << " " << m4 << " " << MWboson << endl;
  // cout << "s = " << s << " at E = " << E << endl;
  
  gneuticharjffpW1dgauss = 2*fabs(m1)/s*pow(squareplus*squareminus,0.5)*pow(pow(E,2)-pow(m2,2),0.5)*(-2*pow(s,4) + (pow(m1,2) + pow(m2,2) + pow(m3,2) + pow(m4,2))*pow(s,3) + (pow(pow(m1,2)-pow(m2,2),2) + pow(pow(m3,2)-pow(m4,2),2) - 2*(pow(m1,2)+pow(m2,2))*(pow(m3,2)+pow(m4,2)))*pow(s,2) + ((pow(m1,2)+pow(m2,2))*pow(pow(m3,2)-pow(m4,2),2) + (pow(m3,2)+pow(m4,2))*pow(pow(m1,2)-pow(m2,2),2))*s - 2*pow(pow(m1,2)-pow(m2,2),2)*pow(pow(m3,2)-pow(m4,2),2))*1/(3*pow(s,2))*1/(pow(s-pow(MWboson,2),2));

  return gneuticharjffpW1dgauss;
}

double gneuticharjffpW2dgauss(double E) ///m1 = mZi, m2 = mWj, m3 = mf, m4 = mfp, MWboson = mw
{
  double gneuticharjffpW2dgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);
  
  gneuticharjffpW2dgauss = 2*fabs(m1)/s*pow(squareplus*squareminus,0.5)*pow(pow(E,2)-pow(m2,2),0.5)*(s-pow(m3,2)-pow(m4,2))/(pow(s-pow(MWboson,2),2));

  return gneuticharjffpW2dgauss;
}


double gneuticharjffpHpm1dgauss(double E) ///m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mHpm;
{
  double gneuticharjffpHpm1dgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);

  gneuticharjffpHpm1dgauss = 2*fabs(m1)/s*pow(squareplus*squareminus,0.5)*pow(pow(E,2)-pow(m2,2),0.5)/(pow(s-pow(m5,2),2));

  return gneuticharjffpHpm1dgauss;
}

double gneuticharjffpHpm2dgauss(double E) ///m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mHpm;
{
  double gneuticharjffpHpm2dgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);

  gneuticharjffpHpm2dgauss = 2*fabs(m1)/s*pow(squareplus*squareminus,0.5)*pow(pow(E,2)-pow(m2,2),0.5)*(s-pow(m3,2)-pow(m4,2))/(pow(s-pow(m5,2),2));

  return gneuticharjffpHpm2dgauss;
}

double gneuticharjffpHpm3dgauss(double E) ///m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mHpm;
{
  double gneuticharjffpHpm3dgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);

  gneuticharjffpHpm3dgauss = 2*fabs(m1)/s*pow(squareplus*squareminus,0.5)*pow(pow(E,2)-pow(m2,2),0.5)*2*fabs(m1)*E/(pow(s-pow(m5,2),2));

  return gneuticharjffpHpm3dgauss;
}

double gneuticharjffpHpm4dgauss(double E) ///m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mHpm;
{
  double gneuticharjffpHpm4dgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);

  gneuticharjffpHpm4dgauss = 2*fabs(m1)/s*pow(squareplus*squareminus,0.5)*pow(pow(E,2)-pow(m2,2),0.5)*2*fabs(m1)*E*(s-pow(m3,2)-pow(m4,2))/(pow(s-pow(m5,2),2));

  return gneuticharjffpHpm4dgauss;
}


double gneuticharjffp1sf1sf2dgauss(double E) ///m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msf1, m6 = msf2
{
  double gneuticharjffp1sf1sf2dgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);

  gneuticharjffp1sf1sf2dgauss = 2*fabs(m1)/s*pow(squareplus*squareminus,0.5)*pow(pow(E,2)-pow(m2,2),0.5)/((s-pow(m5,2))*(s-pow(m6,2)));

  return gneuticharjffp1sf1sf2dgauss;
}

double gneuticharjffp2sf1sf2dgauss(double E) ///m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msf1, m6 = msf2
{
  double gneuticharjffp2sf1sf2dgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);

  gneuticharjffp2sf1sf2dgauss = 2*fabs(m1)/s*pow(squareplus*squareminus,0.5)*pow(pow(E,2)-pow(m2,2),0.5)*(s-pow(m3,2)-pow(m4,2))/((s-pow(m5,2))*(s-pow(m6,2)));

  return gneuticharjffp2sf1sf2dgauss;
}
 
double gneuticharjffp3sf1sf2dgauss(double E) ///m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msf1, m6 = msf2
{
  double gneuticharjffp3sf1sf2dgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);

  gneuticharjffp3sf1sf2dgauss = 2*fabs(m1)/s*pow(squareplus*squareminus,0.5)*pow(pow(E,2)-pow(m2,2),0.5)*2*fabs(m1)*E/((s-pow(m5,2))*(s-pow(m6,2)));

  return gneuticharjffp3sf1sf2dgauss;
} 

double gneuticharjffp4sf1sf2dgauss(double E) ///m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msf1, m6 = msf2
{
  double gneuticharjffp4sf1sf2dgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);

  gneuticharjffp4sf1sf2dgauss = 2*fabs(m1)/s*pow(squareplus*squareminus,0.5)*pow(pow(E,2)-pow(m2,2),0.5)*2*fabs(m1)*E*(s-pow(m3,2)-pow(m4,2))/((s-pow(m5,2))*(s-pow(m6,2)));

  return gneuticharjffp4sf1sf2dgauss;
}
 

double gneuticharjffp1sfp1sf2dgauss(double E) ///m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msfp1, m6 = msf2
{
  double gneuticharjffp1sfp1sf2dgauss = 0, s = 0, squareplus = 0, squareminus = 0, numerator = 0, denominator = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m2,2);
  squareminus = s - pow(m3-m2,2);
  numerator = 0.5*(pow(m2,2)+pow(m3,2)+2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s + 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - 2*pow(m6,2));
  denominator = 0.5*(pow(m2,2)+pow(m3,2)+2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s - 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - 2*pow(m6,2));
  Z = numerator/denominator;

  gneuticharjffp1sfp1sf2dgauss = (2*(2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5) + (pow(m6,2)*s - pow(m1,2)*pow(m3,2) - pow(m2,2)*pow(m4,2))*log(Z)))/(s-pow(m5,2));

  return gneuticharjffp1sfp1sf2dgauss;
}

double gneuticharjffp2sfp1sf2dgauss(double E) ///m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msfp1, m6 = msf2
{
  double gneuticharjffp2sfp1sf2dgauss = 0, s = 0, squareplus = 0, squareminus = 0, numerator = 0, denominator = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m2,2);
  squareminus = s - pow(m3-m2,2);
  numerator = 0.5*(pow(m2,2)+pow(m3,2)+2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s + 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - 2*pow(m6,2));
  denominator = 0.5*(pow(m2,2)+pow(m3,2)+2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s - 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - 2*pow(m6,2));
  Z = numerator/denominator;

  gneuticharjffp2sfp1sf2dgauss = -(2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s + (pow(m6,2)-2*fabs(m1)*E + pow(m4,2)-pow(m3,2))*log(Z))/(s-pow(m5,2));

  return gneuticharjffp2sfp1sf2dgauss;
}

double gneuticharjffp3sfp1sf2dgauss(double E) ///m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msfp1, m6 = msf2
{
  double gneuticharjffp3sfp1sf2dgauss = 0, s = 0, squareplus = 0, squareminus = 0, numerator = 0, denominator = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m2,2);
  squareminus = s - pow(m3-m2,2);
  numerator = 0.5*(pow(m2,2)+pow(m3,2)+2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s + 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - 2*pow(m6,2));
  denominator = 0.5*(pow(m2,2)+pow(m3,2)+2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s - 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - 2*pow(m6,2));
  Z = numerator/denominator;

  gneuticharjffp3sfp1sf2dgauss = (2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s + (pow(m6,2)+pow(m1,2)-2*fabs(m1)*E-pow(m2,2))*log(Z))/(s-pow(m5,2));

  return gneuticharjffp3sfp1sf2dgauss;
}

double gneuticharjffp4sfp1sf2dgauss(double E) ///m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msfp1, m6 = msf2
{
  double gneuticharjffp4sfp1sf2dgauss = 0, s = 0, squareplus = 0, squareminus = 0, numerator = 0, denominator = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m2,2);
  squareminus = s - pow(m3-m2,2);
  numerator = 0.5*(pow(m2,2)+pow(m3,2)+2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s + 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - 2*pow(m6,2));
  denominator = 0.5*(pow(m2,2)+pow(m3,2)+2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s - 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - 2*pow(m6,2));
  Z = numerator/denominator;

  gneuticharjffp4sfp1sf2dgauss = (2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s + (pow(m6,2)-pow(m3,2)-pow(m4,2))*log(Z))/(s-pow(m5,2));

  return gneuticharjffp4sfp1sf2dgauss;
}

double gneuticharjffp5sfp1sf2dgauss(double E) ///m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msfp1, m6 = msf2
{
  double gneuticharjffp5sfp1sf2dgauss = 0, s = 0, squareplus = 0, squareminus = 0, numerator = 0, denominator = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m2,2);
  squareminus = s - pow(m3-m2,2);
  numerator = 0.5*(pow(m2,2)+pow(m3,2)+2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s + 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - 2*pow(m6,2));
  denominator = 0.5*(pow(m2,2)+pow(m3,2)+2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s - 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - 2*pow(m6,2));
  Z = numerator/denominator;

  gneuticharjffp5sfp1sf2dgauss = (-2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - (pow(m6,2)-pow(m1,2)-pow(m2,2))*log(Z))/(s-pow(m5,2));

  return gneuticharjffp5sfp1sf2dgauss;
}

double gneuticharjffp6sfp1sf2dgauss(double E) ///m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msfp1, m6 = msf2
{
  double gneuticharjffp6sfp1sf2dgauss = 0, s = 0, squareplus = 0, squareminus = 0, numerator = 0, denominator = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m2,2);
  squareminus = s - pow(m3-m2,2);
  numerator = 0.5*(pow(m2,2)+pow(m3,2)+2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s + 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - 2*pow(m6,2));
  denominator = 0.5*(pow(m2,2)+pow(m3,2)+2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s - 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - 2*pow(m6,2));
  Z = numerator/denominator;

  gneuticharjffp6sfp1sf2dgauss = log(Z)*(s-pow(m2,2)-pow(m3,2))/(s-pow(m5,2));

  return gneuticharjffp6sfp1sf2dgauss;
}

double gneuticharjffp7sfp1sf2dgauss(double E) ///m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msfp1, m6 = msf2
{
  double gneuticharjffp7sfp1sf2dgauss = 0, s = 0, squareplus = 0, squareminus = 0, numerator = 0, denominator = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m2,2);
  squareminus = s - pow(m3-m2,2);
  numerator = 0.5*(pow(m2,2)+pow(m3,2)+2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s + 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - 2*pow(m6,2));
  denominator = 0.5*(pow(m2,2)+pow(m3,2)+2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s - 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - 2*pow(m6,2));
  Z = numerator/denominator;

  gneuticharjffp7sfp1sf2dgauss = log(Z)*2*fabs(m1)*E/(s-pow(m5,2));

  return gneuticharjffp7sfp1sf2dgauss;
}

double gneuticharjffp8sfp1sf2dgauss(double E) ///m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msfp1, m6 = msf2
{
  double gneuticharjffp8sfp1sf2dgauss = 0, s = 0, squareplus = 0, squareminus = 0, numerator = 0, denominator = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m2,2);
  squareminus = s - pow(m3-m2,2);
  numerator = 0.5*(pow(m2,2)+pow(m3,2)+2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s + 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - 2*pow(m6,2));
  denominator = 0.5*(pow(m2,2)+pow(m3,2)+2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s - 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s - 2*pow(m6,2));
  Z = numerator/denominator;
  if ( Z < 0) {
    cout << "At E = " << E << " numerator = " << numerator << " denominator = " << denominator << endl;
  }

  gneuticharjffp8sfp1sf2dgauss = log(Z)/(s-pow(m5,2));

  return gneuticharjffp8sfp1sf2dgauss;
}


double gneuticharjffp1WHpmdgauss(double E) /// m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mWboson, m6 = mHpm
{
  double gneuticharjffp1WHpmdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0;
  s= pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);
  A = 2*fabs(m1)*E + pow(m3,2) + pow(m4,2) - (pow(m1,2)-pow(m2,2))*(pow(m3,2)-pow(m4,2))/s;
  B = 2*fabs(m1)/s*pow(pow(E,2)-pow(m2,2),0.5)*pow(squareplus*squareminus,0.5);
  
  gneuticharjffp1WHpmdgauss = (-0.5*(A*B) + (pow(m1,2)+pow(m3,2))*B)/((s-pow(m5,2))*(s-pow(m6,2)));

  return gneuticharjffp1WHpmdgauss;
}

double gneuticharjffp2WHpmdgauss(double E) /// m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mWboson, m6 = mHpm
{
  double gneuticharjffp2WHpmdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0;
  s= pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);
  A = 2*fabs(m1)*E + pow(m3,2) + pow(m4,2) - (pow(m1,2)-pow(m2,2))*(pow(m3,2)-pow(m4,2))/s;
  B = 2*fabs(m1)/s*pow(pow(E,2)-pow(m2,2),0.5)*pow(squareplus*squareminus,0.5);
  
  gneuticharjffp2WHpmdgauss = (0.5*(A*B) - (pow(m2,2)+pow(m4,2))*B)/((s-pow(m5,2))*(s-pow(m6,2)));

  return gneuticharjffp2WHpmdgauss;
}

double gneuticharjffp3WHpmdgauss(double E) /// m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mWboson, m6 = mHpm
{
  double gneuticharjffp3WHpmdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0;
  s= pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);
  A = 2*fabs(m1)*E + pow(m3,2) + pow(m4,2) - (pow(m1,2)-pow(m2,2))*(pow(m3,2)-pow(m4,2))/s;
  B = 2*fabs(m1)/s*pow(pow(E,2)-pow(m2,2),0.5)*pow(squareplus*squareminus,0.5);
  
  gneuticharjffp3WHpmdgauss = (0.5*(A*B)+(pow(m1,2)-2*fabs(m1)*E-pow(m3,2))*B)/((s-pow(m5,2))*(s-pow(m6,2)));

  return gneuticharjffp3WHpmdgauss;
}

double gneuticharjffp4WHpmdgauss(double E) /// m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mWboson, m6 = mHpm
{
  double gneuticharjffp4WHpmdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0;
  s= pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);
  A = 2*fabs(m1)*E + pow(m3,2) + pow(m4,2) - (pow(m1,2)-pow(m2,2))*(pow(m3,2)-pow(m4,2))/s;
  B = 2*fabs(m1)/s*pow(pow(E,2)-pow(m2,2),0.5)*pow(squareplus*squareminus,0.5);
  
  gneuticharjffp4WHpmdgauss = (-0.5*(A*B)-(pow(m2,2)-2*fabs(m1)*E-pow(m4,2))*B)/((s-pow(m5,2))*(s-pow(m6,2)));

  return gneuticharjffp4WHpmdgauss;
}

double gneuticharjffpW1Sfpdgauss(double E) /// m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp
{
  double gneuticharjffpW1Sfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m2+m3,2);
  squareminus = s - pow(m2-m3,2);
  A = pow(m2,2) + pow(m3,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  Z = (A + B - 2*pow(m6,2))/(A - B - 2*pow(m6,2));
  
  gneuticharjffpW1Sfpdgauss = (-B - (pow(m6,2)+pow(m4,2)-2*fabs(m1)*E-pow(m3,2))*log(Z))/(s-pow(m5,2));

  return gneuticharjffpW1Sfpdgauss;
}

double gneuticharjffpW2Sfpdgauss(double E) /// m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp
{
  double gneuticharjffpW2Sfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m2+m3,2);
  squareminus = s - pow(m2-m3,2);
  A = pow(m2,2) + pow(m3,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  Z = (A + B - 2*pow(m6,2))/(A - B - 2*pow(m6,2));
  
  gneuticharjffpW2Sfpdgauss = (B + (pow(m6,2)+pow(m1,2)-2*fabs(m1)*E-pow(m2,2))*log(Z))/(s-pow(m5,2));

  return gneuticharjffpW2Sfpdgauss;
}

double gneuticharjffpW3Sfpdgauss(double E) /// m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp
{
  double gneuticharjffpW3Sfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m2+m3,2);
  squareminus = s - pow(m2-m3,2);
  A = pow(m2,2) + pow(m3,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  Z = (A + B - 2*pow(m6,2))/(A - B - 2*pow(m6,2));
  
  gneuticharjffpW3Sfpdgauss = ((pow(m1,2)+pow(m3,2)+pow(m2,2)+pow(m4,2)-1.5*pow(m6,2)-0.25*(A+B))*(0.5*(A+B)-pow(m6,2)) - (pow(m1,2)+pow(m3,2)+pow(m2,2)+pow(m4,2)-1.5*pow(m6,2)-0.25*(A-B))*(0.5*(A-B)-pow(m6,2)) + (pow(m1,2)+pow(m2,2)-pow(m6,2))*(pow(m6,2)-pow(m3,2)-pow(m4,2))*log(Z))/(s-pow(m5,2));

  // if (E < 184) {
  //   E = 183.51155091817742;
  //   s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  //   squareplus = s - pow(m2+m3,2);
  //   squareminus = s - pow(m2-m3,2);
  //   A = pow(m2,2) + pow(m3,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  //   B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  //   Z = (A + B - 2*pow(m6,2))/(A - B - 2*pow(m6,2));
  //   cout << "E = " << E << endl;
  //   cout << "first term = " << (pow(m1,2)+pow(m3,2)+pow(m2,2)+pow(m4,2)-1.5*pow(m6,2)-0.25*(A+B))*(0.5*(A+B)-pow(m6,2)) << endl;
  //   cout << "second term = " <<- (pow(m1,2)+pow(m3,2)+pow(m2,2)+pow(m4,2)-1.5*pow(m6,2)-0.25*(A-B))*(0.5*(A-B)-pow(m6,2)) << endl;
  //   cout << "third term = " << (pow(m1,2)+pow(m2,2)-pow(m6,2))*(pow(m6,2)-pow(m3,2)-pow(m4,2))*log(Z) << endl;
  //   cout << "Reprop = " << 1/(s-pow(m5,2)) << endl;
  //   cout << "tmax = " << 0.5*(A + B) << endl;
  //   cout << "tmin = " << 0.5*(A - B) << endl;
  //   cout << "sumI = " << A << endl;
  //   cout << "diff = " << B << endl;
  //   cout << "s = "<< s << endl;
  //   cout << "log(Z) = "<< log(Z) << endl;
  //   cout << "log(Z)2 = " << log((0.5*(A+B)-pow(m6,2))/(0.5*(A-B)-pow(m6,2))) << endl;
  //   cout << "Part by part for third term: " << endl;
  //   cout << (pow(m1,2)+pow(m2,2)-pow(m6,2)) << " " << (pow(m6,2)-pow(m3,2)-pow(m4,2)) << " " << log(Z) << endl;
  //   cout << "Tot = " << ((pow(m1,2)+pow(m3,2)+pow(m2,2)+pow(m4,2)-1.5*pow(m6,2)-0.25*(A+B))*(0.5*(A+B)-pow(m6,2)) - (pow(m1,2)+pow(m3,2)+pow(m2,2)+pow(m4,2)-1.5*pow(m6,2)-0.25*(A-B))*(0.5*(A-B)-pow(m6,2)) + (pow(m1,2)+pow(m2,2)-pow(m6,2))*(pow(m6,2)-pow(m3,2)-pow(m4,2))*log(Z))/(s-pow(m5,2)) << endl;
  // }
  
  return gneuticharjffpW3Sfpdgauss;
}


double gneuticharjffpW4Sfpdgauss(double E) /// m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp
{
  double gneuticharjffpW4Sfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m2+m3,2);
  squareminus = s - pow(m2-m3,2);
  A = pow(m2,2) + pow(m3,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  Z = (A + B - 2*pow(m6,2))/(A - B - 2*pow(m6,2));
  
  gneuticharjffpW4Sfpdgauss = (B + (pow(m6,2)-pow(m3,2)-pow(m4,2))*log(Z))/(s-pow(m5,2));

  return gneuticharjffpW4Sfpdgauss;
}

double gneuticharjffpW5Sfpdgauss(double E) /// m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp
{
  double gneuticharjffpW5Sfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m2+m3,2);
  squareminus = s - pow(m2-m3,2);
  A = pow(m2,2) + pow(m3,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  Z = (A + B - 2*pow(m6,2))/(A - B - 2*pow(m6,2));
  
  gneuticharjffpW5Sfpdgauss = (-B - (pow(m6,2)-pow(m1,2)-pow(m2,2))*log(Z))/(s-pow(m5,2));

  return gneuticharjffpW5Sfpdgauss;
}

double gneuticharjffpW6Sfpdgauss(double E) /// m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp
{
  double gneuticharjffpW6Sfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m2+m3,2);
  squareminus = s - pow(m2-m3,2);
  A = pow(m2,2) + pow(m3,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  Z = (A + B - 2*pow(m6,2))/(A - B - 2*pow(m6,2));
  
  gneuticharjffpW6Sfpdgauss = (s-pow(m2,2)-pow(m3,2))*log(Z)/(s-pow(m5,2));

  return gneuticharjffpW6Sfpdgauss;
}

double gneuticharjffpW7Sfpdgauss(double E) /// m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp
{
  double gneuticharjffpW7Sfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m2+m3,2);
  squareminus = s - pow(m2-m3,2);
  A = pow(m2,2) + pow(m3,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  Z = (A + B - 2*pow(m6,2))/(A - B - 2*pow(m6,2));
  
  gneuticharjffpW7Sfpdgauss = 2*fabs(m1)*E*log(Z)/(s-pow(m5,2));

  return gneuticharjffpW7Sfpdgauss;
}

double gneuticharjffpW8Sfpdgauss(double E) /// m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp
{
  double gneuticharjffpW8Sfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m2+m3,2);
  squareminus = s - pow(m2-m3,2);
  A = pow(m2,2) + pow(m3,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  Z = (A + B - 2*pow(m6,2))/(A - B - 2*pow(m6,2));
  
  gneuticharjffpW8Sfpdgauss = log(Z)/(s-pow(m5,2));

  return gneuticharjffpW8Sfpdgauss;
}

double gneuticharjffpHg1dgauss(double E) ///m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mWboson, m6 = mHP
{
  double gneuticharjffpHg1dgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);
  
  gneuticharjffpHg1dgauss = 2*fabs(m1)*pow(pow(E,2)-pow(m2,2),0.5)*pow(squareplus*squareminus,0.5)/(s*(s-pow(m5,2))*(s-pow(m6,2)));

  return gneuticharjffpHg1dgauss;
}

double gneuticharjffpHg2dgauss(double E) ///m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mWboson, m6 = mHP
{
  double gneuticharjffpHg2dgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);
  
  gneuticharjffpHg2dgauss = 2*fabs(m1)*pow(pow(E,2)-pow(m2,2),0.5)*pow(squareplus*squareminus,0.5)*(s-pow(m3,2)-pow(m4,2))/(s*(s-pow(m5,2))*(s-pow(m6,2)));

  return gneuticharjffpHg2dgauss;
}

double gneuticharjffpHg3dgauss(double E) ///m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mWboson, m6 = mHP
{
  double gneuticharjffpHg3dgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);
  
  gneuticharjffpHg3dgauss = 2*fabs(m1)*pow(pow(E,2)-pow(m2,2),0.5)*pow(squareplus*squareminus,0.5)*2*fabs(m1)*E/(s*(s-pow(m5,2))*(s-pow(m6,2)));

  return gneuticharjffpHg3dgauss;
}

double gneuticharjffpHg4dgauss(double E) ///m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mWboson, m6 = mHP
{
  double gneuticharjffpHg4dgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);
  
  gneuticharjffpHg4dgauss = 2*fabs(m1)*pow(pow(E,2)-pow(m2,2),0.5)*pow(squareplus*squareminus,0.5)*2*fabs(m1)*E*(s-pow(m3,2)-pow(m4,2))/(s*(s-pow(m5,2))*(s-pow(m6,2)));

  return gneuticharjffpHg4dgauss;
}


double gneuticharjffp1gsfpdgauss(double E) ///m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp1
{
  double gneuticharjffp1gsfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m2,2);
  squareminus = s - pow(m3-m2,2);
  A = pow(m3,2) + pow(m2,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  Z = (0.5*(A+B)-pow(m6,2))/(0.5*(A-B)-pow(m6,2));

  gneuticharjffp1gsfpdgauss = 2*(s*B + (pow(m6,2)*s - pow(m1,2)*pow(m3,2) - pow(m2,2)*pow(m4,2))*log(Z))/(s-pow(m5,2));
  
  return gneuticharjffp1gsfpdgauss;
}

double gneuticharjffp2gsfpdgauss(double E) ///m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp1
{
  double gneuticharjffp2gsfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m2,2);
  squareminus = s - pow(m3-m2,2);
  A = pow(m3,2) + pow(m2,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  Z = (0.5*(A+B)-pow(m6,2))/(0.5*(A-B)-pow(m6,2));

  gneuticharjffp2gsfpdgauss = (-B - (pow(m6,2) + pow(m4,2) - 2*fabs(m1)*E - pow(m3,2))*log(Z))/(s-pow(m5,2));
  
  return gneuticharjffp2gsfpdgauss;
}

double gneuticharjffp3gsfpdgauss(double E) ///m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp1
{
  double gneuticharjffp3gsfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m2,2);
  squareminus = s - pow(m3-m2,2);
  A = pow(m3,2) + pow(m2,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  Z = (0.5*(A+B)-pow(m6,2))/(0.5*(A-B)-pow(m6,2));

  gneuticharjffp3gsfpdgauss = (B + (pow(m6,2)+pow(m1,2)-2*fabs(m1)*E - pow(m2,2))*log(Z))/(s-pow(m5,2));
  
  return gneuticharjffp3gsfpdgauss;
}

double gneuticharjffp4gsfpdgauss(double E) ///m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp1
{
  double gneuticharjffp4gsfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m2,2);
  squareminus = s - pow(m3-m2,2);
  A = pow(m3,2) + pow(m2,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  Z = (0.5*(A+B)-pow(m6,2))/(0.5*(A-B)-pow(m6,2));

  gneuticharjffp4gsfpdgauss = (B + (pow(m6,2)-pow(m3,2)-pow(m4,2))*log(Z))/(s-pow(m5,2));
  
  return gneuticharjffp4gsfpdgauss;
}

double gneuticharjffp5gsfpdgauss(double E) ///m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp1
{
  double gneuticharjffp5gsfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m2,2);
  squareminus = s - pow(m3-m2,2);
  A = pow(m3,2) + pow(m2,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  Z = (0.5*(A+B)-pow(m6,2))/(0.5*(A-B)-pow(m6,2));

  gneuticharjffp5gsfpdgauss = (-B-(pow(m6,2)-pow(m1,2)-pow(m2,2))*log(Z))/(s-pow(m5,2));
  
  return gneuticharjffp5gsfpdgauss;
}

double gneuticharjffp6gsfpdgauss(double E) ///m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp1
{
  double gneuticharjffp6gsfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m2,2);
  squareminus = s - pow(m3-m2,2);
  A = pow(m3,2) + pow(m2,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  Z = (0.5*(A+B)-pow(m6,2))/(0.5*(A-B)-pow(m6,2));

  gneuticharjffp6gsfpdgauss = (s-pow(m2,2)-pow(m3,2))*log(Z)/(s-pow(m5,2));
  
  return gneuticharjffp6gsfpdgauss;
}

double gneuticharjffp7gsfpdgauss(double E) ///m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp1
{
  double gneuticharjffp7gsfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m2,2);
  squareminus = s - pow(m3-m2,2);
  A = pow(m3,2) + pow(m2,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  Z = (0.5*(A+B)-pow(m6,2))/(0.5*(A-B)-pow(m6,2));

  gneuticharjffp7gsfpdgauss = 2*fabs(m1)*E*log(Z)/(s-pow(m5,2));
  
  return gneuticharjffp7gsfpdgauss;
}

double gneuticharjffp8gsfpdgauss(double E) ///m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp1
{
  double gneuticharjffp8gsfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0, A = 0, B = 0, Z = 0;
  s = pow(m1,2) + pow(m4,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m2,2);
  squareminus = s - pow(m3-m2,2);
  A = pow(m3,2) + pow(m2,2) + 2*fabs(m1)*E + (pow(m1,2)-pow(m4,2))*(pow(m3,2)-pow(m2,2))/s;
  B = 2*fabs(m1)*pow(pow(E,2)-pow(m4,2),0.5)*pow(squareplus*squareminus,0.5)/s;
  Z = (0.5*(A+B)-pow(m6,2))/(0.5*(A-B)-pow(m6,2));

  gneuticharjffp8gsfpdgauss = log(Z)/(s-pow(m5,2));
  
  return gneuticharjffp8gsfpdgauss;
}

double gneuticharjffp1sfpsfpdgauss(double E) /// m1 = mneutralinoi, m2 = mfp, m3 = -mf, m4 = charginoj, m5 = msfp1, m6 = msfp1
{
  double gneuticharjffp1sfpsfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);
  
  gneuticharjffp1sfpsfpdgauss = 2*fabs(m1)*pow(pow(E,2)-pow(m2,2),0.5)*pow(squareplus*squareminus,0.5)/(s*(s-pow(m5,2))*(s-pow(m6,2)));
  // cout << "E = " << E << " gneuticharjffp1sfpsfpdgauss =  " <<  gneuticharjffp1sfpsfpdgauss << endl;
  // cout << "m1 = " << m1 << " pow(pow(E,2)-pow(m2,2),0.5) = " << pow(pow(E,2)-pow(m2,2),0.5) << " lambda = " << pow(squareplus*squareminus,0.5) << endl;
  // cout << "s = " << s << " (s-pow(m5,2)) = " << s-pow(m5,2) << " (s-pow(m6,2)) = " << s-pow(m6,2) << endl;

  return gneuticharjffp1sfpsfpdgauss;
}

double gneuticharjffp2sfpsfpdgauss(double E) /// m1 = mneutralinoi, m2 = mfp, m3 = -mf, m4 = charginoj, m5 = msfp1, m6 = msfp1
{
  double gneuticharjffp2sfpsfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);
  
  gneuticharjffp2sfpsfpdgauss = 2*fabs(m1)*pow(pow(E,2)-pow(m2,2),0.5)*pow(squareplus*squareminus,0.5)*(s-pow(m3,2)-pow(m4,2))/(s*(s-pow(m5,2))*(s-pow(m6,2)));

  return gneuticharjffp2sfpsfpdgauss;
}

double gneuticharjffp3sfpsfpdgauss(double E) /// m1 = mneutralinoi, m2 = mfp, m3 = -mf, m4 = charginoj, m5 = msfp1, m6 = msfp1
{
  double gneuticharjffp3sfpsfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);
  
  gneuticharjffp3sfpsfpdgauss = 2*fabs(m1)*pow(pow(E,2)-pow(m2,2),0.5)*pow(squareplus*squareminus,0.5)*2*fabs(m1)*E/(s*(s-pow(m5,2))*(s-pow(m6,2)));

  return gneuticharjffp3sfpsfpdgauss;
}

double gneuticharjffp4sfpsfpdgauss(double E) /// m1 = mneutralinoi, m2 = mfp, m3 = -mf, m4 = charginoj, m5 = msfp1, m6 = msfp1
{
  double gneuticharjffp4sfpsfpdgauss = 0, s = 0, squareplus = 0, squareminus = 0;
  s = pow(m1,2) + pow(m2,2) - 2*fabs(m1)*E;
  squareplus = s - pow(m3+m4,2);
  squareminus = s - pow(m3-m4,2);
  
  gneuticharjffp4sfpsfpdgauss = 2*fabs(m1)*pow(pow(E,2)-pow(m2,2),0.5)*pow(squareplus*squareminus,0.5)*2*fabs(m1)*E*(s-pow(m3,2)-pow(m4,2))/(s*(s-pow(m5,2))*(s-pow(m6,2)));

  return gneuticharjffp4sfpsfpdgauss;
}

///Functions for 1->3 decays via dgauss:

double gluinoamplitudedecaydgausscharginoqqpbarfirsttwogen (double mgluino, double mchargino, double mquark, double mquarkp, double msqL, double msqpL, double g, double thetaL, double thetaR, double alphas, int charg, int onetothree)
{
  double amplitudeW=0, Au=0, Ad=0, psiu=0, psid=0, phiI=0, upper=0;
  upper = (pow(mgluino,2)-2*mquark*fabs(mchargino)-pow(mchargino,2))/(2*mgluino);
  ///cout << "mgluino = " << mgluino << " mchargino = " << mchargino << " mquark = " << mquark << " mquarkp = " << mquarkp << " msqL = " << msqL << " msqpL = " << msqpL << " upper = " << upper << endl;

  if (onetothree == 0) {
    amplitudeW = 0;
  }
  else if (onetothree == 1) {
    
    if(mgluino < mchargino+mquark+mquarkp) {
      amplitudeW = 0;
    }
    else if (mgluino > msqL + mquark || mgluino > msqpL + mquarkp) {
	amplitudeW = 0; /// 1->3 decay not relevant here if one to two decay open
      }

    else {
      if (charg == 1) /// chargino1 decaying
      {
	Ad = g*sin(thetaR); 
	Au = g*sin(thetaL);
      }
    else if (charg == 2) ///chargino2 decaying
      {
	Ad = g*cos(thetaR);
	Au = g*cos(thetaL);
      }

      m1 = mgluino, m2 = msqL, m3 = msqL, m4 = mchargino, mq = mquark;
      ///cout << "mgluinoused = " << m1 << " muLused = " << m2 << " mdLused = " << m3 << " mcharginoused = " << m4 << " mqused = " << mq << endl;
      psiu = dgauss(gpsitildadgauss,mquark,upper,accuracy)*1/(pow(PI,2)*m1);
      m1 = mgluino, m2 = msqpL, m3 = msqpL, m4 = mchargino, mq = mquarkp;
      psid = dgauss(gpsitildadgauss,mquark,upper,accuracy)*1/(pow(PI,2)*m1);
      m1 = mgluino, m2 = msqL, m3 = msqpL, m4 = mchargino, mq = mquark; ///Note mq isn't important really for these modes as they are first two gen quarks
      ///cout << "mgluinoused = " << m1 << " muLused = " << m2 << " mdLused = " << m3 << " mcharginoused = " << m4 << " mqused = " << mq << endl;
      phiI = dgauss(gphitildadgauss,mq,upper,accuracy)*1/(pow(PI,2)*m1);
      
      amplitudeW = alphas/(16*pow(PI,2))*(pow(Ad,2)*psiu + pow(Au,2)*psid + 2*Au*Ad*phiI);
      ///cout << "Au = " << Au << " Ad = " << Ad << endl;
      ///cout << "alphas = " << alphas << endl;
      ///cout << "phiI = " << phiI << " psiu = " << psiu << " psid = " << psid << endl;
	
	}
  }
  return amplitudeW;
}




double gluinoamplitudedecaydgaussneutralinoqqpbarfirsttwogen (double mgluino, double mneutralino, double msqL, double msqR, double mquark, double g, double gp, DoubleMatrix mixNeut, double alphas, char uord, int neut, int onetothree)/// m1 is mgluino, m2 is neutralinoi mass, m3 is sqL mass, m4 is sqR mass, m5 is quark mass but assumed zero in calculation here, just used to check allowed for now; char uord tells us if the quark is u type 'u' or d type 'd', int neut tells us which neutralino it is
{
  double amplitudeW=0, phiL=0, phiR=0, psiL=0, psiR=0, A = 0, B = 0, from = 0, upper = 0;
  int i = neut;
  from = mquark;
  upper = (pow(mgluino,2)-2*mquark*fabs(mneutralino)-pow(mneutralino,2))/(2*mgluino);
  ///cout << "mgluino = " << mgluino << " mneutralino = " << mneutralino << " mquark = " << mquark << " upper = " << upper << endl;
  if(onetothree == 0)
    {
      amplitudeW = 0;
    }
  else if (onetothree == 1)
    {  
      if(mgluino < fabs(mneutralino) + 2*mquark) {
      	amplitudeW =0; 
      }
      else if (mgluino > msqL + mquark || mgluino > msqR + mquark) {
      	amplitudeW = 0; /// 1->3 decay not relevant here if one to two decay open
      }
      else {
	if ( uord == 'u') {
	  A = 1/(pow(2,0.5))*(g*-mixNeut(i,2)+gp/3*-mixNeut(i,1));
	  B = 4/(3*pow(2,0.5))*gp*-mixNeut(i,1);
	}
	else if (uord == 'd') {
	  A = 1/(pow(2,0.5))*(-g*-mixNeut(i,2) + gp/3*-mixNeut(i,1));
	  B = -2/(3*pow(2,0.5))*gp*-mixNeut(i,1);
	}

	m1 = mgluino; mq = mquark; m4 = mneutralino; m2 = msqL; m3 = msqL;
	
	psiL = dgauss(gpsitildadgauss,from,upper,accuracy)*1/(pow(PI,2)*m1);
	phiL = dgauss(gphitildadgauss,from,upper,accuracy)*1/(pow(PI,2)*m1);
	m1 = mgluino; mq = mquark; m4 = mneutralino; m2 = msqR; m3 = msqR;
	
	psiR = dgauss(gpsitildadgauss,from,upper,accuracy)*1/(pow(PI,2)*m1);
	phiR = dgauss(gphitildadgauss,from,upper,accuracy)*1/(pow(PI,2)*m1);

	cout << "psiL = " << psiL << " psiR = " << psiR << " phiL = " << phiL << " phiR = " << phiR << endl;
	amplitudeW = alphas/(8*pow(PI,2))*(pow(A,2)*(psiL + phiL) + pow(B,2)*(psiR + phiR));
	// cout << amplitudeW << endl;

	// cout << "!!!" << endl;
	// cout << "Neutralino" << neut << endl;
	// cout << "Gammast1equiv = " << pow(A,2)*(psiL + phiL)*pow(PI,2)*m1 << endl;
	// cout << "Gammast2equiv = " << pow(B,2)*(psiR + phiR)*pow(PI,2)*m1 << endl;
	// cout << "alphast1 = " << A << endl;
	// cout << "alphast2 = " << B << endl;
	// cout << "psitilda(mg,mqL,mZi) = " << psiL << endl;
	// cout << "phitilda(mg,mqL,mZi) = " << phiL << endl;
	// cout << "psitilda(mg,mqR,mZi) = " << psiR << endl;
	// cout << "phitilda(mg,mqR,mZi) = " << phiR << endl;
	// cout << "prefactor = " << alphas/(8*pow(PI,2)) << endl;
	// cout << "!!!" << endl;

	// if (neut == 3 && uord == 'u') {
	//   cout << "GammaLLst1equiv = " << pow(A,2)*(psiL + phiL)*pow(PI,2)*m1 << endl;
	//   cout << "GammaRRst2equiv = " << pow(B,2)*(psiR + phiR)*pow(PI,2)*m1 << endl;
	//   cout << "Sum of equivs = " << pow(A,2)*(psiL + phiL)*pow(PI,2)*m1 + pow(B,2)*(psiR + phiR)*pow(PI,2)*m1 << endl;
	//   cout << "Difference of equivs = " << pow(A,2)*(psiL + phiL)*pow(PI,2)*m1 - pow(B,2)*(psiR + phiR)*pow(PI,2)*m1 << endl;
	// }
	// else if (neut == 3 && uord == 'd') {
	//   cout << "GammaLLsb1equiv = " << pow(A,2)*(psiL + phiL)*pow(PI,2)*m1 << endl;
	//   cout << "GammaRRsb2equiv = " << pow(B,2)*(psiR + phiR)*pow(PI,2)*m1 << endl;
	//   cout << "Sum of equivs = " << pow(A,2)*(psiL + phiL)*pow(PI,2)*m1 + pow(B,2)*(psiR + phiR)*pow(PI,2)*m1 << endl;
	//   cout << "Difference of equivs = " << pow(A,2)*(psiL + phiL)*pow(PI,2)*m1 - pow(B,2)*(psiR + phiR)*pow(PI,2)*m1 << endl;
	// }
	///cout << "alphas = " << alphas << endl;
	// cout << "GammaLLst1 in limit equiv: " << pow(A,2)*(psiL + (mneutralino)/(fabs(mneutralino))*phiL)*(pow(PI,2)*m1) <<  " GammaRRst2 in limit equiv: " << pow(B,2)*(psiR + (mneutralino)/(fabs(mneutralino))*phiR)*(pow(PI,2)*m1) << endl;
      }
    }
  return amplitudeW;
}







double gluinoamplitudedecaydgaussneutralinottbar (double mgluino, double mst1, double mst2, double mneutralino, double mt, double mWboson, double g, double gp, double thetat, double beta, double alphas, DoubleMatrix mixNeut, double runmt, int neutralino, int onetothree, char torb) ///calculates PW for gluino -> neutralino + q qbar pair where q are t 
{
  double amplitudeW=0, Gammast1=0, Gammast2=0, Gammast1st2=0;
  double AtZ=0, BtZ=0, ft=0, from=0, upper=0;

  from = mt;
  upper = (pow(mgluino,2)-2*mt*fabs(mneutralino)-pow(mneutralino,2))/(2*mgluino);
  ///mneutralino = fabs(mneutralino);
  double gs = pow(alphas*4*PI,0.5);

  

  if (fabs(mgluino) < fabs(mneutralino) + 2*mt || fabs(mgluino)> mst1 + mt || fabs(mgluino) > mst2 + mt || onetothree ==0) { amplitudeW = 0;}
  else {
    
  
    if (torb == 't') {
      ft = g*runmt/(pow(2,0.5)*mWboson*sin(beta));
     
    }
    
    else if (torb == 'b') {
      ft = g*runmt/(pow(2,0.5)*mWboson*cos(beta));
     
    }


    // cout << "gs = " << gs << endl;
    // cout << "thetat = " << thetat << endl;
    // cout << "gs/sqrt(2)*cos(thetat) = " << gs*cos(thetat)/pow(2,0.5) << endl;
    // cout << "gs/sqrt(2)*sin(thetat) = " << gs*sin(thetat)/pow(2,0.5) << endl;
    // cout << "st1alpha1 = " << st1alpha1 << endl;
    // cout << "st1beta1 = " << st1beta1 << endl;
    // cout << "st2alpha1 = " << st2alpha1 << endl;
    // cout << "st2beta1 = " << st2beta1 << endl;

    // cout << "Yukawa = " << ft << endl;
    // // cout << "st1alpha2 = " << st1alpha2 << endl;
    // // cout << "st1beta2 = " << st1beta2 << endl;
    // // cout << "st2alpha2 = " << st2alpha2 << endl;
    // cout << "st2beta2 = " << st2beta2 << endl;

    double psiLLst1=0, chiLLst1=0, phiLLst1=0, rhoLLst1=0, xsiLLst1=0;
    
    m1 = mgluino, mq = mt, m2 = mst1, m3 = mst1, m4 = mneutralino;
    ///cout << "m1 = " << m1 << " mq = " << mq << " m2 = " << m2 << " m3 = " << m3 << " m4 = " << m4 << " from = " << from << " upper = " << upper << endl;
    psiLLst1 = dgauss(gpsitildadgauss,from,upper,accuracy);
    phiLLst1 = dgauss(gphitildadgauss,from,upper,accuracy);
    chiLLst1 = dgauss(gchidgauss,from,upper,accuracy); ///Check no *1/(pow(PI,2)*m1) factor required if this function isn't working
    rhoLLst1 = dgauss(grhodgauss,from,upper,accuracy); ///Check no *1/(pow(PI,2)*m1) factor required if this function isn't working
    xsiLLst1 = dgauss(gxsidgauss,from,upper,accuracy);
 
 
    double zetaL1R1st1=0, XL1R1st1=0;
    zetaL1R1st1 = dgauss(gzetadgauss,from,upper,accuracy);
    XL1R1st1 = dgauss(gXdgauss,from,upper,accuracy);
   
    double YL1R2st1=0;
    YL1R2st1 = dgauss(gYdgauss,from,upper,accuracy);
        
    double psiLLst2=0, chiLLst2=0, phiLLst2=0, rhoLLst2=0, xsiLLst2=0;

    m1 = mgluino, mq = mt, m2 = mst2, m3 = mst2, m4 = mneutralino;
    psiLLst2 = dgauss(gpsitildadgauss,from,upper,accuracy);
    phiLLst2 = dgauss(gphitildadgauss,from,upper,accuracy);
    chiLLst2 = dgauss(gchidgauss,from,upper,accuracy); ///Check no *1/(pow(PI,2)*m1) factor required if this function isn't working
    rhoLLst2 = dgauss(grhodgauss,from,upper,accuracy); ///Check no *1/(pow(PI,2)*m1) factor required if this function isn't working
    xsiLLst2 = dgauss(gxsidgauss,from,upper,accuracy);
    
 
    cout << "In GammaLLst2:::" << endl;
    cout << psiLLst2 << endl;
    cout << chiLLst2 << endl;
    cout << phiLLst2 << endl;
    cout << rhoLLst2 << endl;
    cout << xsiLLst2 << endl;
 
    double zetaL1R1st2=0, XL1R1st2=0;
    zetaL1R1st2 = dgauss(gzetadgauss,from,upper,accuracy);
    XL1R1st2 = dgauss(gXdgauss,from,upper,accuracy);
    
   
    double YL1R2st2=0;
    YL1R2st2 = dgauss(gYdgauss,from,upper,accuracy);

 
    double phitildaLLst1st2=0, rhotildaLLst1st2=0, xsiLLst1st2=0;
    m1 = mgluino, mq = mt, m2 = mst1, m3 = mst2, m4 = mneutralino;
    phitildaLLst1st2 = dgauss(gphitildadgauss,from,upper,accuracy);
    rhotildaLLst1st2 = dgauss(grhodgauss,from,upper,accuracy);
    xsiLLst1st2 = dgauss(gxsidgauss,from,upper,accuracy);

 
    double zetaLRst1st2=0, XLRst1st2=0, YLRst1st2=0, chiprimeLRst1st2=0;
    zetaLRst1st2 = dgauss(gzetadgauss,from,upper,accuracy);
    XLRst1st2 = dgauss(gXdgauss,from,upper,accuracy);
    YLRst1st2 = dgauss(gYdgauss,from,upper,accuracy);
    chiprimeLRst1st2 = dgauss(gchiprimedgauss,from,upper,accuracy);
    
 
 
    Complex ast1alpha1(0.0,0.0), ast1beta1(0.0,0.0), ast2alpha1(0.0,0.0), ast2beta1(0.0,0.0), aAtZ(0.0,0.0), aBtZ(0.0,0.0), aft(0.0,0.0);
    ast1alpha1 = Complex(1.0,2.0);
    // cout << "REAL OF COMPLEX" << ast1alpha1.real() << endl;
    // cout << "IMAG OF COMPLEX" << ast1alpha1.imag() << endl;
    // cout << "Square = " << ast1alpha1*ast1alpha1 << endl;
    // cout << "mod = " << abs(ast1alpha1) << endl;
    double pm = 0;
    
    if (torb == 't') {

      if (mneutralino >=0) {
	ast1alpha1 = Complex(AtZ*cos(thetat) - ft*mixNeut(neutralino,4)*sin(thetat),0.0);
	ast1beta1 = Complex(ft*mixNeut(neutralino,4)*cos(thetat) + BtZ*sin(thetat),0.0);
	ast2alpha1 = Complex(AtZ*sin(thetat)+ft*mixNeut(neutralino,4)*cos(thetat),0.0);
	ast2beta1 = Complex(ft*mixNeut(neutralino,4)*sin(thetat)-BtZ*cos(thetat),0.0);
	cout << "ast1alpha1 = " << ast1alpha1 << endl;
	pm = 1;
      } 


      // cout << mneutralino << endl;
      
      if (mneutralino < 0)
	{
	  ast1alpha1 = Complex(0,-(AtZ*cos(thetat) - ft*mixNeut(neutralino,4)*sin(thetat)));
	  ast1beta1 = Complex(0,-(ft*mixNeut(neutralino,4)*cos(thetat) + BtZ*sin(thetat)));
	  ast2alpha1 = Complex(0,-(AtZ*sin(thetat)+ft*mixNeut(neutralino,4)*cos(thetat)));
	  ast2beta1 = Complex(0,-(ft*mixNeut(neutralino,4)*sin(thetat)-BtZ*cos(thetat)));
	  pm = -1;
	}
      
    }

    else if (torb == 'b') {

      if (mneutralino >=0) {
	ast1alpha1 = Complex(AtZ*cos(thetat) - ft*mixNeut(neutralino,3)*sin(thetat),0.0);
	ast1beta1 = Complex(ft*mixNeut(neutralino,3)*cos(thetat) + BtZ*sin(thetat),0.0);
	ast2alpha1 = Complex(AtZ*sin(thetat)+ft*mixNeut(neutralino,3)*cos(thetat),0.0);
	ast2beta1 = Complex(ft*mixNeut(neutralino,3)*sin(thetat)-BtZ*cos(thetat),0.0);
	cout << "ast1alpha1 = " << ast1alpha1 << endl;
	pm = 1;
      } 


      // cout << mneutralino << endl;
      
      if (mneutralino < 0)
	{
	  ast1alpha1 = Complex(0,-(AtZ*cos(thetat) - ft*mixNeut(neutralino,3)*sin(thetat)));
	  ast1beta1 = Complex(0,-(ft*mixNeut(neutralino,3)*cos(thetat) + BtZ*sin(thetat)));
	  ast2alpha1 = Complex(0,-(AtZ*sin(thetat)+ft*mixNeut(neutralino,3)*cos(thetat)));
	  ast2beta1 = Complex(0,-(ft*mixNeut(neutralino,3)*sin(thetat)-BtZ*cos(thetat)));
	  pm = -1;
	}

    }
      
   
      ///Note the effect of the complex couplings and the pm factors for negative masses cancel out as the couplings always appear in pairs so multiplying them gives an extra minus sign when they are purely imaginary, but this extra minus sign is cancelled out by the extra minus sign in the pm factor. Therefore really the additional minus signs come from the fact I've used the neutralino mass itself throughout my calculation (rather than its absolute value) which therefore naturally introduces additional minus signs.

    // cout << "Comparison of before and after complexisation: " << endl;
    // // cout << "ft: " << ft << " " << aft << endl;
    // // cout << "AtZ: " << AtZ << " " << aAtz << endl;
    // // cout << "BtZ: " << BtZ << " " << aBtz << endl;
    
    // cout << "st1alpha1: " << st1alpha1 << " " << ast1alpha1 << endl;
    // cout << "st2alpha1: " << st2alpha1 << " " << ast2alpha1 << endl;
    // cout << "st1beta1: " << st1beta1 << " " << ast1beta1 << endl;
    // cout << "st2beta1: " << st2beta1 << " " << ast2beta1 << endl;
    // cout << endl;
    // cout << "st1alpha1^2: " << pow(st1alpha1,2) << " " << ast1alpha1*ast1alpha1 << endl;
    // cout << "st2alpha1^2: " << pow(st2alpha1,2) << " " << ast2alpha1*ast2alpha1 << endl;
    // cout << "st1beta1^2: " << pow(st1beta1,2) << " " << ast1beta1*ast1beta1 << endl;
    // cout << "st2beta1^2: " << pow(st2beta1,2) << " " << ast2beta1*ast2beta1 << endl;
    // cout << "st1alpha1^2 + st1beta1^2: " << pow(st1alpha1,2) + pow(st1beta1,2) << " " << ast1alpha1*ast1alpha1 + ast1beta1*ast1beta1 << endl;
    // cout << "st2alpha1^2 + st2beta1^2: " << pow(st2alpha1,2) + pow(st2beta1,2) << " " << ast2alpha1*ast2alpha1 + ast2beta1*ast2beta1 << endl;
    // cout << "st1alpha1*st1beta1: " << st1alpha1*st1beta1 << ""  << ast1alpha1*ast1beta1 << endl;
    // cout << "st2alpha1*st2beta1: " << st2alpha1*st2beta1 << " " << ast2alpha1*ast2beta1 << endl;
	
    
    Complex aGammast1 = Complex(0.0,0.0), aextraGammast1 = Complex(0.0,0.0);

    aGammast1 = (ast1alpha1*ast1alpha1+ast1beta1*ast1beta1)*psiLLst1*pm + 4*pm*mt*mneutralino*chiLLst1*ast1alpha1*ast1beta1 - 4*sin(thetat)*cos(thetat)*(ast1alpha1*ast1alpha1 + ast1beta1*ast1beta1)*mgluino*mt*XL1R1st1*pm - 8*pm*sin(thetat)*cos(thetat)*(ast1alpha1*ast1beta1)*mgluino*mt*mt*mneutralino*zetaL1R1st1 - 2*pm*sin(thetat)*cos(thetat)*ast1alpha1*ast1beta1*YL1R2st1 + pm*(ast1alpha1*ast1alpha1*pow(cos(thetat),2) + ast1beta1*ast1beta1*pow(sin(thetat),2))*phiLLst1 - pm*2*mt*mt*sin(thetat)*cos(thetat)*ast1alpha1*ast1beta1*xsiLLst1 + pm*mgluino*mt*ast1alpha1*ast1beta1*xsiLLst1 - pm*mgluino*mt*ast1alpha1*ast1beta1*pow(mneutralino,2)*rhoLLst1 + pm*mgluino*mt*mt*mneutralino*(pow(sin(thetat),2)*ast1alpha1*ast1alpha1 + pow(cos(thetat),2)*ast1beta1*ast1beta1)*rhoLLst1;

    // cout<< -pm*16*pow(gs,2)*sin(thetat)*cos(thetat)*pow(mgluino/PI,2)*YL1R2st1*ast1alpha1*ast1beta1 + 8*pow(gs,2)*mgluino*mneutralino*mgluino/(pow(PI,2)*mneutralino)*phiLLst1*(ast1alpha1*ast1alpha1*pow(cos(thetat),2)+ast1beta1*ast1beta1*pow(sin(thetat),2)) -pm*16*pow(gs,2)*pow(mt,2)*sin(thetat)*cos(thetat)*pow(mgluino/PI,2)*xsiLLst1*ast1alpha1*ast1beta1 + pm*pow(gs,2)*mgluino*mt*(8*pow(mgluino/PI,2)*xsiLLst1 - 4*pow(mgluino/PI,2)*(pow(mgluino,2)+pow(mneutralino,2))*rhoLLst1 + 8*pow(mgluino/PI,2)*chiprimeL1R2st1)*ast1alpha1*ast1beta1 -pow(gs,2)*mneutralino*mt*sin(thetat)*cos(thetat)*(-8*pow(mgluino/PI,2)*xsiLLst1 + 8*pow(mgluino,4)/pow(PI,2)*rhoLLst1 - 8*pow(mgluino/PI,2)*chiprimeL1R2st1)*(ast1alpha1*ast1alpha1+ast1beta1*ast1beta1) + pm*pow(gs,2)*mgluino*mt*(4*pow(mgluino/PI,2)*(pow(mgluino,2)-pow(mneutralino,2))*rhoLLst1 - 8*pow(mgluino/PI,2)*chiprimeL1R2st1)*ast1alpha1*ast1beta1 -pow(gs,2)*mneutralino*mt*sin(thetat)*cos(thetat)*8*pow(mgluino/PI,2)*chiprimeL1R2st1*(ast1alpha1*ast1alpha1+ast1beta1*ast1beta1) + 8*pow(gs,2)*mgluino*pow(mt,2)*mneutralino*pow(mgluino/PI,2)*rhoLLst1*(pow(sin(thetat),2)*ast1alpha1*ast1alpha1 + pow(cos(thetat),2)*ast1beta1*ast1beta1) << endl;
    
    Gammast1 = aGammast1.real();


    double extraGammast1 = 0;
    aextraGammast1 = -pm*mneutralino*mt*sin(thetat)*cos(thetat)*(ast1alpha1*ast1alpha1 + ast1beta1*ast1beta1)*pow(mgluino,2)*rhoLLst1 + pm*mneutralino*mt*sin(thetat)*cos(thetat)*(ast1alpha1*ast1alpha1 + ast1beta1*ast1beta1)*xsiLLst1;
    extraGammast1 = aextraGammast1.real();


    Complex aGammast2 = Complex(0.0,0.0), aextraGammast2 = Complex(0.0,0.0);
    aGammast2 = pm*(ast2alpha1*ast2alpha1 + ast2beta1*ast2beta1)*psiLLst2 + 4*pm*mt*mneutralino*chiLLst2*ast2alpha1*ast2beta1 + 4*mgluino*mt*sin(thetat)*cos(thetat)*(ast2alpha1*ast2alpha1 + ast2beta1*ast2beta1)*XL1R1st2*pm + 8*pm*sin(thetat)*cos(thetat)*ast2alpha1*ast2beta1*mgluino*pow(mt,2)*mneutralino*zetaL1R1st2 + pm*2*sin(thetat)*cos(thetat)*ast2alpha1*ast2beta1*YL1R2st2 + pm*(pow(sin(thetat),2)*ast2alpha1*ast2alpha1 + pow(cos(thetat),2)*ast2beta1*ast2beta1)*phiLLst2 + pm*xsiLLst2*(2*pow(mt,2)*sin(thetat)*cos(thetat)*ast2alpha1*ast2beta1 + mgluino*mt*ast2alpha1*ast2beta1) + pm*rhoLLst2*(-mgluino*mt*pow(mneutralino,2)*ast2alpha1*ast2beta1) + pm*rhoLLst2*mgluino*mneutralino*pow(mt,2)*(pow(cos(thetat),2)*ast2alpha1*ast2alpha1 + pow(sin(thetat),2)*ast2beta1*ast2beta1);
    Gammast2 = aGammast2.real();




    double extraGammast2 = 0;
    // extraGammast2 = pow(PI,2)/(8*pow(mgluino*gs,2))*(8*pow(mgluino*gs/PI,2)*(rhoLLst2*pow(mgluino,2)*mneutralino*mt*sin(thetat)*cos(thetat)*(pow(st2alpha1,2)+pow(st2beta1,2)) + mneutralino*mt*sin(thetat)*cos(thetat)*(pow(st2alpha1,2) + pow(st2beta1,2))*xsiLLst2)); /// Note no chiprime term whereas Spheno has a chiprime term -> missing term relative to T&B
    aextraGammast2 = pm*(xsiLLst2*-mneutralino*mt*sin(thetat)*cos(thetat)*(ast2alpha1*ast2alpha1 + ast2beta1*ast2beta1) + rhoLLst2*pow(mgluino,2)*mneutralino*mt*sin(thetat)*cos(thetat)*(ast2alpha1*ast2alpha1 + ast2beta1*ast2beta1));
    extraGammast2 = aextraGammast2.real();



    Complex aGammast1st2 = Complex(0.0,0.0), aextraGammast1st2 = Complex(0.0,0.0);
    aGammast1st2 = pow(PI,2)/(8*pow(mgluino*gs,2))*(32*pow(mgluino*gs/PI,2)*pm*mgluino*mt*(pow(cos(thetat),2)-pow(sin(thetat),2))*(ast1alpha1*ast2alpha1 + ast1beta1*ast2beta1)*XLRst1st2 + 32*pm*pow(mgluino*gs/PI,2)*mgluino*pow(mt,2)*mneutralino*(ast1alpha1*ast2beta1 + ast1beta1*ast2alpha1)*(pow(cos(thetat),2)-pow(sin(thetat),2))*zetaLRst1st2 + pm*16*pow(mgluino*gs/PI,2)*(ast1beta1*ast2alpha1*pow(cos(thetat),2) - pow(sin(thetat),2)*ast2beta1*ast1alpha1)*YLRst1st2 + 16*pm*pow(mgluino*gs/PI,2)*sin(thetat)*cos(thetat)*(ast1alpha1*ast2alpha1 - ast1beta1*ast2beta1)*phitildaLLst1st2 + 16*pm*pow(mgluino*gs/PI,2)*mt*mneutralino*(ast1alpha1*ast2alpha1 - ast1beta1*ast2beta1)*chiprimeLRst1st2 + pm*16*pow(mgluino*gs/PI,2)*pow(mt,2)*(pow(cos(thetat),2)*ast1alpha1*ast2beta1 - pow(sin(thetat),2)*ast1beta1*ast2alpha1)*xsiLLst1st2 + 16*pm*pow(mgluino*gs/PI,2)*mgluino*pow(mt,2)*mneutralino*(ast1beta1*ast2beta1-ast1alpha1*ast2alpha1)*sin(thetat)*cos(thetat)*rhotildaLLst1st2);

    Gammast1st2 =  aGammast1st2.real(); ///Gammast1st2 terms as from T&B but with sign change for X term and also the factor of -(cos^2(thetat)-sin^2(thetat))(st1alpha1*st2alpha1+st1beta1*st2beta1) T&B has in the chiprime term has been changed to (cos^2(thetat)+sin^2(thetat))(st1alpha1*st2alpha1 - st1beta1*st2beta1) = 1*(st1alpha1*st2alpha1 - st1beta1*st2beta1), in order in both cases to agree with SPHENO
    double extraGammast1st2 = 0; 
    aextraGammast1st2 = (pow(PI,2)/(8*pow(mgluino*gs,2))*(-32*pm*pow(mgluino*gs/PI,2)*sin(thetat)*cos(thetat)*mgluino*mt*(ast1alpha1*ast2beta1-ast1beta1*ast2alpha1)*chiprimeLRst1st2 -16*pm*pow(mgluino*gs/PI,2)*sin(thetat)*cos(thetat)*mgluino*mt*(ast1alpha1*ast2beta1 - ast1beta1*ast2alpha1)*xsiLLst1st2 + 16*pm*pow(mgluino*gs/PI,2)*mt*mneutralino*(pow(sin(thetat),2)*ast1alpha1*ast2alpha1 - pow(cos(thetat),2)*ast1beta1*ast2beta1)*xsiLLst1st2 + 16*pm*pow(mgluino*gs/PI,2)*pow(mgluino,3)*mt*(ast1alpha1*ast2beta1-ast1beta1*ast2alpha1)*sin(thetat)*cos(thetat)*rhotildaLLst1st2 - 16*pm*pow(mgluino*gs/PI,2)*pow(mgluino,2)*mt*mneutralino*(pow(sin(thetat),2)*ast1alpha1*ast2alpha1 - pow(cos(thetat),2)*ast1beta1*ast2beta1)*rhotildaLLst1st2)); ///Extra terms SPHENO has in Gammast1st2 not present in T&B



    extraGammast1st2 = aextraGammast1st2.real();

    amplitudeW = (alphas)/(8*pow(PI,4)*mgluino)*(Gammast1+Gammast2+Gammast1st2+extraGammast1+extraGammast2+extraGammast1st2);

  }

      // cout << "amplitude for neutralino" << neutralino << " = " << amplitudeW << endl;

  return amplitudeW;
}



// double gluinoamplitudedecaydgaussneutralinobbbar (double mgluino, double msb1, double msb2, double mneutralino, double mb, double mWboson, double g, double gp, double thetab, double beta, double alphas, DoubleMatrix mixNeut, double runmb, int neutralino, int onetothree) ///calculates PW for gluino -> neutralino + q qbar pair where q are b 
// {
//   double amplitudeW=0, Gammasb1=0, Gammasb2=0, Gammasb1sb2=0, GammaLLsb1=0, GammaRRsb1=0, GammaL1R1sb1=0, GammaL1R2sb1=0, GammaLLsb2=0, GammaRRsb2=0, GammaL1R1sb2=0, GammaLLsb1sb2=0, GammaRRsb1sb2=0, GammaRLsb1sb2=0, GammaL2R2sb1=0, GammaL2R1sb1=0, GammaL2R2sb2=0, GammaL2R1sb2=0, GammaL1R2sb2=0, GammaLRsb1sb2=0;
//   double AbZ=0, BbZ=0, sb1alpha1=0, sb1beta1=0, sb2alpha1=0, sb2beta1=0, fb=0, from=0, upper=0;

//   // mb = 200;
//   // runmb = 17.93527128;
//   cout << "mb = " << mb << " runmb = " << runmb << endl;
//   mb = 4.199999999999997;
//   cout << "mb used = " << mb << endl;
//   from = mb;
//   upper = (pow(mgluino,2)-2*mb*fabs(mneutralino)-pow(mneutralino,2))/(2*mgluino);
 
//   if (fabs(mgluino) < fabs(mneutralino) + 2*mb || fabs(mgluino)> msb1 + mb || fabs(mgluino) > msb2 + mb || onetothree ==0) { amplitudeW = 0;}
//   else {

//     AbZ = g/(pow(2,0.5))*mixNeut(neutralino,2) - gp/(3*pow(2,0.5))*mixNeut(neutralino,1);
//     BbZ = 2*gp/(pow(2,0.5)*3)*mixNeut(neutralino,1);
//     fb = g*runmb/(pow(2,0.5)*mWboson*cos(beta));
//     // fb = 1;
//     sb1alpha1 = AbZ*cos(thetab) - fb*mixNeut(neutralino,3)*sin(thetab);
//     sb1beta1 = fb*mixNeut(neutralino,3)*cos(thetab) + BbZ*sin(thetab);
//     sb2alpha1 = AbZ*sin(thetab)+fb*mixNeut(neutralino,3)*cos(thetab);
//     sb2beta1 = fb*mixNeut(neutralino,3)*sin(thetab) - BbZ*cos(thetab);
    
//     double gs = pow(alphas*4*PI,0.5);
//     cout << "gs = " << gs << endl;
//     // cout << "Spheno gs = " << 1.040861045 << endl;
//     // gs = 1.040861045; ///Set to SPheno's value for now

//     double psiLLsb1=0, chiLLsb1=0, phiLLsb1=0, rhoLLsb1=0, xsiLLsb1=0;
    
//     m1 = mgluino, mq = mb, m2 = msb1, m3 = msb1, m4 = mneutralino; ///m4 = fabs(mneutralino);
//     ///cout << "m1 = " << m1 << " mq = " << mq << " m2 = " << m2 << " m3 = " << m3 << " m4 = " << m4 << " from = " << from << " upper = " << upper << endl;
//     psiLLsb1 = dgauss(gpsitildadgauss,from,upper,accuracy);
//     phiLLsb1 = dgauss(gphitildadgauss,from,upper,accuracy);
//     chiLLsb1 = dgauss(gchidgauss,from,upper,accuracy); ///Check no *1/(pow(PI,2)*m1) factor required if this function isn't working
//     rhoLLsb1 = dgauss(grhodgauss,from,upper,accuracy); ///Check no *1/(pow(PI,2)*m1) factor required if this function isn't working
//     xsiLLsb1 = dgauss(gxsidgauss,from,upper,accuracy);

//     double zetaL1R1sb1=0, XL1R1sb1=0;
//     zetaL1R1sb1 = dgauss(gzetadgauss,from,upper,accuracy);
//     XL1R1sb1 = dgauss(gXdgauss,from,upper,accuracy);
    
//     double YL1R2sb1=0, chiprimeL1R2sb1=0;
//     YL1R2sb1 = dgauss(gYdgauss,from,upper,accuracy);
//     chiprimeL1R2sb1 = dgauss(gchiprimedgauss,from,upper,accuracy);

//     double psiLLsb2=0, chiLLsb2=0, phiLLsb2=0, rhoLLsb2=0, xsiLLsb2=0;

//     m1 = mgluino, mq = mb, m2 = msb2, m3 = msb2, m4 = mneutralino; ///m4 = fabs(mneutralino);
//     psiLLsb2 = dgauss(gpsitildadgauss,from,upper,accuracy);
//     phiLLsb2 = dgauss(gphitildadgauss,from,upper,accuracy);
//     chiLLsb2 = dgauss(gchidgauss,from,upper,accuracy); ///Check no *1/(pow(PI,2)*m1) factor required if this function isn't working
//     rhoLLsb2 = dgauss(grhodgauss,from,upper,accuracy); ///Check no *1/(pow(PI,2)*m1) factor required if this function isn't working
//     xsiLLsb2 = dgauss(gxsidgauss,from,upper,accuracy);
    
//     double zetaL1R1sb2=0, XL1R1sb2=0;
//     zetaL1R1sb2 = dgauss(gzetadgauss,from,upper,accuracy);
//     XL1R1sb2 = dgauss(gXdgauss,from,upper,accuracy);
    
//     double YL1R2sb2=0, chiprimeL1R2sb2=0;
//     YL1R2sb2 = dgauss(gYdgauss,from,upper,accuracy);
//     chiprimeL1R2sb2 = dgauss(gchiprimedgauss,from,upper,accuracy);

//     double psitildaLLsb1sb2=0, chitildaLLsb1sb2=0, phitildaLLsb1sb2=0, rhotildaLLsb1sb2=0, xsiLLsb1sb2=0;
//     m1 = mgluino, mq = mb, m2 = msb1, m3 = msb2, m4 = fabs(mneutralino);
//     psitildaLLsb1sb2 = dgauss(gpsitildadgauss,from,upper,accuracy);
//     chitildaLLsb1sb2 = dgauss(gchidgauss,from,upper,accuracy);
//     phitildaLLsb1sb2 = dgauss(gphitildadgauss,from,upper,accuracy);
//     rhotildaLLsb1sb2 = dgauss(grhodgauss,from,upper,accuracy);
//     xsiLLsb1sb2 = dgauss(gxsidgauss,from,upper,accuracy);

//     double zetaLRsb1sb2=0, XLRsb1sb2=0, YLRsb1sb2=0, chiprimeLRsb1sb2=0, xsiLRsb1sb2=0;
//     zetaLRsb1sb2 = dgauss(gzetadgauss,from,upper,accuracy);
//     XLRsb1sb2 = dgauss(gXdgauss,from,upper,accuracy);
//     YLRsb1sb2 = dgauss(gYdgauss,from,upper,accuracy);
//     chiprimeLRsb1sb2 = dgauss(gchiprimedgauss,from,upper,accuracy);
//     xsiLRsb1sb2 = dgauss(gxsidgauss,from,upper,accuracy);

//     m1 = mgluino, mq = mb, m2 = msb2, m3 = msb1, m4 = mneutralino; ///m4 = fabs(mneutralino);
//     double zetaRLsb1sb2=0, XRLsb1sb2=0, YRLsb1sb2=0, chiprimeRLsb1sb2=0, xsiRLsb1sb2=0;
//     zetaRLsb1sb2 = dgauss(gzetadgauss,from,upper,accuracy);
//     XRLsb1sb2 = dgauss(gXdgauss,from,upper,accuracy);
//     YRLsb1sb2 = dgauss(gYdgauss,from,upper,accuracy);
//     chiprimeRLsb1sb2 = dgauss(gchiprimedgauss,from,upper,accuracy);

//     // GammaLLsb1 = (pow(sb1alpha1,2)+pow(sb1beta1,2))*psiLLsb1 - 4*mb*mneutralino*sb1alpha1*sb1beta1*chiLLsb1 + mgluino*(mneutralino*(pow(sb1alpha1,2)/(fabs(mgluino)*fabs(mneutralino))*phiLLsb1 + pow(sb1beta1,2)*pow(mb,2)*rhoLLsb1) - sb1alpha1*sb1beta1*mb*(xsiLLsb1 - pow(mneutralino,2)*rhoLLsb1));
    
//     // GammaRRsb1 = (pow(sb1beta1,2)+pow(sb1alpha1,2))*psiLLsb1 - 4*mb*mneutralino*sb1beta1*sb1alpha1*chiLLsb1 + mgluino*(mneutralino*(pow(sb1beta1,2)/(fabs(mgluino)*fabs(mneutralino))*phiLLsb1 + pow(sb1alpha1,2)*pow(mb,2)*rhoLLsb1) - sb1beta1*sb1alpha1*mb*(xsiLLsb1 - pow(mneutralino,2)*rhoLLsb1));

//     // GammaL1R1sb1 = 2*mgluino*((sb1alpha1*sb1beta1+sb1beta1*sb1alpha1)*mb*mneutralino*zetaL1R1sb1 - (sb1beta1*sb1beta1 + sb1alpha1*sb1alpha1)*XL1R1sb1);
//     // GammaL2R2sb1 = GammaL1R1sb1;

//     // GammaL1R2sb1 = sb1beta1*sb1alpha1*YL1R2sb1 + sb1alpha1*sb1beta1*pow(mb,2)*xsiLLsb1 - mb*mneutralino*(sb1alpha1*sb1alpha1+sb1beta1*sb1beta1)*chiprimeL1R2sb1;
//     // GammaL2R1sb1 = GammaL1R2sb1;

//     // GammaLLsb2 = (pow(sb2alpha1,2)+pow(sb2beta1,2))*psiLLsb2 - 4*mb*mneutralino*sb2alpha1*sb2beta1*chiLLsb2 + mgluino*(mneutralino*(pow(sb2alpha1,2)/(fabs(mgluino)*fabs(mneutralino))*phiLLsb2 + pow(sb2beta1,2)*pow(mb,2)*rhoLLsb2) - sb2alpha1*sb2beta1*mb*(xsiLLsb2 - pow(mneutralino,2)*rhoLLsb2));

//     // GammaRRsb2 = (pow(sb2beta1,2)+pow(sb2alpha1,2))*psiLLsb2 - 4*mb*mneutralino*sb2beta1*sb2alpha1*chiLLsb2 + mgluino*(mneutralino*(pow(sb2beta1,2)/(fabs(mgluino)*fabs(mneutralino))*phiLLsb2 + pow(sb2alpha1,2)*pow(mb,2)*rhoLLsb2) - sb2beta1*sb2alpha1*mb*(xsiLLsb2 - pow(mneutralino,2)*rhoLLsb2));

//     // GammaL1R1sb2 = 2*mgluino*((sb2alpha1*sb2beta1+sb2beta1*sb2alpha1)*mb*mneutralino*zetaL1R1sb2 - (sb2beta1*sb2beta1 + sb2alpha1*sb2alpha1)*XL1R1sb2);
//     // GammaL2R2sb2 = GammaL1R1sb2;

//     // GammaL1R2sb2 = sb2beta1*sb2alpha1*YL1R2sb2 + sb2alpha1*sb2beta1*pow(mb,2)*xsiLLsb2 - mb*mneutralino*(sb2alpha1*sb2alpha1+sb2beta1*sb2beta1)*chiprimeL1R2sb2;
//     // GammaL2R1sb2 = GammaL1R2sb2;

//     // GammaLLsb1sb2 = 2*(sb1alpha1*sb2alpha1+sb1beta1*sb2beta1)*psitildaLLsb1sb2 - 4*mb*mneutralino*(sb1alpha1*sb2beta1+sb2alpha1*sb1beta1)*chitildaLLsb1sb2 - mgluino*(-2*mneutralino*(sb1alpha1*sb2alpha1/(mgluino*fabs(mneutralino))*phitildaLLsb1sb2 + sb1beta1*sb2beta1*pow(mb,2)*rhotildaLLsb1sb2) + (sb1alpha1*sb2beta1+sb2alpha1*sb1beta1)*mb*(xsiLLsb1sb2 - pow(mneutralino,2)*rhotildaLLsb1sb2));

//     // GammaRRsb1sb2 = -2*(sb1alpha1*-sb2beta1+sb1beta1*sb2alpha1)*psitildaLLsb1sb2 - 4*mb*mneutralino*(sb1alpha1*sb2alpha1+-sb2beta1*sb1beta1)*chitildaLLsb1sb2 + mgluino*(-2*mneutralino*(sb1alpha1*-sb2beta1/(mgluino*fabs(mneutralino))*phitildaLLsb1sb2 + sb1beta1*sb2alpha1*pow(mb,2)*rhotildaLLsb1sb2) - (sb1alpha1*sb2alpha1+-sb2beta1*sb1beta1)*mb*(xsiLLsb1sb2 - pow(mneutralino,2)*rhotildaLLsb1sb2));

//     // GammaLRsb1sb2 = 4*mgluino*mb*(mb*mneutralino*(-sb1alpha1*-sb2beta1 + sb1beta1*sb2alpha1)*zetaLRsb1sb2 + (-sb2beta1*sb1beta1-sb1alpha1*sb2alpha1)*XLRsb1sb2) + 2*sb1beta1*sb2alpha1*YLRsb1sb2 + 2*mb*mneutralino*(sb1beta1*-sb2beta1-sb1alpha1*sb2alpha1)*chiprimeLRsb1sb2 - 2*sb1alpha1*-sb2beta1*pow(mb,2)*xsiLLsb1sb2;

//     // GammaRLsb1sb2 = -(4*mgluino*mb*(mb*mneutralino*(-sb2alpha1*-sb1beta1 + sb2beta1*sb1alpha1)*zetaLRsb1sb2 + (-sb1beta1*sb2beta1-sb2alpha1*sb1alpha1)*XLRsb1sb2) + 2*sb2beta1*sb1alpha1*YLRsb1sb2 + 2*mb*mneutralino*(sb2beta1*-sb1beta1-sb2alpha1*sb1alpha1)*chiprimeLRsb1sb2 - 2*sb2alpha1*-sb1beta1*pow(mb,2)*xsiLLsb1sb2);

//     // Gammasb1 = GammaLLsb1*pow(cos(thetab),2) + GammaRRsb1*pow(sin(thetab),2) - sin(thetab)*cos(thetab)*(GammaL1R1sb1+GammaL1R2sb1+GammaL2R1sb1+GammaL2R2sb1);

//     // Gammasb2 = GammaLLsb2*pow(sin(thetab),2) + GammaRRsb2*pow(cos(thetab),2) + sin(thetab)*cos(thetab)*(GammaL1R1sb2+GammaL1R2sb2+GammaL2R1sb2+GammaL2R2sb2);

//     // Gammasb1sb2 = (GammaLLsb1sb2+GammaRRsb1sb2)*sin(thetab)*cos(thetab) + GammaLRsb1sb2*pow(cos(thetab),2) + GammaRLsb1sb2*pow(sin(thetab),2);

//     ///Uncomment the code above and comment the code below to use the formulae as given in Baer and Tata rather than as in SPheno


//     Gammasb1 = (sb1alpha1*sb1alpha1+sb1beta1*sb1beta1)*psiLLsb1 + 4*mb*mneutralino*chiLLsb1*sb1alpha1*sb1beta1 - 4*sin(thetab)*cos(thetab)*(sb1alpha1*sb1alpha1 + sb1beta1*sb1beta1)*mgluino*mb*XL1R1sb1 - 8*sin(thetab)*cos(thetab)*(sb1alpha1*sb1beta1)*mgluino*mb*mb*mneutralino*zetaL1R1sb1 - 2*sin(thetab)*cos(thetab)*sb1alpha1*sb1beta1*YL1R2sb1 + (sb1alpha1*sb1alpha1*pow(cos(thetab),2) + sb1beta1*sb1beta1*pow(sin(thetab),2))*phiLLsb1 - 2*mb*mb*sin(thetab)*cos(thetab)*sb1alpha1*sb1beta1*xsiLLsb1 + mgluino*mb*sb1alpha1*sb1beta1*xsiLLsb1 - mgluino*mb*sb1alpha1*sb1beta1*pow(mneutralino,2)*rhoLLsb1 + mgluino*mb*mb*mneutralino*(pow(sin(thetab),2)*sb1alpha1*sb1alpha1 + pow(cos(thetab),2)*sb1beta1*sb1beta1)*rhoLLsb1;

//     double extraGammasb1 = 0;
//     extraGammasb1 = -mneutralino*mb*sin(thetab)*cos(thetab)*(sb1alpha1*sb1alpha1 + sb1beta1*sb1beta1)*pow(mgluino,2)*rhoLLsb1 + mneutralino*mb*sin(thetab)*cos(thetab)*(sb1alpha1*sb1alpha1 + sb1beta1*sb1beta1)*xsiLLsb1;

//     Gammasb1 = Gammasb1 + extraGammasb1;    

//     Gammasb2 = (sb2alpha1*sb2alpha1 + sb2beta1*sb2beta1)*psiLLsb2 + 4*mb*mneutralino*chiLLsb2*sb2alpha1*sb2beta1 + 4*mgluino*mb*sin(thetab)*cos(thetab)*(sb2alpha1*sb2alpha1 + sb2beta1*sb2beta1)*XL1R1sb2 + 8*sin(thetab)*cos(thetab)*sb2alpha1*sb2beta1*mgluino*pow(mb,2)*mneutralino*zetaL1R1sb2 + 2*sin(thetab)*cos(thetab)*sb2alpha1*sb2beta1*YL1R2sb2 + (pow(sin(thetab),2)*sb2alpha1*sb2alpha1 + pow(cos(thetab),2)*sb2beta1*sb2beta1)*phiLLsb2 + xsiLLsb2*(2*pow(mb,2)*sin(thetab)*cos(thetab)*sb2alpha1*sb2beta1 + mgluino*mb*sb2alpha1*sb2beta1) + rhoLLsb2*(-mgluino*mb*pow(mneutralino,2)*sb2alpha1*sb2beta1) + rhoLLsb2*mgluino*mneutralino*pow(mb,2)*(pow(cos(thetab),2)*sb2alpha1*sb2alpha1 + pow(sin(thetab),2)*sb2beta1*sb2beta1);

//     double extraGammasb2 = 0;
//     extraGammasb2 = (xsiLLsb2*-mneutralino*mb*sin(thetab)*cos(thetab)*(sb2alpha1*sb2alpha1 + sb2beta1*sb2beta1) + rhoLLsb2*pow(mgluino,2)*mneutralino*mb*sin(thetab)*cos(thetab)*(sb2alpha1*sb2alpha1 + sb2beta1*sb2beta1));
 
//     Gammasb2 = Gammasb2 + extraGammasb2;


//     Gammasb1sb2 = pow(PI,2)/(8*pow(mgluino*gs,2))*(32*pow(mgluino*gs/PI,2)*mgluino*mb*(pow(cos(thetab),2)-pow(sin(thetab),2))*(sb1alpha1*sb2alpha1 + sb1beta1*sb2beta1)*XLRsb1sb2 + 32*pow(mgluino*gs/PI,2)*mgluino*pow(mb,2)*mneutralino*(sb1alpha1*sb2beta1 + sb1beta1*sb2alpha1)*(pow(cos(thetab),2)-pow(sin(thetab),2))*zetaLRsb1sb2 + 16*pow(mgluino*gs/PI,2)*(sb1beta1*sb2alpha1*pow(cos(thetab),2) - pow(sin(thetab),2)*sb2beta1*sb1alpha1)*YLRsb1sb2 + 16*pow(mgluino*gs/PI,2)*sin(thetab)*cos(thetab)*(sb1alpha1*sb2alpha1 - sb1beta1*sb2beta1)*phitildaLLsb1sb2 + 16*pow(mgluino*gs/PI,2)*mb*mneutralino*(sb1alpha1*sb2alpha1 - sb1beta1*sb2beta1)*chiprimeLRsb1sb2 + 16*pow(mgluino*gs/PI,2)*pow(mb,2)*(pow(cos(thetab),2)*sb1alpha1*sb2beta1 - pow(sin(thetab),2)*sb1beta1*sb2alpha1)*xsiLLsb1sb2 + 16*pow(mgluino*gs/PI,2)*mgluino*pow(mb,2)*mneutralino*(sb1beta1*sb2beta1-sb1alpha1*sb2alpha1)*sin(thetab)*cos(thetab)*rhotildaLLsb1sb2);
 
//     double extraGammasb1sb2 = 0; 
//     extraGammasb1sb2 = (pow(PI,2)/(8*pow(mgluino*gs,2))*(-32*pow(mgluino*gs/PI,2)*sin(thetab)*cos(thetab)*mgluino*mb*(sb1alpha1*sb2beta1-sb1beta1*sb2alpha1)*chiprimeLRsb1sb2 -16*pow(mgluino*gs/PI,2)*sin(thetab)*cos(thetab)*mgluino*mb*(sb1alpha1*sb2beta1 - sb1beta1*sb2alpha1)*xsiLLsb1sb2 + 16*pow(mgluino*gs/PI,2)*mb*mneutralino*(pow(sin(thetab),2)*sb1alpha1*sb2alpha1 - pow(cos(thetab),2)*sb1beta1*sb2beta1)*xsiLLsb1sb2 + 16*pow(mgluino*gs/PI,2)*pow(mgluino,3)*mb*(sb1alpha1*sb2beta1-sb1beta1*sb2alpha1)*sin(thetab)*cos(thetab)*rhotildaLLsb1sb2 - 16*pow(mgluino*gs/PI,2)*pow(mgluino,2)*mb*mneutralino*(pow(sin(thetab),2)*sb1alpha1*sb2alpha1 - pow(cos(thetab),2)*sb1beta1*sb2beta1)*rhotildaLLsb1sb2)); 

//     Gammasb1sb2 = Gammasb1sb2 + extraGammasb1sb2;



//     amplitudeW = alphas/(8*pow(PI,4)*mgluino)*(Gammasb1+Gammasb2+Gammasb1sb2);

//     cout << "Neutralino " << neutralino << endl;
//     cout << "couplings: " << endl;
//     cout << "fb = " << fb << endl;
//     cout << "gs/sqrt(2)*cos(thetab) = " << gs/pow(2,0.5)*cos(thetab) << endl;
//     cout << "gs/sqrt(2)*sin(thetab) = " << gs/pow(2,0.5)*sin(thetab) << endl;
//     cout << "sb1alpha1 = " << sb1alpha1 << endl;
//     cout << "sb1beta1 = " << sb1beta1 << endl;
//     cout << "sb2alpha1 = " << sb2alpha1 << endl;
//     cout << "sb2beta1 = " << sb2beta1 << endl;
//     cout << "gs^2/2 = " << pow(gs,2)/2 << endl;
//     cout << "gs^2/2*cos(thetab)*sin(thetab) = " << pow(gs,2)/2*cos(thetab)*sin(thetab) << endl;
//     cout << "sb2alpha1*sb2beta1 = " << sb2alpha1*sb2beta1 << endl;
//     cout << "sb2alpha1^2 + sb2beta1^2 = " << pow(sb2alpha1,2) + pow(sb2beta1,2) << endl;
//     cout << "Gammasb1 = " << Gammasb1 << endl;
//     cout << "Gammasb2 = " << Gammasb2 << endl;
//     cout << "Gammasb1sb2 = " << Gammasb1sb2 << endl;
//     cout << endl;
//     cout << "Converted Gammasb1 = " << Gammasb1*8*pow(mgluino*gs/PI,2) << endl;
//     cout << "Converted Gammasb2 = " << Gammasb2*8*pow(mgluino*gs/PI,2) << endl;
//     cout << "Converted Gammasb1sb2 = " << Gammasb1sb2*8*pow(mgluino*gs/PI,2) << endl;
//     cout << "Converted IntegrateScalarS1S2 contribution to Gammasb1sb2 = " << 32*pow(mgluino*gs/PI,2)*mgluino*mb*(pow(cos(thetab),2)-pow(sin(thetab),2))*(sb1alpha1*sb2alpha1 + sb1beta1*sb2beta1)*XLRsb1sb2 + 32*pow(mgluino*gs/PI,2)*mgluino*pow(mb,2)*mneutralino*(sb1alpha1*sb2beta1 + sb1beta1*sb2alpha1)*(pow(cos(thetab),2)-pow(sin(thetab),2))*zetaLRsb1sb2 << endl;
//     cout << "Converted IntegrateScalarST contribution to Gammasb1sb2 = " << 16*pow(mgluino*gs/PI,2)*(sb1beta1*sb2alpha1*pow(cos(thetab),2) - pow(sin(thetab),2)*sb2beta1*sb1alpha1)*YLRsb1sb2 + 16*pow(mgluino*gs/PI,2)*sin(thetab)*cos(thetab)*(sb1alpha1*sb2alpha1 - sb1beta1*sb2beta1)*phitildaLLsb1sb2 + 16*pow(mgluino*gs/PI,2)*mb*mneutralino*(sb1alpha1*sb2alpha1 - sb1beta1*sb2beta1)*chiprimeLRsb1sb2 + 16*pow(mgluino*gs/PI,2)*pow(mb,2)*(pow(cos(thetab),2)*sb1alpha1*sb2beta1 - pow(sin(thetab),2)*sb1beta1*sb2alpha1)*xsiLLsb1sb2 + 16*pow(mgluino*gs/PI,2)*mgluino*pow(mb,2)*mneutralino*(sb1beta1*sb2beta1-sb1alpha1*sb2alpha1)*sin(thetab)*cos(thetab)*rhotildaLLsb1sb2 -32*pow(mgluino*gs/PI,2)*sin(thetab)*cos(thetab)*mgluino*mb*(sb1alpha1*sb2beta1-sb1beta1*sb2alpha1)*chiprimeLRsb1sb2 -16*pow(mgluino*gs/PI,2)*sin(thetab)*cos(thetab)*mgluino*mb*(sb1alpha1*sb2beta1 - sb1beta1*sb2alpha1)*xsiLLsb1sb2 + 16*pow(mgluino*gs/PI,2)*mb*mneutralino*(pow(sin(thetab),2)*sb1alpha1*sb2alpha1 - pow(cos(thetab),2)*sb1beta1*sb2beta1)*xsiLLsb1sb2 + 16*pow(mgluino*gs/PI,2)*pow(mgluino,3)*mb*(sb1alpha1*sb2beta1-sb1beta1*sb2alpha1)*sin(thetab)*cos(thetab)*rhotildaLLsb1sb2 - 16*pow(mgluino*gs/PI,2)*pow(mgluino,2)*mb*mneutralino*(pow(sin(thetab),2)*sb1alpha1*sb2alpha1 - pow(cos(thetab),2)*sb1beta1*sb2beta1)*rhotildaLLsb1sb2 << endl; 
//     cout << "X term = " << 32*pow(mgluino*gs/PI,2)*mgluino*mb*(pow(cos(thetab),2)-pow(sin(thetab),2))*(sb1alpha1*sb2alpha1 + sb1beta1*sb2beta1)*XLRsb1sb2 << endl;
//     cout << "zeta term = " << 32*pow(mgluino*gs/PI,2)*mgluino*pow(mb,2)*mneutralino*(sb1alpha1*sb2beta1 + sb1beta1*sb2alpha1)*(pow(cos(thetab),2)-pow(sin(thetab),2))*zetaLRsb1sb2 << endl;
//     cout << "X integral = " << XLRsb1sb2*8*pow(mgluino*gs/PI,2) << endl;
//     cout << "zeta integral = " << zetaLRsb1sb2*4*pow(mgluino*gs/PI,2) << endl;

//   }

//   return amplitudeW;

// }

      









///calculates PW for gluino -> neutralino + q qbar pair where q are b so third gen
double gluinoamplitudedecaydgaussneutralinobbbarorig (double mgluino, double msb1, double msb2, double mneutralino, double mb, double mWboson, double g, double gp, double thetab, double beta, double alphas, DoubleMatrix mixNeut, double runmb, int neutralino, int onetothree) {
  double amplitudeW=0, Gammasb1=0, Gammasb2=0, Gammasb1sb2=0, GammaLLsb1=0, GammaRRsb1=0, GammaL1R1sb1=0, GammaL1R2sb1=0, GammaLLsb2=0, GammaRRsb2=0, GammaL1R1sb2=0, GammaLLsb1sb2=0, GammaRRsb1sb2=0, GammaRLsb1sb2=0, GammaL2R2sb1=0, GammaL2R1sb1=0, GammaL2R2sb2=0, GammaL2R1sb2=0, GammaL1R2sb2=0, GammaLRsb1sb2=0;
  double AbZ=0, BbZ=0, sb1alpha1=0, sb1beta1=0, sb1alpha2=0, sb1beta2=0, sb2alpha1=0, sb2alpha2=0, sb2beta1=0, sb2beta2=0, fb=0, from=0, upper=0;

  // DoubleVector Etbarmaxmin (double m1, double m2, double massq, double Et); ///required for many of the 1->3 integrals, this gives E max and min of t bar for given Et therefore different to overall limits of integration on Et which are Etmax, Etmin, included here for help debugging if get nans in Etbar
  ///mb = 0; msb1 = 700; msb2 =800; thetab = 0;
  from = mb;
  upper = (pow(mgluino,2)-2*mb*fabs(mneutralino)-pow(mneutralino,2))/(2*mgluino);
  ///mneutralino = fabs(mneutralino);

  if (fabs(mgluino) < fabs(mneutralino) + 2*mb || fabs(mgluino)> msb1 + mb || fabs(mgluino) > msb2 + mb || onetothree ==0) { amplitudeW = 0;}
  else {
    
    // cout << "mgluino = " << mgluino << " mbottom = " << mb << " msb1 = " << msb1 << " msb2 = " << msb2 << " mneutralino = " << mneutralino << " upper = " << upper << endl;

    fb = g*runmb/(pow(2,0.5)*mWboson*cos(beta));
    AbZ = g/(pow(2,0.5))*(mixNeut(neutralino,2)) + gp/(3*pow(2,0.5))*(-mixNeut(neutralino,1));
    BbZ = (-2./3)*gp/(pow(2,0.5))*(-mixNeut(neutralino,1));
    sb1alpha1 = AbZ*cos(thetab) - fb*mixNeut(neutralino,3)*sin(thetab);
    sb1beta1 = fb*mixNeut(neutralino,3)*cos(thetab) + BbZ*sin(thetab);
    sb1alpha2 = BbZ*sin(thetab)+fb*mixNeut(neutralino,3)*cos(thetab);
    sb1beta2 = -fb*mixNeut(neutralino,3)*sin(thetab)+AbZ*cos(thetab);
    sb2alpha1 = AbZ*sin(thetab)+fb*mixNeut(neutralino,3)*cos(thetab);
    sb2beta1 = fb*mixNeut(neutralino,3)*sin(thetab)-BbZ*cos(thetab);
    sb2alpha2 = -BbZ*cos(thetab) + fb*mixNeut(neutralino,3)*sin(thetab);
    sb2beta2 = fb*mixNeut(neutralino,3)*cos(thetab) + AbZ*sin(thetab);

    double psiLLsb1=0, chiLLsb1=0, phiLLsb1=0, rhoLLsb1=0, xsiLLsb1=0;
    
    m1 = mgluino, mq = mb, m2 = msb1, m3 = msb1, m4 = mneutralino;
    ///cout << "m1 = " << m1 << " mq = " << mq << " m2 = " << m2 << " m3 = " << m3 << " m4 = " << m4 << " from = " << from << " upper = " << upper << endl;
    psiLLsb1 = dgauss(gpsitildadgauss,from,upper,accuracy);
    phiLLsb1 = dgauss(gphitildadgauss,from,upper,accuracy);
    chiLLsb1 = dgauss(gchidgauss,from,upper,accuracy); 
    rhoLLsb1 = dgauss(grhodgauss,from,upper,accuracy); 
    xsiLLsb1 = dgauss(gxsidgauss,from,upper,accuracy);
    /// cout << psiLLsb1 << endl;
    /// cout << chiLLsb1 << endl;
    /// cout << phiLLsb1 << endl;
    /// cout << rhoLLsb1 << endl;
    /// cout << xsiLLsb1 << endl;
    /// cout << rhoLLsb1 << endl;
    
    GammaLLsb1 = (pow(sb1alpha1,2)+pow(sb1beta1,2))*psiLLsb1 - 4*mb*fabs(mneutralino)*sb1alpha1*sb1beta1*chiLLsb1 + fabs(mgluino)*((mneutralino)*(1/(mgluino*mneutralino)*pow(sb1alpha1,2)*phiLLsb1 + pow(sb1beta1,2)*pow(mb,2)*rhoLLsb1)-sb1alpha1*sb1beta1*mb*(xsiLLsb1-pow(mneutralino,2)*rhoLLsb1));
    GammaRRsb1 = (pow(sb1alpha2,2)+pow(sb1beta2,2))*psiLLsb1 - 4*mb*fabs(mneutralino)*sb1alpha2*sb1beta2*chiLLsb1 + fabs(mgluino)*((mneutralino)*(1/(mgluino*mneutralino)*pow(sb1alpha2,2)*phiLLsb1 + pow(sb1beta2,2)*pow(mb,2)*rhoLLsb1)-sb1alpha2*sb1beta2*mb*(xsiLLsb1-pow(mneutralino,2)*rhoLLsb1));

    double zetaL1R1sb1=0, XL1R1sb1=0;
    zetaL1R1sb1 = dgauss(gzetadgauss,from,upper,accuracy);
    XL1R1sb1 = dgauss(gXdgauss,from,upper,accuracy);
    
    GammaL1R1sb1 = 2*fabs(mgluino)*mb*((sb1alpha1*sb1alpha2+sb1beta1*sb1beta2)*mb*fabs(mneutralino)*zetaL1R1sb1 - (sb1alpha2*sb1beta1+sb1alpha1*sb1beta2)*XL1R1sb1);
    GammaL2R2sb1 = GammaL1R1sb1;
    
    double YL1R2sb1=0, chiprimeL1R2sb1=0;
    YL1R2sb1 = dgauss(gYdgauss,from,upper,accuracy);
    chiprimeL1R2sb1 = dgauss(gchiprimedgauss,from,upper,accuracy);

    GammaL1R2sb1 = sb1beta1*sb1beta2*YL1R2sb1+sb1alpha1*sb1alpha2*pow(mb,2)*xsiLLsb1-mb*fabs(mneutralino)*(sb1alpha1*sb1beta2+sb1alpha2*sb1beta1)*chiprimeL1R2sb1;
    GammaL2R1sb1 = GammaL1R2sb1;
    
    double psiLLsb2=0, chiLLsb2=0, phiLLsb2=0, rhoLLsb2=0, xsiLLsb2=0;

    m1 = mgluino, mq = mb, m2 = msb2, m3 = msb2, m4 = mneutralino;
    psiLLsb2 = dgauss(gpsitildadgauss,from,upper,accuracy);
    phiLLsb2 = dgauss(gphitildadgauss,from,upper,accuracy);
    chiLLsb2 = dgauss(gchidgauss,from,upper,accuracy); 
    rhoLLsb2 = dgauss(grhodgauss,from,upper,accuracy); 
    xsiLLsb2 = dgauss(gxsidgauss,from,upper,accuracy);
    
    GammaLLsb2 = (pow(sb2alpha1,2)+pow(sb2beta1,2))*psiLLsb2 - 4*mb*fabs(mneutralino)*sb2alpha1*sb2beta1*chiLLsb2 + fabs(mgluino)*((mneutralino)*(1/(mgluino*mneutralino)*pow(sb2alpha1,2)*phiLLsb2 + pow(sb2beta1,2)*pow(mb,2)*rhoLLsb2)-sb2alpha1*sb2beta1*mb*(xsiLLsb2-pow(mneutralino,2)*rhoLLsb2));
    ///cout << "In GammaLLsb2:::" << endl;
    ///cout << psiLLsb2 << endl;
    ///cout << chiLLsb2 << endl;
    //cout << phiLLsb2 << endl;
    ///cout << rhoLLsb2 << endl;
    ///cout << xsiLLsb2 << endl;
    /// double Section1=0, Section2 =0, Section3 = 0, Section4 = 0;
    /// Section1 = (pow(sb2alpha1,2)+pow(sb2beta1,2))*psiLLsb2; 
    /// Section2 =  - 4*mb*fabs(mneutralino)*sb2alpha1*sb2beta1*chiLLsb2;
    /// Section3 = fabs(mgluino)*((mneutralino)*(1/(mgluino*mneutralino)*pow(sb2alpha1,2)*phiLLsb2 + pow(sb2beta1,2)*pow(mb,2)*rhoLLsb2));
    /// Section4 = fabs(mgluino)*-sb2alpha1*sb2beta1*mb*(xsiLLsb2-pow(mneutralino,2)*rhoLLsb2);
    /// cout << "Section 1: " << Section1  << endl;
    /// cout << "Section 2: " << Section2  << endl;
    /// cout << "Section 3: " << Section3  << endl;
    /// cout << "Section 4: " << Section4  << endl;
    /// cout << "GammaLLsb2 should = " << Section1 + Section2 + Section3 + Section4 << endl;

    GammaRRsb2 = (pow(sb2alpha2,2)+pow(sb2beta2,2))*psiLLsb2 - 4*mb*fabs(mneutralino)*sb2alpha2*sb2beta2*chiLLsb2 + fabs(mgluino)*((mneutralino)*(1/(mgluino*mneutralino)*pow(sb2alpha2,2)*phiLLsb2 + pow(sb2beta2,2)*pow(mb,2)*rhoLLsb2)-sb2alpha2*sb2beta2*mb*(xsiLLsb2-pow(mneutralino,2)*rhoLLsb2));

    double zetaL1R1sb2=0, XL1R1sb2=0;
    zetaL1R1sb2 = dgauss(gzetadgauss,from,upper,accuracy);
    XL1R1sb2 = dgauss(gXdgauss,from,upper,accuracy);
    
    GammaL1R1sb2 = 2*fabs(mgluino)*mb*((sb2alpha1*sb2alpha2+sb2beta1*sb2beta2)*mb*fabs(mneutralino)*zetaL1R1sb2 - (sb2alpha2*sb2beta1+sb2alpha1*sb2beta2)*XL1R1sb2);
    GammaL2R2sb2 = GammaL1R1sb2;
    
    double YL1R2sb2=0, chiprimeL1R2sb2=0;
    YL1R2sb2 = dgauss(gYdgauss,from,upper,accuracy);
    chiprimeL1R2sb2 = dgauss(gchiprimedgauss,from,upper,accuracy);

    GammaL1R2sb2 = sb2beta1*sb2beta2*YL1R2sb2+sb2alpha1*sb2alpha2*pow(mb,2)*xsiLLsb2-mb*fabs(mneutralino)*(sb2alpha1*sb2beta2+sb2alpha2*sb2beta1)*chiprimeL1R2sb2;
    GammaL2R1sb2 = GammaL1R2sb2;


    double psitildaLLsb1sb2=0, chitildaLLsb1sb2=0, phitildaLLsb1sb2=0, rhotildaLLsb1sb2=0, xsiLLsb1sb2=0;
    m1 = mgluino, mq = mb, m2 = msb1, m3 = msb2, m4 = mneutralino;
    psitildaLLsb1sb2 = dgauss(gpsitildadgauss,from,upper,accuracy);
    chitildaLLsb1sb2 = dgauss(gchidgauss,from,upper,accuracy);
    phitildaLLsb1sb2 = dgauss(gphitildadgauss,from,upper,accuracy);
    rhotildaLLsb1sb2 = dgauss(grhodgauss,from,upper,accuracy);
    xsiLLsb1sb2 = dgauss(gxsidgauss,from,upper,accuracy);

    ///GammaLLsb1sb2 = 2*(sb1alpha1*sb2alpha1+sb1beta1*sb2beta1)*psitildaLLsb1sb2 - 4*mb*fabs(mneutralino)*(sb1alpha1*sb2beta1+sb2alpha1*sb1beta1)*chitildaLLsb1sb2 - fabs(mgluino)*(-2*fabs(mneutralino)*(sb1alpha1*sb2alpha1/(mgluino*mneutralino)*phitildaLLsb1sb2+sb1beta1*sb1beta2*pow(mb,2)*rhotildaLLsb1sb2) + (sb1alpha1*sb2beta1+sb2alpha1*sb1beta1)*mb*(xsiLLsb1sb2-pow(mneutralino,2)*rhotildaLLsb1sb2));

    GammaLLsb1sb2 = 2*(sb1alpha1*sb2alpha1+sb1beta1*sb2beta1)*psitildaLLsb1sb2 - 4*mb*fabs(mneutralino)*(sb1alpha1*sb2beta1+sb2alpha1*sb1beta1)*chitildaLLsb1sb2 + fabs(mgluino)*(2*(mneutralino)*(sb1alpha1*sb2alpha1/(mgluino*mneutralino)*phitildaLLsb1sb2+sb1beta1*sb1beta2*pow(mb,2)*rhotildaLLsb1sb2) - (sb1alpha1*sb2beta1+sb2alpha1*sb1beta1)*mb*(xsiLLsb1sb2-pow(mneutralino,2)*rhotildaLLsb1sb2)); /// has a (-1)^(thetai) removed

    ///GammaRRsb1sb2 = -2*(-sb1alpha2*-sb2alpha2+sb1beta2*sb2beta2)*psitildaLLsb1sb2 - 4*mb*fabs(mneutralino)*(-sb1alpha2*sb2beta2+-sb2alpha2*sb1beta2)*chitildaLLsb1sb2 + fabs(mgluino)*(-2*fabs(mneutralino)*((-sb1alpha2*-sb2alpha2)/(mgluino*mneutralino)*phitildaLLsb1sb2+sb1beta2*sb2beta2*pow(mb,2)*rhotildaLLsb1sb2) - (-sb1alpha2*sb2beta2+-sb2alpha2*sb1beta2)*mb*(xsiLLsb1sb2-pow(mneutralino,2)*rhotildaLLsb1sb2));

    GammaRRsb1sb2 = -2*(-sb1alpha2*-sb2alpha2+sb1beta2*sb2beta2)*psitildaLLsb1sb2 - 4*mb*fabs(mneutralino)*(-sb1alpha2*sb2beta2+-sb2alpha2*sb1beta2)*chitildaLLsb1sb2 - fabs(mgluino)*(2*(mneutralino)*((-sb1alpha2*-sb2alpha2)/(mgluino*mneutralino)*phitildaLLsb1sb2+sb1beta2*sb2beta2*pow(mb,2)*rhotildaLLsb1sb2) - (-sb1alpha2*sb2beta2+-sb2alpha2*sb1beta2)*mb*(xsiLLsb1sb2-pow(mneutralino,2)*rhotildaLLsb1sb2)); /// has a (-1)^(thetai) removed

    double zetaLRsb1sb2=0, XLRsb1sb2=0, YLRsb1sb2=0, chiprimeLRsb1sb2=0, xsiLRsb1sb2=0;
    zetaLRsb1sb2 = dgauss(gzetadgauss,from,upper,accuracy);
    XLRsb1sb2 = dgauss(gXdgauss,from,upper,accuracy);
    YLRsb1sb2 = dgauss(gYdgauss,from,upper,accuracy);
    chiprimeLRsb1sb2 = dgauss(gchiprimedgauss,from,upper,accuracy);
    xsiLRsb1sb2 = dgauss(gxsidgauss,from,upper,accuracy);
    
    GammaLRsb1sb2 = 4*fabs(mgluino)*mb*(fabs(mneutralino)*mb*(-sb1alpha1*-sb2alpha2+sb1beta1*sb2beta2)*zetaLRsb1sb2 + (-sb2alpha2*sb1beta1-sb1alpha1*sb2beta2)*XLRsb1sb2) + 2*sb1beta1*sb2beta2*YLRsb1sb2 + 2*mb*fabs(mneutralino)*(sb1beta1*-sb2alpha2-sb1alpha1*sb2beta2)*chiprimeLRsb1sb2 - 2*sb1alpha1*-sb2alpha2*pow(mb,2)*xsiLRsb1sb2;

    m1 = mgluino, mq = mb, m2 = msb2, m3 = msb1, m4 = mneutralino;
    double zetaRLsb1sb2=0, XRLsb1sb2=0, YRLsb1sb2=0, chiprimeRLsb1sb2=0;
    zetaRLsb1sb2 = dgauss(gzetadgauss,from,upper,accuracy);
    XRLsb1sb2 = dgauss(gXdgauss,from,upper,accuracy);
    YRLsb1sb2 = dgauss(gYdgauss,from,upper,accuracy);
    chiprimeRLsb1sb2 = dgauss(gchiprimedgauss,from,upper,accuracy);
    

    GammaRLsb1sb2 = -(4*fabs(mgluino)*mb*(fabs(mneutralino)*mb*(-sb2alpha1*-sb1alpha2+sb2beta1*sb1beta2)*zetaRLsb1sb2 + (-sb1alpha2*sb2beta1-sb2alpha1*sb1beta2)*XRLsb1sb2) + 2*sb2beta1*sb1beta2*YRLsb1sb2 + 2*mb*fabs(mneutralino)*(sb2beta1*-sb1alpha2-sb2alpha1*sb1beta2)*chiprimeRLsb1sb2 - 2*sb2alpha1*-sb1alpha2*pow(mb,2)*xsiLRsb1sb2);

    Gammasb1sb2 = (GammaLLsb1sb2+GammaRRsb1sb2)*sin(thetab)*cos(thetab)+GammaLRsb1sb2*pow(cos(thetab),2)+GammaRLsb1sb2*pow(sin(thetab),2);
    cout << "In Gammasb1sb2: " << endl;
    cout << "GammaLLsb1sb2 = " << GammaLLsb1sb2 << " GammaRRsb1sb2 = " << GammaRRsb1sb2 << endl;
    cout << "GammaLRsb1sb2 = " << GammaLRsb1sb2 << " GammaRLsb1sb2 = " << GammaRLsb1sb2 << endl;
    /// cout << zetaLRsb1sb2 << endl;
    /// cout << XLRsb1sb2 << endl;
    /// cout << YLRsb1sb2 << endl;
    /// cout << chiprimeLRsb1sb2 << endl;
    /// cout << xsiLRsb1sb2 << endl;
    /// cout << "SECTIONS" << endl;
    /// cout << 4*fabs(mgluino)*mb*(fabs(mneutralino)*mb*(-sb1alpha1*-sb2alpha2+sb1beta1*sb2beta2)*zetaLRsb1sb2) << endl;
    /// cout << 4*fabs(mgluino)*mb*(-sb2alpha2*sb1beta1-sb1alpha1*sb2beta2)*XLRsb1sb2 << endl;
    /// cout << 2*sb1beta1*sb2beta2*YLRsb1sb2 << endl;
    /// cout << 2*mb*fabs(mneutralino)*(sb1beta1*-sb2alpha2-sb1alpha1*sb2beta2)*chiprimeLRsb1sb2 << endl;
    /// cout << - 2*sb1alpha1*-sb2alpha2*pow(mb,2)*xsiLRsb1sb2 << endl;
    /// cout << "sb1alpha1 = " << sb1alpha1 << endl;
    /// cout << "sb2alpha2 = " << sb2alpha2 << endl;
    /// cout << "sb1beta1 = "<< sb1beta1 << endl;
    /// cout << "sb2beta2 = " << sb2beta2 << endl;
    /// cout << "sb2alpha1 = " << sb2alpha1 << endl;
    /// cout << "-sb1alpha2 = " << -sb1alpha2 << endl;
    /// cout << "sb2beta1 = "<< sb2beta1 << endl;
    /// cout << "sb1beta2 = " << sb1beta2 << endl;
    /// cout << 4*fabs(mgluino)*mb*(fabs(mneutralino)*mb*(-sb2alpha1*-sb1alpha2+sb2beta1*sb1beta2)*zetaRLsb1sb2) << endl;
    /// cout <<  4*fabs(mgluino)*mb*(-sb1alpha2*sb2beta1-sb2alpha1*sb1beta2)*XRLsb1sb2 << endl;
    /// cout << 2*sb2beta1*sb1beta2*YRLsb1sb2 << endl;
    /// cout << 2*mb*fabs(mneutralino)*(sb2beta1*-sb1alpha2-sb2alpha1*sb1beta2)*chiprimeRLsb1sb2 << endl;
    /// cout << - 2*sb2alpha1*-sb1alpha2*pow(mb,2)*xsiLRsb1sb2 << endl;
    /// cout << "GammaRLsb1sb2 should = " << 4*fabs(mgluino)*mb*(fabs(mneutralino)*mb*(-sb2alpha1*-sb1alpha2+sb2beta1*sb1beta2)*zetaRLsb1sb2) + 4*fabs(mgluino)*mb*(-sb1alpha2*sb2beta1-sb2alpha1*sb1beta2)*XRLsb1sb2 + 2*sb2beta1*sb1beta2*YRLsb1sb2 + 2*mb*fabs(mneutralino)*(sb2beta1*-sb1alpha2-sb2alpha1*sb1beta2)*chiprimeRLsb1sb2 - 2*sb2alpha1*-sb1alpha2*pow(mb,2)*xsiLRsb1sb2 << endl;
    
    Gammasb2 = GammaLLsb2*pow(sin(thetab),2)+GammaRRsb2*pow(cos(thetab),2) + sin(thetab)*cos(thetab)*(GammaL1R1sb2+GammaL1R2sb2+GammaL2R1sb2+GammaL2R2sb2);

    Gammasb1 = GammaLLsb1*pow(cos(thetab),2)+GammaRRsb1*pow(sin(thetab),2)-sin(thetab)*cos(thetab)*(GammaL1R1sb1+GammaL1R2sb1+GammaL2R1sb2+GammaL2R2sb1);

    // cout << "Gammasb1 = " << Gammasb1 << " Gammasb2 = " << Gammasb2 << " Gammasb1sb2 = " << Gammasb1sb2 << endl;
    // cout << "GammaLLsb1 = " << GammaLLsb1 << " GammaRRsb1 = " << GammaRRsb1 << " GammaL1R1sb1 = " << GammaL1R1sb1 << " GammaL1R2sb1 = " << GammaL1R2sb1 << endl;
    // cout << "GammaL2R1sb1 = " << GammaL2R1sb1 << " GammaL2R2sb1 = " << GammaL2R2sb1 << endl;
    // cout << "GammaLLsb2 = " << GammaLLsb2 << " GammaRRsb2 = " << GammaRRsb2 << " GammaL1R1sb2 = " << GammaL1R1sb2 << " GammaL1R2sb2 = " << GammaL1R2sb2 << endl;
    // cout << "GammaL2R1sb2 = " << GammaL2R1sb2 << " GammaL2R2sb2 = " << GammaL2R2sb2 << endl;
    // cout << "GammaLLsb1sb2 = " << GammaLLsb1sb2 << " GammaRRsb1sb2 = " << GammaRRsb1sb2 << endl;
    // cout << "GammaLRsb1sb2 = " << GammaLRsb1sb2 << " GammaRLsb1sb2 = " << GammaRLsb1sb2 << endl;

    

    amplitudeW = (alphas)/(8*pow(PI,4)*mgluino)*(Gammasb1+Gammasb2+Gammasb1sb2);

        // if (mq < 1.5 && neutralino == 2) {
	//   cout << endl;
	//   /// IN HERE ONLY SCALE ALL BY 3.90625*10^5 TO COMPARE WITH SPHENO - IMPORTANT ONLY SCALED IN HERE AS THIS SCALING WILL CHANGE PREFACTOR REQUIRED IN AMPLITUDEW TO 1/(256*PI^3*MGLUINO^3)!
	  
	//   cout << "Gammasb1 = "<< Gammasb1*390625 << " Gammasb2 = " << Gammasb2*390625 << " Gammasb1sb2 = " << Gammasb1sb2*390625 << endl;
	//   cout << "GammaLLsb1 = " << GammaLLsb1*390625 << endl;
	//   cout << "GammaRRsb1 = " << GammaRRsb1*390625 << endl;
	//   cout << "GammaL1R1sb1 = " << GammaL1R1sb1*390625 << endl;
	//   cout << "GammaL1R2sb1 = " << GammaL1R2sb1*390625 << endl;
	//   cout << "GammaL2R1sb1 = " << GammaL2R1sb1*390625 << endl;
	//   cout << "GammaL2R2sb1 = " << GammaL2R2sb1*390625 << endl;
	//   cout << "GammaLLsb2 = " << GammaLLsb2*390625 << endl;
	//   cout << "GammaRRsb2 = " << GammaRRsb2*390625 << endl;
	//   cout << "GammaL1R1sb2 = " << GammaL1R1sb2*390625 << endl;
	//   cout << "GammaL1R2sb2 = " << GammaL1R2sb2*390625 << endl;
	//   cout << "GammaL2R1sb2 = " << GammaL2R1sb2*390625 << endl;
	//   cout << "GammaL2R2sb2 = " << GammaL2R2sb2*390625 << endl;
	//   cout << "GammaLLsb1sb2 = " << GammaLLsb1sb2*390625 << endl;
	//   cout << "GammaRRsb1sb2 = " << GammaRRsb1sb2*390625 << endl;
	//   cout << "GammaLRsb1sb2 = " << GammaLRsb1sb2*390625 << endl;
	//   cout << "GammaRLsb1sb2 = " << GammaRLsb1sb2*390625 << endl;
	//   cout << endl;
	// }

  }
  return amplitudeW;
}





double gluinoamplitudedecaydgausschartbbar (double mgluino, double mst1, double mst2, double msb1, double msb2, double mtop, double mbottom, double mchar, double alphas, double thetat, double thetab, double MWboson, double g, double gp, double gammaL, double gammaR, double beta, double runmt, double runmb, int chargino, int onetothree)
{
  double Gammast1 = 0, Gammast2 = 0, Gammast1st2 = 0 , Gammasb1 =0, Gammasb2 = 0, Gammast1sb1 = 0, Gammast1sb2 = 0, Gammast2sb1 = 0, Gammast2sb2 = 0, from = 0, upper = 0, fromb = 0, upperb = 0, amplitudeW = 0, sumsquarest1 = 0, sumsquarest2 = 0, sumsquaresb1 = 0, sumsquaresb2 = 0, alphasb1ch = 0, alphasb2ch = 0, alphast1ch = 0, alphast2ch = 0, betasb1ch = 0, betasb2ch = 0, betast1ch = 0, betast2ch = 0;

  DoubleVector squarkmixcharginocouplings(double g, double theta, double beta, double gammaL, double gammaR, double runmt, double runmb, double mWboson, int torb);

  if (mgluino > mbottom + msb1 || mgluino > mbottom + msb2 || mgluino > mtop + mst1 || mgluino > mtop + mst2 || mgluino < mtop + mbottom + mchar) {amplitudeW = 0;}
  else {
    from = mtop;
    upper = (pow(mgluino,2)+pow(mtop,2)-pow(fabs(mchar)+mbottom,2))/(2*mgluino);
    fromb = mbottom;
    upperb = (pow(mgluino,2)-pow(mtop+fabs(mchar),2))/(2*mgluino);

    cout << "from = " << from << " to = " << upper << endl;
    cout << "fromb = " << fromb << " upperb = " << upperb << endl;
  
    DoubleVector couplingst(16);
    DoubleVector couplingsb(16);

    for (int i=1; i<=16; i++) {
      couplingst(i) = 0;
      couplingsb(i) = 0;
    }

    couplingst = squarkmixcharginocouplings(g,thetat,beta,gammaL,gammaR,runmt,runmb,MWboson,1);
    couplingsb = squarkmixcharginocouplings(g,thetab,beta,gammaL,gammaR,runmt,runmb,MWboson,2);

    if (chargino == 1) {
      sumsquarest1 = squarkmixcharginocouplings(g,thetat,beta,gammaL,gammaR,runmt,runmb,MWboson,1)(1);
      sumsquarest2 = squarkmixcharginocouplings(g,thetat,beta,gammaL,gammaR,runmt,runmb,MWboson,1)(5);
      sumsquaresb1 = squarkmixcharginocouplings(g,thetab,beta,gammaL,gammaR,runmt,runmb,MWboson,2)(1);
      sumsquaresb2 = squarkmixcharginocouplings(g,thetab,beta,gammaL,gammaR,runmt,runmb,MWboson,2)(5);
      alphast1ch = squarkmixcharginocouplings(g,thetat,beta,gammaL,gammaR,runmt,runmb,MWboson,1)(9);
      alphast2ch = squarkmixcharginocouplings(g,thetat,beta,gammaL,gammaR,runmt,runmb,MWboson,1)(13);
      betast1ch = squarkmixcharginocouplings(g,thetat,beta,gammaL,gammaR,runmt,runmb,MWboson,1)(11);
      betast2ch = squarkmixcharginocouplings(g,thetat,beta,gammaL,gammaR,runmt,runmb,MWboson,1)(15);
      alphasb1ch = squarkmixcharginocouplings(g,thetab,beta,gammaL,gammaR,runmt,runmb,MWboson,2)(9);
      alphasb2ch = squarkmixcharginocouplings(g,thetab,beta,gammaL,gammaR,runmt,runmb,MWboson,2)(13);
      betasb1ch = squarkmixcharginocouplings(g,thetab,beta,gammaL,gammaR,runmt,runmb,MWboson,2)(11);
      betasb2ch = squarkmixcharginocouplings(g,thetab,beta,gammaL,gammaR,runmt,runmb,MWboson,2)(15);
    }

    else if (chargino == 2) {
      sumsquarest1 = squarkmixcharginocouplings(g,thetat,beta,gammaL,gammaR,runmt,runmb,MWboson,1)(3);
      sumsquarest2 = squarkmixcharginocouplings(g,thetat,beta,gammaL,gammaR,runmt,runmb,MWboson,1)(7);
      sumsquaresb1 = squarkmixcharginocouplings(g,thetab,beta,gammaL,gammaR,runmt,runmb,MWboson,2)(3);
      sumsquaresb2 = squarkmixcharginocouplings(g,thetab,beta,gammaL,gammaR,runmt,runmb,MWboson,2)(7);
      alphast1ch = squarkmixcharginocouplings(g,thetat,beta,gammaL,gammaR,runmt,runmb,MWboson,1)(10);
      alphast2ch = squarkmixcharginocouplings(g,thetat,beta,gammaL,gammaR,runmt,runmb,MWboson,1)(14);
      betast1ch = squarkmixcharginocouplings(g,thetat,beta,gammaL,gammaR,runmt,runmb,MWboson,1)(12);
      betast2ch = squarkmixcharginocouplings(g,thetat,beta,gammaL,gammaR,runmt,runmb,MWboson,1)(16);
      alphasb1ch = squarkmixcharginocouplings(g,thetab,beta,gammaL,gammaR,runmt,runmb,MWboson,2)(10);
      alphasb2ch = squarkmixcharginocouplings(g,thetab,beta,gammaL,gammaR,runmt,runmb,MWboson,2)(14);
      betasb1ch = squarkmixcharginocouplings(g,thetab,beta,gammaL,gammaR,runmt,runmb,MWboson,2)(12);
      betasb2ch = squarkmixcharginocouplings(g,thetab,beta,gammaL,gammaR,runmt,runmb,MWboson,2)(16);
    }

    double G1st1 = 0, G1st2 = 0, G2sb1 = 0, G2sb2 = 0, G3sb1 = 0, G3sb2 = 0, G4st1sb1 = 0, G4st1sb2 = 0, G4st2sb1 = 0, G4st2sb2 = 0, G5st1sb1 = 0, G5st1sb2 = 0, G5st2sb1 = 0, G5st2sb2 = 0, G6st1sb1 = 0, G6st1sb2 = 0, G6st2sb1 = 0,G6st2sb2 = 0, G7st1sb1 = 0, G7st1sb2 = 0, G7st2sb1 = 0, G7st2sb2 = 0, G8st1 = 0, G8st2 = 0, G8st1st2 = 0;

    // cout << endl;
    // cout << "GLUINO DECAY TO CHARGINO AND T BBAR:" << endl;
    // cout << "couplingst: " << couplingst << endl;
    // cout << "couplingsb: " << couplingsb << endl;
    // cout << "sumsquarest1 = " << sumsquarest1 << endl;
    // cout << "couplingst(1) = " << couplingst(1) << endl;
    // cout << "squaremixcharginocouplings(1) = " << squarkmixcharginocouplings(g,thetat,beta,gammaL,gammaR,runmt,runmb,MWboson,1)(1) << endl;

    m1 = mgluino, m2 = mst1, m3 = mst1, m6 = mtop, m8 = mchar;
    G1st1 = dgauss(gG1dgauss,from,upper,accuracy);
    G8st1 = dgauss(gG8dgauss,from,upper,accuracy);
    
    Gammast1 = sumsquarest1*(G1st1 - sin(2*thetat)*G8st1); ///Different to T&B, they have + sin(2*thetat)*G8, I follow SPheno

    // cout << "G1st1 = " << G1st1 << endl;
    // cout << "G8st1 = " << G8st1 << endl;
    // cout << "Gammast1 = " << Gammast1 << endl;
    
    m1 = mgluino, m2 = mst2, m3 = mst2, m6 = mtop, m8 = mchar;
    G1st2 = dgauss(gG1dgauss,from,upper,accuracy);
    G8st2 = dgauss(gG8dgauss,from,upper,accuracy);

    Gammast2 = sumsquarest2*(G1st2 + sin(2*thetat)*G8st2); ///Different to T&B, they have - sin(2*thetat)*G8, I follow SPheno

    // cout << "G1st2 = " << G1st2 << endl;
    // cout << "G8st2 = " << G8st2 << endl;
    // cout << "Gammast2 = " << Gammast2 << endl;
   
    m1 = mgluino, m2 = mst1, m3 = mst2, m6 = mtop, m8 = mchar;
    G8st1st2 = dgauss(gG8dgauss,from,upper,accuracy);

    Gammast1st2 = 2*(alphast1ch*alphast2ch+betast1ch*betast2ch)*cos(2*thetat)*G8st1st2; ///Global minus sign difference cf T&B, I follow SPheno
    
    
    m1 = mgluino, m4 = msb1, m6 = mtop, m7 = mbottom, m8 = mchar;
    G2sb1 = dgauss(gG2dgauss,fromb,upperb,accuracy);
    G3sb1 = dgauss(gG3dgauss,fromb,upperb,accuracy);

    // cout << "G2sb1 = " << G2sb1 << endl;
    // cout << "G3sb1 = " << G3sb1 << endl;

    Gammasb1 = sumsquaresb1*G2sb1 + alphasb1ch*betasb1ch*G3sb1; ///Different to T&B, they have - alphasb1ch*betasb1ch*G3sb1, I follow SPheno

    
    m1 = mgluino, m4 = msb2, m6 = mtop, m7 = mbottom, m8 = mchar;
    G2sb2 = dgauss(gG2dgauss,fromb,upperb,accuracy);
    G3sb2 = dgauss(gG3dgauss,fromb,upperb,accuracy);

    // cout << "G2sb2 = " << G2sb2 << endl;
    // cout << "G3sb2 = " << G3sb2 << endl;

    Gammasb2 = sumsquaresb2*G2sb2 + alphasb2ch*betasb2ch*G3sb2; ///Different to T&B, they have - alphasb2ch*betasb2ch*G3sb2, I follow SPheno

    ///Taken mb -> 0 limit in squared matrix element (but not in phase space) so no sb1sb2 interference term
    
    
    m1 = mgluino, m2 = mst1, m4 = msb1, m6 = mtop, m7 = mbottom , m8 = mchar;
    G4st1sb1 = dgauss(gG4dgauss,from,upper,accuracy);
    G5st1sb1 = dgauss(gG5dgauss,from,upper,accuracy);
    G6st1sb1 = dgauss(gG6dgauss,from,upper,accuracy);
    G7st1sb1 = dgauss(gG7dgauss,from,upper,accuracy);

    // cout << "G4st1sb1 = " << G4st1sb1 << endl;
    // cout << "G5st1sb1 = " << G5st1sb1 << endl;
    // cout << "G6st1sb1 = " << G6st1sb1 << endl;
    // cout << "G7st1sb1 = " << G7st1sb1 << endl;
    
    Gammast1sb1 = (cos(thetat)*sin(thetab)*alphasb1ch*betast1ch+sin(thetat)*cos(thetab)*betasb1ch*alphast1ch)*G6st1sb1 - (cos(thetat)*cos(thetab)*alphasb1ch*alphast1ch + sin(thetat)*sin(thetab)*betasb1ch*betast1ch)*G4st1sb1 - (cos(thetat)*cos(thetab)*betasb1ch*alphast1ch + sin(thetat)*sin(thetab)*alphasb1ch*betast1ch)*G5st1sb1 + (cos(thetat)*sin(thetab)*betasb1ch*betast1ch + sin(thetat)*cos(thetab)*alphasb1ch*alphast1ch)*G7st1sb1; ///The sign in front of the G7st1sb1 and G5st1sb1 terms has been changed from that given in Baer and Tata in order to agree with SPheno.

    
    m1 = mgluino, m2 = mst1, m4 = msb2, m6 = mtop, m7 = mbottom, m8 = mchar;
    G4st1sb2 = dgauss(gG4dgauss,from,upper,accuracy);
    G5st1sb2 = dgauss(gG5dgauss,from,upper,accuracy);
    G6st1sb2 = dgauss(gG6dgauss,from,upper,accuracy);
    G7st1sb2 = dgauss(gG7dgauss,from,upper,accuracy);

    // cout << "G4st1sb2 = " << G4st1sb2 << endl;
    // cout << "G5st1sb2 = " << G5st1sb2 << endl;
    // cout << "G6st1sb2 = " << G6st1sb2 << endl;
    // cout << "G7st1sb2 = " << G7st1sb2 << endl;

    Gammast1sb2 = (cos(thetat)*-cos(thetab)*alphasb2ch*betast1ch+sin(thetat)*sin(thetab)*betasb2ch*alphast1ch)*G6st1sb2 - (cos(thetat)*sin(thetab)*alphasb2ch*alphast1ch - sin(thetat)*cos(thetab)*betasb2ch*betast1ch)*G4st1sb2 - (cos(thetat)*sin(thetab)*betasb2ch*alphast1ch - sin(thetat)*cos(thetab)*alphasb2ch*betast1ch)*G5st1sb2 + (cos(thetat)*-cos(thetab)*betasb2ch*betast1ch + sin(thetat)*sin(thetab)*alphasb2ch*alphast1ch)*G7st1sb2; ///The sign in front of the G7st1sb1 and G5st1sb1 terms has been changed from that given in Baer and Tata in order to agree with SPheno.

    
    m1 = mgluino, m2 = mst2, m4 = msb1, m6 = mtop, m7 = mbottom, m8 = mchar;
    G4st2sb1 = dgauss(gG4dgauss,from,upper,accuracy);
    G5st2sb1 = dgauss(gG5dgauss,from,upper,accuracy);
    G6st2sb1 = dgauss(gG6dgauss,from,upper,accuracy);
    G7st2sb1 = dgauss(gG7dgauss,from,upper,accuracy);

    // cout << "G4st2sb1 = " << G4st2sb1 << endl;
    // cout << "G5st2sb1 = " << G5st2sb1 << endl;
    // cout << "G6st2sb1 = " << G6st2sb1 << endl;
    // cout << "G7st2sb1 = " << G7st2sb1 << endl;

    Gammast2sb1 = (sin(thetat)*sin(thetab)*alphasb1ch*betast2ch-cos(thetat)*cos(thetab)*betasb1ch*alphast2ch)*G6st2sb1 - (sin(thetat)*cos(thetab)*alphasb1ch*alphast2ch - cos(thetat)*sin(thetab)*betasb1ch*betast2ch)*G4st2sb1 - (sin(thetat)*cos(thetab)*betasb1ch*alphast2ch - cos(thetat)*sin(thetab)*alphasb1ch*betast2ch)*G5st2sb1 + (sin(thetat)*sin(thetab)*betasb1ch*betast2ch - cos(thetat)*cos(thetab)*alphasb1ch*alphast2ch)*G7st2sb1; ///The sign in front of the G7st1sb1 and G5st1sb1 terms has been changed from that given in Baer and Tata in order to agree with SPheno.

    
    m1 = mgluino, m2 = mst2, m4 = msb2, m6 = mtop, m7 = mbottom, m8 = mchar;
    G4st2sb2 = dgauss(gG4dgauss,from,upper,accuracy);
    G5st2sb2 = dgauss(gG5dgauss,from,upper,accuracy);
    G6st2sb2 = dgauss(gG6dgauss,from,upper,accuracy);
    G7st2sb2 = dgauss(gG7dgauss,from,upper,accuracy);

    // cout << "G4st2sb2 = " << G4st2sb2 << endl;
    // cout << "G5st2sb2 = " << G5st2sb2 << endl;
    // cout << "G6st2sb2 = " << G6st2sb2 << endl;
    // cout << "G7st2sb2 = " << G7st2sb2 << endl;


    
    Gammast2sb2 = (sin(thetat)*-cos(thetab)*alphasb2ch*betast2ch-cos(thetat)*sin(thetab)*betasb2ch*alphast2ch)*G6st2sb2 - (sin(thetat)*sin(thetab)*alphasb2ch*alphast2ch + cos(thetat)*cos(thetab)*betasb2ch*betast2ch)*G4st2sb2 - (sin(thetat)*sin(thetab)*betasb2ch*alphast2ch + cos(thetat)*cos(thetab)*alphasb2ch*betast2ch)*G5st2sb2 + (sin(thetat)*-cos(thetab)*betasb2ch*betast2ch - cos(thetat)*sin(thetab)*alphasb2ch*alphast2ch)*G7st2sb2; ///The sign in front of the G7st1sb1 and G5st1sb1 terms has been changed from that given in Baer and Tata in order to agree with SPheno.

    // cout << "Integrals for Gammast1: " << endl;
    // cout << "8*mg^2*G1(mg,mst1,mch1) = " << 8*pow(mgluino,2)*G1st1 << endl;
    // cout << "4*mg/mt*G8(mg,mst1,mst1,mch1) = " << 4*mgluino/mtop*G8st1 << endl;

    // cout << "Integrals for Gammasb1: " << endl;
    // cout << "2*pow(mgluino,2)/(mchar*mtop)*G3(mg,msb1,mch1) = " << 2*pow(mgluino,2)/(mchar*mtop)*G3sb1 << endl;
    // cout << "8*pow(mgluino,2)*G2(mg,msb1,mch1) = " << 8*pow(mgluino,2)*G2sb1 << endl;

    // cout << "terms for Gammasb1: " << endl;
    // cout << sumsquaresb1*G2sb1*4*pow(mgluino*gs,2) << endl;
    // cout << alphasb1ch*betasb1ch*G3sb1*4*pow(mgluino*gs,2) << endl;

    // cout << "terms for Gammasb2: " << endl;
    // cout << sumsquaresb2*G2sb2*4*pow(mgluino*gs,2) << endl;
    // cout << alphasb2ch*betasb2ch*G3sb2*4*pow(mgluino*gs,2) << endl;

    // cout << "Integral for Gammast1st2: " << endl;
    // cout << 4*mgluino/mtop*G8st1st2 << endl;

    // cout << "Couplings for Gammast1sb1: " << endl;
    // cout << "sumI(8) = " << -pow(gs,2)*mgluino*mtop*mbottom*mchar*(sin(thetat)*sin(thetab)*alphast1ch*alphasb1ch + cos(thetat)*cos(thetab)*betast1ch*betasb1ch) << endl;
    // cout << "sumI(7) = " << pow(gs,2)/2*mbottom*mchar*(cos(thetat)*sin(thetab)*alphast1ch*alphasb1ch + sin(thetat)*cos(thetab)*betast1ch*betasb1ch) << endl;
    // cout << "sumI(6) = " << -pow(gs,2)/2*mgluino*mtop*(sin(thetat)*sin(thetab)*betast1ch*alphasb1ch + cos(thetat)*cos(thetab)*alphast1ch*betasb1ch) << endl;
    // cout << "sumI(5) = " << pow(gs,2)/2*mtop*mchar*(sin(thetat)*cos(thetab)*alphast1ch*alphasb1ch + cos(thetat)*sin(thetab)*betast1ch*betasb1ch) << endl;
    // cout << "sumI(4) = " << -pow(gs,2)/2*mgluino*mbottom*(cos(thetat)*cos(thetab)*betast1ch*alphasb1ch + sin(thetat)*sin(thetab)*alphast1ch*betasb1ch) << endl;
    // cout << "sumI(3) = " << pow(gs,2)/2*mbottom*mtop*(sin(thetat)*cos(thetab)*betast1ch*alphasb1ch + cos(thetat)*sin(thetab)*alphast1ch*betasb1ch) << endl;
    // cout << "sumI(2) = " << -pow(gs,2)/2*mgluino*mchar*(cos(thetat)*cos(thetab)*alphast1ch*alphasb1ch + sin(thetat)*sin(thetab)*betast1ch*betasb1ch) << endl;
    // cout << "sumI(1) = " << pow(gs,2)/4*(cos(thetat)*sin(thetab)*betast1ch*alphasb1ch + sin(thetat)*cos(thetab)*alphast1ch*betasb1ch) << endl;

    // cout << "Integrals for Gammast1sb1: " << endl;
    // cout << -4*mgluino/mtop*G5st1sb1 << endl;
    // cout << -4*pow(mgluino,2)/(mchar*mtop)*G7st1sb1 << endl;
    // cout << -4*mgluino/mchar*G4st1sb1 << endl;
    // cout << -8*pow(mgluino,2)*G6st1sb1 << endl;

    // cout << "Term by term for Gammast1sb1: " << endl;
    // cout << "G6 term: " << (cos(thetat)*sin(thetab)*alphasb1ch*betast1ch+sin(thetat)*cos(thetab)*betasb1ch*alphast1ch)*G6st1sb1*4*pow(mgluino*gs,2) << endl;
    // cout << "G4 term: " << - (cos(thetat)*cos(thetab)*alphasb1ch*alphast1ch + sin(thetat)*sin(thetab)*betasb1ch*betast1ch)*G4st1sb1*4*pow(mgluino*gs,2) << endl;
    // cout << "G7 term: " << - (cos(thetat)*sin(thetab)*betasb1ch*betast1ch + sin(thetat)*cos(thetab)*alphasb1ch*alphast1ch)*G7st1sb1*4*pow(mgluino*gs,2) << endl;
    // cout << "G5 term: " <<  (cos(thetat)*cos(thetab)*betasb1ch*alphast1ch + sin(thetat)*sin(thetab)*alphasb1ch*betast1ch)*G5st1sb1*4*pow(mgluino*gs,2) << endl;

    // cout << "Term by term for Gammast1sb2: " << endl;
    // cout << (cos(thetat)*-cos(thetab)*alphasb2ch*betast1ch+sin(thetat)*sin(thetab)*betasb2ch*alphast1ch)*G6st1sb2*4*pow(mgluino*gs,2) << endl;
    // cout << - (cos(thetat)*sin(thetab)*alphasb2ch*alphast1ch - sin(thetat)*cos(thetab)*betasb2ch*betast1ch)*G4st1sb2*4*pow(mgluino*gs,2) << endl;
    // cout << - (cos(thetat)*sin(thetab)*betasb2ch*alphast1ch - sin(thetat)*cos(thetab)*alphasb2ch*betast1ch)*G5st1sb2*4*pow(mgluino*gs,2) << endl;
    // cout << + (cos(thetat)*-cos(thetab)*betasb2ch*betast1ch + sin(thetat)*sin(thetab)*alphasb2ch*alphast1ch)*G7st1sb2*4*pow(mgluino*gs,2) << endl;

    // cout << "Term by term for Gammast2sb1: " << endl;
    // cout << (sin(thetat)*sin(thetab)*alphasb1ch*betast2ch-cos(thetat)*cos(thetab)*betasb1ch*alphast2ch)*G6st2sb1*4*pow(mgluino*gs,2) << endl;
    // cout << - (sin(thetat)*cos(thetab)*alphasb1ch*alphast2ch - cos(thetat)*sin(thetab)*betasb1ch*betast2ch)*G4st2sb1*4*pow(mgluino*gs,2) << endl;
    // cout << - (sin(thetat)*cos(thetab)*betasb1ch*alphast2ch - cos(thetat)*sin(thetab)*alphasb1ch*betast2ch)*G5st2sb1*4*pow(mgluino*gs,2) << endl;
    // cout << + (sin(thetat)*sin(thetab)*betasb1ch*betast2ch - cos(thetat)*cos(thetab)*alphasb1ch*alphast2ch)*G7st2sb1*4*pow(mgluino*gs,2) << endl;

    // cout << "Term by term for Gammast2sb2: " << endl;
    // cout << (sin(thetat)*-cos(thetab)*alphasb2ch*betast2ch-cos(thetat)*sin(thetab)*betasb2ch*alphast2ch)*G6st2sb2*4*pow(mgluino*gs,2) << endl;
    // cout << - (sin(thetat)*sin(thetab)*alphasb2ch*alphast2ch + cos(thetat)*cos(thetab)*betasb2ch*betast2ch)*G4st2sb2*4*pow(mgluino*gs,2) << endl;
    // cout << - (sin(thetat)*sin(thetab)*betasb2ch*alphast2ch + cos(thetat)*cos(thetab)*alphasb2ch*betast2ch)*G5st2sb2*4*pow(mgluino*gs,2) << endl;
    // cout << + (sin(thetat)*-cos(thetab)*betasb2ch*betast2ch - cos(thetat)*sin(thetab)*alphasb2ch*alphast2ch)*G7st2sb2*4*pow(mgluino*gs,2) << endl;

    
    
    // cout << "Couplings: " << endl;

    // cout << "gs/sqrt(2)*cos(thetat) = " << gs*cos(thetat)/pow(2,0.5) << " gs/sqrt(2)*sin(thetat) = " << gs*sin(thetat)/pow(2,0.5) << endl;
    // cout << "gs/sqrt(2)*cos(thetab) = " << gs*cos(thetab)/pow(2,0.5) << " gs/sqrt(2)*sin(thetab) = " << gs*sin(thetab)/pow(2,0.5) << endl;
    // cout << -g*sin(gammaR)*cos(thetat) + g*runmt/(pow(2,0.5)*MWboson*sin(beta))*cos(gammaR)*sin(thetat) << endl;

    // cout << "alphast1ch1 = " << couplingst(9) << " alphast1ch2 = " << couplingst(10) << " betast1ch1 = " << couplingst(11) << " betast1ch2 = " << couplingst(12) << endl;
    // cout << "alphast2ch1 = " << couplingst(13) << " alphast2ch2 = " << couplingst(14) << " betast2ch1 = " << couplingst(15) << " betast2ch2 = " << couplingst(16) << endl;
    // cout << "alphasb1ch1 = " << couplingsb(9) << " alphasb1ch2 = " << couplingsb(10) << " betasb1ch1 = " << couplingsb(11) << " betasb1ch2 = " << couplingsb(12) << endl;
    // cout << "alphasb2ch1 = " << couplingsb(13) << " alphasb2ch2 = " << couplingsb(14) << " betasb2ch1 = " << couplingsb(15) << " betasb2ch2 = " << couplingsb(16) << endl;
    
    // cout << "Gammast1 = " << Gammast1 << " Gammast2 = " << Gammast2 << endl;
    // cout << "Gammasb1 = " << Gammasb1 << " Gammasb2 = " << Gammasb2 << endl;
    // cout << "Gammast1st2 = " << Gammast1st2 << endl;
    // cout << "Gammast1sb1 = " << Gammast1sb1 << " Gammast1sb2 = " << Gammast1sb2 << endl;
    // cout << "Gammast2sb1 = " << Gammast2sb1 << " Gammast2sb2 = " << Gammast2sb2 << endl;
    // cout << "fac from SPheno = " << 1/(256*pow(PI*mgluino,3)) << endl;
    // cout << "Conversion factor = " << 4*pow(mgluino*gs,2) << endl;
    // cout << "Converted Gammast1 = " << Gammast1*4*pow(mgluino*gs,2) << " Converted Gammast2 = " << Gammast2*4*pow(mgluino*gs,2) << endl;
    // cout << "Converted Gammasb1 = " << Gammasb1*4*pow(mgluino*gs,2) << " Converted Gammasb2 = " << Gammasb2*4*pow(mgluino*gs,2) << endl;
    // cout << "Converted Gammast1st2 = " << Gammast1st2*4*pow(mgluino*gs,2) << endl;
    // cout << "Converted Gammast1sb1 = " << Gammast1sb1*4*pow(mgluino*gs,2) << " Converted Gammast1sb2 = " << Gammast1sb2*4*pow(mgluino*gs,2) << endl;
    // cout << "Converted Gammast2sb1 = " << Gammast2sb1*4*pow(mgluino*gs,2) << " Converted Gammast2sb2 = " << Gammast2sb2*4*pow(mgluino*gs,2) << endl;

    amplitudeW = alphas/(16*pow(PI,2)*mgluino)*(Gammast1 + Gammast2 + Gammast1st2 + Gammasb1 + Gammasb2 + Gammast1sb1 + Gammast2sb1 + Gammast1sb2 + Gammast2sb2);
  }
  
  return amplitudeW;

}


double gluinoamplitudedecaydgausschartbbarorig (double mgluino, double mst1, double mst2, double msb1, double msb2, double mtop, double mbottom, double mchar, double alphas, double thetat, double thetab, double MWBoson, double g, double gp, double gammaL, double gammaR, double beta, double runmt, double runmb, int chargino, int onetothree) ///Calculates PW for gluino 1->3 decays to chargino and a q q'bar pair, m2 is st1 mass, m3 is st2 mass, m4 is sb1 mass, m5 is sb2 mass, m6 is top mass, m7 is bottom mass, m8 is chargino mass
{
  double Gammast1 = 0, Gammast2 = 0, Gammast1st2 = 0 , Gammasb1 =0, Gammasb2 = 0, Gammast1sb1 = 0, Gammast1sb2 = 0, Gammast2sb1 = 0, Gammast2sb2 = 0, alphast1char = 0, betast1char = 0, alphasb1char = 0, betasb1char = 0, alphast2char = 0, betast2char = 0, alphasb2char = 0, betasb2char = 0, ft = 0, fb = 0, from = 0, upper = 0, fromb = 0, upperb = 0, amplitudeW = 0;
  
  if (mgluino > mbottom + msb1 || mgluino > mbottom + msb2 || mgluino > mtop + mst1 || mgluino > mtop + mst2 || mgluino < mtop + mbottom + mchar) {amplitudeW = 0;}
  else {
    from = mtop;
    upper = (pow(mgluino,2)+pow(mtop,2)-pow(mchar+mbottom,2))/(2*mgluino);
    fromb = mbottom;
    upperb = (pow(mgluino,2)-pow(mtop+mchar,2))/(2*mgluino);
    ft = g*runmt/(pow(2,0.5)*MWBoson*sin(beta));
    fb = g*runmb/(pow(2,0.5)*MWBoson*cos(beta));
    if (chargino == 1) {
      alphast1char = -g*sin(gammaR)*cos(thetat)+ft*cos(gammaR)*sin(thetat);
      betast1char = -fb*cos(gammaL)*cos(thetat);
      alphasb1char = -g*sin(gammaL)*cos(thetab)+fb*cos(gammaL)*sin(thetab);
      betasb1char = -ft*cos(gammaR)*cos(thetab);
      alphast2char = -g*sin(gammaR)*sin(thetat)+ft*cos(gammaR)*-cos(thetat);
      betast2char = -fb*cos(gammaL)*sin(thetat);
      alphasb2char = -g*sin(gammaL)*sin(thetab)-fb*cos(gammaL)*cos(thetab);
      betasb2char = -ft*cos(gammaR)*sin(thetab);
    }
    else if (chargino == 2) {
      alphast1char = -g*cos(gammaR)*cos(thetat)-ft*sin(gammaR)*sin(thetat);
      betast1char = fb*sin(gammaL)*cos(thetat);
      alphasb1char = -g*cos(gammaL)*cos(thetab)-fb*sin(gammaL)*sin(thetab);
      betasb1char = ft*sin(gammaR)*cos(thetab);
      alphast2char = -g*cos(gammaR)*sin(thetat)-ft*sin(gammaR)*-cos(thetat);
      betast2char = fb*sin(gammaL)*sin(thetat);
      alphasb2char = -g*cos(gammaL)*sin(thetab)+fb*sin(gammaL)*cos(thetab);
      betasb2char = ft*sin(gammaR)*sin(thetab);
    }
    
    double G1st1=0, G8st1=0;
    m1 = mgluino, m2 = mst1, m3 = mst1, m6 = mtop, m8 = mchar;
    G1st1 = dgauss(gG1dgauss,from,upper,accuracy);
    G8st1 = dgauss(gG8dgauss,from,upper,accuracy);
    
    Gammast1 = (pow(alphast1char,2)+pow(betast1char,2))*(G1st1 - sin(2*thetat)*G8st1);

    double G1st2=0, G8st2=0;
    m1 = mgluino, m2 = mst2, m3 = mst2, m6 = mtop, m8 = mchar;
    G1st2 = dgauss(gG1dgauss,from,upper,accuracy);
    G8st2 = dgauss(gG8dgauss,from,upper,accuracy);

    Gammast2 = (pow(alphast2char,2)+pow(betast2char,2))*(G1st2 - sin(2*thetat)*G8st2);

    double G8st1st2=0;
    m1 = mgluino, m2 = mst1, m3 = mst2, m6 = mtop, m8 = mchar;
    G8st1st2 = dgauss(gG8dgauss,from,upper,accuracy);

    Gammast1st2 = -2*(alphast1char*alphast2char+betast1char*betast2char)*cos(2*thetat)*G8st1st2;

    
    double G2sb1=0, G3sb1=0;
    m1 = mgluino, m4 = msb1, m6 = mtop, m7 = mbottom, m8 = mchar;
    G2sb1 = dgauss(gG2dgauss,fromb,upperb,accuracy);
    G3sb1 = dgauss(gG3dgauss,fromb,upperb,accuracy);

    Gammasb1 = (pow(alphasb1char,2)+pow(betasb1char,2))*G2sb1 - alphasb1char*betasb1char*G3sb1;

    double G2sb2=0, G3sb2=0;
    m1 = mgluino, m4 = msb2, m6 = mtop, m7 = mbottom, m8 = mchar;
    G2sb2 = dgauss(gG2dgauss,fromb,upperb,accuracy);
    G3sb2 = dgauss(gG3dgauss,fromb,upperb,accuracy);

    Gammasb2 = (pow(alphasb2char,2)+pow(betasb2char,2))*G2sb2 - alphasb2char*betasb2char*G3sb2;

    ///Taken mb -> 0 limit in squared matrix element (but not in phase space) so no sb1sb2 interference term
    

    double G6st1sb1=0, G4st1sb1=0, G5st1sb1=0, G7st1sb1=0;
    m1 = mgluino, m2 = mst1, m4 = msb1, m6 = mtop, m7 = mbottom , m8 = mchar;
    G4st1sb1 = dgauss(gG4dgauss,from,upper,accuracy);
    G5st1sb1 = dgauss(gG5dgauss,from,upper,accuracy);
    G6st1sb1 = dgauss(gG6dgauss,from,upper,accuracy);
    G7st1sb1 = dgauss(gG7dgauss,from,upper,accuracy);

    Gammast1sb1 = (cos(thetat)*sin(thetab)*alphasb1char*betast1char+sin(thetat)*cos(thetab)*betasb1char*alphast1char)*G6st1sb1 - (cos(thetat)*cos(thetab)*alphasb1char*alphast1char + sin(thetat)*sin(thetab)*betasb1char*betast1char)*G4st1sb1 + (cos(thetat)*cos(thetab)*betasb1char*alphast1char + sin(thetat)*sin(thetab)*alphasb1char*betast1char)*G5st1sb1 - (cos(thetat)*sin(thetab)*betasb1char*betast1char + sin(thetat)*cos(thetab)*alphasb1char*alphast1char)*G7st1sb1;

    double G6st1sb2=0, G4st1sb2=0, G5st1sb2=0, G7st1sb2=0;
    m1 = mgluino, m2 = mst1, m4 = msb2, m6 = mtop, m7 = mbottom, m8 = mchar;
    G4st1sb2 = dgauss(gG4dgauss,from,upper,accuracy);
    G5st1sb2 = dgauss(gG5dgauss,from,upper,accuracy);
    G6st1sb2 = dgauss(gG6dgauss,from,upper,accuracy);
    G7st1sb2 = dgauss(gG7dgauss,from,upper,accuracy);

    Gammast1sb2 = (cos(thetat)*-cos(thetab)*alphasb2char*betast1char+sin(thetat)*sin(thetab)*betasb2char*alphast1char)*G6st1sb2 - (cos(thetat)*sin(thetab)*alphasb2char*alphast1char - sin(thetat)*cos(thetab)*betasb2char*betast1char)*G4st1sb2 + (cos(thetat)*sin(thetab)*betasb2char*alphast1char - sin(thetat)*cos(thetab)*alphasb2char*betast1char)*G5st1sb2 - (cos(thetat)*-cos(thetab)*betasb2char*betast1char + sin(thetat)*sin(thetab)*alphasb2char*alphast1char)*G7st1sb2;

    double G6st2sb1=0, G4st2sb1=0, G5st2sb1=0, G7st2sb1=0;
    m1 = mgluino, m2 = mst2, m4 = msb1, m6 = mtop, m7 = mbottom, m8 = mchar;
    G4st2sb1 = dgauss(gG4dgauss,from,upper,accuracy);
    G5st2sb1 = dgauss(gG5dgauss,from,upper,accuracy);
    G6st2sb1 = dgauss(gG6dgauss,from,upper,accuracy);
    G7st2sb1 = dgauss(gG7dgauss,from,upper,accuracy);

    Gammast2sb1 = (sin(thetat)*sin(thetab)*alphasb1char*betast2char-cos(thetat)*cos(thetab)*betasb1char*alphast2char)*G6st2sb1 - (sin(thetat)*cos(thetab)*alphasb1char*alphast2char - cos(thetat)*sin(thetab)*betasb1char*betast2char)*G4st2sb1 + (sin(thetat)*cos(thetab)*betasb1char*alphast2char - cos(thetat)*sin(thetab)*alphasb1char*betast2char)*G5st2sb1 - (sin(thetat)*sin(thetab)*betasb1char*betast2char - cos(thetat)*cos(thetab)*alphasb1char*alphast2char)*G7st2sb1;

    double G6st2sb2=0, G4st2sb2=0, G5st2sb2=0, G7st2sb2=0;
    m1 = mgluino, m2 = mst2, m4 = msb2, m6 = mtop, m7 = mbottom, m8 = mchar;
    G4st2sb2 = dgauss(gG4dgauss,from,upper,accuracy);
    G5st2sb2 = dgauss(gG5dgauss,from,upper,accuracy);
    G6st2sb2 = dgauss(gG6dgauss,from,upper,accuracy);
    G7st2sb2 = dgauss(gG7dgauss,from,upper,accuracy);
    
    Gammast2sb2 = (sin(thetat)*-cos(thetab)*alphasb2char*betast2char-cos(thetat)*sin(thetab)*betasb2char*alphast2char)*G6st2sb2 - (sin(thetat)*sin(thetab)*alphasb2char*alphast2char + cos(thetat)*cos(thetab)*betasb2char*betast2char)*G4st2sb2 + (sin(thetat)*sin(thetab)*betasb2char*alphast2char + cos(thetat)*cos(thetab)*alphasb2char*betast2char)*G5st2sb2 - (sin(thetat)*-cos(thetab)*betasb2char*betast2char - cos(thetat)*sin(thetab)*alphasb2char*alphast2char)*G7st2sb2;

    /// cout << endl;
    /// cout << "GLUINO TO CHARGINO + 3RD GEN QUARKS INFO: " << endl;
    /// cout << "gluinoamplitudedecaychartbbar: " << endl;
    /// cout << "Gammast1 = " << Gammast1 << " Gammast2 = " << Gammast2 << " Gammast1st2 = " << Gammast1st2 << endl;
    /// cout << "Gammasb1 = " << Gammasb1 << " Gammasb2 = " << Gammasb2 << " Gammast1sb1 = " << Gammast1sb1 << endl;
    /// cout << "Gammast2sb1 = " << Gammast2sb1 << " Gammast1sb2 = " << Gammast1sb2 << " Gammast2sb2 = " << Gammast2sb2 << endl;
    /// cout << "m1 = " << m1 << " m2 = " << m2 << " m3 = " << m3 << " m4 = " << m4 << endl;
    /// cout << "m5 = " << m5 << " m6 = " << m6 << " m7 = " << m7 << " m8 = " << m8 << endl;
    /// cout << "A = " << pow(m1,2)+pow(m6,2)-2*250*m1 << endl;
    /// cout << "pt = " << pow(pow(250,2)-pow(m6,2),0.5) << endl;
    /// ///cout << "mg*pt*Et = " << m1*250*pow(pow(250,2)-pow(m6,2),0.5) << endl;
    /// ///cout << "(A-mchar^2)^2 = " << pow(pow(m1,2)+pow(m6,2)-2*250*m1-pow(m8,2),2) << endl;
    /// ///cout << "denom = " << pow(pow(m1,2)+pow(m6,2)-2*250*m1-pow(m2,2),2)*(pow(m1,2)+pow(m6,2)-2*250*m1) << endl;
    /// cout << "gG1 at Et=250 is: " << gG1(250,m1,m2,m8,m6,to,from) << endl;
    /// cout << "gG2 at Ebbar=250 is: " << gG2(250,m1,m4,m8,m6,m7,tob,fromb) << endl;
    /// cout << "gG3 at Ebbar=250 is: " << gG3(250,m1,m4,m8,m6,m7,tob,fromb) << endl;
    /// cout << "gG4 at Et=250 is: " << gG4(250,m1,m2,m4,m8,m6,m7,to,from) << endl;
    /// DoubleVector Ebbarmaxmin (double mass1, double mass2, double mass3, double mass4, double Et);
    /// cout << "Ebbarmax = " << Ebbarmaxmin(m1, m6, m7, m8, 250)(1) << endl;
    /// cout << "Ebbarmin = " << Ebbarmaxmin(m1, m6, m7, m8, 250)(2) << endl;
    /// double Xfunc (double mass1, double mass2, double mass3, double mass4, double mass5, double Et);
    /// cout << " Xfunc = " << Xfunc(m1, m6, m7, m8, m4, 250) << endl;
    /// cout << "gG5 at Et=250 is: " << gG5(250,m1,m2,m4,m8,m6,m7,to,from) << endl;
    /// cout << "gG6 at Et=250 is: " << gG6(250,m1,m2,m4,m8,m6,m7,to,from) << endl;
    /// cout << "gG7 at Et=250 is: " << gG7(250,m1,m2,m4,m8,m6,m7,to,from) << endl;
    /// cout << "gG8 at Et=250 is: " << gG8(250,m1,m2,m3,m8,m6,m7,to,from) << endl;

    amplitudeW = alphas/(16*pow(PI,2)*mgluino)*(Gammast1+Gammast2+Gammast1st2+Gammasb1+Gammasb2+Gammast1sb1+Gammast1sb2+Gammast2sb1+Gammast2sb2);
    // cout << "Gammast1 = " << Gammast1 << " Gammast2 = " << Gammast2 << " Gammast1st2 = " << Gammast1st2 << " Gammasb1 = " << Gammasb1 << " Gammasb2 = " << Gammasb2 << endl;
    // cout << "Gammast1sb1 = " << Gammast1sb1 << " Gammast1sb2 = " << Gammast1sb2 << " Gammast2sb1 = " << Gammast2sb1 << " Gammast2sb2 = "<< Gammast2sb2 << endl;
  }
  return amplitudeW;
}






double neutralinoamplitudedecaydgaussneutralinoffbar (double mneutralinoi, double msf1, double msf2, double mZboson, double mhiggsl, double mhiggsH, double mhiggsA, double mneutralinoj, double mf, double alphas, double thetaq, double mWboson, double g, double gp, double alpha, double beta, double runmq, DoubleMatrix mixNeut, int ineutralino, int jneutralino, int onetothree, char uordornuorl)
{
  double GammaZ = 0, Gammahsf1 = 0, Gammahsf2 = 0, GammaHsf1 = 0, GammaHsf2 = 0, GammaAsf1 = 0, GammaAsf2 = 0, GammaZsf1 = 0, GammaZsf2 = 0, amplitudeW = 0;

  DoubleVector squarkmixcharginocouplings(double g, double theta, double beta, double gammaL, double gammaR, double runmt, double runmb, double mWboson, int torb);

  cout.precision(7);
  cout << "masses: " << "mneutralinoi = " << mneutralinoi << " msf1 = " << msf1 << " msf2 = " << msf2 << " mZboson = " << mZboson << endl;
  cout << "masses: " << "mhiggsl = " << mhiggsl << " mhiggsH = " << mhiggsH << " mhiggsA = " << mhiggsA << " mneutralinoj = " << mneutralinoj << " mf = " << mf << endl;
  // runmq = 0.0013012;
  cout << "running mass: " << runmq << endl;

  if (fabs(mneutralinoi) > mf + msf1 || fabs(mneutralinoi) > mf + msf2 || fabs(mneutralinoi) > fabs(mneutralinoj) + mhiggsl || fabs(mneutralinoi) > fabs(mneutralinoj) + mhiggsH || fabs(mneutralinoi) > fabs(mneutralinoj) + mhiggsA || fabs(mneutralinoi) > fabs(mneutralinoj) + mZboson || fabs(mneutralinoi) < fabs(mneutralinoj) + mf + mf) {
    amplitudeW = 0;
    cout << "not calculated" << endl;
    cout << fabs(mneutralinoi) - mf - msf1 << endl;
    cout << fabs(mneutralinoi) - mf - msf2 << endl;
    cout << fabs(mneutralinoi) - fabs(mneutralinoj) - mZboson << endl;
    cout << fabs(mneutralinoi) - fabs(mneutralinoj) - mhiggsl << endl;
    cout << fabs(mneutralinoi) - fabs(mneutralinoj) - mhiggsH << endl;
    cout << fabs(mneutralinoi) - fabs(mneutralinoj) - mhiggsA << endl;
    cout << fabs(mneutralinoi)-fabs(mneutralinoj)-mf-mf << endl;
    
  }
  else {
  

    double from = 0, to = 0, fromz = 0, toz = 0, fq = 0, AZi = 0, BZi = 0, sf1alpha1Zi = 0, sf1beta1Zi = 0, sf2alpha1Zi = 0, sf2beta1Zi = 0, AZj = 0, BZj = 0, sf1alpha1Zj = 0, sf1beta1Zj = 0, sf2alpha1Zj = 0, sf2beta1Zj = 0, alphaf = 0, betaf = 0, XijA = 0, XjiA = 0, Wij = 0, Xijh = 0, Xjih = 0, XijH = 0, XjiH = 0, Nc = 0, trigofalphah = 0, trigofalphaH = 0, Aq = 0 , goldstoneffcoup = 0;
        
    from = mf;
    to = (pow(mneutralinoi,2) - 2*mf*fabs(mneutralinoj) - pow(mneutralinoj,2))/(2*fabs(mneutralinoi));

    cout << "g = " << g << " gp = " << gp << endl;

    double ri = 0, rj = 0;
    if (mneutralinoi >= 0) { ri = 1;}
    else if (mneutralinoi < 0) { ri = -1;} ///correction factor for negative masses
    if (mneutralinoj >= 0) { rj = 1;}
    else if (mneutralinoj < 0) { rj = -1;} ///correction factor for negative masses
    
    if (uordornuorl == 'u') {
      fq = g*runmq/(pow(2,0.5)*mWboson*sin(beta));
      AZi = g/(pow(2,0.5))*(-mixNeut(ineutralino,2)) + gp/(3*pow(2,0.5))*(-mixNeut(ineutralino,1));
      BZi = (4./3)*gp/(pow(2,0.5))*(-mixNeut(ineutralino,1));
      sf1alpha1Zi = AZi*cos(thetaq) - fq*mixNeut(ineutralino,4)*sin(thetaq);
      sf1beta1Zi = fq*mixNeut(ineutralino,4)*cos(thetaq) + BZi*sin(thetaq);
      sf2alpha1Zi = (AZi*sin(thetaq)+fq*mixNeut(ineutralino,4)*cos(thetaq));
      sf2beta1Zi = fq*mixNeut(ineutralino,4)*sin(thetaq)-BZi*cos(thetaq);
      AZj = g/(pow(2,0.5))*(-mixNeut(jneutralino,2)) + gp/(3*pow(2,0.5))*(-mixNeut(jneutralino,1));
      BZj = (4./3)*gp/(pow(2,0.5))*(-mixNeut(jneutralino,1));
      sf1alpha1Zj = AZj*cos(thetaq) - fq*mixNeut(jneutralino,4)*sin(thetaq);
      sf1beta1Zj = fq*mixNeut(jneutralino,4)*cos(thetaq) + BZj*sin(thetaq);
      sf2alpha1Zj = (AZj*sin(thetaq)+fq*mixNeut(jneutralino,4)*cos(thetaq));
      sf2beta1Zj = fq*mixNeut(jneutralino,4)*sin(thetaq)-BZj*cos(thetaq);
      alphaf =-5*gp/(g*12) + 0.25*(g/gp);
      betaf = -0.25*(gp/g + g/gp);
      Nc = 3;
      trigofalphah = cos(alpha);
      trigofalphaH = sin(alpha);
      Aq = g*runmq/(mWboson*tan(beta));
      goldstoneffcoup = -fq*sin(beta)/sqrt(2);
    }
    
    else if (uordornuorl == 'd') {
      fq = g*runmq/(pow(2,0.5)*mWboson*cos(beta));
      AZi = g/(pow(2,0.5))*(mixNeut(ineutralino,2)) + gp/(3*pow(2,0.5))*(-mixNeut(ineutralino,1));
      BZi = (2./3)*gp/(pow(2,0.5))*(mixNeut(ineutralino,1));
      sf1alpha1Zi = AZi*cos(thetaq) - fq*mixNeut(ineutralino,3)*sin(thetaq);
      sf1beta1Zi = fq*mixNeut(ineutralino,3)*cos(thetaq) + BZi*sin(thetaq);
      sf2alpha1Zi = (AZi*sin(thetaq)+fq*mixNeut(ineutralino,3)*cos(thetaq));
      sf2beta1Zi = fq*mixNeut(ineutralino,3)*sin(thetaq)-BZi*cos(thetaq);
      AZj = g/(pow(2,0.5))*(mixNeut(jneutralino,2)) + gp/(3*pow(2,0.5))*(-mixNeut(jneutralino,1));
      BZj = (2./3)*gp/(pow(2,0.5))*(mixNeut(jneutralino,1));
      sf1alpha1Zj = AZj*cos(thetaq) - fq*mixNeut(jneutralino,3)*sin(thetaq);
      sf1beta1Zj = fq*mixNeut(jneutralino,3)*cos(thetaq) + BZj*sin(thetaq);
      sf2alpha1Zj = (AZj*sin(thetaq)+fq*mixNeut(jneutralino,3)*cos(thetaq));
      sf2beta1Zj = fq*mixNeut(jneutralino,3)*sin(thetaq)-BZj*cos(thetaq);
      alphaf = gp/(g*12) - 0.25*(g/gp);
      betaf = 0.25*(gp/g + g/gp);
      Nc = 3;
      trigofalphah = -sin(alpha);
      trigofalphaH = cos(alpha);
      Aq = g*runmq*tan(beta)/(mWboson);
      goldstoneffcoup = fq*cos(beta)/sqrt(2);
    }

    else if (uordornuorl == 'n') {
      fq = 0;
      AZi = g/(pow(2,0.5))*(-mixNeut(ineutralino,2)) + gp/(pow(2,0.5))*(mixNeut(ineutralino,1));
      BZi = 0;
      sf1alpha1Zi = AZi*cos(thetaq) - fq*mixNeut(ineutralino,4)*sin(thetaq);
      sf1beta1Zi = fq*mixNeut(ineutralino,4)*cos(thetaq) + BZi*sin(thetaq);
      sf2alpha1Zi = (AZi*sin(thetaq)+fq*mixNeut(ineutralino,4)*cos(thetaq));
      sf2beta1Zi = fq*mixNeut(ineutralino,4)*sin(thetaq)-BZi*cos(thetaq);
      AZj = g/(pow(2,0.5))*(-mixNeut(jneutralino,2)) + gp/(pow(2,0.5))*(mixNeut(jneutralino,1));
      BZj = 0;
      sf1alpha1Zj = AZj*cos(thetaq) - fq*mixNeut(jneutralino,4)*sin(thetaq);
      sf1beta1Zj = fq*mixNeut(jneutralino,4)*cos(thetaq) + BZj*sin(thetaq);
      sf2alpha1Zj = (AZj*sin(thetaq)+fq*mixNeut(jneutralino,4)*cos(thetaq));
      sf2beta1Zj = fq*mixNeut(jneutralino,4)*sin(thetaq)-BZj*cos(thetaq);
      alphaf = 0.25*(gp/g + g/gp);
      betaf = -0.25*(gp/g + g/gp);
      Nc = 1;
      trigofalphah = cos(alpha);
      trigofalphaH = sin(alpha);
      Aq = g*runmq/(tan(beta)*mWboson);
      goldstoneffcoup = -fq*sin(beta)/sqrt(2);
    }

    else if (uordornuorl == 'l') {
      fq = g*runmq/(pow(2,0.5)*mWboson*cos(beta));
      AZi = g/(pow(2,0.5))*(mixNeut(ineutralino,2)) + gp/(pow(2,0.5))*(mixNeut(ineutralino,1));
      BZi = pow(2,0.5)*gp*mixNeut(ineutralino,1);
      sf1alpha1Zi = AZi*cos(thetaq) - fq*mixNeut(ineutralino,3)*sin(thetaq);
      sf1beta1Zi = fq*mixNeut(ineutralino,3)*cos(thetaq) + BZi*sin(thetaq);
      sf2alpha1Zi = (AZi*sin(thetaq)+fq*mixNeut(ineutralino,3)*cos(thetaq));
      sf2beta1Zi = fq*mixNeut(ineutralino,3)*sin(thetaq)-BZi*cos(thetaq);
      AZj = g/(pow(2,0.5))*(mixNeut(jneutralino,2)) + gp/(pow(2,0.5))*(mixNeut(jneutralino,1));
      BZj = pow(2,0.5)*gp*mixNeut(jneutralino,1);
      sf1alpha1Zj = AZj*cos(thetaq) - fq*mixNeut(jneutralino,3)*sin(thetaq);
      sf1beta1Zj = fq*mixNeut(jneutralino,3)*cos(thetaq) + BZj*sin(thetaq);
      sf2alpha1Zj = (AZj*sin(thetaq)+fq*mixNeut(jneutralino,3)*cos(thetaq));
      sf2beta1Zj = fq*mixNeut(jneutralino,3)*sin(thetaq)-BZj*cos(thetaq);
      alphaf = 0.75*gp/g - 0.25*g/gp;
      betaf = 0.25*(gp/g + g/gp);
      Nc = 1;
      trigofalphah = -sin(alpha);
      trigofalphaH = cos(alpha);
      Aq = g*runmq*tan(beta)/(mWboson);
      goldstoneffcoup = fq*cos(beta)/sqrt(2);
    }



    // cout << "Couplings: " << endl;
    // cout << "fermion mass: " << mf << endl;
    // cout << "runmq = " << runmq << endl;
    // cout << "fq = " << fq << endl;
    // cout << "fq*v(i,4) = " << fq*mixNeut(ineutralino,4) << endl;
    // cout << "fq*v(i,3) = " << fq*mixNeut(ineutralino,3) << endl;
    // cout << "AZi = " << AZi << endl;
    // cout << "BZi = " << BZi << endl;
    // cout << "sf1alpha1Zi = " << sf1alpha1Zi << endl;
    // cout << "sf1beta1Zi = " << sf1beta1Zi << endl;
    // cout << "sf2alpha1Zi = " << sf2alpha1Zi << endl;
    // cout << "sf2beta1Zi = " << sf2beta1Zi << endl;
    // cout << "sf1alpha1Zj = " << sf1alpha1Zj << endl;
    // cout << "sf1beta1Zj = " << sf1beta1Zj << endl;
    // cout << "sf2alpha1Zj = " << sf2alpha1Zj << endl;
    // // cout << "sf2alpha1Zj first term = " << (AZj*sin(thetaq)) << endl;
    // // cout << "sf2alpha1Zj second term = " << (fq*mixNeut(jneutralino,3)*cos(thetaq)) << endl;
    // cout << "sf2beta1Zj = "<< sf2beta1Zj << endl;

    // cout << "sin(thetaq) = " << sin(thetaq) << endl;
    // cout << "AZi = " << AZi << endl;
    // cout << "cos(thetaq) = " << cos(thetaq) << endl;
    // cout << "fq*v(i,3) = " << fq*mixNeut(ineutralino,3) << endl;
    // cout << "sin(thetaq)*Azi = " << sin(thetaq)*AZi << endl;
    // cout << "cos(thetaq)fq*v(i,3) = " << cos(thetaq)*fq*mixNeut(ineutralino,3) << endl; 
    // cout << "coupR1 equiv = " << sin(thetaq)*AZi + cos(thetaq)*fq*mixNeut(ineutralino,3) << endl;

    double YZisf1sf1Zj = 0, YZisf2sf2Zj = 0, psitildaZisf1sf2Zj = 0, phitildaZisf1sf2Zj = 0, YZisf1sf2Zj = 0;

    m1 = mneutralinoi, m2 = msf1, m3 = msf1, m4 = mneutralinoj, mq = mf;
    YZisf1sf1Zj = dgauss(gYdgauss,from,to,accuracy);

    m1 = mneutralinoi, m2 = msf2, m3 = msf2, m4 = mneutralinoj, mq = mf;
    YZisf2sf2Zj = dgauss(gYdgauss,from,to,accuracy);

    m1 = mneutralinoi, m2 = msf1, m3 = msf2, m4 = mneutralinoj, mq = mf;
    psitildaZisf1sf2Zj = dgauss(gpsitildadgauss,from,to,accuracy);
    phitildaZisf1sf2Zj = dgauss(gphitildadgauss,from,to,accuracy);
    YZisf1sf2Zj = dgauss(gYdgauss,from,to,accuracy);


    fromz = fabs(mneutralinoj);
    toz = (pow(mneutralinoi,2) + pow(mneutralinoj,2) - 4*pow(mf,2))/(2*fabs(mneutralinoi));
    
    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, MZboson = mZboson, mh = mhiggsl, mH = mhiggsH, mA = mhiggsA, g1 = g, g2 = gp, NeutMIX = mixNeut, neutralinoi = ineutralino, neutralinoj = jneutralino, alphamix = alpha,mq = mf;

    Wij = 0.25*pow(pow(g,2)+pow(gp,2),0.5)*(mixNeut(ineutralino,4)*mixNeut(jneutralino,4) - mixNeut(ineutralino,3)*mixNeut(jneutralino,3));
    double sinthetaW = 0;
    sinthetaW = gp/(pow(pow(g,2)+pow(gp,2),0.5));

   
    ///WORKING FORMULAE FROM HERE DOWNWARDS!!!!!

    ///Redo of Z component via SPheno formulae:

    double intZ1 = 0, intZ2 = 0, intZ3 = 0, intZ4 = 0, sminz = 0, smaxz = 0;
    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, MZboson = mZboson;
    sminz = 4*pow(mf,2);
    smaxz = pow(fabs(mneutralinoi)-fabs(mneutralinoj),2);
    intZ1 = dgauss(gneutineutjffZ1dgauss,sminz,smaxz,accuracy);
    intZ2 = dgauss(gneutineutjffZ2dgauss,sminz,smaxz,accuracy);
    intZ3 = dgauss(gneutineutjffZ3dgauss,sminz,smaxz,accuracy);
    intZ4 = dgauss(gneutineutjffZ4dgauss,sminz,smaxz,accuracy);

    GammaZ = 64*pow(g*sinthetaW,2)*pow(Wij,2)*(-4*fabs(mneutralinoi)*fabs(mneutralinoj)*pow(mf,2)*(pow(alphaf,2)-pow(betaf,2))*intZ4*-rj*ri + pow(mf,2)*(pow(alphaf,2)-pow(betaf,2))*intZ3 - fabs(mneutralinoi)*fabs(mneutralinoj)*(pow(alphaf,2) + pow(betaf,2))*intZ2*-rj*ri + 0.5*(pow(alphaf,2) + pow(betaf,2))*intZ1);

    // cout << "REDONE GAMMAZ: " << endl;
    // cout << "intZ1 = " << intZ1 << endl;
    // cout << "intZ2 = " << intZ2 << endl;
    // cout << "intZ3 = " << intZ3 << endl;
    // cout << "intZ4 = " << intZ4 << endl;
    // cout << "coupcomboZ1 = " << 64*pow(g*sinthetaW,2)*pow(Wij,2)*0.5*(pow(alphaf,2) + pow(betaf,2)) << endl;
    // cout << "coupcomboZ2 = " << -ri*rj*64*pow(g*sinthetaW,2)*pow(Wij,2)*-fabs(mneutralinoi)*fabs(mneutralinoj)*(pow(alphaf,2) + pow(betaf,2)) << endl;
    // cout << "coupcomboZ3 = " << 64*pow(g*sinthetaW,2)*pow(Wij,2)*pow(mf,2)*(pow(alphaf,2)-pow(betaf,2)) << endl;
    // cout << "coupcomboZ4 = " << -ri*rj*64*pow(g*sinthetaW,2)*pow(Wij,2)*-4*fabs(mneutralinoi)*fabs(mneutralinoj)*pow(mf,2)*(pow(alphaf,2)-pow(betaf,2)) << endl;
    // cout << "term by term for GammaZ: " << endl;
    // cout << 64*pow(g*sinthetaW,2)*pow(Wij,2)*0.5*(pow(alphaf,2) + pow(betaf,2))*intZ1 << endl;
    // cout << -ri*rj*64*pow(g*sinthetaW,2)*pow(Wij,2)*-fabs(mneutralinoi)*fabs(mneutralinoj)*(pow(alphaf,2) + pow(betaf,2))*intZ2 << endl;
    // cout << 64*pow(g*sinthetaW,2)*pow(Wij,2)*pow(mf,2)*(pow(alphaf,2)-pow(betaf,2))*intZ3 << endl;
    // cout << -ri*rj*64*pow(g*sinthetaW,2)*pow(Wij,2)*-4*fabs(mneutralinoi)*fabs(mneutralinoj)*pow(mf,2)*(pow(alphaf,2)-pow(betaf,2))*intZ4 << endl;
    // cout << "GammaZ for comp = " << GammaZ << endl;

    ///Redo of sf component via SPheno formulae:

    ///First sf t sf u msf1-msf1, msf1-msf2, msf2-msf2 components:
     m1 = mneutralinoi, m2 = msf1, m3 = msf1, m4 = mneutralinoj, mq = mf;
     double xsiZisf1sf1Zj = 0, rhotildaZisf1sf1Zj = 0, chiprimeZisf1sf1Zj = 0, phitildaZisf1sf1Zj = 0, psitildaZisf1sf1Zj = 0, zetaZisf1sf1Zj = 0, XZisf1sf1Zj = 0, chitildaZisf1sf1Zj = 0;
    phitildaZisf1sf1Zj = dgauss(gphitildadgauss,from,to,accuracy);
    psitildaZisf1sf1Zj = dgauss(gpsitildadgauss,from,to,accuracy);
    YZisf1sf1Zj = dgauss(gYdgauss,from,to,accuracy);
    xsiZisf1sf1Zj = dgauss(gxsidgauss,from,to,accuracy);
    rhotildaZisf1sf1Zj = dgauss(grhodgauss,from,to,accuracy);
    chiprimeZisf1sf1Zj = dgauss(gchiprimedgauss,from,to,accuracy);
    zetaZisf1sf1Zj = dgauss(gzetadgauss,from,to,accuracy);
    XZisf1sf1Zj = dgauss(gXdgauss,from,to,accuracy);
    chitildaZisf1sf1Zj = dgauss(gchidgauss,from,to,accuracy);
    // cout << "integrals in Gammasftsfumsf1msf1: " << endl;
    // cout << "xsiZisf1sf1Zj = " <<  xsiZisf1sf1Zj << endl;
    // cout << "rhotildaZisf1sf1Zj = " << rhotildaZisf1sf1Zj << endl;
    // cout << "chiprimeZisf1sf1Zj = " << chiprimeZisf1sf1Zj << endl;
    // cout << "zetaZisf1sf1Zj = " << zetaZisf1sf1Zj << endl;
    // cout << "XZisf1sf1Zj = " << XZisf1sf1Zj << endl;
    // cout << "chitildaZisf1sf1Zj = " << chitildaZisf1sf1Zj << endl;
   

    m1 = mneutralinoi, m2 = msf2, m3 = msf2, m4 = mneutralinoj, mq = mf;
    double xsiZisf2sf2Zj = 0, rhotildaZisf2sf2Zj = 0, chiprimeZisf2sf2Zj = 0, phitildaZisf2sf2Zj = 0, psitildaZisf2sf2Zj = 0, zetaZisf2sf2Zj = 0, XZisf2sf2Zj = 0, chitildaZisf2sf2Zj = 0;
    phitildaZisf2sf2Zj = dgauss(gphitildadgauss,from,to,accuracy);
    psitildaZisf2sf2Zj = dgauss(gpsitildadgauss,from,to,accuracy);
    YZisf2sf2Zj = dgauss(gYdgauss,from,to,accuracy);
    xsiZisf2sf2Zj = dgauss(gxsidgauss,from,to,accuracy);
    rhotildaZisf2sf2Zj = dgauss(grhodgauss,from,to,accuracy);
    chiprimeZisf2sf2Zj = dgauss(gchiprimedgauss,from,to,accuracy);
    zetaZisf2sf2Zj = dgauss(gzetadgauss,from,to,accuracy);
    XZisf2sf2Zj = dgauss(gXdgauss,from,to,accuracy);
    chitildaZisf2sf2Zj = dgauss(gchidgauss,from,to,accuracy);
    // cout << "integrals in Gammasftsfumsf2msf2: " << endl;
    // cout << "xsiZisf2sf2Zj = " <<  xsiZisf2sf2Zj << endl;
    // cout << "rhotildaZisf2sf2Zj = " << rhotildaZisf2sf2Zj << endl;
    // cout << "chiprimeZisf2sf2Zj = " << chiprimeZisf2sf2Zj << endl;
    // cout << "zetaZisf2sf2Zj = " << zetaZisf2sf2Zj << endl;
    // cout << "XZisf2sf2Zj = " << XZisf2sf2Zj << endl;
    // cout << "chitildaZisf2sf2Zj = " << chitildaZisf2sf2Zj << endl;

    m1 = mneutralinoi, m2 = msf1, m3 = msf2, m4 = mneutralinoj, mq = mf;

    double xsiZisf1sf2Zj = 0, rhotildaZisf1sf2Zj = 0, chiprimeZisf1sf2Zj = 0, zetaZisf1sf2Zj = 0, XZisf1sf2Zj = 0, chitildaZisf1sf2Zj = 0;
    xsiZisf1sf2Zj = dgauss(gxsidgauss,from,to,accuracy);
    rhotildaZisf1sf2Zj = dgauss(grhodgauss,from,to,accuracy);
    chiprimeZisf1sf2Zj = dgauss(gchiprimedgauss,from,to,accuracy);
    zetaZisf1sf2Zj = dgauss(gzetadgauss,from,to,accuracy);
    XZisf1sf2Zj = dgauss(gXdgauss,from,to,accuracy);
    chitildaZisf1sf2Zj = dgauss(gchidgauss,from,to,accuracy);
    // cout << "integrals in Gammasftsfumsf1msf2: " << endl;
    // cout << "xsiZisf1sf2Zj = " <<  xsiZisf1sf2Zj << endl;
    // cout << "rhotildaZisf1sf2Zj = " << rhotildaZisf1sf2Zj << endl;
    // cout << "chiprimeZisf1sf2Zj = " << chiprimeZisf1sf2Zj << endl;
    // cout << "zetaZisf1sf2Zj = " << zetaZisf1sf2Zj << endl;
    // cout << "XZisf1sf2Zj = " << XZisf1sf2Zj << endl;
    // cout << "chitildaZisf1sf2Zj = " << chitildaZisf1sf2Zj << endl;

    double Gammasftsfumsf1msf2 = 0, Gammasftsfumsf1msf1 = 0, Gammasftsfumsf2msf2 = 0;
    Gammasftsfumsf1msf1 = -2*(8*(sf1alpha1Zi*sf1beta1Zi*sf1beta1Zj*sf1alpha1Zj + sf1beta1Zi*sf1alpha1Zi*sf1alpha1Zj*sf1beta1Zj)*pow(mneutralinoi/PI,2)*YZisf1sf1Zj*ri -(sf1alpha1Zi*sf1alpha1Zi*sf1alpha1Zj*sf1alpha1Zj + sf1beta1Zi*sf1beta1Zi*sf1beta1Zj*sf1beta1Zj)*8*pow(mneutralinoi/PI,2)*phitildaZisf1sf1Zj*ri*rj + (sf1beta1Zi*sf1alpha1Zi*sf1beta1Zj*sf1alpha1Zj + sf1alpha1Zi*sf1beta1Zi*sf1alpha1Zj*sf1beta1Zj)*pow(mf,2)*8*pow(mneutralinoi/PI,2)*xsiZisf1sf1Zj*ri -((sf1alpha1Zi*sf1alpha1Zi*sf1beta1Zj*sf1alpha1Zj + sf1beta1Zi*sf1beta1Zi*sf1alpha1Zj*sf1beta1Zj)*fabs(mneutralinoi)*mf)*(8*pow(mneutralinoi/PI,2)*xsiZisf1sf1Zj - 4*pow(mneutralinoi/PI,2)*(pow(mneutralinoi,2)+pow(mneutralinoj,2))*rhotildaZisf1sf1Zj*ri + 8*pow(mneutralinoi/PI,2)*chiprimeZisf1sf1Zj) + fabs(mneutralinoj)*rj*mf*(sf1beta1Zi*sf1alpha1Zi*sf1alpha1Zj*sf1alpha1Zj + sf1alpha1Zi*sf1beta1Zi*sf1beta1Zj*sf1beta1Zj)*(-8*pow(mneutralinoi/PI,2)*xsiZisf1sf1Zj + 8*pow(mneutralinoi,4)/pow(PI,2)*rhotildaZisf1sf1Zj*ri - 8*pow(mneutralinoi/PI,2)*chiprimeZisf1sf1Zj) - (sf1beta1Zi*sf1beta1Zi*sf1beta1Zj*sf1alpha1Zj + sf1alpha1Zi*sf1alpha1Zi*sf1alpha1Zj*sf1beta1Zj)*fabs(mneutralinoi)*ri*mf*(4*pow(mneutralinoi/PI,2)*(pow(mneutralinoi,2)-pow(mneutralinoj,2))*rhotildaZisf1sf1Zj - 8*pow(mneutralinoi/PI,2)*chiprimeZisf1sf1Zj) + (sf1alpha1Zi*sf1beta1Zi*sf1alpha1Zj*sf1alpha1Zj + sf1beta1Zi*sf1alpha1Zi*sf1beta1Zj*sf1beta1Zj)*mf*fabs(mneutralinoj)*rj*ri*8*pow(mneutralinoi/PI,2)*chiprimeZisf1sf1Zj -2*(sf1beta1Zi*sf1beta1Zi*sf1alpha1Zj*sf1alpha1Zj  + sf1alpha1Zi*sf1alpha1Zi*sf1beta1Zj*sf1beta1Zj)*pow(mf,2)*ri*rj*fabs(mneutralinoi)*fabs(mneutralinoj)*4*pow(mneutralinoi/PI,2)*rhotildaZisf1sf1Zj);
    // cout << "Fermion mass: " << mf << endl;
    // cout << "Gammasftsfumsf1msf1 = " << Gammasftsfumsf1msf1 << endl;

    Gammasftsfumsf2msf2 = -2*(8*(sf2alpha1Zi*sf2beta1Zi*sf2beta1Zj*sf2alpha1Zj + sf2beta1Zi*sf2alpha1Zi*sf2alpha1Zj*sf2beta1Zj)*pow(mneutralinoi/PI,2)*YZisf2sf2Zj*ri -(sf2alpha1Zi*sf2alpha1Zi*sf2alpha1Zj*sf2alpha1Zj + sf2beta1Zi*sf2beta1Zi*sf2beta1Zj*sf2beta1Zj)*8*pow(mneutralinoi/PI,2)*phitildaZisf2sf2Zj*ri*rj + (sf2beta1Zi*sf2alpha1Zi*sf2beta1Zj*sf2alpha1Zj + sf2alpha1Zi*sf2beta1Zi*sf2alpha1Zj*sf2beta1Zj)*pow(mf,2)*8*pow(mneutralinoi/PI,2)*xsiZisf2sf2Zj*ri -((sf2alpha1Zi*sf2alpha1Zi*sf2beta1Zj*sf2alpha1Zj + sf2beta1Zi*sf2beta1Zi*sf2alpha1Zj*sf2beta1Zj)*fabs(mneutralinoi)*mf)*(8*pow(mneutralinoi/PI,2)*xsiZisf2sf2Zj - 4*pow(mneutralinoi/PI,2)*(pow(mneutralinoi,2)+pow(mneutralinoj,2))*rhotildaZisf2sf2Zj*ri + 8*pow(mneutralinoi/PI,2)*chiprimeZisf2sf2Zj) + fabs(mneutralinoj)*rj*mf*(sf2beta1Zi*sf2alpha1Zi*sf2alpha1Zj*sf2alpha1Zj + sf2alpha1Zi*sf2beta1Zi*sf2beta1Zj*sf2beta1Zj)*(-8*pow(mneutralinoi/PI,2)*xsiZisf2sf2Zj + 8*pow(mneutralinoi,4)/pow(PI,2)*rhotildaZisf2sf2Zj*ri - 8*pow(mneutralinoi/PI,2)*chiprimeZisf2sf2Zj) - (sf2beta1Zi*sf2beta1Zi*sf2beta1Zj*sf2alpha1Zj + sf2alpha1Zi*sf2alpha1Zi*sf2alpha1Zj*sf2beta1Zj)*fabs(mneutralinoi)*ri*mf*(4*pow(mneutralinoi/PI,2)*(pow(mneutralinoi,2)-pow(mneutralinoj,2))*rhotildaZisf2sf2Zj - 8*pow(mneutralinoi/PI,2)*chiprimeZisf2sf2Zj) + (sf2alpha1Zi*sf2beta1Zi*sf2alpha1Zj*sf2alpha1Zj + sf2beta1Zi*sf2alpha1Zi*sf2beta1Zj*sf2beta1Zj)*mf*fabs(mneutralinoj)*rj*ri*8*pow(mneutralinoi/PI,2)*chiprimeZisf2sf2Zj -2*(sf2beta1Zi*sf2beta1Zi*sf2alpha1Zj*sf2alpha1Zj  + sf2alpha1Zi*sf2alpha1Zi*sf2beta1Zj*sf2beta1Zj)*pow(mf,2)*fabs(mneutralinoi)*fabs(mneutralinoj)*ri*rj*4*pow(mneutralinoi/PI,2)*rhotildaZisf2sf2Zj);

    // cout << "Gammasftsfumsf2msf2 = " << Gammasftsfumsf2msf2 << endl;

    Gammasftsfumsf1msf2 = -2*(8*(sf1alpha1Zi*sf2beta1Zi*sf1beta1Zj*sf2alpha1Zj + sf1beta1Zi*sf2alpha1Zi*sf1alpha1Zj*sf2beta1Zj)*pow(mneutralinoi/PI,2)*YZisf1sf2Zj -(sf1alpha1Zi*sf2alpha1Zi*sf1alpha1Zj*sf2alpha1Zj + sf1beta1Zi*sf2beta1Zi*sf1beta1Zj*sf2beta1Zj)*8*pow(mneutralinoi/PI,2)*phitildaZisf1sf2Zj*ri*rj + (sf1beta1Zi*sf2alpha1Zi*sf1beta1Zj*sf2alpha1Zj + sf1alpha1Zi*sf2beta1Zi*sf1alpha1Zj*sf2beta1Zj)*pow(mf,2)*8*pow(mneutralinoi/PI,2)*xsiZisf1sf2Zj*ri -((sf1alpha1Zi*sf2alpha1Zi*sf1beta1Zj*sf2alpha1Zj + sf1beta1Zi*sf2beta1Zi*sf1alpha1Zj*sf2beta1Zj)*fabs(mneutralinoi)*mf)*(8*pow(mneutralinoi/PI,2)*xsiZisf1sf2Zj - 4*pow(mneutralinoi/PI,2)*(pow(mneutralinoi,2)+pow(mneutralinoj,2))*rhotildaZisf1sf2Zj*ri + 8*pow(mneutralinoi/PI,2)*chiprimeZisf1sf2Zj) + fabs(mneutralinoj)*rj*mf*(sf1beta1Zi*sf2alpha1Zi*sf1alpha1Zj*sf2alpha1Zj + sf1alpha1Zi*sf2beta1Zi*sf1beta1Zj*sf2beta1Zj)*(-8*pow(mneutralinoi/PI,2)*xsiZisf1sf2Zj + 8*pow(mneutralinoi,4)/pow(PI,2)*rhotildaZisf1sf2Zj*ri - 8*pow(mneutralinoi/PI,2)*chiprimeZisf1sf2Zj) - (sf1beta1Zi*sf2beta1Zi*sf1beta1Zj*sf2alpha1Zj + sf1alpha1Zi*sf2alpha1Zi*sf1alpha1Zj*sf2beta1Zj)*fabs(mneutralinoi)*ri*mf*(4*pow(mneutralinoi/PI,2)*(pow(mneutralinoi,2)-pow(mneutralinoj,2))*rhotildaZisf1sf2Zj - 8*pow(mneutralinoi/PI,2)*chiprimeZisf1sf2Zj) + (sf1alpha1Zi*sf2beta1Zi*sf1alpha1Zj*sf2alpha1Zj + sf1beta1Zi*sf2alpha1Zi*sf1beta1Zj*sf2beta1Zj)*mf*fabs(mneutralinoj)*rj*8*pow(mneutralinoi/PI,2)*chiprimeZisf1sf2Zj -2*(sf1beta1Zi*sf2beta1Zi*sf1alpha1Zj*sf2alpha1Zj  + sf1alpha1Zi*sf2alpha1Zi*sf1beta1Zj*sf2beta1Zj)*pow(mf,2)*fabs(mneutralinoi)*fabs(mneutralinoj)*ri*rj*4*pow(mneutralinoi/PI,2)*rhotildaZisf1sf2Zj);
    // cout << "Fermion mass: " << mf << endl;
    // cout << "Gammasftsfumsf1msf2 = " << Gammasftsfumsf1msf2 << endl;
    // cout << "Contribution by contribution:" << endl;
    // cout << 8*(sf1alpha1Zi*sf2beta1Zi*sf1beta1Zj*sf2alpha1Zj + sf1beta1Zi*sf2alpha1Zi*sf1alpha1Zj*sf2beta1Zj)*pow(mneutralinoi/PI,2)*YZisf1sf2Zj << endl;
    // cout << -(sf1alpha1Zi*sf2alpha1Zi*sf1alpha1Zj*sf2alpha1Zj + sf1beta1Zi*sf2beta1Zi*sf1beta1Zj*sf2beta1Zj)*8*pow(mneutralinoi/PI,2)*phitildaZisf1sf2Zj*ri*rj << endl;
    // cout << (sf1beta1Zi*sf2alpha1Zi*sf1beta1Zj*sf2alpha1Zj + sf1alpha1Zi*sf2beta1Zi*sf1alpha1Zj*sf2beta1Zj)*pow(mf,2)*8*pow(mneutralinoi/PI,2)*xsiZisf1sf2Zj*ri << endl;
    // cout << -((sf1alpha1Zi*sf2alpha1Zi*sf1beta1Zj*sf2alpha1Zj + sf1beta1Zi*sf2beta1Zi*sf1alpha1Zj*sf2beta1Zj)*fabs(mneutralinoi)*mf)*(8*pow(mneutralinoi/PI,2)*xsiZisf1sf2Zj - 4*pow(mneutralinoi/PI,2)*(pow(mneutralinoi,2)+pow(mneutralinoj,2))*rhotildaZisf1sf2Zj*ri + 8*pow(mneutralinoi/PI,2)*chiprimeZisf1sf2Zj) << endl;
    // cout << fabs(mneutralinoj)*rj*mf*(sf1beta1Zi*sf2alpha1Zi*sf1alpha1Zj*sf2alpha1Zj + sf1alpha1Zi*sf2beta1Zi*sf1beta1Zj*sf2beta1Zj)*(-8*pow(mneutralinoi/PI,2)*xsiZisf1sf2Zj + 8*pow(mneutralinoi,4)/pow(PI,2)*rhotildaZisf1sf2Zj*ri - 8*pow(mneutralinoi/PI,2)*chiprimeZisf1sf2Zj) << endl;

    // cout << - (sf1beta1Zi*sf2beta1Zi*sf1beta1Zj*sf2alpha1Zj + sf1alpha1Zi*sf2alpha1Zi*sf1alpha1Zj*sf2beta1Zj)*fabs(mneutralinoi)*ri*mf*(4*pow(mneutralinoi/PI,2)*(pow(mneutralinoi,2)-pow(mneutralinoj,2))*rhotildaZisf1sf2Zj - 8*pow(mneutralinoi/PI,2)*chiprimeZisf1sf2Zj) << endl;
    // cout << (sf1alpha1Zi*sf2beta1Zi*sf1alpha1Zj*sf2alpha1Zj + sf1beta1Zi*sf2alpha1Zi*sf1beta1Zj*sf2beta1Zj)*mf*fabs(mneutralinoj)*rj*8*pow(mneutralinoi/PI,2)*chiprimeZisf1sf2Zj << endl;
    // cout << -2*(sf1beta1Zi*sf2beta1Zi*sf1alpha1Zj*sf2alpha1Zj  + sf1alpha1Zi*sf2alpha1Zi*sf1beta1Zj*sf2beta1Zj)*pow(mf,2)*fabs(mneutralinoi)*fabs(mneutralinoj)*ri*rj*4*pow(mneutralinoi/PI,2)*rhotildaZisf1sf2Zj << endl;

    // // cout << "FOCUS ON 4TH AND 5TH TERMS: " << endl;
    // // cout << "4th term in pieces: " <<  -((sf1alpha1Zi*sf2alpha1Zi*sf1beta1Zj*sf2alpha1Zj + sf1beta1Zi*sf2beta1Zi*sf1alpha1Zj*sf2beta1Zj)*fabs(mneutralinoi)*ri*mf)*8*pow(mneutralinoi/PI,2)*xsiZisf1sf2Zj << " " << -((sf1alpha1Zi*sf2alpha1Zi*sf1beta1Zj*sf2alpha1Zj + sf1beta1Zi*sf2beta1Zi*sf1alpha1Zj*sf2beta1Zj)*fabs(mneutralinoi)*ri*mf)*-4*pow(mneutralinoi/PI,2)*(pow(mneutralinoi,2)+pow(mneutralinoj,2))*rhotildaZisf1sf2Zj << " " << -((sf1alpha1Zi*sf2alpha1Zi*sf1beta1Zj*sf2alpha1Zj + sf1beta1Zi*sf2beta1Zi*sf1alpha1Zj*sf2beta1Zj)*fabs(mneutralinoi)*ri*mf)*8*pow(mneutralinoi/PI,2)*chiprimeZisf1sf2Zj << " Changed: " << -((sf1alpha1Zi*sf2alpha1Zi*sf1beta1Zj*sf2alpha1Zj + sf1beta1Zi*sf2beta1Zi*sf1alpha1Zj*sf2beta1Zj)*fabs(mneutralinoi)*mf)*(8*pow(mneutralinoi/PI,2)*xsiZisf1sf2Zj - 4*pow(mneutralinoi/PI,2)*(pow(mneutralinoi,2)+pow(mneutralinoj,2))*rhotildaZisf1sf2Zj*ri + 8*pow(mneutralinoi/PI,2)*chiprimeZisf1sf2Zj) << endl;
    // // cout << "5th term in pieces: " << fabs(mneutralinoj)*ri*rj*mf*(sf1beta1Zi*sf2alpha1Zi*sf1alpha1Zj*sf2alpha1Zj + sf1alpha1Zi*sf2beta1Zi*sf1beta1Zj*sf2beta1Zj)*-8*pow(mneutralinoi/PI,2)*xsiZisf1sf2Zj << " " << fabs(mneutralinoj)*ri*rj*mf*(sf1beta1Zi*sf2alpha1Zi*sf1alpha1Zj*sf2alpha1Zj + sf1alpha1Zi*sf2beta1Zi*sf1beta1Zj*sf2beta1Zj)*8*pow(mneutralinoi,4)/pow(PI,2)*rhotildaZisf1sf2Zj << " " << fabs(mneutralinoj)*ri*rj*mf*(sf1beta1Zi*sf2alpha1Zi*sf1alpha1Zj*sf2alpha1Zj + sf1alpha1Zi*sf2beta1Zi*sf1beta1Zj*sf2beta1Zj)*-8*pow(mneutralinoi/PI,2)*chiprimeZisf1sf2Zj << " Changed: " << fabs(mneutralinoj)*rj*mf*(sf1beta1Zi*sf2alpha1Zi*sf1alpha1Zj*sf2alpha1Zj + sf1alpha1Zi*sf2beta1Zi*sf1beta1Zj*sf2beta1Zj)*(-8*pow(mneutralinoi/PI,2)*xsiZisf1sf2Zj + 8*pow(mneutralinoi,4)/pow(PI,2)*rhotildaZisf1sf2Zj*ri - 8*pow(mneutralinoi/PI,2)*chiprimeZisf1sf2Zj)  << endl;
    

    ///sf sf diag contribution 2x as t and u same
    double Gammasf1sf1diag = 0, Gammasf2sf2diag = 0;
    Gammasf1sf1diag = (pow(sf1alpha1Zi,2)+pow(sf1beta1Zi,2))*(pow(sf1alpha1Zj,2)+pow(sf1beta1Zj,2))*8*pow(mneutralinoi/PI,2)*psitildaZisf1sf1Zj + rj*4*(pow(sf1alpha1Zi,2)+pow(sf1beta1Zi,2))*sf1alpha1Zj*sf1beta1Zj*mf*fabs(mneutralinoj)*8*pow(mneutralinoi/PI,2)*chitildaZisf1sf1Zj - ri*4*(pow(sf1alpha1Zj,2)+pow(sf1beta1Zj,2))*sf1alpha1Zi*sf1beta1Zi*fabs(mneutralinoi)*mf*8*pow(mneutralinoi/PI,2)*XZisf1sf1Zj - ri*rj*16*sf1alpha1Zi*sf1beta1Zi*sf1alpha1Zj*sf1beta1Zj*fabs(mneutralinoi)*pow(mf,2)*fabs(mneutralinoj)*4*pow(mneutralinoi/PI,2)*zetaZisf1sf1Zj;
    Gammasf2sf2diag = (pow(sf2alpha1Zi,2)+pow(sf2beta1Zi,2))*(pow(sf2alpha1Zj,2)+pow(sf2beta1Zj,2))*8*pow(mneutralinoi/PI,2)*psitildaZisf2sf2Zj + rj*4*(pow(sf2alpha1Zi,2)+pow(sf2beta1Zi,2))*sf2alpha1Zj*sf2beta1Zj*mf*fabs(mneutralinoj)*8*pow(mneutralinoi/PI,2)*chitildaZisf2sf2Zj - 4*ri*(pow(sf2alpha1Zj,2)+pow(sf2beta1Zj,2))*sf2alpha1Zi*sf2beta1Zi*fabs(mneutralinoi)*mf*8*pow(mneutralinoi/PI,2)*XZisf2sf2Zj - ri*rj*16*sf2alpha1Zi*sf2beta1Zi*sf2alpha1Zj*sf2beta1Zj*fabs(mneutralinoi)*pow(mf,2)*fabs(mneutralinoj)*4*pow(mneutralinoi/PI,2)*zetaZisf2sf2Zj;
    cout << "neutralino-fermion-sfermion couplings: " << endl;
    cout << "mf = " << mf << endl;
    cout << "sf1alpha1Zi = " << sf1alpha1Zi << endl;
    cout << "sf1beta1Zi = " << sf1beta1Zi << endl;
    cout << "yukawa u: " << fq << endl;
    // cout << "Gammasf1sf1diag term by term:" << endl;
    // cout << (pow(sf1alpha1Zi,2)+pow(sf1beta1Zi,2))*(pow(sf1alpha1Zj,2)+pow(sf1beta1Zj,2))*8*pow(mneutralinoi/PI,2)*psitildaZisf1sf1Zj << endl;
    // cout << rj*4*(pow(sf1alpha1Zi,2)+pow(sf1beta1Zi,2))*sf1alpha1Zj*sf1beta1Zj*mf*fabs(mneutralinoj)*8*pow(mneutralinoi/PI,2)*chitildaZisf1sf1Zj << endl;
    // cout << -ri*4*(pow(sf1alpha1Zj,2)+pow(sf1beta1Zj,2))*sf1alpha1Zi*sf1beta1Zi*fabs(mneutralinoi)*mf*8*pow(mneutralinoi/PI,2)*XZisf1sf1Zj << endl;
    // cout << - ri*rj*16*sf1alpha1Zi*sf1beta1Zi*sf1alpha1Zj*sf1beta1Zj*fabs(mneutralinoi)*pow(mf,2)*fabs(mneutralinoj)*4*pow(mneutralinoi/PI,2)*zetaZisf1sf1Zj << endl;
    // cout << "coefficients for Gammasf1sf1diag: " << endl;
    // cout << (pow(sf1alpha1Zi,2)+pow(sf1beta1Zi,2))*(pow(sf1alpha1Zj,2)+pow(sf1beta1Zj,2))<< endl;
    // cout << rj*4*(pow(sf1alpha1Zi,2)+pow(sf1beta1Zi,2))*sf1alpha1Zj*sf1beta1Zj*mf*fabs(mneutralinoj) << endl;
    // cout << -ri*4*(pow(sf1alpha1Zj,2)+pow(sf1beta1Zj,2))*sf1alpha1Zi*sf1beta1Zi*fabs(mneutralinoi)*mf << endl;
    // cout << - ri*rj*16*sf1alpha1Zi*sf1beta1Zi*sf1alpha1Zj*sf1beta1Zj*fabs(mneutralinoi)*pow(mf,2)*fabs(mneutralinoj) << endl;
    // cout << "integrals for Gammasf1sf1diag: " << endl;
    // cout << "psitildaZisf1sf1Zj = " << psitildaZisf1sf1Zj*8*pow(mneutralinoi/PI,2) << endl;
    // cout << "chitildaZisf1sf1Zj = " << chitildaZisf1sf1Zj*8*pow(mneutralinoi/PI,2) << endl;
    // cout << "XZisf1sf1Zj = " << XZisf1sf1Zj*8*pow(mneutralinoi/PI,2) << endl;
    // cout << "zetaZisf1sf1Zj = " << zetaZisf1sf1Zj*4*pow(mneutralinoi/PI,2) << endl;
    // cout << "Gammasf1sf1diag = " << Gammasf1sf1diag << endl;
    // cout << "Gammasf2sf2diag term by term: " << endl;
    // cout << (pow(sf2alpha1Zi,2)+pow(sf2beta1Zi,2))*(pow(sf2alpha1Zj,2)+pow(sf2beta1Zj,2))*8*pow(mneutralinoi/PI,2)*psitildaZisf2sf2Zj << endl;
    // cout << rj*4*(pow(sf2alpha1Zi,2)+pow(sf2beta1Zi,2))*sf2alpha1Zj*sf2beta1Zj*mf*fabs(mneutralinoj)*8*pow(mneutralinoi/PI,2)*chitildaZisf2sf2Zj << endl;
    // cout << -ri*4*(pow(sf2alpha1Zj,2)+pow(sf2beta1Zj,2))*sf2alpha1Zi*sf2beta1Zi*fabs(mneutralinoi)*mf*8*pow(mneutralinoi/PI,2)*XZisf2sf2Zj << endl;
    // cout << - ri*rj*16*sf2alpha1Zi*sf2beta1Zi*sf2alpha1Zj*sf2beta1Zj*fabs(mneutralinoi)*pow(mf,2)*fabs(mneutralinoj)*4*pow(mneutralinoi/PI,2)*zetaZisf2sf2Zj << endl;
    // cout << "coefficients for Gammasf2sf2diag: " << endl;
    // cout << (pow(sf2alpha1Zi,2)+pow(sf2beta1Zi,2))*(pow(sf2alpha1Zj,2)+pow(sf2beta1Zj,2))<< endl;
    // cout << rj*4*(pow(sf2alpha1Zi,2)+pow(sf2beta1Zi,2))*sf2alpha1Zj*sf2beta1Zj*mf*fabs(mneutralinoj) << endl;
    // cout << -ri*4*(pow(sf2alpha1Zj,2)+pow(sf2beta1Zj,2))*sf2alpha1Zi*sf2beta1Zi*fabs(mneutralinoi)*mf << endl;
    // cout << - ri*rj*16*sf2alpha1Zi*sf2beta1Zi*sf2alpha1Zj*sf2beta1Zj*fabs(mneutralinoi)*pow(mf,2)*fabs(mneutralinoj) << endl;
    // cout << "integrals for Gammasf2sf2diag: " << endl;
    // cout << "psitildaZisf2sf2Zj = " << psitildaZisf2sf2Zj*8*pow(mneutralinoi/PI,2) << endl;
    // cout << "chitildaZisf2sf2Zj = " << chitildaZisf2sf2Zj*8*pow(mneutralinoi/PI,2) << endl;
    // cout << "XZisf2sf2Zj = " << XZisf2sf2Zj*8*pow(mneutralinoi/PI,2) << endl;
    // cout << "zetaZisf2sf2Zj = " << zetaZisf2sf2Zj*4*pow(mneutralinoi/PI,2) << endl;
    // cout << "Gammasf2sf2diag = " << Gammasf2sf2diag << endl;

    ///sf sf non diag 2x as t and u same
    double Gammasfsfnondiag = 0;
    Gammasfsfnondiag = 16*pow(mneutralinoi/PI,2)*((sf1beta1Zi*sf2beta1Zi + sf1alpha1Zi*sf2alpha1Zi)*(sf1alpha1Zj*sf2alpha1Zj + sf2beta1Zj*sf1beta1Zj)*psitildaZisf1sf2Zj + rj*2*(sf1beta1Zi*sf2beta1Zi + sf1alpha1Zi*sf2alpha1Zi)*(sf2alpha1Zj*sf1beta1Zj + sf1alpha1Zj*sf2beta1Zj)*mf*fabs(mneutralinoj)*chitildaZisf1sf2Zj - ri*2*(sf1alpha1Zi*sf2beta1Zi + sf2alpha1Zi*sf1beta1Zi)*(sf1alpha1Zj*sf2alpha1Zj + sf2beta1Zj*sf1beta1Zj)*fabs(mneutralinoi)*mf*XZisf1sf2Zj - ri*rj*2*(sf1alpha1Zi*sf2beta1Zi + sf2alpha1Zi*sf1beta1Zi)*(sf2alpha1Zj*sf1beta1Zj + sf1alpha1Zj*sf2beta1Zj)*pow(mf,2)*fabs(mneutralinoi)*fabs(mneutralinoj)*zetaZisf1sf2Zj);
    // cout << "Gammasfsfnondiag = " << Gammasfsfnondiag << endl;
    // cout << "Contribution by contribution:" << endl;
    // cout << 16*pow(mneutralinoi/PI,2)*((sf1beta1Zi*sf2beta1Zi + sf1alpha1Zi*sf2alpha1Zi)*(sf1alpha1Zj*sf2alpha1Zj + sf2beta1Zj*sf1beta1Zj)*psitildaZisf1sf2Zj) << endl;
    // cout << 16*pow(mneutralinoi/PI,2)*(+2*(sf1beta1Zi*sf2beta1Zi + sf1alpha1Zi*sf2alpha1Zi)*(sf2alpha1Zj*sf1beta1Zj + sf1alpha1Zj*sf2beta1Zj)*mf*fabs(mneutralinoj)*chitildaZisf1sf2Zj)*rj << endl;
    // cout << 16*pow(mneutralinoi/PI,2)*(- 2*(sf1alpha1Zi*sf2beta1Zi + sf2alpha1Zi*sf1beta1Zi)*(sf1alpha1Zj*sf2alpha1Zj + sf2beta1Zj*sf1beta1Zj)*fabs(mneutralinoi)*ri*mf*XZisf1sf2Zj) << endl;
    // cout << 16*pow(mneutralinoi/PI,2)*(-2*(sf1alpha1Zi*sf2beta1Zi + sf2alpha1Zi*sf1beta1Zi)*(sf2alpha1Zj*sf1beta1Zj + sf1alpha1Zj*sf2beta1Zj)*pow(mf,2)*fabs(mneutralinoi)*fabs(mneutralinoj)*ri*rj*zetaZisf1sf2Zj) << endl;
    // cout << "integrals: " << endl;
    // cout << "psitildaZisf1sf2Zj = " << psitildaZisf1sf2Zj*16*pow(mneutralinoi/PI,2) << endl;
    // cout << "chitildaZisf1sf2Zj = " << chitildaZisf1sf2Zj*16*pow(mneutralinoi/PI,2) << endl;
    // cout << "XZisf1sf2Zj = " << XZisf1sf2Zj*16*pow(mneutralinoi/PI,2) << endl;
    // cout << "zetaZisf1sf2Zj = " << 16*pow(mneutralinoi/PI,2)*zetaZisf1sf2Zj << endl;
    // cout << "Couplings: " << endl;
    // cout << ((sf1beta1Zi*sf2beta1Zi + sf1alpha1Zi*sf2alpha1Zi)*(sf1alpha1Zj*sf2alpha1Zj + sf2beta1Zj*sf1beta1Zj)) << endl;
    // cout << (+2*(sf1beta1Zi*sf2beta1Zi + sf1alpha1Zi*sf2alpha1Zi)*(sf2alpha1Zj*sf1beta1Zj + sf1alpha1Zj*sf2beta1Zj)*mf*mneutralinoj) << endl;
    // cout << - 2*(sf1alpha1Zi*sf2beta1Zi + sf2alpha1Zi*sf1beta1Zi)*(sf1alpha1Zj*sf2alpha1Zj + sf2beta1Zj*sf1beta1Zj)*fabs(mneutralinoi)*ri*mf << endl;
    // cout << -2*(sf1alpha1Zi*sf2beta1Zi + sf2alpha1Zi*sf1beta1Zi)*(sf2alpha1Zj*sf1beta1Zj + sf1alpha1Zj*sf2beta1Zj)*pow(mf,2)*fabs(mneutralinoi)*fabs(mneutralinoj)*ri*rj << endl;
    // cout << "coupC(1) equiv = " << (sf1beta1Zi*sf2beta1Zi + sf1alpha1Zi*sf2alpha1Zi) << endl;
    // cout << "coupC(3) equiv = " << (sf1alpha1Zj*sf2alpha1Zj + sf2beta1Zj*sf1beta1Zj) << endl;
    // cout << "coupC(4) equiv = " << (sf2alpha1Zj*sf1beta1Zj + sf1alpha1Zj*sf2beta1Zj) << endl;
    

    double Gammasftot = 0;
    Gammasftot = 2*Gammasf1sf1diag + 2*Gammasf2sf2diag + 2*Gammasfsfnondiag +Gammasftsfumsf1msf1 + Gammasftsfumsf2msf2 + 2*Gammasftsfumsf1msf2;
    // cout << "Gammasftot = " << Gammasftot << endl;
    // cout << "Contributions: " << endl;
    // cout << "Gammasf1sf1diag t = " << Gammasf1sf1diag << endl;
    // cout << "Gammasf1sf1diag u = " << Gammasf1sf1diag << endl;
    // cout << "Gammasf2sf2diag t = " << Gammasf2sf2diag << endl;
    // cout << "Gammasf2sf2diag u = " << Gammasf2sf2diag << endl;
    // cout << "Gammasfsfnondiag t = " << Gammasfsfnondiag << endl;
    // cout << "Gammasfsfnondiag u = " << Gammasfsfnondiag << endl;
    // cout << "Gammasftsfumsf1msf1 = " << Gammasftsfumsf1msf1 << endl;
    // cout << "Gammasftsfumsf1msf2 = " << Gammasftsfumsf1msf2 << endl;
    // cout << "Gammasftsfumsf2msf1 = " << Gammasftsfumsf1msf2 << endl;
    // cout << "Gammasftsfumsf2msf2 = " << Gammasftsfumsf2msf2 << endl;

    ///Redo Gammah:

    double Gammah = 0, GammaH = 0, GammahHinterf = 0, integralh1 = 0, integralh2 = 0, integralh3 = 0, integralh4 =0, integralH1 = 0, integralH2 = 0, integralH3 = 0, integralH4 = 0, integralhH1 = 0, integralhH2 = 0, integralhH3 = 0, integralhH4 = 0;
    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, MZboson = mZboson, mh = mhiggsl, mH = mhiggsH, mA = mhiggsA, g1 = g, g2 = gp, NeutMIX = mixNeut, neutralinoi = ineutralino, neutralinoj = jneutralino, alphamix = alpha,mq = mf;

    integralh1 = dgauss(gintegralh1dgauss,fromz,toz,accuracy);
    integralh2 = dgauss(gintegralh2dgauss,fromz,toz,accuracy);
    integralh3 = dgauss(gintegralh3dgauss,fromz,toz,accuracy);
    integralh4 = dgauss(gintegralh4dgauss,fromz,toz,accuracy);

    integralH1 = dgauss(gintegralH1dgauss,fromz,toz,accuracy);
    integralH2 = dgauss(gintegralH2dgauss,fromz,toz,accuracy);
    integralH3 = dgauss(gintegralH3dgauss,fromz,toz,accuracy);
    integralH4 = dgauss(gintegralH4dgauss,fromz,toz,accuracy);

    integralhH1 = dgauss(gintegralhH1dgauss,fromz,toz,accuracy);
    integralhH2 = dgauss(gintegralhH2dgauss,fromz,toz,accuracy);
    integralhH3 = dgauss(gintegralhH3dgauss,fromz,toz,accuracy);
    integralhH4 = dgauss(gintegralhH4dgauss,fromz,toz,accuracy);


    // // // runmq = 2.577; ///Temporarily set to match SPheno's yukawa coupling

    // cout << "integralh1 = " << integralh1 << endl;
    // cout << "integralh2 = " << integralh2 << endl;
    // cout << "integralh3 = " << integralh3 << endl;
    // cout << "integralh4 = " << integralh4 << endl;
    // cout << "integralH1 = " << integralH1 << endl;
    // cout << "integralH2 = " << integralH2 << endl;
    // cout << "integralH3 = " << integralH3 << endl;
    // cout << "integralH4 = " << integralH4 << endl;
    // cout << "integralhH1 = " << integralhH1 << endl;
    // cout << "integralhH2 = " << integralhH2 << endl;
    // cout << "integralhH3 = " << integralhH3 << endl;
    // cout << "integralhH4 = " << integralhH4 << endl;


    // // cout << "masses for integralh1->4:" << mneutralinoi << " " << mneutralinoj << " " << mh << " " << mq << endl;
    // // cout << "kappa equiv at s = 266.62408746350735: " << 2*mneutralinoi*pow(pow(706.335,2) - pow(m4,2),0.5) << " " << pow(pow(266.624087,2)-4*pow(mq,2),0.5) << endl;

    // // // fq = 0.14883252161557187; ///yukawa used in Spheno for Gammah
    // // // fq = 0.13663644; ///yukawa used in Spheno for GammaH
    // cout << "term by term Gammah: " << endl;
    // cout << integralh4*2*pow(Xijh + Xjih,2)*pow(fq*trigofalphah,2) << endl;
    // cout << -4*integralh3*pow(Xijh + Xjih,2)*pow(fq*trigofalphah,2)*pow(mq,2) << endl;
    // cout << rj*4*pow(Xijh + Xjih,2)*pow(fq*trigofalphah,2)*mneutralinoi*fabs(mneutralinoj)*integralh2 << endl;
    // cout << -rj*8*pow(Xijh + Xjih,2)*pow(fq*trigofalphah,2)*mneutralinoi*fabs(mneutralinoj)*pow(mq,2)*integralh1 << endl;

    // cout << "term by term GammaH: " << endl;
    // cout << integralH4*2*pow(XijH + XjiH,2)*pow(fq*trigofalphaH,2) << endl;
    // cout << -4*integralH3*pow(XijH + XjiH,2)*pow(fq*trigofalphaH,2)*pow(mq,2) << endl;
    // cout << 4*rj*pow(XijH + XjiH,2)*pow(fq*trigofalphaH,2)*mneutralinoi*fabs(mneutralinoj)*integralH2 << endl;
    // cout << -rj*8*pow(XijH + XjiH,2)*pow(fq*trigofalphaH,2)*mneutralinoi*fabs(mneutralinoj)*pow(mq,2)*integralH1 << endl;

    // cout << "term by term GammahH: " << endl;
    // cout <<  2*2*(Xijh + Xjih)*(XijH + XjiH)*pow(fq,2)*trigofalphah*trigofalphaH*(integralhH4) << endl;
    // cout << 2*2*(Xijh + Xjih)*(XijH + XjiH)*pow(fq,2)*trigofalphah*trigofalphaH*-2*pow(mq,2)*integralhH3 << endl;
    // cout << 2*2*(Xijh + Xjih)*(XijH + XjiH)*pow(fq,2)*trigofalphah*trigofalphaH*2*rj*mneutralinoi*fabs(mneutralinoj)*integralhH2 << endl;
    // cout << 2*2*(Xijh + Xjih)*(XijH + XjiH)*pow(fq,2)*trigofalphah*trigofalphaH*-4*rj*mneutralinoi*fabs(mneutralinoj)*pow(mq,2)*integralhH1 << endl;

    // cout << "original Gammah couplings: " << endl;
    // cout << (Xijh + Xjih) << endl;
    // cout << -(Xijh + Xjih) << endl;
    // cout << fq*trigofalphah/pow(2,0.5) << endl;
    // cout << fq*trigofalphah/pow(2,0.5) << endl;

    // cout << "combo couplings Gammah then GammaH: " << endl;
    // cout << 2*pow(Xijh + Xjih,2) << endl;
    // cout << ri*rj*pow(Xijh + Xjih,2) << endl;
    // cout << pow(fq*trigofalphah,2) << endl;
    // cout << pow(fq*trigofalphah,2)/2 << endl;
    // cout << "fq = " << fq << endl;
    // cout << 2*pow(XijH + XjiH,2) << endl;
    // cout << ri*rj*pow(XijH + XjiH,2) << endl;
    // cout << pow(fq*trigofalphaH,2) << endl;
    // cout << pow(fq*trigofalphaH,2)/2 << endl;
    // cout << "alpha = " << alpha << " cos(alpha) = " << cos(alpha) << " sin(alpha) = " << sin(alpha) << endl;

    Gammah = (2*pow(Xijh + Xjih,2)*pow(fq*trigofalphah,2)*(integralh4 -2*pow(mq,2)*integralh3 +rj*2*mneutralinoi*fabs(mneutralinoj)*integralh2 - rj*4*mneutralinoi*fabs(mneutralinoj)*pow(mq,2)*integralh1));
    // cout << "Gammah = " << Gammah << endl;
    
    GammaH = (2*pow(XijH+ XjiH,2)*pow(fq*trigofalphaH,2)*(integralH4 - 2*pow(mq,2)*integralH3 +rj*2*mneutralinoi*fabs(mneutralinoj)*integralH2 - rj*4*mneutralinoi*fabs(mneutralinoj)*pow(mq,2)*integralH1));
    // cout << "GammaH = " << GammaH << endl;

    GammahHinterf = 2*2*(Xijh + Xjih)*(XijH + XjiH)*pow(fq,2)*trigofalphah*trigofalphaH*(integralhH4 - 2*pow(mq,2)*integralhH3 + 2*ri*rj*fabs(mneutralinoi)*fabs(mneutralinoj)*integralhH2 - 4*ri*rj*fabs(mneutralinoi)*fabs(mneutralinoj)*pow(mq,2)*integralhH1);
    // cout << "GammahHinterf = " << GammahHinterf << endl;
    // // cout << (Xijh + Xjih) << " " << (XijH + XjiH) << " " << trigofalphah << " " << trigofalphaH << " " << (integralhH4 - 2*pow(mq,2)*integralhH3 - 2*mneutralinoi*fabs(mneutralinoj)*integralhH2 + 4*mneutralinoi*fabs(mneutralinoj)*pow(mq,2)*integralhH1) << endl;


    ///Pseudoscalar A contribution:

    // cout << "XijA = " << XijA << " XjiA = " << XjiA << " XijA + XjiA = " << XijA + XjiA << endl;
    // cout << "Aq = " << Aq << endl;
    // cout << "CoupC equivs: " << 2*pow(XijA+XjiA,2) << " " << -ri*rj*pow(XijA+XjiA,2) << " " << pow(Aq,2)*0.5 << " " << -pow(Aq,2)*0.25 << endl;


    double GammaA = 0;
    double integralA1 = 0, integralA2 = 0, integralA3 = 0, integralA4 = 0;
    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, MZboson = mZboson, mh = mhiggsl, mH = mhiggsH, mA = mhiggsA, g1 = g, g2 = gp, NeutMIX = mixNeut, neutralinoi = ineutralino, neutralinoj = jneutralino, alphamix = alpha,mq = mf;

    integralA1 = dgauss(gintegralA1dgauss,fromz,toz,accuracy);
    integralA2 = dgauss(gintegralA2dgauss,fromz,toz,accuracy);
    integralA3 = dgauss(gintegralA3dgauss,fromz,toz,accuracy);
    integralA4 = dgauss(gintegralA4dgauss,fromz,toz,accuracy);

    // cout << "integralA1 = " << integralA1 << endl;
    // cout << "integralA2 = " << integralA2 << endl;
    // cout << "integralA3 = " << integralA3 << endl;
    // cout << "integralA4 = " << integralA4 << endl;

    // cout << "Pseudoscalar contribution term by term: " << endl;
    // cout << pow(XijA + XjiA,2)*pow(Aq,2)*(integralA4) << endl;
    // cout << pow(XijA + XjiA,2)*pow(Aq,2)*(2*pow(mq,2)*integralA3) << endl;
    // cout << -rj*ri*pow(XijA + XjiA,2)*pow(Aq,2)*2*fabs(mneutralinoi)*fabs(mneutralinoj)*integralA2 << endl;
    // cout << -rj*ri*pow(XijA + XjiA,2)*pow(Aq,2)*4*pow(mq,2)*fabs(mneutralinoi)*fabs(mneutralinoj)*integralA1 << endl;
    // cout << "Total = " << pow(XijA + XjiA,2)*pow(Aq,2)*(integralA4) +pow(XijA + XjiA,2)*pow(g*runmq*tan(beta)/(mWboson),2)*(2*pow(mq,2)*integralA3) + pow(XijA + XjiA,2)*pow(Aq,2)*2*fabs(mneutralinoi)*fabs(mneutralinoj)*integralA2*-rj*ri + pow(XijA + XjiA,2)*pow(g*runmq*tan(beta)/(mWboson),2)*4*pow(mq,2)*fabs(mneutralinoi)*fabs(mneutralinoj)*integralA1*-rj*ri << endl;

    GammaA = pow(XijA + XjiA,2)*pow(Aq,2)*(integralA4 + 2*pow(mq,2)*integralA3 + 2*fabs(mneutralinoi)*fabs(mneutralinoj)*integralA2*-rj*ri + 4*pow(mq,2)*fabs(mneutralinoi)*fabs(mneutralinoj)*integralA1*-rj*ri);

    // cout << "GammaA = " << GammaA << endl;


    double Gammagoldstone = 0; ///Have an additional pseudoscalar goldstone with mass of Z due to being in Feynman gauge, to add in the longitudinal polarisation of the Z
    double integralgoldstone1 = 0, integralgoldstone2 = 0, integralgoldstone3 = 0, integralgoldstone4 = 0;
    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, MZboson = mZboson, mh = mhiggsl, mH = mhiggsH, mA = mhiggsA, g1 = g, g2 = gp, NeutMIX = mixNeut, neutralinoi = ineutralino, neutralinoj = jneutralino, alphamix = alpha,mq = mf;
    mA = mZboson; ///set so can use same integrals as for pseudoscalar A boson but now with Z mass

    double goldstoneneutineutjcoup = 0;
    goldstoneneutineutjcoup = -0.5*((gp*mixNeut(neutralinoi,1)-g*mixNeut(neutralinoi,2))*(mixNeut(neutralinoj,3)*-cos(beta) - mixNeut(neutralinoj,4)*sin(beta)) + (gp*mixNeut(neutralinoj,1)-g*mixNeut(neutralinoj,2))*(mixNeut(neutralinoi,3)*-cos(beta) - mixNeut(neutralinoi,4)*sin(beta)));
    // cout << "cosb = " << cos(beta) << " sinb = " << sin(beta) << endl;
    // cout << "goldstoneneutineutjcoup = " << goldstoneneutineutjcoup << endl;
    // cout << "goldstoneffcoup = " << goldstoneffcoup << endl;
    // cout << "CoupC equivs for goldstone: " << 2*pow(goldstoneneutineutjcoup,2) << " " << pow(goldstoneneutineutjcoup,2) << " " << 2*pow(goldstoneffcoup,2) << " " << -pow(goldstoneffcoup,2) << endl; 


    integralgoldstone1 = dgauss(gintegralA1dgauss,fromz,toz,accuracy);
    integralgoldstone2 = dgauss(gintegralA2dgauss,fromz,toz,accuracy);
    integralgoldstone3 = dgauss(gintegralA3dgauss,fromz,toz,accuracy);
    integralgoldstone4 = dgauss(gintegralA4dgauss,fromz,toz,accuracy);

    // cout << "integralgoldstone1 = " << integralgoldstone1 << endl;
    // cout << "integralgoldstone2 = " << integralgoldstone2 << endl;
    // cout << "integralgoldstone3 = " << integralgoldstone3 << endl;
    // cout << "integralgoldstone4 = " << integralgoldstone4 << endl;

    // cout << "Goldstone contribution term by term: " << endl;
    // cout << 2*pow(goldstoneneutineutjcoup,2)*2*pow(goldstoneffcoup,2)*(integralgoldstone4) << endl;
    // cout << 2*pow(goldstoneneutineutjcoup,2)*-pow(goldstoneffcoup,2)*(4*-pow(mq,2)*integralgoldstone3) << endl;
    // cout << -rj*ri*pow(goldstoneneutineutjcoup,2)*2*pow(goldstoneffcoup,2)*4*fabs(mneutralinoi)*fabs(mneutralinoj)*integralgoldstone2 << endl;
    // cout << -rj*ri*pow(goldstoneneutineutjcoup,2)*-pow(goldstoneffcoup,2)*16*-pow(mq,2)*fabs(mneutralinoi)*fabs(mneutralinoj)*integralgoldstone1 << endl;
    // cout << "Total = " << 2*pow(goldstoneneutineutjcoup,2)*2*pow(goldstoneffcoup,2)*(integralgoldstone4) + 2*pow(goldstoneneutineutjcoup,2)*-pow(goldstoneffcoup,2)*(4*-pow(mq,2)*integralgoldstone3) -rj*ri*pow(goldstoneneutineutjcoup,2)*2*pow(goldstoneffcoup,2)*4*fabs(mneutralinoi)*fabs(mneutralinoj)*integralgoldstone2 -rj*ri*pow(goldstoneneutineutjcoup,2)*-pow(goldstoneffcoup,2)*16*-pow(mq,2)*fabs(mneutralinoi)*fabs(mneutralinoj)*integralgoldstone1 << endl;

    Gammagoldstone = pow(goldstoneneutineutjcoup,2)*pow(goldstoneffcoup,2)*4*(integralgoldstone4 + 2*pow(mq,2)*integralgoldstone3 + 2*fabs(mneutralinoi)*fabs(mneutralinoj)*integralgoldstone2*-rj*ri + 4*pow(mq,2)*fabs(mneutralinoi)*fabs(mneutralinoj)*integralgoldstone1*-rj*ri);
    // cout << "Gammagoldstone = " << Gammagoldstone << endl;

    // ///Z-sfermion interference terms:
    // cout << "couplings for msf1: " << endl;
    // cout << "coup2(1) = (Nj – Ni – Z)L = " << 2*Wij << endl;
    // cout << "coup2(2) = (Nj - Ni – Z)R = " << 2*Wij << endl;
    // cout << "coup2(3) = [(f – Ni – sf)R]* = " << sf1alpha1Zi << endl;
    // cout << "coup2(4) = [(f-Ni-sf)L]* = " << -sf1beta1Zi << endl;
    // cout << "coup2(5) = fL = -cL*g/costhetaW = " << -(T3 - qf*pow(gp,2)/(pow(g,2)+pow(gp,2)))*g/costhetaW << " = -g*sin(thetaW)*(alphaf-betaf) = " << -g*sinthetaW*(alphaf-betaf) << endl;
    // cout << "coup2(6) = fR = -cR*g/costhetaW = " << qf*pow(gp,2)/(pow(g,2)+pow(gp,2))*g/costhetaW << " = -g*sin(thetaW)*(alphaf+betaf) = " << -g*sinthetaW*(alphaf+betaf) << endl;
    // cout << "coup2(7) = f – Nj – sfL = " << sf1beta1Zj << endl;
    // cout << "coup2(8) = f – Nj – sfR = " << sf1alpha1Zj << endl;

    double coupcombo1Zsf1 = 0, coupcombo2Zsf1 = 0, coupcombo3Zsf1 = 0, coupcombo4Zsf1 = 0, coupcombo5Zsf1 = 0, coupcombo6Zsf1 = 0, coupcombo7Zsf1 = 0, coupcombo8Zsf1 = 0; 
    coupcombo1Zsf1 = -2*2*Wij*g*sinthetaW*(-sf1alpha1Zi*(alphaf-betaf)*sf1beta1Zj + sf1beta1Zi*(alphaf+betaf)*sf1alpha1Zj)*mf*fabs(mneutralinoi);
    coupcombo2Zsf1 = 2*2*Wij*g*sinthetaW*(-sf1alpha1Zi*(alphaf+betaf)*sf1beta1Zj + sf1beta1Zi*(alphaf-betaf)*sf1alpha1Zj)*mf*fabs(mneutralinoj)*-ri*rj;
    coupcombo3Zsf1 = -2*2*Wij*g*sinthetaW*(sf1beta1Zi*(alphaf+betaf)*sf1beta1Zj - sf1alpha1Zi*(alphaf - betaf)*sf1alpha1Zj)*ri;
    coupcombo4Zsf1 = -4*2*Wij*g*sinthetaW*(-sf1alpha1Zi*(alphaf+betaf)*sf1beta1Zj + sf1beta1Zi*(alphaf-betaf)*sf1alpha1Zj)*fabs(mneutralinoi)*mf;
    coupcombo5Zsf1 = 4*2*Wij*g*sinthetaW*(-sf1alpha1Zi*(alphaf-betaf)*sf1beta1Zj + sf1beta1Zi*(alphaf+betaf)*sf1alpha1Zj)*mf*fabs(mneutralinoj)*-ri*rj;
    coupcombo6Zsf1 = 2*2*Wij*g*sinthetaW*(sf1beta1Zi*(alphaf+betaf)*sf1beta1Zj - sf1alpha1Zi*(alphaf-betaf)*sf1alpha1Zj)*fabs(mneutralinoi)*fabs(mneutralinoj)*-rj;
    coupcombo7Zsf1 = -2*2*Wij*g*sinthetaW*(sf1beta1Zi*(alphaf-betaf)*sf1beta1Zj - sf1alpha1Zi*(alphaf+betaf)*sf1alpha1Zj)*pow(mf,2)*ri;
    coupcombo8Zsf1 = 8*2*Wij*g*sinthetaW*(sf1beta1Zi*(alphaf-betaf)*sf1beta1Zj - sf1alpha1Zi*(alphaf+betaf)*sf1alpha1Zj)*pow(mf,2)*fabs(mneutralinoi)*fabs(mneutralinoj)*-rj;
    // cout << "SumI coupling combos for Z msf1: " << endl;
    // cout << "sumI(8) = " << coupcombo8Zsf1 << endl;
    // cout << "sumI(7) = " << coupcombo7Zsf1 << endl;
    // cout << "sumI(6) = " << coupcombo6Zsf1 << endl;
    // cout << "sumI(5) = " << coupcombo5Zsf1 << endl;
    // cout << "sumI(4) = " << coupcombo4Zsf1 << endl;
    // cout << "sumI(3) = " << coupcombo3Zsf1 << endl;
    // cout << "sumI(2) = " << coupcombo2Zsf1 << endl;
    // cout << "sumI(1) = " << coupcombo1Zsf1 << endl;

    double integral1Zsf1 = 0, integral2Zsf1 = 0, integral3Zsf1 = 0, integral4Zsf1 = 0, integral5Zsf1 = 0, integral6Zsf1 = 0, integral7Zsf1 = 0, integral8Zsf1 = 0, integral1Zsf2 = 0, integral2Zsf2 = 0, integral3Zsf2 = 0, integral4Zsf2 = 0, integral5Zsf2 = 0, integral6Zsf2 = 0, integral7Zsf2 = 0, integral8Zsf2 = 0;

    double fromzsfE = 0, tozsfE = 0;
    fromzsfE = fabs(mneutralinoj);
    tozsfE = (pow(mneutralinoi,2) + pow(mneutralinoj,2) - 4*pow(mf,2))/(2*fabs(mneutralinoi));
    
    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, MZboson = mZboson, m2 = msf1;
    integral1Zsf1 = 2*fabs(m1)*dgauss(gintegral1Zsfdgauss,fromzsfE,tozsfE,accuracy);
    integral2Zsf1 = 2*fabs(m1)*dgauss(gintegral2Zsfdgauss,fromzsfE,tozsfE,accuracy);
    integral3Zsf1 = 2*fabs(m1)*dgauss(gintegral3Zsfdgauss,fromzsfE,tozsfE,accuracy);
    integral4Zsf1 = 2*fabs(m1)*dgauss(gintegral4Zsfdgauss,fromzsfE,tozsfE,accuracy);
    integral5Zsf1 = 2*fabs(m1)*dgauss(gintegral5Zsfdgauss,fromzsfE,tozsfE,accuracy);
    integral6Zsf1 = 2*fabs(m1)*dgauss(gintegral6Zsfdgauss,fromzsfE,tozsfE,accuracy);
    integral7Zsf1 = 2*fabs(m1)*dgauss(gintegral7Zsfdgauss,fromzsfE,tozsfE,accuracy);
    integral8Zsf1 = 2*fabs(m1)*dgauss(gintegral8Zsfdgauss,fromzsfE,tozsfE,accuracy);

    // cout << "integrals for Zsf with msf1: " << endl;
    // cout << "integral1Zsf1 = " << integral1Zsf1 << endl;
    // cout << "integral2Zsf1 = " << integral2Zsf1 << endl;
    // cout << "integral3Zsf1 = " << integral3Zsf1 << endl;
    // cout << "integral4Zsf1 = " << integral4Zsf1 << endl;
    // cout << "integral5Zsf1 = " << integral5Zsf1 << endl;
    // cout << "integral6Zsf1 = " << integral6Zsf1 << endl;
    // cout << "integral7Zsf1 = " << integral7Zsf1 << endl;
    // cout << "integral8Zsf1 = " << integral8Zsf1 << endl;

    // cout << "Term by term for Zsf with msf1: " << endl;
    // cout << coupcombo1Zsf1*integral1Zsf1 << endl;
    // cout << coupcombo2Zsf1*integral2Zsf1 << endl;
    // cout << coupcombo3Zsf1*integral3Zsf1 << endl;
    // cout << coupcombo4Zsf1*integral4Zsf1 << endl;
    // cout << coupcombo5Zsf1*integral5Zsf1 << endl;
    // cout << coupcombo6Zsf1*integral6Zsf1 << endl;
    // cout << coupcombo7Zsf1*integral7Zsf1 << endl;
    // cout << coupcombo8Zsf1*integral8Zsf1 << endl;

    GammaZsf1 = (coupcombo1Zsf1*integral1Zsf1 + coupcombo2Zsf1*integral2Zsf1 + coupcombo3Zsf1*integral3Zsf1 + coupcombo4Zsf1*integral4Zsf1 + coupcombo5Zsf1*integral5Zsf1 + coupcombo6Zsf1*integral6Zsf1 + coupcombo7Zsf1*integral7Zsf1 + coupcombo8Zsf1*integral8Zsf1)*ri;
    // cout << "GammaZsf1 = " << GammaZsf1 << endl;

    // cout << "couplings for msf2: " << endl;
    // cout << "coup2(1) = (Nj – Ni – Z)L = " << 2*Wij << endl;
    // cout << "coup2(2) = (Nj - Ni – Z)R = " << 2*Wij << endl;
    // cout << "coup2(3) = [(f – Ni – sf)R]* = " << -sf2alpha1Zi << endl;
    // cout << "coup2(4) = [(f-Ni-sf)L]* = " << sf2beta1Zi << endl;
    // cout << "coup2(5) = fL = -cL*g/costhetaW = " << -(T3 - qf*pow(gp,2)/(pow(g,2)+pow(gp,2)))*g/costhetaW << " = -g*sin(thetaW)*(alphaf-betaf) = " << -g*sinthetaW*(alphaf-betaf) << endl;
    // cout << "coup2(6) = fR = -cR*g/costhetaW = " << qf*pow(gp,2)/(pow(g,2)+pow(gp,2))*g/costhetaW << " = -g*sin(thetaW)*(alphaf+betaf) = " << -g*sinthetaW*(alphaf+betaf) << endl;
    // cout << "coup2(7) = f – Nj – sfL = " << -sf2beta1Zj << endl;
    // cout << "coup2(8) = f – Nj – sfR = " << -sf2alpha1Zj << endl;

    double coupcombo1Zsf2 = 0, coupcombo2Zsf2 = 0, coupcombo3Zsf2 = 0, coupcombo4Zsf2 = 0, coupcombo5Zsf2 = 0, coupcombo6Zsf2 = 0, coupcombo7Zsf2 = 0, coupcombo8Zsf2 = 0;
    coupcombo1Zsf2 = 2*2*Wij*g*sinthetaW*(-sf2alpha1Zi*(alphaf-betaf)*sf2beta1Zj + sf2beta1Zi*(alphaf+betaf)*sf2alpha1Zj)*mf*fabs(mneutralinoi);
    coupcombo2Zsf2 = -2*2*Wij*g*sinthetaW*(-sf2alpha1Zi*(alphaf+betaf)*sf2beta1Zj + sf2beta1Zi*(alphaf-betaf)*sf2alpha1Zj)*mf*fabs(mneutralinoj)*-ri*rj;
    coupcombo3Zsf2 = 2*2*Wij*g*sinthetaW*(sf2beta1Zi*(alphaf+betaf)*sf2beta1Zj - sf2alpha1Zi*(alphaf - betaf)*sf2alpha1Zj)*ri;
    coupcombo4Zsf2 = 4*2*Wij*g*sinthetaW*(-sf2alpha1Zi*(alphaf+betaf)*sf2beta1Zj + sf2beta1Zi*(alphaf-betaf)*sf2alpha1Zj)*fabs(mneutralinoi)*mf;
    coupcombo5Zsf2 = -4*2*Wij*g*sinthetaW*(-sf2alpha1Zi*(alphaf-betaf)*sf2beta1Zj + sf2beta1Zi*(alphaf+betaf)*sf2alpha1Zj)*mf*fabs(mneutralinoj)*-ri*rj;
    coupcombo6Zsf2 =  -2*2*Wij*g*sinthetaW*(sf2beta1Zi*(alphaf+betaf)*sf2beta1Zj - sf2alpha1Zi*(alphaf-betaf)*sf2alpha1Zj)*fabs(mneutralinoi)*fabs(mneutralinoj)*-rj;
    coupcombo7Zsf2 = 2*2*Wij*g*sinthetaW*(sf2beta1Zi*(alphaf-betaf)*sf2beta1Zj - sf2alpha1Zi*(alphaf+betaf)*sf2alpha1Zj)*pow(mf,2)*ri;
    coupcombo8Zsf2 = -8*2*Wij*g*sinthetaW*(sf2beta1Zi*(alphaf-betaf)*sf2beta1Zj - sf2alpha1Zi*(alphaf+betaf)*sf2alpha1Zj)*pow(mf,2)*fabs(mneutralinoi)*fabs(mneutralinoj)*-rj;
    // cout << "SumI coupling combos for msf2: " << endl;
    // cout << "sumI(8) = " << coupcombo8Zsf2 << endl;
    // cout << "sumI(7) = " << coupcombo7Zsf2 << endl;
    // cout << "sumI(6) = " << coupcombo6Zsf2 << endl;
    // cout << "sumI(5) = " << coupcombo5Zsf2 << endl;
    // cout << "sumI(4) = " << coupcombo4Zsf2 << endl;
    // cout << "sumI(3) = " << coupcombo3Zsf2 << endl;
    // cout << "sumI(2) = " << coupcombo2Zsf2 << endl;
    // cout << "sumI(1) = " << coupcombo1Zsf2 << endl;
    // // cout << "sumI(3) part 1 = " << 2*2*Wij*g*sinthetaW*(sf2beta1Zi*(alphaf+betaf)*sf2beta1Zj)*ri << endl;
    // // cout << "sumI(3) part 2 = " << 2*2*Wij*g*sinthetaW*ri*-sf2alpha1Zi*(alphaf - betaf)*sf2alpha1Zj << endl;

    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, MZboson = mZboson, m2 = msf2;
    integral1Zsf2 = 2*fabs(m1)*dgauss(gintegral1Zsfdgauss,fromzsfE,tozsfE,accuracy);
    integral2Zsf2 = 2*fabs(m1)*dgauss(gintegral2Zsfdgauss,fromzsfE,tozsfE,accuracy);
    integral3Zsf2 = 2*fabs(m1)*dgauss(gintegral3Zsfdgauss,fromzsfE,tozsfE,accuracy);
    integral4Zsf2 = 2*fabs(m1)*dgauss(gintegral4Zsfdgauss,fromzsfE,tozsfE,accuracy);
    integral5Zsf2 = 2*fabs(m1)*dgauss(gintegral5Zsfdgauss,fromzsfE,tozsfE,accuracy);
    integral6Zsf2 = 2*fabs(m1)*dgauss(gintegral6Zsfdgauss,fromzsfE,tozsfE,accuracy);
    integral7Zsf2 = 2*fabs(m1)*dgauss(gintegral7Zsfdgauss,fromzsfE,tozsfE,accuracy);
    integral8Zsf2 = 2*fabs(m1)*dgauss(gintegral8Zsfdgauss,fromzsfE,tozsfE,accuracy);

    // cout << "integrals for Zsf with msf2: " << endl;
    // cout << "integral1Zsf2 = " << integral1Zsf2 << endl;
    // cout << "integral2Zsf2 = " << integral2Zsf2 << endl;
    // cout << "integral3Zsf2 = " << integral3Zsf2 << endl;
    // cout << "integral4Zsf2 = " << integral4Zsf2 << endl;
    // cout << "integral5Zsf2 = " << integral5Zsf2 << endl;
    // cout << "integral6Zsf2 = " << integral6Zsf2 << endl;
    // cout << "integral7Zsf2 = " << integral7Zsf2 << endl;
    // cout << "integral8Zsf2 = " << integral8Zsf2 << endl;

    // cout << "Term by term for Zsf with msf2: " << endl;
    // cout << coupcombo1Zsf2*integral1Zsf2 << endl;
    // cout << coupcombo2Zsf2*integral2Zsf2 << endl;
    // cout << coupcombo3Zsf2*integral3Zsf2 << endl;
    // cout << coupcombo4Zsf2*integral4Zsf2 << endl;
    // cout << coupcombo5Zsf2*integral5Zsf2 << endl;
    // cout << coupcombo6Zsf2*integral6Zsf2 << endl;
    // cout << coupcombo7Zsf2*integral7Zsf2 << endl;
    // cout << coupcombo8Zsf2*integral8Zsf2 << endl;

    GammaZsf2 = (coupcombo1Zsf2*integral1Zsf2 + coupcombo2Zsf2*integral2Zsf2 + coupcombo3Zsf2*integral3Zsf2 + coupcombo4Zsf2*integral4Zsf2 + coupcombo5Zsf2*integral5Zsf2 + coupcombo6Zsf2*integral6Zsf2 + coupcombo7Zsf2*integral7Zsf2 + coupcombo8Zsf2*integral8Zsf2)*ri;
    // cout << "GammaZsf2 = " << GammaZsf2 << endl;

    
    ///REDO h/H - sf intereference terms:
    // cout << "h/H - sf couplings for h-sf1: " << endl;
    // cout << -(Xjih + Xijh) << endl;
    // cout << (Xijh + Xjih) << endl;
    // cout << sf1alpha1Zi << endl;
    // cout << -sf1beta1Zi << endl;
    // cout << -fq*trigofalphah/pow(2,0.5) << endl;
    // cout << -fq*trigofalphah/pow(2,0.5) << endl;
    // cout << sf1beta1Zj << endl;
    // cout << sf1alpha1Zj << endl;
    // cout << endl;


    double coupcombo1hsf1 = 0, coupcombo2hsf1 = 0, coupcombo3hsf1 = 0, coupcombo4hsf1 = 0, coupcombo5hsf1 = 0, coupcombo6hsf1 = 0, coupcombo7hsf1 = 0, coupcombo8hsf1 = 0, coupcombo1Hsf1 = 0, coupcombo2Hsf1 = 0, coupcombo3Hsf1 = 0, coupcombo4Hsf1 = 0, coupcombo5Hsf1 = 0, coupcombo6Hsf1 = 0, coupcombo7Hsf1 = 0, coupcombo8Hsf1 = 0, coupcombo1hsf2 = 0, coupcombo2hsf2 = 0, coupcombo3hsf2 = 0, coupcombo4hsf2 = 0, coupcombo5hsf2 = 0, coupcombo6hsf2 = 0, coupcombo7hsf2 = 0, coupcombo8hsf2 = 0, coupcombo1Hsf2 = 0, coupcombo2Hsf2 = 0, coupcombo3Hsf2 = 0, coupcombo4Hsf2 = 0, coupcombo5Hsf2 = 0, coupcombo6Hsf2 = 0, coupcombo7Hsf2 = 0, coupcombo8Hsf2 = 0;

    coupcombo1hsf1 = 0.5*(Xijh+Xjih)*fq*trigofalphah/(pow(2,0.5))*(sf1alpha1Zi*sf1beta1Zj + sf1beta1Zi*sf1alpha1Zj)*-ri*rj;
    coupcombo2hsf1 = (Xijh+Xjih)*fq*trigofalphah/(pow(2,0.5))*(sf1beta1Zi*sf1beta1Zj + sf1alpha1Zi*sf1alpha1Zj)*fabs(mneutralinoi)*mq*-rj;
    coupcombo3hsf1 = (Xijh+Xjih)*fq*trigofalphah/(pow(2,0.5))*(sf1beta1Zi*sf1beta1Zj + sf1alpha1Zi*sf1alpha1Zj)*mq*fabs(mneutralinoj)*ri;
    coupcombo4hsf1 = (Xijh+Xjih)*fq*trigofalphah/(pow(2,0.5))*(-sf1beta1Zi*sf1beta1Zj - sf1alpha1Zi*sf1alpha1Zj)*fabs(mneutralinoi)*mq*-rj;
    coupcombo5hsf1 = (Xijh+Xjih)*fq*trigofalphah/(pow(2,0.5))*(sf1beta1Zi*sf1beta1Zj + sf1alpha1Zi*sf1alpha1Zj)*-mq*fabs(mneutralinoj)*ri;
    coupcombo6hsf1 = (Xijh+Xjih)*fq*trigofalphah/(pow(2,0.5))*(-sf1alpha1Zi*sf1beta1Zj - sf1beta1Zi*sf1alpha1Zj)*fabs(mneutralinoi)*fabs(mneutralinoj);
    coupcombo7hsf1 = (Xijh+Xjih)*fq*trigofalphah/(pow(2,0.5))*(sf1alpha1Zi*sf1beta1Zj + sf1beta1Zi*sf1alpha1Zj)*-pow(mq,2)*-ri*rj;
    coupcombo8hsf1 = 2*(Xijh+Xjih)*fq*trigofalphah/(pow(2,0.5))*(sf1alpha1Zi*sf1beta1Zj + sf1beta1Zi*sf1alpha1Zj)*fabs(mneutralinoi)*pow(mq,2)*fabs(mneutralinoj);

    // cout << "h - sf1 coupling combos: " << endl;
    // cout << coupcombo1hsf1 << endl;
    // cout << coupcombo2hsf1 << endl;
    // cout << coupcombo3hsf1 << endl;
    // cout << coupcombo4hsf1 << endl;
    // cout << coupcombo5hsf1 << endl;
    // cout << coupcombo6hsf1 << endl;
    // cout << coupcombo7hsf1 << endl;
    // cout << coupcombo8hsf1 << endl;


    // cout << "h/H - sf couplings for H-sf1: " << endl;
    // cout << -(XjiH + XijH) << endl;
    // cout << (XijH + XjiH) << endl;
    // cout << sf1alpha1Zi << endl;
    // cout << -sf1beta1Zi << endl;
    // cout << -fq*trigofalphaH/pow(2,0.5) << endl;
    // cout << -fq*trigofalphaH/pow(2,0.5) << endl;
    // cout << sf1beta1Zj << endl;
    // cout << sf1alpha1Zj << endl;
    // // cout << sf2alpha1Zi << endl;
    // // cout << sf2beta1Zi << endl;
    // // cout << sf2alpha1Zj << endl;
    // // cout << sf2beta1Zj << endl;
    // cout << endl;

    coupcombo1Hsf1 = 0.5*(XijH+XjiH)*fq*trigofalphaH/(pow(2,0.5))*(sf1alpha1Zi*sf1beta1Zj + sf1beta1Zi*sf1alpha1Zj)*-ri*rj;
    coupcombo2Hsf1 = (XijH+XjiH)*fq*trigofalphaH/(pow(2,0.5))*(sf1beta1Zi*sf1beta1Zj + sf1alpha1Zi*sf1alpha1Zj)*fabs(mneutralinoi)*mq*-rj;
    coupcombo3Hsf1 = (XijH+XjiH)*fq*trigofalphaH/(pow(2,0.5))*(sf1beta1Zi*sf1beta1Zj + sf1alpha1Zi*sf1alpha1Zj)*mq*fabs(mneutralinoj)*ri;
    coupcombo4Hsf1 = (XijH+XjiH)*fq*trigofalphaH/(pow(2,0.5))*(-sf1beta1Zi*sf1beta1Zj - sf1alpha1Zi*sf1alpha1Zj)*fabs(mneutralinoi)*mq*-rj;
    coupcombo5Hsf1 = (XijH+XjiH)*fq*trigofalphaH/(pow(2,0.5))*(sf1beta1Zi*sf1beta1Zj + sf1alpha1Zi*sf1alpha1Zj)*-mq*fabs(mneutralinoj)*ri;
    coupcombo6Hsf1 = (XijH+XjiH)*fq*trigofalphaH/(pow(2,0.5))*(-sf1alpha1Zi*sf1beta1Zj - sf1beta1Zi*sf1alpha1Zj)*fabs(mneutralinoi)*fabs(mneutralinoj);
    coupcombo7Hsf1 = (XijH+XjiH)*fq*trigofalphaH/(pow(2,0.5))*(sf1alpha1Zi*sf1beta1Zj + sf1beta1Zi*sf1alpha1Zj)*-pow(mq,2)*-ri*rj;
    coupcombo8Hsf1 = 2*(XijH+XjiH)*fq*trigofalphaH/(pow(2,0.5))*(sf1alpha1Zi*sf1beta1Zj + sf1beta1Zi*sf1alpha1Zj)*fabs(mneutralinoi)*pow(mq,2)*fabs(mneutralinoj);

    // cout << "H - sf1 coupling combos: " << endl;
    // cout << coupcombo1Hsf1 << endl;
    // cout << coupcombo2Hsf1 << endl;
    // cout << coupcombo3Hsf1 << endl;
    // cout << coupcombo4Hsf1 << endl;
    // cout << coupcombo5Hsf1 << endl;
    // cout << coupcombo6Hsf1 << endl;
    // cout << coupcombo7Hsf1 << endl;
    // cout << coupcombo8Hsf1 << endl;


    // cout << "h/H - sf couplings for h-sf2: " << endl;
    // cout << -(Xjih + Xijh) << endl;
    // cout << (Xijh + Xjih) << endl;
    // cout << -sf2alpha1Zi << endl;
    // cout << sf2beta1Zi << endl;
    // cout << -fq*trigofalphah/pow(2,0.5) << endl;
    // cout << -fq*trigofalphah/pow(2,0.5) << endl;
    // cout << -sf2beta1Zj << endl;
    // cout << -sf2alpha1Zj << endl;
    // cout << endl;

    coupcombo1hsf2 = 0.5*(Xijh+Xjih)*fq*trigofalphah/(pow(2,0.5))*(sf2alpha1Zi*sf2beta1Zj + sf2beta1Zi*sf2alpha1Zj)*-ri*rj;
    coupcombo2hsf2 = (Xijh+Xjih)*fq*trigofalphah/(pow(2,0.5))*(sf2beta1Zi*sf2beta1Zj + sf2alpha1Zi*sf2alpha1Zj)*fabs(mneutralinoi)*mq*-rj;
    coupcombo3hsf2 = (Xijh+Xjih)*fq*trigofalphah/(pow(2,0.5))*(sf2beta1Zi*sf2beta1Zj + sf2alpha1Zi*sf2alpha1Zj)*mq*fabs(mneutralinoj)*ri;
    coupcombo4hsf2 = (Xijh+Xjih)*fq*trigofalphah/(pow(2,0.5))*(-sf2beta1Zi*sf2beta1Zj - sf2alpha1Zi*sf2alpha1Zj)*fabs(mneutralinoi)*mq*-rj;
    coupcombo5hsf2 = (Xijh+Xjih)*fq*trigofalphah/(pow(2,0.5))*(sf2beta1Zi*sf2beta1Zj + sf2alpha1Zi*sf2alpha1Zj)*-mq*fabs(mneutralinoj)*ri;
    coupcombo6hsf2 = (Xijh+Xjih)*fq*trigofalphah/(pow(2,0.5))*(-sf2alpha1Zi*sf2beta1Zj - sf2beta1Zi*sf2alpha1Zj)*fabs(mneutralinoi)*fabs(mneutralinoj);
    coupcombo7hsf2 = (Xijh+Xjih)*fq*trigofalphah/(pow(2,0.5))*(sf2alpha1Zi*sf2beta1Zj + sf2beta1Zi*sf2alpha1Zj)*-pow(mq,2)*-ri*rj;
    coupcombo8hsf2 = 2*(Xijh+Xjih)*fq*trigofalphah/(pow(2,0.5))*(sf2alpha1Zi*sf2beta1Zj + sf2beta1Zi*sf2alpha1Zj)*fabs(mneutralinoi)*pow(mq,2)*fabs(mneutralinoj);

    // cout << "h - sf2 coupling combos: " << endl;
    // cout << coupcombo1hsf2 << endl;
    // cout << coupcombo2hsf2 << endl;
    // cout << coupcombo3hsf2 << endl;
    // cout << coupcombo4hsf2 << endl;
    // cout << coupcombo5hsf2 << endl;
    // cout << coupcombo6hsf2 << endl;
    // cout << coupcombo7hsf2 << endl;
    // cout << coupcombo8hsf2 << endl;


    // cout << "h/H - sf couplings for H-sf2: " << endl;
    // cout << (XjiH + XijH) << endl;
    // cout << -(XijH + XjiH) << endl;
    // cout << -sf2alpha1Zi << endl;
    // cout << sf2beta1Zi << endl;
    // cout << fq*trigofalphaH/pow(2,0.5) << endl;
    // cout << fq*trigofalphaH/pow(2,0.5) << endl;
    // cout << -sf2beta1Zj << endl;
    // cout << -sf2alpha1Zj << endl;
    // cout << endl;

    coupcombo1Hsf2 = 0.5*(XijH+XjiH)*fq*trigofalphaH/(pow(2,0.5))*(sf2alpha1Zi*sf2beta1Zj + sf2beta1Zi*sf2alpha1Zj)*-ri*rj;
    coupcombo2Hsf2 = (XijH+XjiH)*fq*trigofalphaH/(pow(2,0.5))*(sf2beta1Zi*sf2beta1Zj + sf2alpha1Zi*sf2alpha1Zj)*fabs(mneutralinoi)*mq*-rj;
    coupcombo3Hsf2 = (XijH+XjiH)*fq*trigofalphaH/(pow(2,0.5))*(sf2beta1Zi*sf2beta1Zj + sf2alpha1Zi*sf2alpha1Zj)*mq*fabs(mneutralinoj)*ri;
    coupcombo4Hsf2 = (XijH+XjiH)*fq*trigofalphaH/(pow(2,0.5))*(-sf2beta1Zi*sf2beta1Zj - sf2alpha1Zi*sf2alpha1Zj)*fabs(mneutralinoi)*mq*-rj;
    coupcombo5Hsf2 = (XijH+XjiH)*fq*trigofalphaH/(pow(2,0.5))*(sf2beta1Zi*sf2beta1Zj + sf2alpha1Zi*sf2alpha1Zj)*-mq*fabs(mneutralinoj)*ri;
    coupcombo6Hsf2 = (XijH+XjiH)*fq*trigofalphaH/(pow(2,0.5))*(-sf2alpha1Zi*sf2beta1Zj - sf2beta1Zi*sf2alpha1Zj)*fabs(mneutralinoi)*fabs(mneutralinoj);
    coupcombo7Hsf2 = (XijH+XjiH)*fq*trigofalphaH/(pow(2,0.5))*(sf2alpha1Zi*sf2beta1Zj + sf2beta1Zi*sf2alpha1Zj)*-pow(mq,2)*-ri*rj;
    coupcombo8Hsf2 = 2*(XijH+XjiH)*fq*trigofalphaH/(pow(2,0.5))*(sf2alpha1Zi*sf2beta1Zj + sf2beta1Zi*sf2alpha1Zj)*fabs(mneutralinoi)*pow(mq,2)*fabs(mneutralinoj);

    // cout << "H - sf2 coupling combos: " << endl;
    // cout << coupcombo1Hsf2 << endl;
    // cout << coupcombo2Hsf2 << endl;
    // cout << coupcombo3Hsf2 << endl;
    // cout << coupcombo4Hsf2 << endl;
    // cout << coupcombo5Hsf2 << endl;
    // cout << coupcombo6Hsf2 << endl;
    // cout << coupcombo7Hsf2 << endl;
    // cout << coupcombo8Hsf2 << endl;

    // cout << endl;
    // cout << "Integrals for h-sf1: " << endl;
    
    double integral1hsf1 = 0, integral2hsf1 = 0, integral3hsf1 = 0, integral4hsf1 = 0, integral5hsf1 = 0, integral6hsf1 = 0, integral7hsf1 = 0, integral8hsf1 = 0, integral1hsf2 = 0, integral2hsf2 = 0, integral3hsf2 = 0, integral4hsf2 = 0, integral5hsf2 = 0, integral6hsf2 = 0, integral7hsf2 = 0, integral8hsf2 = 0, integral1Hsf1 = 0, integral2Hsf1 = 0, integral3Hsf1 = 0, integral4Hsf1 = 0, integral5Hsf1 = 0, integral6Hsf1 = 0, integral7Hsf1 = 0, integral8Hsf1 = 0, integral1Hsf2 = 0, integral2Hsf2 = 0, integral3Hsf2 = 0, integral4Hsf2 = 0, integral5Hsf2 = 0, integral6Hsf2 = 0, integral7Hsf2 = 0, integral8Hsf2 = 0;

    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, mh = mhiggsl, mH = mhiggsH, mA = mhiggsA, m2 = msf1;
    integral1hsf1 = 2*fabs(m1)*dgauss(gintegral1hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral2hsf1 = 2*fabs(m1)*dgauss(gintegral2hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral3hsf1 = 2*fabs(m1)*dgauss(gintegral3hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral4hsf1 = 2*fabs(m1)*dgauss(gintegral4hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral5hsf1 = 2*fabs(m1)*dgauss(gintegral5hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral6hsf1 = 2*fabs(m1)*dgauss(gintegral6hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral7hsf1 = 2*fabs(m1)*dgauss(gintegral7hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral8hsf1 = 2*fabs(m1)*dgauss(gintegral8hsfdgauss,fromzsfE,tozsfE,accuracy);

    // cout << "integrals for hsf with msf1: " << endl;
    // cout << "integral1hsf1 = " << integral1hsf1 << endl;
    // cout << "integral2hsf1 = " << integral2hsf1 << endl;
    // cout << "integral3hsf1 = " << integral3hsf1 << endl;
    // cout << "integral4hsf1 = " << integral4hsf1 << endl;
    // cout << "integral5hsf1 = " << integral5hsf1 << endl;
    // cout << "integral6hsf1 = " << integral6hsf1 << endl;
    // cout << "integral7hsf1 = " << integral7hsf1 << endl;
    // cout << "integral8hsf1 = " << integral8hsf1 << endl;

    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, mh = mhiggsl, mH = mhiggsH, mA = mhiggsA, m2 = msf1;
    integral1Hsf1 = 2*fabs(m1)*dgauss(gintegral1Hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral2Hsf1 = 2*fabs(m1)*dgauss(gintegral2Hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral3Hsf1 = 2*fabs(m1)*dgauss(gintegral3Hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral4Hsf1 = 2*fabs(m1)*dgauss(gintegral4Hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral5Hsf1 = 2*fabs(m1)*dgauss(gintegral5Hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral6Hsf1 = 2*fabs(m1)*dgauss(gintegral6Hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral7Hsf1 = 2*fabs(m1)*dgauss(gintegral7Hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral8Hsf1 = 2*fabs(m1)*dgauss(gintegral8Hsfdgauss,fromzsfE,tozsfE,accuracy);

    // cout << "integrals for Hsf with msf1: " << endl;
    // cout << "integral1Hsf1 = " << integral1Hsf1 << endl;
    // cout << "integral2Hsf1 = " << integral2Hsf1 << endl;
    // cout << "integral3Hsf1 = " << integral3Hsf1 << endl;
    // cout << "integral4Hsf1 = " << integral4Hsf1 << endl;
    // cout << "integral5Hsf1 = " << integral5Hsf1 << endl;
    // cout << "integral6Hsf1 = " << integral6Hsf1 << endl;
    // cout << "integral7Hsf1 = " << integral7Hsf1 << endl;
    // cout << "integral8Hsf1 = " << integral8Hsf1 << endl;


    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, mh = mhiggsl, mH = mhiggsH, mA = mhiggsA, m2 = msf2;
    integral1hsf2 = 2*fabs(m1)*dgauss(gintegral1hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral2hsf2 = 2*fabs(m1)*dgauss(gintegral2hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral3hsf2 = 2*fabs(m1)*dgauss(gintegral3hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral4hsf2 = 2*fabs(m1)*dgauss(gintegral4hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral5hsf2 = 2*fabs(m1)*dgauss(gintegral5hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral6hsf2 = 2*fabs(m1)*dgauss(gintegral6hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral7hsf2 = 2*fabs(m1)*dgauss(gintegral7hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral8hsf2 = 2*fabs(m1)*dgauss(gintegral8hsfdgauss,fromzsfE,tozsfE,accuracy);

    // cout << "integrals for hsf with msf2: " << endl;
    // cout << "integral1hsf2 = " << integral1hsf2 << endl;
    // cout << "integral2hsf2 = " << integral2hsf2 << endl;
    // cout << "integral3hsf2 = " << integral3hsf2 << endl;
    // cout << "integral4hsf2 = " << integral4hsf2 << endl;
    // cout << "integral5hsf2 = " << integral5hsf2 << endl;
    // cout << "integral6hsf2 = " << integral6hsf2 << endl;
    // cout << "integral7hsf2 = " << integral7hsf2 << endl;
    // cout << "integral8hsf2 = " << integral8hsf2 << endl;


    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, mh = mhiggsl, mH = mhiggsH, mA = mhiggsA, m2 = msf2;
    integral1Hsf2 = 2*fabs(m1)*dgauss(gintegral1Hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral2Hsf2 = 2*fabs(m1)*dgauss(gintegral2Hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral3Hsf2 = 2*fabs(m1)*dgauss(gintegral3Hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral4Hsf2 = 2*fabs(m1)*dgauss(gintegral4Hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral5Hsf2 = 2*fabs(m1)*dgauss(gintegral5Hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral6Hsf2 = 2*fabs(m1)*dgauss(gintegral6Hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral7Hsf2 = 2*fabs(m1)*dgauss(gintegral7Hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral8Hsf2 = 2*fabs(m1)*dgauss(gintegral8Hsfdgauss,fromzsfE,tozsfE,accuracy);

    // cout << "integrals for Hsf with msf2: " << endl;
    // cout << "integral1Hsf2 = " << integral1Hsf2 << endl;
    // cout << "integral2Hsf2 = " << integral2Hsf2 << endl;
    // cout << "integral3Hsf2 = " << integral3Hsf2 << endl;
    // cout << "integral4Hsf2 = " << integral4Hsf2 << endl;
    // cout << "integral5Hsf2 = " << integral5Hsf2 << endl;
    // cout << "integral6Hsf2 = " << integral6Hsf2 << endl;
    // cout << "integral7Hsf2 = " << integral7Hsf2 << endl;
    // cout << "integral8Hsf2 = " << integral8Hsf2 << endl;


    //   cout << "term by term for hsf1: " << endl;
    //   cout << coupcombo1hsf1*integral1hsf1 << endl;
    //   cout << coupcombo2hsf1*integral2hsf1 << endl;
    //   cout << coupcombo3hsf1*integral3hsf1 << endl;
    //   cout << coupcombo4hsf1*integral4hsf1 << endl;
    //   cout << coupcombo5hsf1*integral5hsf1 << endl;
    //   cout << coupcombo6hsf1*integral6hsf1 << endl;
    //   cout << coupcombo7hsf1*integral7hsf1 << endl;
    //   cout << coupcombo8hsf1*integral8hsf1 << endl;
      
    //   cout << "term by term for Hsf1: " << endl;
    //   cout << coupcombo1Hsf1*integral1Hsf1 << endl;
    //   cout << coupcombo2Hsf1*integral2Hsf1 << endl;
    //   cout << coupcombo3Hsf1*integral3Hsf1 << endl;
    //   cout << coupcombo4Hsf1*integral4Hsf1 << endl;
    //   cout << coupcombo5Hsf1*integral5Hsf1 << endl;
    //   cout << coupcombo6Hsf1*integral6Hsf1 << endl;
    //   cout << coupcombo7Hsf1*integral7Hsf1 << endl;
    //   cout << coupcombo8Hsf1*integral8Hsf1 << endl;
      
    //   cout << "term by term for hsf2: " << endl;
    //   cout << coupcombo1hsf2*integral1hsf2 << endl;
    //   cout << coupcombo2hsf2*integral2hsf2 << endl;
    //   cout << coupcombo3hsf2*integral3hsf2 << endl;
    //   cout << coupcombo4hsf2*integral4hsf2 << endl;
    //   cout << coupcombo5hsf2*integral5hsf2 << endl;
    //   cout << coupcombo6hsf2*integral6hsf2 << endl;
    //   cout << coupcombo7hsf2*integral7hsf2 << endl;
    //   cout << coupcombo8hsf2*integral8hsf2 << endl;
      
    //   cout << "term by term for Hsf2: " << endl;
    //   cout << coupcombo1Hsf2*integral1Hsf2 << endl;
    //   cout << coupcombo2Hsf2*integral2Hsf2 << endl;
    //   cout << coupcombo3Hsf2*integral3Hsf2 << endl;
    //   cout << coupcombo4Hsf2*integral4Hsf2 << endl;
    //   cout << coupcombo5Hsf2*integral5Hsf2 << endl;
    //   cout << coupcombo6Hsf2*integral6Hsf2 << endl;
    //   cout << coupcombo7Hsf2*integral7Hsf2 << endl;
    //   cout << coupcombo8Hsf2*integral8Hsf2 << endl;
      
      Gammahsf1 = coupcombo1hsf1*integral1hsf1+coupcombo2hsf1*integral2hsf1+coupcombo3hsf1*integral3hsf1+coupcombo4hsf1*integral4hsf1+coupcombo5hsf1*integral5hsf1+coupcombo6hsf1*integral6hsf1+coupcombo7hsf1*integral7hsf1+coupcombo8hsf1*integral8hsf1;
      GammaHsf1 = coupcombo1Hsf1*integral1Hsf1+coupcombo2Hsf1*integral2Hsf1+coupcombo3Hsf1*integral3Hsf1+coupcombo4Hsf1*integral4Hsf1+coupcombo5Hsf1*integral5Hsf1+coupcombo6Hsf1*integral6Hsf1+coupcombo7Hsf1*integral7Hsf1+coupcombo8Hsf1*integral8Hsf1;
      Gammahsf2 = coupcombo1hsf2*integral1hsf2+coupcombo2hsf2*integral2hsf2+coupcombo3hsf2*integral3hsf2+coupcombo4hsf2*integral4hsf2+coupcombo5hsf2*integral5hsf2+coupcombo6hsf2*integral6hsf2+coupcombo7hsf2*integral7hsf2+coupcombo8hsf2*integral8hsf2;
      GammaHsf2 = coupcombo1Hsf2*integral1Hsf2+coupcombo2Hsf2*integral2Hsf2+coupcombo3Hsf2*integral3Hsf2+coupcombo4Hsf2*integral4Hsf2+coupcombo5Hsf2*integral5Hsf2+coupcombo6Hsf2*integral6Hsf2+coupcombo7Hsf2*integral7Hsf2+coupcombo8Hsf2*integral8Hsf2;
        

    // cout << "Overall h/H-sf interferences contributions: " << endl;
    // cout << "Gammahsf1 = " << Gammahsf1 << endl;
    // cout << "GammaHsf1 = " << GammaHsf1 << endl;
    // cout << "Gammahsf2 = " << Gammahsf2 << endl;
    // cout << "GammaHsf2 = " << GammaHsf2 << endl;

    // cout << endl;


    ///Redo A-sf interference:
    // cout << "A-sf1 couplings: " << endl;
    // cout << "-(XijA + XjiA) = " << -(XijA + XjiA) << endl;
    // cout << "-(XijA + XjiA) = " << -(XijA + XjiA) << endl;
    // cout << sf1alpha1Zi << endl;
    // cout << -sf1beta1Zi << endl;
    // cout << "-Aq/2 = " << -Aq/2 << endl;
    // cout << "Aq/2 = " << Aq/2 << endl;
    // cout << sf1beta1Zj << endl;
    // cout << sf1alpha1Zj << endl;

    double coupcombo1Asf1 = 0, coupcombo2Asf1 = 0, coupcombo3Asf1 = 0, coupcombo4Asf1 = 0, coupcombo5Asf1 = 0, coupcombo6Asf1 = 0, coupcombo7Asf1 = 0, coupcombo8Asf1 = 0, coupcombo1Asf2 = 0, coupcombo2Asf2 = 0, coupcombo3Asf2 = 0, coupcombo4Asf2 = 0, coupcombo5Asf2 = 0, coupcombo6Asf2 = 0, coupcombo7Asf2 = 0, coupcombo8Asf2 = 0;  
    
    coupcombo1Asf1 = 0.5*(XijA + XjiA)*Aq/2*(sf1alpha1Zi*sf1beta1Zj + sf1beta1Zi*sf1alpha1Zj)*ri;
    coupcombo2Asf1 = -(XijA + XjiA)*Aq/2*fabs(mneutralinoi)*mq*(sf1beta1Zi*sf1beta1Zj + sf1alpha1Zi*sf1alpha1Zj);
    coupcombo3Asf1 = (XijA + XjiA)*Aq/2*(-sf1beta1Zi*sf1beta1Zj - sf1alpha1Zi*sf1alpha1Zj)*mq*fabs(mneutralinoj)*-ri*rj;
    coupcombo4Asf1 = (XijA + XjiA)*Aq/2*(-sf1beta1Zi*sf1beta1Zj - sf1alpha1Zi*sf1alpha1Zj)*mq*fabs(mneutralinoi);
    coupcombo5Asf1 = -(XijA + XjiA)*Aq/2*(sf1beta1Zi*sf1beta1Zj + sf1alpha1Zi*sf1alpha1Zj)*mq*fabs(mneutralinoj)*-ri*rj;
    coupcombo6Asf1 = (XijA + XjiA)*Aq/2*(sf1alpha1Zi*sf1beta1Zj + sf1beta1Zi*sf1alpha1Zj)*fabs(mneutralinoi)*fabs(mneutralinoj)*-rj;
    coupcombo7Asf1 = (XijA + XjiA)*Aq/2*pow(mq,2)*(sf1alpha1Zi*sf1beta1Zj + sf1beta1Zi*sf1alpha1Zj)*ri;
    coupcombo8Asf1 = (XijA + XjiA)*Aq*fabs(mneutralinoi)*pow(mq,2)*fabs(mneutralinoj)*(sf1alpha1Zi*sf1beta1Zj + sf1beta1Zi*sf1alpha1Zj)*-rj;

    // cout << "coupling combos for Asf1: " << endl;
    // cout << "coupcombo1Asf1 = " << coupcombo1Asf1 << endl;
    // cout << "coupcombo2Asf1 = " << coupcombo2Asf1 << endl;
    // cout << "coupcombo3Asf1 = " << coupcombo3Asf1 << endl;
    // cout << "coupcombo4Asf1 = " << coupcombo4Asf1 << endl;
    // cout << "coupcombo5Asf1 = " << coupcombo5Asf1 << endl;
    // cout << "coupcombo6Asf1 = " << coupcombo6Asf1 << endl;
    // cout << "coupcombo7Asf1 = " << coupcombo7Asf1 << endl;
    // cout << "coupcombo8Asf1 = " << coupcombo8Asf1 << endl;
    

    // cout << "A-sf2 couplings: " << endl;
    // cout << "-(XijA + XjiA) = " << -(XijA + XjiA) << endl;
    // cout << "-(XijA + XjiA) = " << -(XijA + XjiA) << endl;
    // cout << -sf2alpha1Zi << endl;
    // cout << sf2beta1Zi << endl;
    // cout << "-Aq/2 = " << -Aq/2 << endl;
    // cout << "Aq/2 = " << Aq/2 << endl;
    // cout << -sf2beta1Zj << endl;
    // cout << -sf2alpha1Zj << endl;

    coupcombo1Asf2 = 0.5*(XijA + XjiA)*Aq/2*(sf2alpha1Zi*sf2beta1Zj + sf2beta1Zi*sf2alpha1Zj)*ri;
    coupcombo2Asf2 = -(XijA + XjiA)*Aq/2*fabs(mneutralinoi)*mq*(sf2beta1Zi*sf2beta1Zj + sf2alpha1Zi*sf2alpha1Zj);
    coupcombo3Asf2 = (XijA + XjiA)*Aq/2*(-sf2beta1Zi*sf2beta1Zj - sf2alpha1Zi*sf2alpha1Zj)*mq*fabs(mneutralinoj)*-ri*rj;
    coupcombo4Asf2 = (XijA + XjiA)*Aq/2*(-sf2beta1Zi*sf2beta1Zj - sf2alpha1Zi*sf2alpha1Zj)*mq*fabs(mneutralinoi);
    coupcombo5Asf2 = -(XijA + XjiA)*Aq/2*(sf2beta1Zi*sf2beta1Zj + sf2alpha1Zi*sf2alpha1Zj)*mq*fabs(mneutralinoj)*-ri*rj;
    coupcombo6Asf2 = (XijA + XjiA)*Aq/2*(sf2alpha1Zi*sf2beta1Zj + sf2beta1Zi*sf2alpha1Zj)*fabs(mneutralinoi)*fabs(mneutralinoj)*-rj;
    coupcombo7Asf2 = (XijA + XjiA)*Aq/2*pow(mq,2)*(sf2alpha1Zi*sf2beta1Zj + sf2beta1Zi*sf2alpha1Zj)*ri;
    coupcombo8Asf2 = (XijA + XjiA)*Aq*fabs(mneutralinoi)*pow(mq,2)*fabs(mneutralinoj)*(sf2alpha1Zi*sf2beta1Zj + sf2beta1Zi*sf2alpha1Zj)*-rj;
   
    // cout << "coupling combos for Asf2: " << endl;
    // cout << "coupcombo1Asf2 = " << coupcombo1Asf2 << endl;
    // cout << "coupcombo2Asf2 = " << coupcombo2Asf2 << endl;
    // cout << "coupcombo3Asf2 = " << coupcombo3Asf2 << endl;
    // cout << "coupcombo4Asf2 = " << coupcombo4Asf2 << endl;
    // cout << "coupcombo5Asf2 = " << coupcombo5Asf2 << endl;
    // cout << "coupcombo6Asf2 = " << coupcombo6Asf2 << endl;
    // cout << "coupcombo7Asf2 = " << coupcombo7Asf2 << endl;
    // cout << "coupcombo8Asf2 = " << coupcombo8Asf2 << endl;


    double integral1Asf1 = 0, integral2Asf1 = 0, integral3Asf1 = 0, integral4Asf1 = 0, integral5Asf1 = 0, integral6Asf1 = 0, integral7Asf1 = 0, integral8Asf1 = 0, integral1Asf2 = 0, integral2Asf2 = 0, integral3Asf2 = 0, integral4Asf2 = 0, integral5Asf2 = 0, integral6Asf2 = 0, integral7Asf2 = 0, integral8Asf2 = 0; 

    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, mh = mhiggsA, m2 = msf1; ///here set mh = mA as using the integrands written for h with mh -> mA
    integral1Asf1 = 2*fabs(m1)*dgauss(gintegral1hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral2Asf1 = 2*fabs(m1)*dgauss(gintegral2hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral3Asf1 = 2*fabs(m1)*dgauss(gintegral3hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral4Asf1 = 2*fabs(m1)*dgauss(gintegral4hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral5Asf1 = 2*fabs(m1)*dgauss(gintegral5hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral6Asf1 = 2*fabs(m1)*dgauss(gintegral6hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral7Asf1 = 2*fabs(m1)*dgauss(gintegral7hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral8Asf1 = 2*fabs(m1)*dgauss(gintegral8hsfdgauss,fromzsfE,tozsfE,accuracy);

    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, mh = mhiggsA, m2 = msf2; ///here set mh = mA as using the integrands written for h with mh -> mA
    integral1Asf2 = 2*fabs(m1)*dgauss(gintegral1hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral2Asf2 = 2*fabs(m1)*dgauss(gintegral2hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral3Asf2 = 2*fabs(m1)*dgauss(gintegral3hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral4Asf2 = 2*fabs(m1)*dgauss(gintegral4hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral5Asf2 = 2*fabs(m1)*dgauss(gintegral5hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral6Asf2 = 2*fabs(m1)*dgauss(gintegral6hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral7Asf2 = 2*fabs(m1)*dgauss(gintegral7hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral8Asf2 = 2*fabs(m1)*dgauss(gintegral8hsfdgauss,fromzsfE,tozsfE,accuracy);

    // cout << "Integrals for Asf1: " << endl;
    // cout << "integral1Asf1 = " << integral1Asf1 << endl;
    // cout << "integral2Asf1 = " << integral2Asf1 << endl;
    // cout << "integral3Asf1 = " << integral3Asf1 << endl;
    // cout << "integral4Asf1 = " << integral4Asf1 << endl;
    // cout << "integral5Asf1 = " << integral5Asf1 << endl;
    // cout << "integral6Asf1 = " << integral6Asf1 << endl;
    // cout << "integral7Asf1 = " << integral7Asf1 << endl;
    // cout << "integral8Asf1 = " << integral8Asf1 << endl;

    // cout << "Integrals for Asf2: " << endl;
    // cout << "integral1Asf2 = " << integral1Asf2 << endl;
    // cout << "integral2Asf2 = " << integral2Asf2 << endl;
    // cout << "integral3Asf2 = " << integral3Asf2 << endl;
    // cout << "integral4Asf2 = " << integral4Asf2 << endl;
    // cout << "integral5Asf2 = " << integral5Asf2 << endl;
    // cout << "integral6Asf2 = " << integral6Asf2 << endl;
    // cout << "integral7Asf2 = " << integral7Asf2 << endl;
    // cout << "integral8Asf2 = " << integral8Asf2 << endl;

    // cout << endl;
    // cout << "Term by term for Asf1: " << endl;
    // cout << coupcombo1Asf1*integral1Asf1 << endl;
    // cout << coupcombo2Asf1*integral2Asf1 << endl;
    // cout << coupcombo3Asf1*integral3Asf1 << endl;
    // cout << coupcombo4Asf1*integral4Asf1 << endl;
    // cout << coupcombo5Asf1*integral5Asf1 << endl;
    // cout << coupcombo6Asf1*integral6Asf1 << endl;
    // cout << coupcombo7Asf1*integral7Asf1 << endl;
    // cout << coupcombo8Asf1*integral8Asf1 << endl;

    // cout << "Term by term for Asf2: " << endl;
    // cout << coupcombo1Asf2*integral1Asf2 << endl;
    // cout << coupcombo2Asf2*integral2Asf2 << endl;
    // cout << coupcombo3Asf2*integral3Asf2 << endl;
    // cout << coupcombo4Asf2*integral4Asf2 << endl;
    // cout << coupcombo5Asf2*integral5Asf2 << endl;
    // cout << coupcombo6Asf2*integral6Asf2 << endl;
    // cout << coupcombo7Asf2*integral7Asf2 << endl;
    // cout << coupcombo8Asf2*integral8Asf2 << endl;

    GammaAsf1 = coupcombo1Asf1*integral1Asf1 + coupcombo2Asf1*integral2Asf1 + coupcombo3Asf1*integral3Asf1 + coupcombo4Asf1*integral4Asf1+ coupcombo5Asf1*integral5Asf1 + coupcombo6Asf1*integral6Asf1 + coupcombo7Asf1*integral7Asf1 + coupcombo8Asf1*integral8Asf1;

    GammaAsf2 = coupcombo1Asf2*integral1Asf2 + coupcombo2Asf2*integral2Asf2 + coupcombo3Asf2*integral3Asf2 + coupcombo4Asf2*integral4Asf2+ coupcombo5Asf2*integral5Asf2 + coupcombo6Asf2*integral6Asf2 + coupcombo7Asf2*integral7Asf2 + coupcombo8Asf2*integral8Asf2;

    // cout << "GammaAsf1 = " << GammaAsf1 << endl;
    // cout << "GammaAsf2 = " << GammaAsf2 << endl;


    ///Goldstone - sf interference:
    double Gammagsf1 = 0, Gammagsf2 = 0;
    // cout << "couplings for goldstone - sf1: " << endl;
    // cout << "coup2(1) = (Nj – Ni – P0)L = " << goldstoneneutineutjcoup << endl;
    // cout << "coup2(2) = (Nj - Ni – P0)R = " << -goldstoneneutineutjcoup << endl;
    // cout << "coup2(3) = [(f – Ni – sf)R]* = " << sf1alpha1Zi << endl;
    // cout << "coup2(4) = [(f-Ni-sf)L]* = " << -sf1beta1Zi << endl;
    // cout << "coup2(5) = (f-f-P0)L = " << goldstoneffcoup << endl;
    // cout << "coup2(6) = (f-f-P0)R = " << -goldstoneffcoup << endl;
    // cout << "coup2(7) = f – Nj – sfL = " << -sf1beta1Zj << endl;
    // cout << "coup2(8) = f – Nj – sfR = " << sf1alpha1Zj << endl;

    double coupcombo1gsf1 = 0, coupcombo2gsf1 = 0, coupcombo3gsf1 = 0, coupcombo4gsf1 = 0, coupcombo5gsf1 = 0, coupcombo6gsf1 = 0, coupcombo7gsf1 = 0, coupcombo8gsf1 = 0; 
    coupcombo1gsf1 = 0.5*goldstoneneutineutjcoup*goldstoneffcoup*(sf1alpha1Zi*sf1beta1Zj + sf1beta1Zi*sf1alpha1Zj);
    coupcombo2gsf1 = -goldstoneneutineutjcoup*goldstoneffcoup*(sf1beta1Zi*sf1beta1Zj + sf1alpha1Zi*sf1alpha1Zj)*fabs(mneutralinoi)*mf*ri;
    coupcombo3gsf1 = goldstoneneutineutjcoup*goldstoneffcoup*(sf1beta1Zi*sf1beta1Zj + sf1alpha1Zi*sf1alpha1Zj)*mf*fabs(mneutralinoj)*rj;
    coupcombo4gsf1 = -goldstoneneutineutjcoup*goldstoneffcoup*(sf1beta1Zi*sf1beta1Zj + sf1alpha1Zi*sf1alpha1Zj)*fabs(mneutralinoi)*mf*ri;
    coupcombo5gsf1 = goldstoneneutineutjcoup*goldstoneffcoup*(sf1beta1Zi*sf1beta1Zj + sf1alpha1Zi*sf1alpha1Zj)*fabs(mneutralinoj)*mf*rj;
    coupcombo6gsf1 = goldstoneneutineutjcoup*goldstoneffcoup*(sf1alpha1Zi*sf1beta1Zj + sf1beta1Zi*sf1alpha1Zj)*fabs(mneutralinoi)*fabs(mneutralinoj)*-rj*ri;
    coupcombo7gsf1 = goldstoneneutineutjcoup*goldstoneffcoup*(sf1alpha1Zi*sf1beta1Zj + sf1beta1Zi*sf1alpha1Zj)*pow(mf,2);
    coupcombo8gsf1 = 2*goldstoneneutineutjcoup*goldstoneffcoup*(-sf1alpha1Zi*sf1beta1Zj - sf1beta1Zi*sf1alpha1Zj)*fabs(mneutralinoi)*fabs(mneutralinoj)*pow(mf,2)*rj*ri;

    // cout << "SumI coupling combos for g msf1: " << endl;
    // cout << "sumI(8) = " << coupcombo8gsf1 << endl;
    // cout << "sumI(7) = " << coupcombo7gsf1 << endl;
    // cout << "sumI(6) = " << coupcombo6gsf1 << endl;
    // cout << "sumI(5) = " << coupcombo5gsf1 << endl;
    // cout << "sumI(4) = " << coupcombo4gsf1 << endl;
    // cout << "sumI(3) = " << coupcombo3gsf1 << endl;
    // cout << "sumI(2) = " << coupcombo2gsf1 << endl;
    // cout << "sumI(1) = " << coupcombo1gsf1 << endl;

    double integral1gsf1 = 0, integral2gsf1 = 0, integral3gsf1 = 0, integral4gsf1 = 0, integral5gsf1 = 0, integral6gsf1 = 0, integral7gsf1 = 0, integral8gsf1 = 0, integral1gsf2 = 0, integral2gsf2 = 0, integral3gsf2 = 0, integral4gsf2 = 0, integral5gsf2 = 0, integral6gsf2 = 0, integral7gsf2 = 0, integral8gsf2 = 0; 

    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, mh = mZboson, m2 = msf1; ///here set mh = mZ as using the integrands written for h with mh -> mA -> mZ
    integral1gsf1 = 2*fabs(m1)*dgauss(gintegral1hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral2gsf1 = 2*fabs(m1)*dgauss(gintegral2hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral3gsf1 = 2*fabs(m1)*dgauss(gintegral3hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral4gsf1 = 2*fabs(m1)*dgauss(gintegral4hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral5gsf1 = 2*fabs(m1)*dgauss(gintegral5hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral6gsf1 = 2*fabs(m1)*dgauss(gintegral6hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral7gsf1 = 2*fabs(m1)*dgauss(gintegral7hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral8gsf1 = 2*fabs(m1)*dgauss(gintegral8hsfdgauss,fromzsfE,tozsfE,accuracy);

    
    // cout << "integrals for goldstone-sf with msf1: " << endl;
    // cout << "integral1gsf1 = " << integral1gsf1 << endl;
    // cout << "integral2gsf1 = " << integral2gsf1 << endl;
    // cout << "integral3gsf1 = " << integral3gsf1 << endl;
    // cout << "integral4gsf1 = " << integral4gsf1 << endl;
    // cout << "integral5gsf1 = " << integral5gsf1 << endl;
    // cout << "integral6gsf1 = " << integral6gsf1 << endl;
    // cout << "integral7gsf1 = " << integral7gsf1 << endl;
    // cout << "integral8gsf1 = " << integral8gsf1 << endl;

    // cout << "Term by term for goldstone-sf with msf1: " << endl;
    // cout << coupcombo1gsf1*integral1gsf1 << endl;
    // cout << coupcombo2gsf1*integral2gsf1 << endl;
    // cout << coupcombo3gsf1*integral3gsf1 << endl;
    // cout << coupcombo4gsf1*integral4gsf1 << endl;
    // cout << coupcombo5gsf1*integral5gsf1 << endl;
    // cout << coupcombo6gsf1*integral6gsf1 << endl;
    // cout << coupcombo7gsf1*integral7gsf1 << endl;
    // cout << coupcombo8gsf1*integral8gsf1 << endl;

    Gammagsf1 = (coupcombo1gsf1*integral1gsf1 + coupcombo2gsf1*integral2gsf1 + coupcombo3gsf1*integral3gsf1 + coupcombo4gsf1*integral4gsf1 + coupcombo5gsf1*integral5gsf1 + coupcombo6gsf1*integral6gsf1 + coupcombo7gsf1*integral7gsf1 + coupcombo8gsf1*integral8gsf1);
    // cout << "Gammagsf1 = " << Gammagsf1 << endl;

    // cout << "couplings for goldstone - sf2: " << endl;
    // cout << "coup2(1) = (Nj – Ni – P0)L = " << goldstoneneutineutjcoup << endl;
    // cout << "coup2(2) = (Nj - Ni – P0)R = " << -goldstoneneutineutjcoup << endl;
    // cout << "coup2(3) = [(f – Ni – sf)R]* = " << -sf2alpha1Zi << endl;
    // cout << "coup2(4) = [(f-Ni-sf)L]* = " << sf2beta1Zi << endl;
    // cout << "coup2(5) = (f-f-P0)L = " << goldstoneffcoup << endl;
    // cout << "coup2(6) = (f-f-P0)R = " << -goldstoneffcoup << endl;
    // cout << "coup2(7) = f – Nj – sfL = " << sf2beta1Zj << endl;
    // cout << "coup2(8) = f – Nj – sfR = " << -sf2alpha1Zj << endl;

    double coupcombo1gsf2 = 0, coupcombo2gsf2 = 0, coupcombo3gsf2 = 0, coupcombo4gsf2 = 0, coupcombo5gsf2 = 0, coupcombo6gsf2 = 0, coupcombo7gsf2 = 0, coupcombo8gsf2 = 0; 
    coupcombo1gsf2 = 0.5*goldstoneneutineutjcoup*goldstoneffcoup*(sf2alpha1Zi*sf2beta1Zj + sf2beta1Zi*sf2alpha1Zj);
    coupcombo2gsf2 = -goldstoneneutineutjcoup*goldstoneffcoup*(-sf2beta1Zi*-sf2beta1Zj + -sf2alpha1Zi*-sf2alpha1Zj)*fabs(mneutralinoi)*-mf*-ri;
    coupcombo3gsf2 = -goldstoneneutineutjcoup*goldstoneffcoup*(-sf2beta1Zi*sf2beta1Zj + sf2alpha1Zi*-sf2alpha1Zj)*mf*fabs(mneutralinoj)*rj;
    coupcombo4gsf2 = -goldstoneneutineutjcoup*goldstoneffcoup*(-sf2beta1Zi*-sf2beta1Zj - sf2alpha1Zi*-sf2alpha1Zj)*fabs(mneutralinoi)*mf*ri;
    coupcombo5gsf2 = goldstoneneutineutjcoup*goldstoneffcoup*(-sf2beta1Zi*-sf2beta1Zj - sf2alpha1Zi*-sf2alpha1Zj)*fabs(mneutralinoj)*-mf*-rj;
    coupcombo6gsf2 = goldstoneneutineutjcoup*goldstoneffcoup*(-sf2alpha1Zi*-sf2beta1Zj - sf2beta1Zi*-sf2alpha1Zj)*fabs(mneutralinoi)*fabs(mneutralinoj)*-rj*ri;
    coupcombo7gsf2 = goldstoneneutineutjcoup*goldstoneffcoup*(-sf2alpha1Zi*-sf2beta1Zj - sf2beta1Zi*-sf2alpha1Zj)*pow(mf,2);
    coupcombo8gsf2 = 2*goldstoneneutineutjcoup*goldstoneffcoup*(sf2alpha1Zi*-sf2beta1Zj + sf2beta1Zi*-sf2alpha1Zj)*fabs(mneutralinoi)*fabs(mneutralinoj)*-pow(mf,2)*-rj*ri;

    // cout << "SumI coupling combos for g msf2: " << endl;
    // cout << "sumI(8) = " << coupcombo8gsf2 << endl;
    // cout << "sumI(7) = " << coupcombo7gsf2 << endl;
    // cout << "sumI(6) = " << coupcombo6gsf2 << endl;
    // cout << "sumI(5) = " << coupcombo5gsf2 << endl;
    // cout << "sumI(4) = " << coupcombo4gsf2 << endl;
    // cout << "sumI(3) = " << coupcombo3gsf2 << endl;
    // cout << "sumI(2) = " << coupcombo2gsf2 << endl;
    // cout << "sumI(1) = " << coupcombo1gsf2 << endl;

    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, mh = mZboson, m2 = msf2; ///here set mh = mZ as using the integrands written for h with mh -> mA -> mZ
    integral1gsf2 = 2*fabs(m1)*dgauss(gintegral1hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral2gsf2 = 2*fabs(m1)*dgauss(gintegral2hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral3gsf2 = 2*fabs(m1)*dgauss(gintegral3hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral4gsf2 = 2*fabs(m1)*dgauss(gintegral4hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral5gsf2 = 2*fabs(m1)*dgauss(gintegral5hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral6gsf2 = 2*fabs(m1)*dgauss(gintegral6hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral7gsf2 = 2*fabs(m1)*dgauss(gintegral7hsfdgauss,fromzsfE,tozsfE,accuracy);
    integral8gsf2 = 2*fabs(m1)*dgauss(gintegral8hsfdgauss,fromzsfE,tozsfE,accuracy);

    
    // cout << "integrals for goldstone-sf with msf2: " << endl;
    // cout << "integral1gsf2 = " << integral1gsf2 << endl;
    // cout << "integral2gsf2 = " << integral2gsf2 << endl;
    // cout << "integral3gsf2 = " << integral3gsf2 << endl;
    // cout << "integral4gsf2 = " << integral4gsf2 << endl;
    // cout << "integral5gsf2 = " << integral5gsf2 << endl;
    // cout << "integral6gsf2 = " << integral6gsf2 << endl;
    // cout << "integral7gsf2 = " << integral7gsf2 << endl;
    // cout << "integral8gsf2 = " << integral8gsf2 << endl;

    // cout << "Term by term for goldstone-sf with msf2: " << endl;
    // cout << coupcombo1gsf2*integral1gsf2 << endl;
    // cout << coupcombo2gsf2*integral2gsf2 << endl;
    // cout << coupcombo3gsf2*integral3gsf2 << endl;
    // cout << coupcombo4gsf2*integral4gsf2 << endl;
    // cout << coupcombo5gsf2*integral5gsf2 << endl;
    // cout << coupcombo6gsf2*integral6gsf2 << endl;
    // cout << coupcombo7gsf2*integral7gsf2 << endl;
    // cout << coupcombo8gsf2*integral8gsf2 << endl;

    Gammagsf2 = (coupcombo1gsf2*integral1gsf2 + coupcombo2gsf2*integral2gsf2 + coupcombo3gsf2*integral3gsf2 + coupcombo4gsf2*integral4gsf2 + coupcombo5gsf2*integral5gsf2 + coupcombo6gsf2*integral6gsf2 + coupcombo7gsf2*integral7gsf2 + coupcombo8gsf2*integral8gsf2);
    // cout << "Gammagsf2 = " << Gammagsf2 << endl;

    ///Z-A interference (not in T&B but in SPheno)
    // cout << "Z-A couplings: " << endl;
    // cout << 2*Wij << endl;
    // cout << 2*Wij << endl;
    // cout << -(XijA + XjiA) << endl;
    // cout << -(XijA + XjiA) << endl;
    // cout << -g*sinthetaW*(alphaf-betaf) << endl;
    // cout << -g*sinthetaW*(alphaf+betaf) << endl;
    // cout << Aq/2 << endl;
    // cout << -Aq/2 << endl;

    double coupcombo1ZA = 0, coupcombo2ZA = 0, coupcombo3ZA = 0, coupcombo4ZA = 0;
    coupcombo1ZA = 4*Wij*(XijA+XjiA)*Aq*g*sinthetaW*betaf*fabs(mneutralinoj)*mq*-ri*rj;
    coupcombo2ZA = 4*Wij*(XijA+XjiA)*Aq*g*sinthetaW*betaf*fabs(mneutralinoi)*mq;
    coupcombo3ZA = 4*Wij*(XijA+XjiA)*Aq*g*sinthetaW*betaf*mq*fabs(mneutralinoj)*-ri*rj;
    coupcombo4ZA = 4*Wij*(XijA+XjiA)*Aq*g*sinthetaW*betaf*fabs(mneutralinoi)*mq;
    // cout << "Coupling combos for Z-A: " << endl;
    // cout << coupcombo1ZA << endl;
    // cout << coupcombo2ZA << endl;
    // cout << coupcombo3ZA << endl;
    // cout << coupcombo4ZA << endl
      ;

    
    double integral1ZA = 0, integral2ZA = 0, integral3ZA = 0, integral4ZA = 0;
    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, mA = mhiggsA, m2 = msf1, MZboson = mZboson;
    integral1ZA = 2*fabs(m1)*dgauss(gintegral1ZAdgauss,fromzsfE,tozsfE,accuracy);
    integral2ZA = 2*fabs(m1)*dgauss(gintegral2ZAdgauss,fromzsfE,tozsfE,accuracy);
    integral3ZA = 2*fabs(m1)*dgauss(gintegral3ZAdgauss,fromzsfE,tozsfE,accuracy);
    integral4ZA = 2*fabs(m1)*dgauss(gintegral4ZAdgauss,fromzsfE,tozsfE,accuracy);

    // cout << "Integrals for Z-A: " << endl;
    // cout << integral1ZA << endl;
    // cout << integral2ZA << endl;
    // cout << integral3ZA << endl;
    // cout << integral4ZA << endl;

    // cout << "Term by term for Z-A: " << endl;
    // cout << coupcombo1ZA*integral1ZA << endl;
    // cout << coupcombo2ZA*integral2ZA << endl;
    // cout << coupcombo3ZA*integral3ZA << endl;
    // cout << coupcombo4ZA*integral4ZA << endl;

    double GammaZA = 0;
    
    GammaZA = coupcombo1ZA*integral1ZA + coupcombo2ZA*integral2ZA + coupcombo3ZA*integral3ZA + coupcombo4ZA*integral4ZA;
    // cout << "GammaZA = " << GammaZA << endl;



    ///Z-goldstone interference (not in T&B but in SPheno)
    // cout << "Z-goldstone couplings: " << endl;
    // cout << -2*Wij << endl;
    // cout << -2*Wij << endl;
    // cout << goldstoneneutineutjcoup << endl;
    // cout << goldstoneneutineutjcoup << endl;
    // cout << -g*sinthetaW*(alphaf-betaf) << endl;
    // cout << -g*sinthetaW*(alphaf+betaf) << endl;
    // cout << goldstoneffcoup << endl;
    // cout << -goldstoneffcoup << endl;

    double coupcombo1Zg = 0, coupcombo2Zg = 0, coupcombo3Zg = 0, coupcombo4Zg = 0;
    coupcombo1Zg = 8*Wij*goldstoneffcoup*goldstoneneutineutjcoup*g*sinthetaW*betaf*fabs(mneutralinoj)*mq*-rj;
    coupcombo2Zg = 8*Wij*goldstoneffcoup*goldstoneneutineutjcoup*g*sinthetaW*betaf*fabs(mneutralinoi)*mq*ri;
    coupcombo3Zg = 8*Wij*goldstoneffcoup*goldstoneneutineutjcoup*g*sinthetaW*betaf*fabs(mneutralinoj)*mq*-rj;
    coupcombo4Zg = 8*Wij*goldstoneffcoup*goldstoneneutineutjcoup*g*sinthetaW*betaf*fabs(mneutralinoi)*mq*ri;
    // cout << "Coupling combos for Z-goldstone: " << endl;
    // cout << coupcombo1Zg << endl;
    // cout << coupcombo2Zg << endl;
    // cout << coupcombo3Zg << endl;
    // cout << coupcombo4Zg << endl;

    
    double integral1Zg = 0, integral2Zg = 0, integral3Zg = 0, integral4Zg = 0;
    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, mA = mZboson, m2 = msf1, MZboson = mZboson;
    integral1Zg = 2*fabs(m1)*dgauss(gintegral1ZAdgauss,fromzsfE,tozsfE,accuracy);
    integral2Zg = 2*fabs(m1)*dgauss(gintegral2ZAdgauss,fromzsfE,tozsfE,accuracy);
    integral3Zg = 2*fabs(m1)*dgauss(gintegral3ZAdgauss,fromzsfE,tozsfE,accuracy);
    integral4Zg = 2*fabs(m1)*dgauss(gintegral4ZAdgauss,fromzsfE,tozsfE,accuracy);

    // cout << "Integrals for Z-g: " << endl;
    // cout << integral1Zg << endl;
    // cout << integral2Zg << endl;
    // cout << integral3Zg << endl;
    // cout << integral4Zg << endl;

    // cout << "Term by term for Z-g: " << endl;
    // cout << coupcombo1Zg*integral1Zg << endl;
    // cout << coupcombo2Zg*integral2Zg << endl;
    // cout << coupcombo3Zg*integral3Zg << endl;
    // cout << coupcombo4Zg*integral4Zg << endl;

    double GammaZg = 0;
    
    GammaZg = coupcombo1Zg*integral1Zg + coupcombo2Zg*integral2Zg + coupcombo3Zg*integral3Zg + coupcombo4Zg*integral4Zg;
    // cout << "GammaZg = " << GammaZg << endl;

    ///Goldstone-A interference
    double GammagA = 0;
    // cout << "Goldstone-A couplings: " << endl;
    // cout << goldstoneneutineutjcoup << endl;
    // cout << -goldstoneneutineutjcoup << endl;
    // cout << -(XijA + XjiA) << endl;
    // cout << (XijA + XjiA) << endl;
    // cout << goldstoneffcoup << endl;
    // cout << -goldstoneffcoup << endl;
    // cout << -Aq/2 << endl;
    // cout << Aq/2 << endl;

    ///Coupling combos:
    double coupcombogA1 = 0, coupcombogA2 = 0, coupcombogA3 = 0, coupcombogA4 = 0;
    coupcombogA1 = -2*goldstoneneutineutjcoup*(XijA+XjiA)*ri;
    coupcombogA2 = 2*goldstoneneutineutjcoup*(XijA+XjiA)*rj;
    coupcombogA3 = -goldstoneffcoup*Aq;
    coupcombogA4 = goldstoneffcoup*Aq;
    // cout << "coupcombogA1 = " << coupcombogA1 << endl;
    // cout << "coupcombogA2 = " << coupcombogA2 << endl;
    // cout << "coupcombogA3 = " << coupcombogA3 << endl;
    // cout << "coupcombogA4 = " << coupcombogA4 << endl;

    double integralgA1 = 0, integralgA2 = 0, integralgA3 = 0, integralgA4 = 0;
    m1 = mneutralinoi, m4 = mneutralinoj, mq = mf, MZboson = mZboson, mA = mhiggsA;
    integralgA1 = 2*fabs(m1)*dgauss(gneutineutjffgA1dgauss,fromz,toz,accuracy);
    integralgA2 = 2*fabs(m1)*dgauss(gneutineutjffgA2dgauss,fromz,toz,accuracy);
    integralgA3 = 2*fabs(m1)*dgauss(gneutineutjffgA3dgauss,fromz,toz,accuracy);
    integralgA4 = 2*fabs(m1)*dgauss(gneutineutjffgA4dgauss,fromz,toz,accuracy);
    // cout << "integralgA1 = " << integralgA1 << endl;
    // cout << "integralgA2 = " << integralgA2 << endl;
    // cout << "integralgA3 = " << integralgA3 << endl;
    // cout << "integralgA4 = " << integralgA4 << endl;

    // cout << "term by term: " << endl;
    // cout << coupcombogA1*coupcombogA3*integralgA4 << endl;
    // cout << -2*coupcombogA1*coupcombogA4*pow(mq,2)*integralgA3 << endl;
    // cout << 2*coupcombogA2*coupcombogA3*fabs(mneutralinoi)*fabs(mneutralinoj)*integralgA2 << endl;
    // cout << -4*coupcombogA2*coupcombogA4*pow(mq,2)*fabs(mneutralinoi)*fabs(mneutralinoj)*integralgA1 << endl;
    
    GammagA = coupcombogA1*coupcombogA3*integralgA4 - 2*coupcombogA1*coupcombogA4*pow(mq,2)*integralgA3 + 2*coupcombogA2*coupcombogA3*fabs(mneutralinoi)*fabs(mneutralinoj)*integralgA2 -4*coupcombogA2*coupcombogA4*pow(mq,2)*fabs(mneutralinoi)*fabs(mneutralinoj)*integralgA1;
    // cout << "GammagA = " << GammagA << endl; ///MULTIPLY BY TWO IN TOTAL AMPLITUDEW


    // cout << "Total list of contributions: " << endl;
    // cout.precision(16);
    // cout << "GammaZ = " << GammaZ << endl;
    // cout << "Gammah = " << Gammah << endl;
    // cout << "GammaH = " << GammaH << endl;
    // cout << "GammaA = " << GammaA << endl;
    // cout << "GammahH = " << GammahHinterf << endl;
    // cout << "Gammasftot = " << Gammasftot << endl;
    // cout << "2*Gammasf1sf1diag = " << 2*Gammasf1sf1diag << endl;
    // cout << "2*Gammasf2sf2diag = " << 2*Gammasf2sf2diag << endl;
    // cout << "2*Gammasfsfnondiag = " << 2*Gammasfsfnondiag << endl;
    // cout << "Gammasftsfumsf1msf1 = " << Gammasftsfumsf1msf1 << endl;
    // cout << "Gammasftsfumsf2msf2 = " << Gammasftsfumsf2msf2 << endl;
    // cout << "Gammasftsfumsf1msf2 = " << Gammasftsfumsf1msf2 << endl;
    // cout << "Gammasftsfumsf1msf2 = " << Gammasftsfumsf1msf2 << endl;
    // cout << "Gammahsf1 tot = " << -4*Gammahsf1  << endl;
    // cout << "Gammahsf2 tot = " << -4*Gammahsf2  << endl;
    // cout << "GammaHsf1 tot = " << -4*GammaHsf1  << endl;
    // cout << "GammaHsf2 tot = " << -4*GammaHsf2  << endl;
    // cout << "GammaAsf1 tot = " << -4*GammaAsf1  << endl;
    // cout << "GammaAsf2 tot = " << -4*GammaAsf2  << endl;
    // cout << "GammaZsf1 tot = " << 4*GammaZsf1  << endl;
    // cout << "GammaZsf2 tot = " << -4*GammaZsf2  << endl;
    // cout << "GammaZA tot = " << -4*GammaZA << endl;
    // cout << "Gammagoldstone tot = " << Gammagoldstone << endl;
    // cout << "GammagA tot = " << 2*GammagA << endl;
    // cout << "GammaZg tot = " << -4*GammaZg << endl;
    // cout << "Gammagsf1 tot = " << -4*Gammagsf1 << endl;
    // cout << "Gammagsf2 tot = " << -4*Gammagsf2 << endl;
    // cout << "Total = " << GammaZ + Gammah + GammaH + GammaA + GammahHinterf + Gammasftot - 4*Gammahsf1 - 4*Gammahsf2 - 4*GammaHsf1 - 4*GammaHsf2 - 4*GammaAsf1 - 4*GammaAsf2 + 4*GammaZsf1 - 4*GammaZsf2 - 4*GammaZA + 2*GammagA - 4*GammaZg + Gammagoldstone - 4*Gammagsf1 - 4*Gammagsf2 << endl;

    amplitudeW = Nc/(512*pow(PI,3)*pow(fabs(mneutralinoi),3))*(GammaZ + Gammah + GammaH + GammaA + GammahHinterf + Gammasftot - 4*Gammahsf1 - 4*Gammahsf2 - 4*GammaHsf1 - 4*GammaHsf2 - 4*GammaAsf1 - 4*GammaAsf2 + 4*GammaZsf1 - 4*GammaZsf2 - 4*GammaZA + 2*GammagA - 4*GammaZg + Gammagoldstone - 4*Gammagsf1 -4*Gammagsf2);
    // cout << "amplitude = " << amplitudeW << endl;
    // cout << "from = " << from  << " fromz = " << fromz << " fromZsfE = " << fromzsfE << endl;
    // cout << "to = " << to << " toz = "<< toz << " toZsfE = " << tozsfE << endl;
    // cout << "sminz = " << sminz << " smaxz = " << smaxz << endl;
// Gammasftsfumsf1msf1 + Gammasftsfumsf2msf2 + 2*Gammasftsfumsf1msf2 + 

    
}
  
  return amplitudeW;
}

double neutralinoamplitudedecaycharginoffprimebar (double mneutralinoi, double msfp1, double msfp2, double msf1, double msf2, double mWboson, double mHP, double mcharginoj, double mfp, double mf, double thetaqp, double thetaq, double g, double gp, double alpha, double beta, double thetaL2, double thetaR2, double runmqp, double runmq, DoubleMatrix mixNeut, int ineutralino, int jchargino, int onetothree, char qorl, char norc) {
  
  double amplitudeW = 0;

  if (fabs(mneutralinoi) > msf1 + mf || fabs(mneutralinoi) > msf2 + mf || fabs(mneutralinoi) > msfp1 + mfp || fabs(mneutralinoi) > msfp2 + mfp || fabs(mneutralinoi) > fabs(mcharginoj) + mHP ||fabs(mneutralinoi) > fabs(mcharginoj) + mWboson || fabs(mneutralinoi) < fabs(mcharginoj) + mf + mfp){
    amplitudeW = 0;
  }

  else{

    double GammaW = 0, GammaHpm = 0, Gammagoldstone = 0, Gammasfp1 = 0, Gammasfp2 = 0, Gammasf1 = 0, Gammasf2 = 0, Gammasf1sf2 = 0, Gammasfp1sf1 = 0, Gammasfp1sf2 = 0, Gammasfp2sf1 = 0, Gammasfp2sf2 = 0, GammaWHpm = 0, GammaWgoldstone = 0, GammaWSfp1 = 0, GammaWSfp2 = 0, GammaWSf1 = 0, GammaWSf2 = 0, GammaHgoldstone = 0, Gammagsfp1 = 0, Gammagsfp2 = 0, GammaHpmsfp1 = 0, GammaHpmsfp2 = 0, Gammagsf1 = 0, Gammagsf2 = 0, GammaHpmsf1 = 0, GammaHpmsf2 = 0, Gammasfpsfp = 0;

    double charneutWcoupL = 0, charneutWcoupR = 0, coupHpmcharneutL = 0, coupHpmcharneutR = 0, coupHpm1charneutL = 0, coupHpm1charneutR = 0, coupHpm2charneutL = 0, coupHpm2charneutR = 0, fd = 0, fu = 0, coupHpm1ffpd = 0, coupHpm1ffpu = 0, coupHpm2ffpd = 0, coupHpm2ffpu = 0;
    
    // runmqp = 4*runmqp;

    fu = g*runmqp/(pow(2,0.5)*sin(beta)*mWboson); ///Just usual yukawa for up type
    fd = g*runmq/(pow(2,0.5)*cos(beta)*mWboson); ///Just usual yukawa for down type

    double ri = 0, rj = 0, rc = 0;
    if (mneutralinoi >= 0) { ri = 1;}
    else if (mneutralinoi < 0) { ri = -1;} ///correction factor for negative masses
    if (mcharginoj >= 0) { rj = 1;}
    else if (mcharginoj < 0) { rj = -1;} ///correction factor for negative masses
    if (norc == 'n') { rc = 1;}
    else if (norc == 'c') { rc = -1;} ///correction factor for if it's chargino -> neutralino fp fbar rather than neutralino -> chargino fpbar f

    if ( jchargino == 1) {
      charneutWcoupL = g*(sin(thetaL2)*mixNeut(ineutralino,2) + cos(thetaL2)*mixNeut(ineutralino,3)/(pow(2,0.5)));
      charneutWcoupR = g*(sin(thetaR2)*mixNeut(ineutralino,2) - cos(thetaR2)*mixNeut(ineutralino,4)/(pow(2,0.5)));
      ///Xij in T&B is -(charneutWcoupL + charneutWcoupR)/g Xij = 0.5*((cos(thetaR2)/pow(2,0.5)*mixNeut(ineutralino,4) - sin(thetaR2)*mixNeut(ineutralino,2)) - cos(thetaL2)/pow(2,0.5)*mixNeut(ineutralino,3) - sin(thetaL2)*mixNeut(ineutralino,2));
      ///Yij in T&B is -(charneutWcoupL - charneutWcoupR)/g Yij = 0.5*((-cos(thetaR2)/pow(2,0.5)*mixNeut(ineutralino,4) + sin(thetaR2)*mixNeut(ineutralino,2)) - cos(thetaL2)/pow(2,0.5)*mixNeut(ineutralino,3) - sin(thetaL2)*mixNeut(ineutralino,2));
      coupHpmcharneutL = (g*sin(thetaR2)*mixNeut(ineutralino,4) + cos(thetaR2)/(pow(2,0.5))*(gp*mixNeut(ineutralino,1)+g*mixNeut(ineutralino,2)));
      coupHpmcharneutR = (g*sin(thetaL2)*mixNeut(ineutralino,3) - cos(thetaL2)/(pow(2,0.5))*(gp*mixNeut(ineutralino,1)+g*mixNeut(ineutralino,2)));
    }

    else if ( jchargino == 2) {
      charneutWcoupL = g*(cos(thetaL2)*mixNeut(ineutralino,2) - sin(thetaL2)*mixNeut(ineutralino,3)/(pow(2,0.5)));
      charneutWcoupR = g*(cos(thetaR2)*mixNeut(ineutralino,2) + sin(thetaR2)*mixNeut(ineutralino,4)/(pow(2,0.5)));
      ///Xij in T&B is -(charneutWcoupL + charneutWcoupR)/g Xij = 0.5*((-sin(thetaR2)/pow(2,0.5)*mixNeut(ineutralino,4) - cos(thetaR2)*mixNeut(ineutralino,2)) + sin(thetaL2)/pow(2,0.5)*mixNeut(ineutralino,3) - cos(thetaL2)*mixNeut(ineutralino,2));
      ///Yij in T&B is -(charneutWcoupL - charneutWcoupR)/g Yij = 0.5*((sin(thetaR2)/pow(2,0.5)*mixNeut(ineutralino,4) + cos(thetaR2)*mixNeut(ineutralino,2)) + sin(thetaL2)/pow(2,0.5)*mixNeut(ineutralino,3) - cos(thetaL2)*mixNeut(ineutralino,2));
      coupHpmcharneutL = (g*cos(thetaR2)*mixNeut(ineutralino,4) - sin(thetaR2)/(pow(2,0.5))*(gp*mixNeut(ineutralino,1)+g*mixNeut(ineutralino,2)));
      coupHpmcharneutR = (g*cos(thetaL2)*mixNeut(ineutralino,3) + sin(thetaL2)/(pow(2,0.5))*(gp*mixNeut(ineutralino,1)+g*mixNeut(ineutralino,2)));
    }
    /*    cout << "masses: " << mneutralinoi << " " << mcharginoj << " " << mf << " " << mfp << endl;
//    cout << "charneutWcoupL = " << charneutWcoupL << endl;
//    cout << "charneutWcoupR = " << charneutWcoupR << endl;*/
    // cout << "Xij = " << Xij << endl;
    // cout << "Yij = " << Yij << endl;

    double AZiu = 0, BZiu = 0, sf1alpha1Ziu = 0, sf1beta1Ziu = 0, sf2alpha1Ziu = 0, sf2beta1Ziu = 0;
    double AZid = 0, BZid = 0, sf1alpha1Zid = 0, sf1beta1Zid = 0, sf2alpha1Zid = 0, sf2beta1Zid = 0;
    double Nc = 0;

    ///Comp5 parameters SPheno
    // thetaqp = 0.012739834;
    // fu = 0.0035821736428123590;
    // thetaq = 0.002822517544;
    // fd = 0.0026936984678902413;
    // mf = 0.095;
    ///Comp6 parameters SPheno
    // thetaqp = 0.012739834; ///Set a charm mixing angle for comp with Spheno.
    // thetaq = 0.002822490594; ///Set a strange mixing angle for comp with Spheno.
    // // // // fu = 3.5751006e-03 ; ///Set to SPheno charm yukawa for comp
    //  fu = 0.0035821736428123590 ; ///Set to SPheno charm yukawa for comp
    //  fd = 0.0026936984678902413; ///Set to SPheno strange yukawa for comp
    //  mf = 0.095; ///Set to strange mass used in SPheno for comp
    // thetaq = 0.006864603779; ///Set to Spheno smuon mixing angle for comp with SPheno.
    // ///Comp7 paramaters SPheno
    // fu = 3.61018253E-03; fd = 2.623044449E-03;
    // mf = 0.095; ///SEt to strange mass used in SPheno for comp
    // thetaqp = 0.006764419744;
    // // thetaq = 0.032110826;
    // thetaq = 0.440319343;
    ///Comp8 parameters SPheno:
    // fu = 3.6038222055756308E-003;
    // thetaqp = 0.126880167;
    // fd = 2.6314457055891605E-003;
    // thetaq = 0.113207937;
    // mf = 0.095; ///SEt to strange mass used in SPheno for comp
    
    if (qorl == 'q') {
      AZiu = g/(pow(2,0.5))*(-mixNeut(ineutralino,2)) + gp/(3*pow(2,0.5))*(-mixNeut(ineutralino,1));
      BZiu = (4./3)*gp/(pow(2,0.5))*(-mixNeut(ineutralino,1));
      sf1alpha1Ziu = AZiu*cos(thetaqp)*rj*-rc*ri - fu*mixNeut(ineutralino,4)*sin(thetaqp);
      // sf1beta1Ziu = fu*mixNeut(ineutralino,4)*cos(thetaqp) + ri*rc*BZiu*sin(thetaqp);
      sf1beta1Ziu = -rc*fu*mixNeut(ineutralino,4)*cos(thetaqp) - BZiu*sin(thetaqp);
      sf2alpha1Ziu = ri*rc*fu*mixNeut(ineutralino,4)*cos(thetaqp) + AZiu*sin(thetaqp);
      sf2beta1Ziu = -BZiu*cos(thetaqp)*rj*-rc*ri + fu*mixNeut(ineutralino,4)*sin(thetaqp);
   
      /*      cout << "sf1beta1Ziu = " << sf1beta1Ziu << endl;
      cout << "first term: " << fu*mixNeut(ineutralino,4)*cos(thetaqp) << endl;
      cout << "second term: " << BZiu*sin(thetaqp) << endl;
      cout << "fu= " << fu << " cos(thetaqp) = " << cos(thetaqp) << endl;
      cout << "BZiu = " << BZiu << " sin(thetaqp) = " << sin(thetaqp) << endl;
      */      

      AZid = g/(pow(2,0.5))*(mixNeut(ineutralino,2)) + gp/(3*pow(2,0.5))*(-mixNeut(ineutralino,1));
      BZid = (2./3)*gp/(pow(2,0.5))*(mixNeut(ineutralino,1));
      sf1alpha1Zid = AZid*cos(thetaq)*rj*-rc*ri - fd*mixNeut(ineutralino,4)*sin(thetaq);
      sf1beta1Zid = -rc*fd*mixNeut(ineutralino,3)*cos(thetaq) - BZid*sin(thetaq);
      sf2alpha1Zid = fd*mixNeut(ineutralino,3)*cos(thetaq)*rc + AZid*sin(thetaq);
      sf2beta1Zid = -BZid*cos(thetaq)*rj*-rc*ri + fd*mixNeut(ineutralino,4)*sin(thetaq);
      
      Nc = 3;
    }



    else if (qorl == 'l') {
      AZiu = g/(pow(2,0.5))*(-mixNeut(ineutralino,2)) + gp/(pow(2,0.5))*(mixNeut(ineutralino,1));
      BZiu = 0;
      sf1alpha1Ziu = AZiu*cos(thetaqp)*rj*-rc*ri - fu*mixNeut(ineutralino,4)*sin(thetaqp);
      sf1beta1Ziu = -rc*fu*mixNeut(ineutralino,4)*cos(thetaqp) - BZiu*sin(thetaqp);
      sf2alpha1Ziu = 0; ///No snuR exists so only one sfp contribution
      sf2beta1Ziu = 0; ///No snuR exists so only one sfp contribution

         
      AZid = g/(pow(2,0.5))*(mixNeut(ineutralino,2)) + gp/(pow(2,0.5))*(mixNeut(ineutralino,1));
      BZid = pow(2,0.5)*gp*mixNeut(ineutralino,1);
      sf1alpha1Zid = AZid*cos(thetaq)*rj*-rc*ri - fd*mixNeut(ineutralino,3)*sin(thetaq);
      sf1beta1Zid = -rc*fd*mixNeut(ineutralino,3)*cos(thetaq) - BZid*sin(thetaq);
      sf2alpha1Zid = fd*mixNeut(ineutralino,3)*cos(thetaq)*rc + AZid*sin(thetaq);
      sf2beta1Zid = -BZid*cos(thetaq)*rj*-rc*ri + fd*mixNeut(ineutralino,3)*sin(thetaq);
      
      Nc = 1;
    }

    



    ///GammaW
    double intW1 = 0, intW2 = 0, from = 0, to = 0;
    from = fabs(mcharginoj);
    to = 1/(2*fabs(mneutralinoi))*(pow(mneutralinoi,2)+pow(mcharginoj,2)-pow(mf,2)-pow(mfp,2)-2*mf*mfp);
    m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, MWboson = mWboson;
    intW1 = 2*fabs(m1)*dgauss(gneuticharjffpW1dgauss,from,to,accuracy);
    intW2 = 2*fabs(m1)*dgauss(gneuticharjffpW2dgauss,from,to,accuracy);
    GammaW = -8*charneutWcoupL*charneutWcoupR*pow(g,2)/2*fabs(mneutralinoi)*fabs(mcharginoj)*intW2*ri*rj + 2*(pow(charneutWcoupL,2)+pow(charneutWcoupR,2))*pow(g,2)/2*intW1;
    cout << "integrals in GammaW:" << endl;
    cout.precision(12);
    cout << "intW1 = " << intW1 << endl;
    cout << "intW2 = " << intW2 << endl;
    cout << "coefficients: " << endl;
    cout << 2*(pow(charneutWcoupL,2)+pow(charneutWcoupR,2))*pow(g,2)/2 << endl;
    cout << -8*charneutWcoupL*charneutWcoupR*pow(g,2)/2*fabs(mneutralinoi)*fabs(mcharginoj)*ri*rj << endl;
    cout << "term by term: " << endl;
    cout << 2*(pow(charneutWcoupL,2)+pow(charneutWcoupR,2))*pow(g,2)/2*intW1 << endl;
    cout << -8*charneutWcoupL*charneutWcoupR*pow(g,2)/2*fabs(mneutralinoi)*fabs(mcharginoj)*intW2*ri*rj << endl;
    cout << "GammaW = " << GammaW << endl;
    // cout << "from = " << from << "to = "<< to << endl;
    cout << "runmq = " << runmq << " runmqp = " << runmqp << endl;

    ///GammaHpm
    /*    cout << "coupHpmcharneutL = " << coupHpmcharneutL << endl;
    cout << "coupHpmcharneutR = " << coupHpmcharneutR << endl;
    cout << "sin(beta) = " << sin(beta) << endl;
    cout << "cos(beta) = " << cos(beta) << endl;
    cout << "yukawas: "<< endl;
    cout << "fu = " << fu << endl;
    cout << "fd = " << fd << endl;
    */
    double coupcombo1Hpm1 = 0, coupcombo2Hpm1 = 0, coupcombo3Hpm1 = 0, coupcombo4Hpm1 = 0, int1Wpm = 0, int2Wpm = 0, int3Wpm = 0, int4Wpm = 0;
    double coupcombo1Hpm2 = 0, coupcombo2Hpm2 = 0, coupcombo3Hpm2 = 0, coupcombo4Hpm2 = 0, int1Hpm = 0, int2Hpm = 0, int3Hpm = 0, int4Hpm = 0;
    cout.precision(12);
    ///Hpm1 contribution (W+ goldstone):
    coupHpm1charneutL = coupHpmcharneutL*sin(beta);
    coupHpm1charneutR = coupHpmcharneutR*-cos(beta);
    //    cout << "coupHpm1charneutL = " << coupHpm1charneutL << endl;
    //    cout << "coupHpm1charneutR = " << coupHpm1charneutR << endl;
    coupHpm1ffpu = fu*sin(beta);
    coupHpm1ffpd = fd*-cos(beta);
    //    cout << "coupHpm1ffpu = " << coupHpm1ffpu << endl;
    //    cout << "coupHpm1ffpd = " << coupHpm1ffpd << endl;
    coupcombo1Hpm1 = pow(coupHpm1charneutL,2) + pow(coupHpm1charneutR,2);
    coupcombo2Hpm1 = coupHpm1charneutL*coupHpm1charneutR*ri;
    coupcombo3Hpm1 = pow(coupHpm1ffpu,2) + pow(coupHpm1ffpd,2);
    coupcombo4Hpm1 = coupHpm1ffpu*coupHpm1ffpd;
    /*    cout << "coupcombo1Hpm1 = " << coupcombo1Hpm1 << endl;
    cout << "coupcombo2Hpm1 = " << coupcombo2Hpm1 << endl;
    cout << "coupcombo3Hpm1 = " << coupcombo3Hpm1 << endl;
    cout << "coupcombo4Hpm1 = " << coupcombo4Hpm1 << endl; */
    
    // mfp = 0.095; ///SET BY HAND FOR A COMPARISON WITH SPHENO
    m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mWboson;
    int1Wpm = 2*fabs(m1)*dgauss(gneuticharjffpHpm1dgauss,from,to,accuracy);
    int2Wpm = 2*fabs(m1)*dgauss(gneuticharjffpHpm2dgauss,from,to,accuracy);
    int3Wpm = 2*fabs(m1)*dgauss(gneuticharjffpHpm3dgauss,from,to,accuracy);
    int4Wpm = 2*fabs(m1)*dgauss(gneuticharjffpHpm4dgauss,from,to,accuracy);   

    ///Hpm2 contribution (Actual Hpm):
    coupHpm2charneutL = coupHpmcharneutL*cos(beta);
    coupHpm2charneutR = coupHpmcharneutR*sin(beta);
    //    cout << "coupHpm2charneutL = " << coupHpm2charneutL << endl;
    //    cout << "coupHpm2charneutR = " << coupHpm2charneutR << endl;
    coupHpm2ffpu = fu*cos(beta);
    coupHpm2ffpd = fd*sin(beta);
    //    cout << "coupHpm2ffpu = " << coupHpm2ffpu << endl;
    //    cout << "coupHpm2ffpd = " << coupHpm2ffpd << endl;
    coupcombo1Hpm2 = pow(coupHpm2charneutL,2) + pow(coupHpm2charneutR,2);
    coupcombo2Hpm2 = coupHpm2charneutL*coupHpm2charneutR*ri;
    coupcombo3Hpm2 = pow(coupHpm2ffpu,2) + pow(coupHpm2ffpd,2);
    coupcombo4Hpm2 = coupHpm2ffpu*coupHpm2ffpd;
    /*    cout << "coupcombo1Hpm2 = " << coupcombo1Hpm2 << endl;
    cout << "coupcombo2Hpm2 = " << coupcombo2Hpm2 << endl;
    cout << "coupcombo3Hpm2 = " << coupcombo3Hpm2 << endl;
    cout << "coupcombo4Hpm2 = " << coupcombo4Hpm2 << endl; */

    m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mHP;
    int1Hpm = 2*fabs(m1)*dgauss(gneuticharjffpHpm1dgauss,from,to,accuracy);
    int2Hpm = 2*fabs(m1)*dgauss(gneuticharjffpHpm2dgauss,from,to,accuracy);
    int3Hpm = 2*fabs(m1)*dgauss(gneuticharjffpHpm3dgauss,from,to,accuracy);
    int4Hpm = 2*fabs(m1)*dgauss(gneuticharjffpHpm4dgauss,from,to,accuracy);  

    cout.precision(16);
    /*    cout << "Integrals for Hpm1 (W+ goldstone:) " << endl;
    cout << "int1Wpm = " << int1Wpm << endl;
    cout << "int2Wpm = " << int2Wpm << endl;
    cout << "int3Wpm = " << int3Wpm << endl;
    cout << "int4Wpm = " << int4Wpm << endl;

    cout << "Integrals for Hpm2 (Actual Hpm:) " << endl;
    cout << "int1Hpm = " << int1Hpm << endl;
    cout << "int2Hpm = " << int2Hpm << endl;
    cout << "int3Hpm = " << int3Hpm << endl;
    cout << "int4Hpm = " << int4Hpm << endl;
    */
    cout.precision(25);
    /*    cout << "Hpm1 (W goldstone contribution) term by term: " << endl;
    cout << coupcombo1Hpm1*coupcombo3Hpm1*int4Wpm << endl;
    cout << 4*coupcombo1Hpm1*coupcombo4Hpm1*int3Wpm*-mf*mfp << endl;
    cout << 4*coupcombo2Hpm1*coupcombo3Hpm1*int2Wpm*fabs(mneutralinoi)*fabs(mcharginoj)*rj << endl;
    cout << 16*coupcombo2Hpm1*coupcombo4Hpm1*int1Wpm*-mf*mfp*fabs(mneutralinoi)*fabs(mcharginoj)*rj << endl;
    */
    Gammagoldstone = coupcombo1Hpm1*coupcombo3Hpm1*int4Wpm - 4*coupcombo1Hpm1*coupcombo4Hpm1*int3Wpm*mf*mfp + 4*coupcombo2Hpm1*coupcombo3Hpm1*int2Wpm*fabs(mneutralinoi)*fabs(mcharginoj)*rj - 16*coupcombo2Hpm1*coupcombo4Hpm1*int1Wpm*mf*mfp*fabs(mneutralinoi)*fabs(mcharginoj)*rj;

    /*    cout << "Hpm2 (Actual Hpm contribution) term by term: " << endl;
    cout << coupcombo1Hpm2*coupcombo3Hpm2*int4Hpm << endl;
    cout << 4*coupcombo1Hpm2*coupcombo4Hpm2*int3Hpm*-mf*mfp << endl;
    cout << 4*coupcombo2Hpm2*coupcombo3Hpm2*int2Hpm*fabs(mneutralinoi)*fabs(mcharginoj)*rj << endl;
    cout << 16*coupcombo2Hpm2*coupcombo4Hpm2*int1Hpm*-mf*mfp*fabs(mneutralinoi)*fabs(mcharginoj)*rj << endl;
    */
    GammaHpm = coupcombo1Hpm2*coupcombo3Hpm2*int4Hpm - 4*coupcombo1Hpm2*coupcombo4Hpm2*int3Hpm*mf*mfp + 4*coupcombo2Hpm2*coupcombo3Hpm2*int2Hpm*fabs(mneutralinoi)*fabs(mcharginoj)*rj - 16*coupcombo2Hpm2*coupcombo4Hpm2*int1Hpm*mf*mfp*fabs(mneutralinoi)*fabs(mcharginoj)*rj;



    ///Sfp Sfp diagonal (Remember fp is u-type fermion)
    cout.precision(12);
    /*    cout << "sf1alpha1Ziu = " << sf1alpha1Ziu << endl;
    cout << "Pieces of sf1alpha1Ziu: " << endl;
    cout << "AZiu*cos(thetaqp) = " << AZiu*cos(thetaqp) << " -yuk*v(i,4)*sin(thetaqp) = " << - fu*mixNeut(ineutralino,4)*sin(thetaqp) << endl;
    cout << "AZiu = " << AZiu << endl;
    cout << "sf2alpha1Ziu = " << sf2alpha1Ziu << endl;
    cout << "first term = " << fu*mixNeut(ineutralino,4)*cos(thetaqp) << endl;
    cout << "fu = " << fu << "mixNeut(i,4) = " << mixNeut(ineutralino,4) << "cos(thetaqp) = " << cos(thetaqp) << endl;
    cout << "second term = " <<  AZiu*sin(thetaqp) << endl;
    cout << "AZiu = " << AZiu << "sin(thetaqp) = " << sin(thetaqp) << endl;
    cout << "sf1beta1Ziu = " << sf1beta1Ziu << endl;
    cout << "first term = " << fu*mixNeut(ineutralino,4)*cos(thetaqp) << endl;
    cout << fu << " " << mixNeut(ineutralino,4) << " " << cos(thetaqp) << endl;
    cout << "second term = " << BZiu*sin(thetaqp) << endl;
    cout << BZiu << " " << sin(thetaqp) << endl;
    cout << "sf2beta1Ziu = " << sf2beta1Ziu << endl;
    cout << -BZiu*cos(thetaqp) << " "<< fu*mixNeut(ineutralino,4)*sin(thetaqp) << endl;
    cout << "sf1alpha1Zid = " << sf1alpha1Zid << endl;
    cout << "sf2alpha1Zid = " << sf2alpha1Zid << endl;
    cout << "first term = " << fd*mixNeut(ineutralino,3)*cos(thetaq) << endl;
    cout << fd << " " << mixNeut(ineutralino,3) << " " << cos(thetaq) << endl;
    cout << "second term = " << AZid*sin(thetaq) << endl;
    cout << AZid << " " << sin(thetaq) << endl;
    cout << "sf1beta1Zid = " << sf1beta1Zid << endl;
    cout << "first termn = " << fd*mixNeut(ineutralino,3)*cos(thetaq) << endl;
    cout << "fd = " << fd << " cos(thetaq) = " << cos(thetaq) << " mixNeut(ineutralino,3) = "<< mixNeut(ineutralino,3) << endl;
    cout << "second term = " << BZid*sin(thetaq) << endl;
    cout << "BZid = " << BZid << " sin(thetaq) = " << sin(thetaq) << endl;

    cout << "sf2beta1Zid = " << sf2beta1Zid << endl;*/
    double alphasfp1char = 0, betasfp1char = 0, alphasf1char = 0, betasf1char = 0, alphasfp2char = 0, betasfp2char = 0, alphasf2char = 0, betasf2char = 0;

    // thetaqp = 0.182002275;
    // thetaq = 1.252210642;

    if (jchargino == 1) {
      alphasfp1char = -g*sin(thetaR2)*cos(thetaqp) + fu*cos(thetaR2)*sin(thetaqp);
      betasfp1char = -fd*cos(thetaL2)*cos(thetaqp);
      alphasf1char = -g*sin(thetaL2)*cos(thetaq) + fd*cos(thetaL2)*sin(thetaq);
      betasf1char = -fu*cos(thetaR2)*cos(thetaq);
      alphasfp2char = -g*sin(thetaR2)*sin(thetaqp) + fu*cos(thetaR2)*-cos(thetaqp);
      betasfp2char = fd*cos(thetaL2)*sin(thetaqp);
      alphasf2char = fd*cos(thetaL2)*cos(thetaq) + rc*g*sin(thetaL2)*sin(thetaq);
      betasf2char = -fu*cos(thetaR2)*sin(thetaq);

      
    }
    else if (jchargino == 2) {
      alphasfp1char = -g*cos(thetaR2)*cos(thetaqp) - fu*sin(thetaR2)*sin(thetaqp);
      betasfp1char = fd*sin(thetaL2)*cos(thetaqp);
      alphasf1char = -g*cos(thetaL2)*cos(thetaq) - fd*sin(thetaL2)*sin(thetaq);
      betasf1char = fu*sin(thetaR2)*cos(thetaq);
      alphasfp2char = g*cos(thetaR2)*sin(thetaqp) - fu*sin(thetaR2)*-cos(thetaq);
      betasfp2char = fd*sin(thetaL2)*sin(thetaqp);
      alphasf2char = -fd*sin(thetaL2)*cos(thetaq) + rc*g*cos(thetaL2)*sin(thetaq);
      betasf2char = fu*sin(thetaR2)*sin(thetaq);
    }


    /*    cout << "alphasfp1char = " << alphasfp1char << endl;
    cout << "betasfp1char = " << betasfp1char << endl;
    cout << "-fd = " << -fd << endl;
    cout << "cos(thetaL2) = " << cos(thetaL2) << endl;
    cout << "cos(thetaqp) = " << cos(thetaqp) << endl;
    cout << "alphasf1char = " << alphasf1char << endl;
    cout << "betasf1char = " << betasf1char << endl;
    cout << "bit by bit: " << fu << " " << cos(thetaR2) << " " << cos(thetaqp) <<endl;
    cout << "alternative: " << fd*cos(thetaq)*cos(thetaL2) << endl;
    cout << "alphasfp2char = " << alphasfp2char << endl;
    cout << "first term = " << g*cos(thetaR2)*sin(thetaqp) << endl;
    cout << "second term = " << fu*-sin(thetaR2)*-cos(thetaqp) << endl;
    cout << "cos(thetaR2) = " << cos(thetaR2) << " g = " << g << " sin(thetaqp) = " << sin(thetaqp) << endl;
    cout << "fu = " << fu << " sin(thetaR2) = " << sin(thetaR2) << " -cos(thetaqp) = " << -cos(thetaqp) << endl;
    cout << "betasfp2char = " << betasfp2char << endl;
    cout << "alphasf2char = " << alphasf2char << endl;
    cout << "first term = " << fd*sin(thetaL2)*cos(thetaq) << endl;
    cout << fd << " " << sin(thetaL2) << " " << cos(thetaq) << endl;
    cout << "second term = " << - g*cos(thetaL2)*sin(thetaq) << endl;
    cout << -g << " " << cos(thetaL2) << " " << sin(thetaq) << endl;
    cout << "betasf2char = " << betasf2char << endl;

    cout << "cos(thetaL2) = " << cos(thetaL2) << endl;
    cout << "sin(thetaL2) = " << sin(thetaL2) << endl;
    cout << "cos(thetaR2) = " << cos(thetaR2) << endl;
    cout << "sin(thetaR2) = " << sin(thetaR2) << endl;

    // cout.precision(28);
    cout << scientific << "GammaW = " << GammaW << endl;
    cout << scientific << "Gammagoldstone = " << Gammagoldstone << endl;
    cout << scientific << "GammaHpm = " << GammaHpm << endl;
    */

    
    double coupcombo1sfp1 = 0, coupcombo2sfp1 = 0, coupcombo3sfp1 = 0, coupcombo4sfp1 = 0;
    coupcombo1sfp1 = pow(sf1alpha1Ziu,2) + pow(sf1beta1Ziu,2);
    coupcombo2sfp1 = -sf1alpha1Ziu*sf1beta1Ziu*ri;
    coupcombo3sfp1 = pow(alphasfp1char,2) + pow(betasfp1char,2);
    coupcombo4sfp1 = -alphasfp1char*betasfp1char;
    /*    cout << "Coup combos for sfp 1: " << endl;
    cout << "coupcombo1sfp1 = " << coupcombo1sfp1 << endl;
    cout << "coupcombo2sfp1 = " << coupcombo2sfp1 << endl;
    cout << "coupcombo3sfp1 = " << coupcombo3sfp1 << endl;
    cout << "coupcombo4sfp1 = " << coupcombo4sfp1 << endl;
    */
    double Eupper = 0;
    Eupper = 1/(2*fabs(mneutralinoi))*(pow(mneutralinoi,2) + pow(mfp,2) - pow(mf,2) - pow(mcharginoj,2) -2*mf*fabs(mcharginoj));
    // cout << "Eupper = " << Eupper << endl;
    double int1sfp1 = 0, int2sfp1 = 0, int3sfp1 = 0, int4sfp1 = 0;
    m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = msfp1;
    int1sfp1 = 2*fabs(m1)*dgauss(gneuticharjffpHpm1dgauss,mfp,Eupper,accuracy);
    int2sfp1 = 2*fabs(m1)*dgauss(gneuticharjffpHpm2dgauss,mfp,Eupper,accuracy);
    int3sfp1 = 2*fabs(m1)*dgauss(gneuticharjffpHpm3dgauss,mfp,Eupper,accuracy);
    int4sfp1 = 2*fabs(m1)*dgauss(gneuticharjffpHpm4dgauss,mfp,Eupper,accuracy);
    cout.precision(18);
    /*    cout << "Integrals for sfp1: " << endl;
    cout << "int1sfp1 = " << int1sfp1 << endl;
    cout << "int2sfp1 = " << int2sfp1 << endl;
    cout << "int3sfp1 = " << int3sfp1 << endl;
    cout << "int4sfp1 = " << int4sfp1 << endl;
    cout << "term by term for sfp1: " << endl;
    cout << coupcombo1sfp1*coupcombo3sfp1*int4sfp1 << endl;
    cout << 4*coupcombo1sfp1*coupcombo4sfp1*-mf*fabs(mcharginoj)*int3sfp1*rc << endl;
    cout << 4*coupcombo2sfp1*coupcombo3sfp1*fabs(mneutralinoi)*mfp*int2sfp1*rc << endl;
    cout << 16*coupcombo2sfp1*coupcombo4sfp1*fabs(mneutralinoi)*mfp*-mf*fabs(mcharginoj)*int1sfp1 << endl;
    */
    Gammasfp1 = coupcombo1sfp1*coupcombo3sfp1*int4sfp1 + 4*coupcombo1sfp1*coupcombo4sfp1*-mf*fabs(mcharginoj)*int3sfp1*rc + 4*coupcombo2sfp1*coupcombo3sfp1*fabs(mneutralinoi)*mfp*int2sfp1*rc + 16*coupcombo2sfp1*coupcombo4sfp1*fabs(mneutralinoi)*mfp*-mf*fabs(mcharginoj)*int1sfp1;
    cout << scientific << "Gammasfp1 = " << Gammasfp1 << endl;

    double coupcombo1sfp2 = 0, coupcombo2sfp2 = 0, coupcombo3sfp2 = 0, coupcombo4sfp2 = 0;
    coupcombo1sfp2 = pow(sf2alpha1Ziu,2) + pow(sf2beta1Ziu,2);
    coupcombo2sfp2 = sf2alpha1Ziu*sf2beta1Ziu*ri;
    coupcombo3sfp2 = pow(alphasfp2char,2) + pow(betasfp2char,2);
    coupcombo4sfp2 = alphasfp2char*betasfp2char;
    cout << "Coup combos for sfp 2: " << endl;
    cout << "coupcombo1sfp2 = " << coupcombo1sfp2 << endl;
    cout << "coupcombo2sfp2 = " << coupcombo2sfp2 << endl;
    cout << "coupcombo3sfp2 = " << coupcombo3sfp2 << endl;
    cout << "coupcombo4sfp2 = " << coupcombo4sfp2 << endl;

    double int1sfp2 = 0, int2sfp2 = 0, int3sfp2 = 0, int4sfp2 = 0;
    m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = msfp2;
    int1sfp2 = 2*fabs(m1)*dgauss(gneuticharjffpHpm1dgauss,mfp,Eupper,accuracy);
    int2sfp2 = 2*fabs(m1)*dgauss(gneuticharjffpHpm2dgauss,mfp,Eupper,accuracy);
    int3sfp2 = 2*fabs(m1)*dgauss(gneuticharjffpHpm3dgauss,mfp,Eupper,accuracy);
    int4sfp2 = 2*fabs(m1)*dgauss(gneuticharjffpHpm4dgauss,mfp,Eupper,accuracy);
    cout.precision(22);
    /*    cout << "Integrals for sfp2: " << endl;
    cout << "int1sfp2 = " << int1sfp2 << endl;
    cout << "int2sfp2 = " << int2sfp2 << endl;
    cout << "int3sfp2 = " << int3sfp2 << endl;
    cout << "int4sfp2 = " << int4sfp2 << endl;
    cout << "term by term for sfp2: " << endl;
    cout << coupcombo1sfp2*coupcombo3sfp2*int4sfp2 << endl;
    cout << 4*coupcombo1sfp2*coupcombo4sfp2*-mf*fabs(mcharginoj)*int3sfp2*rc << endl;
    cout << 4*coupcombo2sfp2*coupcombo3sfp2*fabs(mneutralinoi)*mfp*int2sfp2*rc << endl;
    cout << 16*coupcombo2sfp2*coupcombo4sfp2*fabs(mneutralinoi)*mfp*-mf*fabs(mcharginoj)*int1sfp2 << endl;
    */
    Gammasfp2 = coupcombo1sfp2*coupcombo3sfp2*int4sfp2 + 4*coupcombo1sfp2*coupcombo4sfp2*-mf*fabs(mcharginoj)*int3sfp2*rc + 4*coupcombo2sfp2*coupcombo3sfp2*fabs(mneutralinoi)*mfp*int2sfp2*rc + 16*coupcombo2sfp2*coupcombo4sfp2*fabs(mneutralinoi)*mfp*-mf*fabs(mcharginoj)*int1sfp2;
    //    cout << scientific << "Gammasfp2 = " << Gammasfp2 << endl;

    ///Sf Sf diagonal
    double coupcombo1sf1 = 0, coupcombo2sf1 = 0, coupcombo3sf1 = 0, coupcombo4sf1 = 0;
    coupcombo1sf1 = pow(sf1alpha1Zid,2) + pow(sf1beta1Zid,2);
    coupcombo2sf1 = -sf1alpha1Zid*sf1beta1Zid;
    coupcombo3sf1 = pow(alphasf1char,2) + pow(betasf1char,2);
    coupcombo4sf1 = -alphasf1char*betasf1char*rj;
    /*    cout << "Coup combos for sf 1: " << endl;
    cout << "coupcombo1sf1 = " << coupcombo1sf1 << endl;
    cout << "coupcombo2sf1 = " << coupcombo2sf1 << endl;
    cout << "coupcombo3sf1 = " << coupcombo3sf1 << endl;
    cout << "coupcombo4sf1 = " << coupcombo4sf1 << endl;
    */
    double Eupper2 = 0;
    Eupper2 = 1/(2*fabs(mneutralinoi))*(pow(mneutralinoi,2) + pow(mf,2) - pow(mfp,2) - pow(mcharginoj,2) -2*mfp*fabs(mcharginoj));
    double int1sf1 = 0, int2sf1 = 0, int3sf1 = 0, int4sf1 = 0;
    m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msf1;
    int1sf1 = 2*fabs(m1)*dgauss(gneuticharjffpHpm1dgauss,mf,Eupper2,accuracy);
    int2sf1 = 2*fabs(m1)*dgauss(gneuticharjffpHpm2dgauss,mf,Eupper2,accuracy);
    int3sf1 = 2*fabs(m1)*dgauss(gneuticharjffpHpm3dgauss,mf,Eupper2,accuracy);
    int4sf1 = 2*fabs(m1)*dgauss(gneuticharjffpHpm4dgauss,mf,Eupper2,accuracy);
    cout.precision(18);
    /*    cout << "Integrals for sf1: " << endl;
    cout << "int1sf1 = " << int1sf1 << endl;
    cout << "int2sf1 = " << int2sf1 << endl;
    cout << "int3sf1 = " << int3sf1 << endl;
    cout << "int4sf1 = " << int4sf1 << endl;
    */
    
    cout << "term by term for sf1: " << endl;
    cout << coupcombo1sf1*coupcombo3sf1*int4sf1 << endl;
    cout << 4*coupcombo1sf1*coupcombo4sf1*-fabs(mcharginoj)*mfp*int3sf1*rc*rj << endl;
    cout << 4*coupcombo2sf1*coupcombo3sf1*fabs(mneutralinoi)*mf*int2sf1*rc << endl;
    cout << 16*coupcombo2sf1*coupcombo4sf1*fabs(mneutralinoi)*mf*-mfp*fabs(mcharginoj)*int1sf1*rj << endl;

    Gammasf1 = coupcombo1sf1*coupcombo3sf1*int4sf1 + 4*coupcombo1sf1*coupcombo4sf1*-mfp*fabs(mcharginoj)*int3sf1*rc*rj + 4*coupcombo2sf1*coupcombo3sf1*fabs(mneutralinoi)*mf*int2sf1*rc + 16*coupcombo2sf1*coupcombo4sf1*fabs(mneutralinoi)*mf*-mfp*fabs(mcharginoj)*rj*int1sf1;
    //    cout << scientific << "Gammasf1 = " << Gammasf1 << endl;

    double coupcombo1sf2 = 0, coupcombo2sf2 = 0, coupcombo3sf2 = 0, coupcombo4sf2 = 0;
    coupcombo1sf2 = pow(sf2alpha1Zid,2) + pow(sf2beta1Zid,2);
    coupcombo2sf2 = sf2alpha1Zid*sf2beta1Zid;
    coupcombo3sf2 = pow(alphasf2char,2) + pow(betasf2char,2);
    coupcombo4sf2 = alphasf2char*betasf2char*rc;
    /*    cout << "Coup combos for sf 2: " << endl;
    cout << "coupcombo1sf2 = " << coupcombo1sf2 << endl;
    cout << "coupcombo2sf2 = " << coupcombo2sf2 << endl;
    cout << "coupcombo3sf2 = " << coupcombo3sf2 << endl;
    cout << "coupcombo4sf2 = " << coupcombo4sf2 << endl;
    */
    double int1sf2 = 0, int2sf2 = 0, int3sf2 = 0, int4sf2 = 0;
    m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msf2;
    int1sf2 = 2*fabs(m1)*dgauss(gneuticharjffpHpm1dgauss,mf,Eupper2,accuracy);
    int2sf2 = 2*fabs(m1)*dgauss(gneuticharjffpHpm2dgauss,mf,Eupper2,accuracy);
    int3sf2 = 2*fabs(m1)*dgauss(gneuticharjffpHpm3dgauss,mf,Eupper2,accuracy);
    int4sf2 = 2*fabs(m1)*dgauss(gneuticharjffpHpm4dgauss,mf,Eupper2,accuracy);
    /*    cout.precision(26);
    cout << "Integrals for sf2: " << endl;
    cout << "int1sf2 = " << int1sf2 << endl;
    cout << "int2sf2 = " << int2sf2 << endl;
    cout << "int3sf2 = " << int3sf2 << endl;
    cout << "int4sf2 = " << int4sf2 << endl;
    
    cout << "term by term for sf2: " << endl;
    cout << coupcombo1sf2*coupcombo3sf2*int4sf2 << endl;
    cout << 4*coupcombo1sf2*coupcombo4sf2*-fabs(mcharginoj)*mfp*int3sf2*rc << endl;
    cout << 4*coupcombo2sf2*coupcombo3sf2*fabs(mneutralinoi)*mf*int2sf2*rc << endl;
    cout << 16*coupcombo2sf2*coupcombo4sf2*fabs(mneutralinoi)*mf*-mfp*fabs(mcharginoj)*int1sf2 << endl;
    */
    Gammasf2 = coupcombo1sf2*coupcombo3sf2*int4sf2 + 4*coupcombo1sf2*coupcombo4sf2*-mfp*fabs(mcharginoj)*int3sf2*rc + 4*coupcombo2sf2*coupcombo3sf2*fabs(mneutralinoi)*mf*int2sf2*rc + 16*coupcombo2sf2*coupcombo4sf2*fabs(mneutralinoi)*mf*-mfp*fabs(mcharginoj)*int1sf2;
    //    cout << scientific << "Gammasf2 = " << Gammasf2 << endl;

    ///Sf - Sf interference
    double coupcombo1sf1sf2 = 0, coupcombo2sf1sf2 = 0, coupcombo3sf1sf2 = 0, coupcombo4sf1sf2 = 0;
    coupcombo1sf1sf2 = (sf1alpha1Zid*-sf2alpha1Zid + sf1beta1Zid*sf2beta1Zid)*rj*-rc*ri;
    coupcombo2sf1sf2 = (-sf1beta1Zid*-sf2alpha1Zid - sf1alpha1Zid*sf2beta1Zid)*ri*rj*-rc;
    coupcombo3sf1sf2 = (betasf1char*-betasf2char + alphasf1char*alphasf2char);
    coupcombo4sf1sf2 = (-alphasf1char*-betasf2char - betasf1char*alphasf2char)*rj*rc;

    //    cout << "Coupling combos for sf1 sf2 interference: " << endl;
    cout.precision(12);
    /*    cout << coupcombo1sf1sf2 << endl;
    cout << coupcombo2sf1sf2 << endl;
    cout << coupcombo3sf1sf2 << endl;
    cout << coupcombo4sf1sf2 << endl;*/

    double int1sf1sf2 = 0, int2sf1sf2 = 0, int3sf1sf2 = 0, int4sf1sf2 = 0;
    m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msf1, m6 = msf2;
    int1sf1sf2 = 2*fabs(m1)*dgauss(gneuticharjffp1sf1sf2dgauss,mf,Eupper2,accuracy);
    int2sf1sf2 = 2*fabs(m1)*dgauss(gneuticharjffp2sf1sf2dgauss,mf,Eupper2,accuracy);
    int3sf1sf2 = 2*fabs(m1)*dgauss(gneuticharjffp3sf1sf2dgauss,mf,Eupper2,accuracy);
    int4sf1sf2 = 2*fabs(m1)*dgauss(gneuticharjffp4sf1sf2dgauss,mf,Eupper2,accuracy);
    
    /*    cout << "Integrals for sf1 sf2 interference: " << endl;
    cout.precision(20);
    cout << int1sf1sf2 << endl;
    cout << int2sf1sf2 << endl;
    cout << int3sf1sf2 << endl;
    cout << int4sf1sf2 << endl;

    cout << "Term by term for sf1 sf2 interference: " << endl;
    cout << coupcombo1sf1sf2*coupcombo3sf1sf2*int4sf1sf2 << endl;
    cout << 2*coupcombo1sf1sf2*coupcombo4sf1sf2*mfp*-fabs(mcharginoj)*int3sf1sf2*rc << endl;
    cout << 2*coupcombo2sf1sf2*coupcombo3sf1sf2*fabs(mneutralinoi)*mf*int2sf1sf2*rc << endl;
    cout << 4*coupcombo2sf1sf2*coupcombo4sf1sf2*fabs(mneutralinoi)*mf*-fabs(mcharginoj)*mfp*int1sf1sf2 << endl;
    */
    Gammasf1sf2 = 2*(coupcombo1sf1sf2*coupcombo3sf1sf2*int4sf1sf2 + 2*coupcombo1sf1sf2*coupcombo4sf1sf2*mfp*-fabs(mcharginoj)*int3sf1sf2 + 2*coupcombo2sf1sf2*coupcombo3sf1sf2*fabs(mneutralinoi)*mf*int2sf1sf2 + 4*coupcombo2sf1sf2*coupcombo4sf1sf2*fabs(mneutralinoi)*mf*-fabs(mcharginoj)*mfp*int1sf1sf2);
    cout << scientific << "Gammasf1sf2 = " << Gammasf1sf2 << endl;

    ///Sfp t sf u interference
    ///Sfp 1 sf 2
    
    double coupcombo1sfp1sf2 = 0, coupcombo2sfp1sf2 = 0, coupcombo3sfp1sf2 = 0, coupcombo4sfp1sf2 = 0, coupcombo5sfp1sf2 = 0, coupcombo6sfp1sf2 = 0, coupcombo7sfp1sf2 = 0, coupcombo8sfp1sf2 = 0;
    coupcombo1sfp1sf2 = -0.5*(sf1alpha1Ziu*sf2beta1Zid*betasfp1char*alphasf2char + rc*ri*sf1beta1Ziu*sf2alpha1Zid*alphasfp1char*betasf2char);
    coupcombo2sfp1sf2 = -ri*fabs(mneutralinoi)*fabs(mcharginoj)*(ri*sf1alpha1Ziu*sf2alpha1Zid*alphasfp1char*alphasf2char + sf1beta1Ziu*sf2beta1Zid*betasfp1char*betasf2char);
    coupcombo3sfp1sf2 = ri*rc*mf*mfp*(sf1beta1Ziu*sf2alpha1Zid*betasfp1char*alphasf2char + ri*sf1alpha1Ziu*sf2beta1Zid*alphasfp1char*betasf2char);
    coupcombo8sfp1sf2 = ri*2*fabs(mneutralinoi)*fabs(mcharginoj)*mf*mfp*(sf1beta1Ziu*sf2beta1Zid*alphasfp1char*alphasf2char + rc*ri*sf1alpha1Ziu*sf2alpha1Zid*betasfp1char*betasf2char);
    if (norc == 'n') {
    coupcombo4sfp1sf2 = fabs(mneutralinoi)*mf*(-sf1alpha1Ziu*sf2alpha1Zid*betasfp1char*alphasf2char - ri*sf1beta1Ziu*sf2beta1Zid*alphasfp1char*betasf2char);
    coupcombo5sfp1sf2 = mfp*fabs(mcharginoj)*(ri*sf1beta1Ziu*sf2alpha1Zid*alphasfp1char*alphasf2char + sf1alpha1Ziu*sf2beta1Zid*betasfp1char*betasf2char)*rj;
    coupcombo6sfp1sf2 = -ri*fabs(mneutralinoi)*mfp*(-sf1beta1Ziu*sf2beta1Zid*betasfp1char*alphasf2char - ri*sf1alpha1Ziu*sf2alpha1Zid*alphasfp1char*betasf2char);
    coupcombo7sfp1sf2 = -ri*fabs(mcharginoj)*mf*(ri*sf1alpha1Ziu*sf2beta1Zid*alphasfp1char*alphasf2char + sf1beta1Ziu*sf2alpha1Zid*betasfp1char*betasf2char)*rj;
    }
    else if (norc == 'c') {
      coupcombo4sfp1sf2 = fabs(mneutralinoi)*mf*(-rj*alphasfp1char*alphasf2char*sf1beta1Ziu*sf2alpha1Zid + betasfp1char*betasf2char*sf1alpha1Ziu*sf2beta1Zid);
      coupcombo5sfp1sf2 = fabs(mcharginoj)*mfp*(alphasf2char*betasfp1char*sf1alpha1Ziu*sf2alpha1Zid - rj*alphasfp1char*betasf2char*sf1beta1Ziu*sf2beta1Zid);
      coupcombo6sfp1sf2 = -fabs(mneutralinoi)*mfp*(-betasfp1char*betasf2char*sf1beta1Ziu*sf2alpha1Zid - alphasfp1char*alphasf2char*sf1alpha1Ziu*sf2beta1Zid);
      coupcombo7sfp1sf2 = -fabs(mcharginoj)*mf*(-alphasfp1char*betasf2char*sf1alpha1Ziu*sf2alpha1Zid + rj*betasfp1char*alphasf2char*sf1beta1Ziu*sf2beta1Zid);
    }


    /*    cout << "Coupling combos for sfp 1 sf 2 interference: " << endl;
    cout << coupcombo1sfp1sf2 << endl;
    cout << coupcombo2sfp1sf2 << endl;
    cout << coupcombo3sfp1sf2 << endl;
    cout << coupcombo4sfp1sf2 << endl;
    cout << "first term: " << fabs(mneutralinoi)*mf*(alphasfp1char*alphasf2char*sf1beta1Ziu*sf2alpha1Zid) << " second term: " << fabs(mneutralinoi)*mf*alphasfp1char*betasf2char*sf1alpha1Ziu*sf2beta1Zid << endl;
    cout << "rj = " << rj << endl;
    cout << coupcombo5sfp1sf2 << endl;
    cout << coupcombo6sfp1sf2 << endl;
    cout << coupcombo7sfp1sf2 << endl;
    cout << coupcombo8sfp1sf2 << endl;*/

    double int1sfp1sf2 = 0, int2sfp1sf2 = 0, int3sfp1sf2 = 0, int4sfp1sf2 = 0, int5sfp1sf2 = 0, int6sfp1sf2 = 0, int7sfp1sf2 = 0, int8sfp1sf2 = 0;
    m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msfp1, m6 = msf2;
    int1sfp1sf2 = 2*fabs(m1)*dgauss(gneuticharjffp1sfp1sf2dgauss,mfp,Eupper,accuracy);
    int2sfp1sf2 = 2*fabs(m1)*dgauss(gneuticharjffp2sfp1sf2dgauss,mfp,Eupper,accuracy);
    int3sfp1sf2 = 2*fabs(m1)*dgauss(gneuticharjffp3sfp1sf2dgauss,mfp,Eupper,accuracy);
    int4sfp1sf2 = 2*fabs(m1)*dgauss(gneuticharjffp4sfp1sf2dgauss,mfp,Eupper,accuracy);
    int5sfp1sf2 = 2*fabs(m1)*dgauss(gneuticharjffp5sfp1sf2dgauss,mfp,Eupper,accuracy);
    int6sfp1sf2 = 2*fabs(m1)*dgauss(gneuticharjffp6sfp1sf2dgauss,mfp,Eupper,accuracy);
    int7sfp1sf2 = 2*fabs(m1)*dgauss(gneuticharjffp7sfp1sf2dgauss,mfp,Eupper,accuracy);
    int8sfp1sf2 = 2*fabs(m1)*dgauss(gneuticharjffp8sfp1sf2dgauss,mfp,Eupper,accuracy);

    /*    cout << "Integrals for sfp 1 sf 2 interference: " << endl;
    cout << int1sfp1sf2 << endl;
    cout << int2sfp1sf2 << endl;
    cout << int3sfp1sf2 << endl;
    cout << int4sfp1sf2 << endl;
    cout << int5sfp1sf2 << endl;
    cout << int6sfp1sf2 << endl;
    cout << int7sfp1sf2 << endl;
    cout << int8sfp1sf2 << endl;

    cout << "Term by term for sfp 1 sf 2 interference: " << endl;
    cout.precision(26);
    cout << coupcombo1sfp1sf2*int1sfp1sf2 << endl;
    cout << coupcombo2sfp1sf2*int2sfp1sf2 << endl;
    cout << coupcombo3sfp1sf2*int3sfp1sf2 << endl;
    cout << coupcombo4sfp1sf2*int4sfp1sf2 << endl;
    cout << coupcombo5sfp1sf2*int5sfp1sf2 << endl;
    cout << coupcombo6sfp1sf2*int6sfp1sf2 << endl;
    cout << coupcombo7sfp1sf2*int7sfp1sf2 << endl;
    cout << coupcombo8sfp1sf2*int8sfp1sf2 << endl;
    */
    Gammasfp1sf2 = coupcombo1sfp1sf2*int1sfp1sf2 + coupcombo2sfp1sf2*int2sfp1sf2 + coupcombo3sfp1sf2*int3sfp1sf2 + coupcombo4sfp1sf2*int4sfp1sf2 + coupcombo5sfp1sf2*int5sfp1sf2 + coupcombo6sfp1sf2*int6sfp1sf2 + coupcombo7sfp1sf2*int7sfp1sf2 + coupcombo8sfp1sf2*int8sfp1sf2;
    cout << scientific << "Gammasfp1sf2 = " << Gammasfp1sf2 << endl;

    ///Sfp 1 Sf 1 interference

    double coupcombo1sfp1sf1 = 0, coupcombo2sfp1sf1 = 0, coupcombo3sfp1sf1 = 0, coupcombo4sfp1sf1 = 0, coupcombo5sfp1sf1 = 0, coupcombo6sfp1sf1 = 0, coupcombo7sfp1sf1 = 0, coupcombo8sfp1sf1 = 0;
    coupcombo1sfp1sf1 = 0.5*(ri*sf1alpha1Ziu*sf1beta1Zid*betasfp1char*alphasf1char + sf1beta1Ziu*sf1alpha1Zid*alphasfp1char*betasf1char)*rj;
    coupcombo2sfp1sf1 = -fabs(mneutralinoi)*fabs(mcharginoj)*(sf1alpha1Ziu*sf1alpha1Zid*alphasfp1char*alphasf1char + ri*sf1beta1Ziu*sf1beta1Zid*betasfp1char*betasf1char)*ri*rj;
    coupcombo3sfp1sf1 = mf*mfp*(sf1beta1Ziu*sf1alpha1Zid*betasfp1char*alphasf1char + ri*sf1alpha1Ziu*sf1beta1Zid*alphasfp1char*betasf1char)*rj;
    coupcombo8sfp1sf1 = -2*fabs(mneutralinoi)*fabs(mcharginoj)*mf*mfp*(ri*sf1beta1Ziu*sf1beta1Zid*alphasfp1char*alphasf1char + sf1alpha1Ziu*sf1alpha1Zid*betasfp1char*betasf1char)*ri*rj;
    if (norc == 'n') {
    coupcombo4sfp1sf1 = fabs(mneutralinoi)*mf*(-sf1alpha1Ziu*sf1alpha1Zid*betasfp1char*alphasf1char - ri*sf1beta1Ziu*sf1beta1Zid*alphasfp1char*betasf1char)*ri;
    coupcombo5sfp1sf1 = mfp*fabs(mcharginoj)*(sf1beta1Ziu*sf1alpha1Zid*alphasfp1char*alphasf1char + ri*sf1alpha1Ziu*sf1beta1Zid*betasfp1char*betasf1char)*rj;
    coupcombo6sfp1sf1 = fabs(mneutralinoi)*mfp*(-ri*sf1beta1Ziu*sf1beta1Zid*betasfp1char*alphasf1char - sf1alpha1Ziu*sf1alpha1Zid*alphasfp1char*betasf1char)*ri;
    coupcombo7sfp1sf1 = fabs(mcharginoj)*mf*(ri*sf1alpha1Ziu*sf1beta1Zid*alphasfp1char*alphasf1char + sf1beta1Ziu*sf1alpha1Zid*betasfp1char*betasf1char)*rj;
    }
    else if (norc == 'c') {
      coupcombo4sfp1sf1 = -fabs(mneutralinoi)*mf*(alphasfp1char*alphasf1char*sf1beta1Ziu*sf1alpha1Zid + betasfp1char*betasf1char*sf1alpha1Ziu*sf1beta1Zid)*rj;
      coupcombo5sfp1sf1 = fabs(mcharginoj)*mfp*(alphasf1char*betasfp1char*sf1alpha1Ziu*sf1alpha1Zid + alphasfp1char*betasf1char*sf1beta1Ziu*sf1beta1Zid)*rj;
      coupcombo6sfp1sf1 = fabs(mneutralinoi)*mfp*(-betasfp1char*betasf1char*sf1beta1Ziu*sf1alpha1Zid - alphasfp1char*alphasf1char*sf1alpha1Ziu*sf1beta1Zid)*rj;
      coupcombo7sfp1sf1 = -fabs(mcharginoj)*mf*(-alphasfp1char*betasf1char*sf1alpha1Ziu*sf1alpha1Zid - betasfp1char*alphasf1char*sf1beta1Ziu*sf1beta1Zid)*rj;
    }
    

    /*    cout << "Coupling combos for sfp 1 sf 1 interference: " << endl;
    cout << coupcombo1sfp1sf1 << endl;
    cout << coupcombo2sfp1sf1 << endl;
    cout << coupcombo3sfp1sf1 << endl;
    cout << coupcombo4sfp1sf1 << endl;
    cout << coupcombo5sfp1sf1 << endl;
    cout << coupcombo6sfp1sf1 << endl;
    cout << coupcombo7sfp1sf1 << endl;
    cout << coupcombo8sfp1sf1 << endl;
    */
    double int1sfp1sf1 = 0, int2sfp1sf1 = 0, int3sfp1sf1 = 0, int4sfp1sf1 = 0, int5sfp1sf1 = 0, int6sfp1sf1 = 0, int7sfp1sf1 = 0, int8sfp1sf1 = 0;
    m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msfp1, m6 = msf1;
    int1sfp1sf1 = 2*fabs(m1)*dgauss(gneuticharjffp1sfp1sf2dgauss,mfp,Eupper,accuracy);
    int2sfp1sf1 = 2*fabs(m1)*dgauss(gneuticharjffp2sfp1sf2dgauss,mfp,Eupper,accuracy);
    int3sfp1sf1 = 2*fabs(m1)*dgauss(gneuticharjffp3sfp1sf2dgauss,mfp,Eupper,accuracy);
    int4sfp1sf1 = 2*fabs(m1)*dgauss(gneuticharjffp4sfp1sf2dgauss,mfp,Eupper,accuracy);
    int5sfp1sf1 = 2*fabs(m1)*dgauss(gneuticharjffp5sfp1sf2dgauss,mfp,Eupper,accuracy);
    int6sfp1sf1 = 2*fabs(m1)*dgauss(gneuticharjffp6sfp1sf2dgauss,mfp,Eupper,accuracy);
    int7sfp1sf1 = 2*fabs(m1)*dgauss(gneuticharjffp7sfp1sf2dgauss,mfp,Eupper,accuracy);
    int8sfp1sf1 = 2*fabs(m1)*dgauss(gneuticharjffp8sfp1sf2dgauss,mfp,Eupper,accuracy);

    /*    cout << "Integrals for sfp 1 sf 1 interference: " << endl;
    cout << int1sfp1sf1 << endl;
    cout << int2sfp1sf1 << endl;
    cout << int3sfp1sf1 << endl;
    cout << int4sfp1sf1 << endl;
    cout << int5sfp1sf1 << endl;
    cout << int6sfp1sf1 << endl;
    cout << int7sfp1sf1 << endl;
    cout << int8sfp1sf1 << endl;

    cout << "Term by term for sfp 1 sf 1 interference: " << endl;
    cout.precision(26);
    cout << coupcombo1sfp1sf1*int1sfp1sf1 << endl;
    cout << coupcombo2sfp1sf1*int2sfp1sf1 << endl;
    cout << coupcombo3sfp1sf1*int3sfp1sf1 << endl;
    cout << coupcombo4sfp1sf1*int4sfp1sf1 << endl;
    cout << coupcombo5sfp1sf1*int5sfp1sf1 << endl;
    cout << coupcombo6sfp1sf1*int6sfp1sf1 << endl;
    cout << coupcombo7sfp1sf1*int7sfp1sf1 << endl;
    cout << coupcombo8sfp1sf1*int8sfp1sf1 << endl;
    */
    Gammasfp1sf1 = coupcombo1sfp1sf1*int1sfp1sf1 + coupcombo2sfp1sf1*int2sfp1sf1 + coupcombo3sfp1sf1*int3sfp1sf1 + coupcombo4sfp1sf1*int4sfp1sf1 + coupcombo5sfp1sf1*int5sfp1sf1 + coupcombo6sfp1sf1*int6sfp1sf1 + coupcombo7sfp1sf1*int7sfp1sf1 + coupcombo8sfp1sf1*int8sfp1sf1;
    //    cout << scientific << "Gammasfp1sf1 = " << Gammasfp1sf1 << endl;


    ///Sfp 2 Sf 2 interference
    
    double coupcombo1sfp2sf2 = 0, coupcombo2sfp2sf2 = 0, coupcombo3sfp2sf2 = 0, coupcombo4sfp2sf2 = 0, coupcombo5sfp2sf2 = 0, coupcombo6sfp2sf2 = 0, coupcombo7sfp2sf2 = 0, coupcombo8sfp2sf2 = 0;
    coupcombo8sfp2sf2 = 2*fabs(mneutralinoi)*fabs(mcharginoj)*mf*mfp*(sf2beta1Ziu*sf2beta1Zid*alphasfp2char*alphasf2char - sf2alpha1Ziu*sf2alpha1Zid*betasfp2char*betasf2char)*ri*rj;

    if (norc == 'n') {
      coupcombo1sfp2sf2 = 0.5*(-sf2alpha1Ziu*sf2beta1Zid*betasfp2char*alphasf2char + ri*sf2beta1Ziu*sf2alpha1Zid*alphasfp2char*betasf2char)*rj;
      coupcombo2sfp2sf2 = -fabs(mneutralinoi)*fabs(mcharginoj)*(sf2alpha1Ziu*sf2alpha1Zid*alphasfp2char*alphasf2char - sf2beta1Ziu*sf2beta1Zid*betasfp2char*betasf2char)*ri*rj;
      coupcombo3sfp2sf2 = -mf*mfp*(-sf2beta1Ziu*sf2alpha1Zid*betasfp2char*alphasf2char + sf2alpha1Ziu*sf2beta1Zid*alphasfp2char*betasf2char);
      coupcombo4sfp2sf2 = fabs(mneutralinoi)*mf*(sf2alpha1Ziu*sf2alpha1Zid*betasfp2char*alphasf2char - sf2beta1Ziu*sf2beta1Zid*alphasfp2char*betasf2char)*ri*rj;
      coupcombo5sfp2sf2 = mfp*fabs(mcharginoj)*(sf2beta1Ziu*sf2alpha1Zid*alphasfp2char*alphasf2char + ri*rj*sf2alpha1Ziu*sf2beta1Zid*betasfp2char*betasf2char)*rj*ri;
      coupcombo6sfp2sf2 = -ri*fabs(mneutralinoi)*mfp*(sf2beta1Ziu*sf2beta1Zid*betasfp2char*alphasf2char - sf2alpha1Ziu*sf2alpha1Zid*alphasfp2char*betasf2char);
      coupcombo7sfp2sf2 = fabs(mcharginoj)*mf*(sf2alpha1Ziu*sf2beta1Zid*alphasfp2char*alphasf2char - sf2beta1Ziu*sf2alpha1Zid*betasfp2char*betasf2char)*rj;
    }
    else if (norc == 'c') {
      coupcombo1sfp2sf2 = 0.5*(-rj*sf2alpha1Ziu*sf2beta1Zid*betasfp2char*alphasf2char - sf2beta1Ziu*sf2alpha1Zid*alphasfp2char*betasf2char);
      coupcombo2sfp2sf2 = rj*fabs(mneutralinoi)*fabs(mcharginoj)*(sf2alpha1Ziu*sf2alpha1Zid*alphasfp2char*alphasf2char - rj*sf2beta1Ziu*sf2beta1Zid*betasfp2char*betasf2char)*ri;
      coupcombo3sfp2sf2 = mf*mfp*(-rj*sf2beta1Ziu*sf2alpha1Zid*betasfp2char*alphasf2char - sf2alpha1Ziu*sf2beta1Zid*alphasfp2char*betasf2char);
      coupcombo4sfp2sf2 = -rj*fabs(mneutralinoi)*mf*(alphasfp2char*alphasf2char*sf2beta1Ziu*sf2alpha1Zid + betasfp2char*betasf2char*sf2alpha1Ziu*sf2beta1Zid);
      coupcombo5sfp2sf2 = -rj*fabs(mcharginoj)*mfp*(alphasf2char*betasfp2char*sf2alpha1Ziu*sf2alpha1Zid - alphasfp2char*betasf2char*sf2beta1Ziu*sf2beta1Zid)*rj;
      coupcombo6sfp2sf2 = rj*fabs(mneutralinoi)*mfp*(-betasfp2char*betasf2char*sf2beta1Ziu*sf2alpha1Zid - alphasfp2char*alphasf2char*sf2alpha1Ziu*sf2beta1Zid);
      coupcombo7sfp2sf2 = -fabs(mcharginoj)*mf*(-alphasfp2char*betasf2char*sf2alpha1Ziu*sf2alpha1Zid + betasfp2char*alphasf2char*sf2beta1Ziu*sf2beta1Zid);
    }
    
      

    /*    cout << "Coupling combos for sfp 2 sf 2 interference: " << endl;
    cout << coupcombo1sfp2sf2 << endl;
    cout << "first term: " << 0.5*-sf2alpha1Ziu*sf2beta1Zid*betasfp2char*alphasf2char << " second term: " << 0.5*-sf2beta1Ziu*sf2alpha1Zid*alphasfp2char*betasf2char << endl;
    cout << coupcombo2sfp2sf2 << endl;
    cout << coupcombo3sfp2sf2 << endl;
    cout << coupcombo4sfp2sf2 << endl;
    cout << coupcombo5sfp2sf2 << endl;
    cout << coupcombo6sfp2sf2 << endl;
    cout << coupcombo7sfp2sf2 << endl;
    cout << coupcombo8sfp2sf2 << endl;
    */
    double int1sfp2sf2 = 0, int2sfp2sf2 = 0, int3sfp2sf2 = 0, int4sfp2sf2 = 0, int5sfp2sf2 = 0, int6sfp2sf2 = 0, int7sfp2sf2 = 0, int8sfp2sf2 = 0;
    m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msfp2, m6 = msf2;
    int1sfp2sf2 = 2*fabs(m1)*dgauss(gneuticharjffp1sfp1sf2dgauss,mfp,Eupper,accuracy);
    int2sfp2sf2 = 2*fabs(m1)*dgauss(gneuticharjffp2sfp1sf2dgauss,mfp,Eupper,accuracy);
    int3sfp2sf2 = 2*fabs(m1)*dgauss(gneuticharjffp3sfp1sf2dgauss,mfp,Eupper,accuracy);
    int4sfp2sf2 = 2*fabs(m1)*dgauss(gneuticharjffp4sfp1sf2dgauss,mfp,Eupper,accuracy);
    int5sfp2sf2 = 2*fabs(m1)*dgauss(gneuticharjffp5sfp1sf2dgauss,mfp,Eupper,accuracy);
    int6sfp2sf2 = 2*fabs(m1)*dgauss(gneuticharjffp6sfp1sf2dgauss,mfp,Eupper,accuracy);
    int7sfp2sf2 = 2*fabs(m1)*dgauss(gneuticharjffp7sfp1sf2dgauss,mfp,Eupper,accuracy);
    int8sfp2sf2 = 2*fabs(m1)*dgauss(gneuticharjffp8sfp1sf2dgauss,mfp,Eupper,accuracy);

    /*    cout << "Integrals for sfp 2 sf 2 interference: " << endl;
    cout << int1sfp2sf2 << endl;
    cout << int2sfp2sf2 << endl;
    cout << int3sfp2sf2 << endl;
    cout << int4sfp2sf2 << endl;
    cout << int5sfp2sf2 << endl;
    cout << int6sfp2sf2 << endl;
    cout << int7sfp2sf2 << endl;
    cout << int8sfp2sf2 << endl;

    cout << "Term by term for sfp 2 sf 2 interference: " << endl;
    cout.precision(26);
    cout << coupcombo1sfp2sf2*int1sfp2sf2 << endl;
    cout << coupcombo2sfp2sf2*int2sfp2sf2 << endl;
    cout << coupcombo3sfp2sf2*int3sfp2sf2 << endl;
    cout << coupcombo4sfp2sf2*int4sfp2sf2 << endl;
    cout << coupcombo5sfp2sf2*int5sfp2sf2 << endl;
    cout << coupcombo6sfp2sf2*int6sfp2sf2 << endl;
    cout << coupcombo7sfp2sf2*int7sfp2sf2 << endl;
    cout << coupcombo8sfp2sf2*int8sfp2sf2 << endl;
    */
    Gammasfp2sf2 = coupcombo1sfp2sf2*int1sfp2sf2 + coupcombo2sfp2sf2*int2sfp2sf2 + coupcombo3sfp2sf2*int3sfp2sf2 + coupcombo4sfp2sf2*int4sfp2sf2 + coupcombo5sfp2sf2*int5sfp2sf2 + coupcombo6sfp2sf2*int6sfp2sf2 + coupcombo7sfp2sf2*int7sfp2sf2 + coupcombo8sfp2sf2*int8sfp2sf2;
    //    cout << scientific << "Gammasfp2sf2 = " << Gammasfp2sf2 << endl;


    ///Sfp 2 Sf 1 interference
    
    double coupcombo1sfp2sf1 = 0, coupcombo2sfp2sf1 = 0, coupcombo3sfp2sf1 = 0, coupcombo4sfp2sf1 = 0, coupcombo5sfp2sf1 = 0, coupcombo6sfp2sf1 = 0, coupcombo7sfp2sf1 = 0, coupcombo8sfp2sf1 = 0;
    coupcombo8sfp2sf1 = -2*fabs(mneutralinoi)*fabs(mcharginoj)*mf*mfp*(sf2beta1Ziu*sf1beta1Zid*alphasfp2char*alphasf1char - sf2alpha1Ziu*sf1alpha1Zid*betasfp2char*betasf1char);

    if (norc == 'n') {
      coupcombo1sfp2sf1 = 0.5*(-sf2alpha1Ziu*sf1beta1Zid*betasfp2char*alphasf1char + sf2beta1Ziu*sf1alpha1Zid*alphasfp2char*betasf1char);
      coupcombo2sfp2sf1 = ri*fabs(mneutralinoi)*fabs(mcharginoj)*(sf2alpha1Ziu*sf1alpha1Zid*alphasfp2char*alphasf1char - sf2beta1Ziu*sf1beta1Zid*betasfp2char*betasf1char);
      coupcombo3sfp2sf1 = mf*mfp*(-sf2beta1Ziu*sf1alpha1Zid*betasfp2char*alphasf1char + sf2alpha1Ziu*sf1beta1Zid*alphasfp2char*betasf1char);
      coupcombo4sfp2sf1 = -ri*fabs(mneutralinoi)*mf*(sf2alpha1Ziu*sf1alpha1Zid*betasfp2char*alphasf1char + ri*sf2beta1Ziu*sf1beta1Zid*alphasfp2char*betasf1char);
      coupcombo5sfp2sf1 = mfp*fabs(mcharginoj)*(sf2beta1Ziu*sf1alpha1Zid*alphasfp2char*alphasf1char - sf2alpha1Ziu*sf1beta1Zid*betasfp2char*betasf1char)*rj;
      coupcombo6sfp2sf1 = fabs(mneutralinoi)*mfp*(sf2beta1Ziu*sf1beta1Zid*betasfp2char*alphasf1char + ri*sf2alpha1Ziu*sf1alpha1Zid*alphasfp2char*betasf1char);
      coupcombo7sfp2sf1 = -ri*fabs(mcharginoj)*mf*(sf2alpha1Ziu*sf1beta1Zid*alphasfp2char*alphasf1char + ri*sf2beta1Ziu*sf1alpha1Zid*betasfp2char*betasf1char)*rj;
    }
    else if (norc == 'c') {
      coupcombo1sfp2sf1 = -0.5*(-sf2alpha1Ziu*sf1beta1Zid*betasfp2char*alphasf1char - sf2beta1Ziu*sf1alpha1Zid*alphasfp2char*betasf1char);
      coupcombo2sfp2sf1 = fabs(mneutralinoi)*fabs(mcharginoj)*(sf2alpha1Ziu*sf1alpha1Zid*alphasfp2char*alphasf1char + sf2beta1Ziu*sf1beta1Zid*betasfp2char*betasf1char)*ri;
      coupcombo3sfp2sf1 = mf*mfp*(-sf2beta1Ziu*sf1alpha1Zid*betasfp2char*alphasf1char - sf2alpha1Ziu*sf1beta1Zid*alphasfp2char*betasf1char);
      coupcombo4sfp2sf1 = -fabs(mneutralinoi)*mf*(alphasfp2char*alphasf1char*sf2beta1Ziu*sf1alpha1Zid + betasfp2char*betasf1char*sf2alpha1Ziu*sf1beta1Zid);
      coupcombo5sfp2sf1 = fabs(mcharginoj)*mfp*(alphasf1char*betasfp2char*sf2alpha1Ziu*sf1alpha1Zid + alphasfp2char*betasf1char*sf2beta1Ziu*sf1beta1Zid);
      coupcombo6sfp2sf1 = -fabs(mneutralinoi)*mfp*(-betasfp2char*betasf1char*sf2beta1Ziu*sf1alpha1Zid - alphasfp2char*alphasf1char*sf2alpha1Ziu*sf1beta1Zid);
      coupcombo7sfp2sf1 = fabs(mcharginoj)*mf*(-alphasfp2char*betasf1char*sf2alpha1Ziu*sf1alpha1Zid - betasfp2char*alphasf1char*sf2beta1Ziu*sf1beta1Zid);
    }

    /*    cout << "Coupling combos for sfp 2 sf 1 interference: " << endl;
    cout << coupcombo1sfp2sf1 << endl;
    cout << coupcombo2sfp2sf1 << endl;
    cout << coupcombo3sfp2sf1 << endl;
    cout << coupcombo4sfp2sf1 << endl;
    cout << coupcombo5sfp2sf1 << endl;
    cout << coupcombo6sfp2sf1 << endl;
    cout << coupcombo7sfp2sf1 << endl;
    cout << coupcombo8sfp2sf1 << endl;
    */
    double int1sfp2sf1 = 0, int2sfp2sf1 = 0, int3sfp2sf1 = 0, int4sfp2sf1 = 0, int5sfp2sf1 = 0, int6sfp2sf1 = 0, int7sfp2sf1 = 0, int8sfp2sf1 = 0;
    m1 = mneutralinoi, m2 = mf, m3 = mcharginoj, m4 = mfp, m5 = msfp2, m6 = msf1;
    int1sfp2sf1 = 2*fabs(m1)*dgauss(gneuticharjffp1sfp1sf2dgauss,mfp,Eupper,accuracy);
    int2sfp2sf1 = 2*fabs(m1)*dgauss(gneuticharjffp2sfp1sf2dgauss,mfp,Eupper,accuracy);
    int3sfp2sf1 = 2*fabs(m1)*dgauss(gneuticharjffp3sfp1sf2dgauss,mfp,Eupper,accuracy);
    int4sfp2sf1 = 2*fabs(m1)*dgauss(gneuticharjffp4sfp1sf2dgauss,mfp,Eupper,accuracy);
    int5sfp2sf1 = 2*fabs(m1)*dgauss(gneuticharjffp5sfp1sf2dgauss,mfp,Eupper,accuracy);
    int6sfp2sf1 = 2*fabs(m1)*dgauss(gneuticharjffp6sfp1sf2dgauss,mfp,Eupper,accuracy);
    int7sfp2sf1 = 2*fabs(m1)*dgauss(gneuticharjffp7sfp1sf2dgauss,mfp,Eupper,accuracy);
    int8sfp2sf1 = 2*fabs(m1)*dgauss(gneuticharjffp8sfp1sf2dgauss,mfp,Eupper,accuracy);

    /*    cout << "Integrals for sfp 2 sf 1 interference: " << endl;
    cout << int1sfp2sf1 << endl;
    cout << int2sfp2sf1 << endl;
    cout << int3sfp2sf1 << endl;
    cout << int4sfp2sf1 << endl;
    cout << int5sfp2sf1 << endl;
    cout << int6sfp2sf1 << endl;
    cout << int7sfp2sf1 << endl;
    cout << int8sfp2sf1 << endl;

    cout << "Term by term for sfp 2 sf 1 interference: " << endl;
    cout.precision(26);
    cout << coupcombo1sfp2sf1*int1sfp2sf1 << endl;
    cout << coupcombo2sfp2sf1*int2sfp2sf1 << endl;
    cout << coupcombo3sfp2sf1*int3sfp2sf1 << endl;
    cout << coupcombo4sfp2sf1*int4sfp2sf1 << endl;
    cout << coupcombo5sfp2sf1*int5sfp2sf1 << endl;
    cout << coupcombo6sfp2sf1*int6sfp2sf1 << endl;
    cout << coupcombo7sfp2sf1*int7sfp2sf1 << endl;
    cout << coupcombo8sfp2sf1*int8sfp2sf1 << endl;
    */
    Gammasfp2sf1 = coupcombo1sfp2sf1*int1sfp2sf1 + coupcombo2sfp2sf1*int2sfp2sf1 + coupcombo3sfp2sf1*int3sfp2sf1 + coupcombo4sfp2sf1*int4sfp2sf1 + coupcombo5sfp2sf1*int5sfp2sf1 + coupcombo6sfp2sf1*int6sfp2sf1 + coupcombo7sfp2sf1*int7sfp2sf1 + coupcombo8sfp2sf1*int8sfp2sf1;
    cout << scientific << "Gammasfp2sf1 = " << Gammasfp2sf1 << endl;


    ///W-Hpm interference
    double coupcombo1WHpm = 0, coupcombo2WHpm = 0, coupcombo3WHpm = 0, coupcombo4WHpm = 0;
    coupcombo1WHpm = (charneutWcoupR*coupHpm2charneutR + charneutWcoupL*coupHpm2charneutL)*-g/(pow(2,0.5))*coupHpm2ffpu*fabs(mcharginoj)*mfp*rc;
    coupcombo2WHpm = (charneutWcoupL*coupHpm2charneutR + charneutWcoupR*coupHpm2charneutL)*g/(pow(2,0.5))*-coupHpm2ffpd*fabs(mneutralinoi)*-mf*ri*rc*rj;
    coupcombo3WHpm = (charneutWcoupR*coupHpm2charneutR + charneutWcoupL*coupHpm2charneutL)*g/(pow(2,0.5))*-coupHpm2ffpd*fabs(mcharginoj)*-mf*rc;
    coupcombo4WHpm = (charneutWcoupL*coupHpm2charneutR + charneutWcoupR*coupHpm2charneutL)*-g/(pow(2,0.5))*coupHpm2ffpu*fabs(mneutralinoi)*mfp*ri*rc*rj;
    
    /*    cout << "Coupling combos for W Hpm interference: " << endl;
    cout.precision(12);
    cout << coupcombo1WHpm << endl;
    cout << coupcombo2WHpm << endl;
    cout << coupcombo3WHpm << endl;
    cout << coupcombo4WHpm << endl;
    cout << "1 first bit: " << charneutWcoupR*coupHpmcharneutR << " 1 second bit: " << charneutWcoupL*coupHpmcharneutL << " 1 third bit: " << -g/(pow(2,0.5))*coupHpm1ffpu << " 1 postfactor: " << fabs(mcharginoj)*mfp << endl;
    */
    double int1WHpm = 0, int2WHpm = 0, int3WHpm = 0, int4WHpm = 0;
    double Eupper3 = 0;
    Eupper3 = 1/(2*fabs(mneutralinoi))*(pow(mneutralinoi,2) + pow(mcharginoj,2) - pow(mf,2) - pow(mfp,2) - 2*mf*mfp);
    m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mWboson, m6 = mHP;
    int1WHpm = 2*fabs(m1)*dgauss(gneuticharjffp1WHpmdgauss,fabs(mcharginoj), Eupper3, accuracy);
    int2WHpm = 2*fabs(m1)*dgauss(gneuticharjffp2WHpmdgauss,fabs(mcharginoj), Eupper3, accuracy);
    int3WHpm = 2*fabs(m1)*dgauss(gneuticharjffp3WHpmdgauss,fabs(mcharginoj), Eupper3, accuracy);
    int4WHpm = 2*fabs(m1)*dgauss(gneuticharjffp4WHpmdgauss,fabs(mcharginoj), Eupper3, accuracy);

    /*    cout << "Integrals for W Hpm interference: " << endl;
    cout << int1WHpm << endl;
    cout << int2WHpm << endl;
    cout << int3WHpm << endl;
    cout << int4WHpm << endl;

    cout << "Term by term for W Hpm interference: " << endl;
    cout.precision(16);
    cout << coupcombo1WHpm*int1WHpm << endl;
    cout << coupcombo2WHpm*int2WHpm << endl;
    cout << coupcombo3WHpm*int3WHpm << endl;
    cout << coupcombo4WHpm*int4WHpm << endl;
    */
    GammaWHpm = coupcombo1WHpm*int1WHpm + coupcombo2WHpm*int2WHpm + coupcombo3WHpm*int3WHpm + coupcombo4WHpm*int4WHpm;
    cout << scientific << "GammaWHpm = " << GammaWHpm << endl;

    ///W-goldstone interference
    double coupcombo1Wg = 0, coupcombo2Wg = 0, coupcombo3Wg = 0, coupcombo4Wg = 0;
    coupcombo1Wg = (charneutWcoupR*coupHpm1charneutR + charneutWcoupL*coupHpm1charneutL)*-g/(pow(2,0.5))*coupHpm1ffpu*fabs(mcharginoj)*mfp*rc;
    coupcombo2Wg = (charneutWcoupL*coupHpm1charneutR + charneutWcoupR*coupHpm1charneutL)*g/(pow(2,0.5))*-coupHpm1ffpd*fabs(mneutralinoi)*-mf*ri*rc*rj;
    coupcombo3Wg = (charneutWcoupR*coupHpm1charneutR + charneutWcoupL*coupHpm1charneutL)*g/(pow(2,0.5))*-coupHpm1ffpd*fabs(mcharginoj)*-mf*rc;
    coupcombo4Wg = (charneutWcoupL*coupHpm1charneutR + charneutWcoupR*coupHpm1charneutL)*-g/(pow(2,0.5))*coupHpm1ffpu*fabs(mneutralinoi)*mfp*ri*rc*rj;
    
    /*    cout << "Coupling combos for W goldstone interference: " << endl;
    cout.precision(12);
    cout << coupcombo1Wg << endl;
    cout << coupcombo2Wg << endl;
    cout << coupcombo3Wg << endl;
    cout << coupcombo4Wg << endl;
    */
    double int1Wg = 0, int2Wg = 0, int3Wg = 0, int4Wg = 0;
    Eupper3 = 1/(2*fabs(mneutralinoi))*(pow(mneutralinoi,2) + pow(mcharginoj,2) - pow(mf,2) - pow(mfp,2) - 2*mf*mfp);
    m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mWboson, m6 = mWboson;
    int1Wg = 2*fabs(m1)*dgauss(gneuticharjffp1WHpmdgauss,fabs(mcharginoj), Eupper3, accuracy);
    int2Wg = 2*fabs(m1)*dgauss(gneuticharjffp2WHpmdgauss,fabs(mcharginoj), Eupper3, accuracy);
    int3Wg = 2*fabs(m1)*dgauss(gneuticharjffp3WHpmdgauss,fabs(mcharginoj), Eupper3, accuracy);
    int4Wg = 2*fabs(m1)*dgauss(gneuticharjffp4WHpmdgauss,fabs(mcharginoj), Eupper3, accuracy);

    /*    cout << "Integrals for W goldstone interference: " << endl;
    cout << int1Wg << endl;
    cout << int2Wg << endl;
    cout << int3Wg << endl;
    cout << int4Wg << endl;

    cout << "Term by term for W goldstone interference: " << endl;
    cout.precision(16);
    cout << coupcombo1Wg*int1Wg << endl;
    cout << coupcombo2Wg*int2Wg << endl;
    cout << coupcombo3Wg*int3Wg << endl;
    cout << coupcombo4Wg*int4Wg << endl;
    */
    GammaWgoldstone = coupcombo1Wg*int1Wg + coupcombo2Wg*int2Wg + coupcombo3Wg*int3Wg + coupcombo4Wg*int4Wg;
    cout << scientific << "GammaWgoldstone = " << GammaWgoldstone << endl;

    cout << "g = " << g << " -g/sqrt(2) = " << -g/pow(2,0.5) << endl;
    
    ///W Sfp 1 interference
    double coupcombo1Wsfp1 = 0, coupcombo2Wsfp1 = 0, coupcombo3Wsfp1 = 0, coupcombo4Wsfp1 = 0, coupcombo5Wsfp1 = 0, coupcombo6Wsfp1 = 0, coupcombo7Wsfp1 = 0, coupcombo8Wsfp1 = 0;
    coupcombo1Wsfp1 = 2*charneutWcoupL*sf1alpha1Ziu*-g/(pow(2,0.5))*betasfp1char*fabs(mneutralinoi)*mf;
    coupcombo2Wsfp1 = -2*charneutWcoupL*-sf1beta1Ziu*g/(pow(2,0.5))*alphasfp1char*mfp*fabs(mcharginoj);
    coupcombo3Wsfp1 = -2*charneutWcoupR*sf1alpha1Ziu*g/(pow(2,0.5))*alphasfp1char*-ri*rc*rj;
    coupcombo4Wsfp1 = -ri*4*charneutWcoupR*sf1beta1Ziu*g/(pow(2,0.5))*alphasfp1char*fabs(mneutralinoi)*mfp*rj;
    coupcombo5Wsfp1 = -4*charneutWcoupR*sf1alpha1Ziu*g/(pow(2,0.5))*betasfp1char*mf*fabs(mcharginoj)*rj*-ri;
    coupcombo6Wsfp1 = 2*charneutWcoupL*sf1alpha1Ziu*g/(pow(2,0.5))*alphasfp1char*fabs(mneutralinoi)*fabs(mcharginoj)*-rc;
    coupcombo7Wsfp1 = -2*charneutWcoupL*sf1beta1Ziu*g/(pow(2,0.5))*betasfp1char*mfp*mf*-rc;
    coupcombo8Wsfp1 = 8*charneutWcoupR*sf1beta1Ziu*g/(pow(2,0.5))*betasfp1char*fabs(mneutralinoi)*mfp*mf*fabs(mcharginoj)*rj*-rc*ri;
    
    cout << "Coupling combos for W Sfp 1 interference: " << endl;
    cout << coupcombo1Wsfp1 << endl;
    cout << coupcombo2Wsfp1 << endl;
    cout << coupcombo3Wsfp1 << endl;
    cout << coupcombo4Wsfp1 << endl;
    cout << coupcombo5Wsfp1 << endl;
    cout << coupcombo6Wsfp1 << endl;
    cout << coupcombo7Wsfp1 << endl;
    cout << coupcombo8Wsfp1 << endl;
    cout << "first part " << 8*charneutWcoupR*sf1beta1Ziu << " second part " << g/(pow(2,0.5))*betasfp1char << " third part " << fabs(mneutralinoi)*mfp*mf*fabs(mcharginoj) << endl;

    double intW1Sfp1 = 0, intW2Sfp1 = 0, intW3Sfp1 = 0, intW4Sfp1 = 0, intW5Sfp1 = 0, intW6Sfp1 = 0, intW7Sfp1 = 0, intW8Sfp1 = 0;
    m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp1;
    intW1Sfp1 = 2*fabs(m1)*dgauss(gneuticharjffpW1Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW2Sfp1 = 2*fabs(m1)*dgauss(gneuticharjffpW2Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW3Sfp1 = 2*fabs(m1)*dgauss(gneuticharjffpW3Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW4Sfp1 = 2*fabs(m1)*dgauss(gneuticharjffpW4Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW5Sfp1 = 2*fabs(m1)*dgauss(gneuticharjffpW5Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW6Sfp1 = 2*fabs(m1)*dgauss(gneuticharjffpW6Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW7Sfp1 = 2*fabs(m1)*dgauss(gneuticharjffpW7Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW8Sfp1 = 2*fabs(m1)*dgauss(gneuticharjffpW8Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);

    cout << "Integrals for W Sfp1" << endl;
    cout << "intW1Sfp1 = " << intW1Sfp1 << endl;
    cout << "intW2Sfp1 = " << intW2Sfp1 << endl;
    cout << "intW3Sfp1 = " << intW3Sfp1 << endl;
    cout << "intW4Sfp1 = " << intW4Sfp1 << endl;
    cout << "intW5Sfp1 = " << intW5Sfp1 << endl;
    cout << "intW6Sfp1 = " << intW6Sfp1 << endl;
    cout << "intW7Sfp1 = " << intW7Sfp1 << endl;
    cout << "intW8Sfp1 = " << intW8Sfp1 << endl;

    cout << "W Sfp 1 interference: " << endl;
    cout << coupcombo1Wsfp1*intW1Sfp1 << endl;
    cout << coupcombo2Wsfp1*intW2Sfp1 << endl;
    cout << coupcombo3Wsfp1*intW3Sfp1 << endl;
    cout << coupcombo4Wsfp1*intW4Sfp1 << endl;
    cout << coupcombo5Wsfp1*intW5Sfp1 << endl;
    cout << coupcombo6Wsfp1*intW6Sfp1 << endl;
    cout << coupcombo7Wsfp1*intW7Sfp1 << endl;
    cout << coupcombo8Wsfp1*intW8Sfp1 << endl;

    GammaWSfp1 = coupcombo1Wsfp1*intW1Sfp1 + coupcombo2Wsfp1*intW2Sfp1 + coupcombo3Wsfp1*intW3Sfp1 + coupcombo4Wsfp1*intW4Sfp1 + coupcombo5Wsfp1*intW5Sfp1 + coupcombo6Wsfp1*intW6Sfp1 + coupcombo7Wsfp1*intW7Sfp1 + coupcombo8Wsfp1*intW8Sfp1;

    cout << scientific << "GammaWSfp1 = " << GammaWSfp1 << endl;

    

    /// W Sfp 2 interference
    double coupcombo1Wsfp2 = 0, coupcombo2Wsfp2 = 0, coupcombo3Wsfp2 = 0, coupcombo4Wsfp2 = 0, coupcombo5Wsfp2 = 0, coupcombo6Wsfp2 = 0, coupcombo7Wsfp2 = 0, coupcombo8Wsfp2 = 0;
    coupcombo1Wsfp2 = -2*charneutWcoupL*sf2alpha1Ziu*-g/(pow(2,0.5))*betasfp2char*fabs(mneutralinoi)*-mf*rj;
    coupcombo2Wsfp2 = -ri*2*charneutWcoupL*-sf2beta1Ziu*g/(pow(2,0.5))*alphasfp2char*mfp*fabs(mcharginoj)*rj;
    coupcombo3Wsfp2 = -2*charneutWcoupR*sf2alpha1Ziu*g/(pow(2,0.5))*alphasfp2char*rc*ri;
    coupcombo4Wsfp2 = -4*charneutWcoupR*sf2beta1Ziu*g/(pow(2,0.5))*alphasfp2char*fabs(mneutralinoi)*mfp;
    coupcombo5Wsfp2 = 4*charneutWcoupR*sf2alpha1Ziu*g/(pow(2,0.5))*betasfp2char*mf*fabs(mcharginoj)*ri;
    coupcombo6Wsfp2 = 2*charneutWcoupL*sf2alpha1Ziu*g/(pow(2,0.5))*alphasfp2char*fabs(mneutralinoi)*fabs(mcharginoj)*rj*rc;
    coupcombo7Wsfp2 = 2*charneutWcoupL*sf2beta1Ziu*g/(pow(2,0.5))*betasfp2char*mfp*mf*rj*-ri*rc;
    coupcombo8Wsfp2 = 8*charneutWcoupR*sf2beta1Ziu*g/(pow(2,0.5))*betasfp2char*fabs(mneutralinoi)*mfp*mf*fabs(mcharginoj)*rc;
    
    cout << "Coupling combos for W Sfp 2 interference: " << endl;
    cout << coupcombo1Wsfp2 << endl;
    cout << coupcombo2Wsfp2 << endl;
    cout << coupcombo3Wsfp2 << endl;
    cout << coupcombo4Wsfp2 << endl;
    cout << coupcombo5Wsfp2 << endl;
    cout << coupcombo6Wsfp2 << endl;
    cout << coupcombo7Wsfp2 << endl;
    cout << coupcombo8Wsfp2 << endl;

    double intW1Sfp2 = 0, intW2Sfp2 = 0, intW3Sfp2 = 0, intW4Sfp2 = 0, intW5Sfp2 = 0, intW6Sfp2 = 0, intW7Sfp2 = 0, intW8Sfp2 = 0;
    m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp2;
    intW1Sfp2 = 2*fabs(m1)*dgauss(gneuticharjffpW1Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW2Sfp2 = 2*fabs(m1)*dgauss(gneuticharjffpW2Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW3Sfp2 = 2*fabs(m1)*dgauss(gneuticharjffpW3Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW4Sfp2 = 2*fabs(m1)*dgauss(gneuticharjffpW4Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW5Sfp2 = 2*fabs(m1)*dgauss(gneuticharjffpW5Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW6Sfp2 = 2*fabs(m1)*dgauss(gneuticharjffpW6Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW7Sfp2 = 2*fabs(m1)*dgauss(gneuticharjffpW7Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW8Sfp2 = 2*fabs(m1)*dgauss(gneuticharjffpW8Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);

    cout << "Integrals for W Sfp2" << endl;
    cout << "intW1Sfp2 = " << intW1Sfp2 << endl;
    cout << "intW2Sfp2 = " << intW2Sfp2 << endl;
    cout << "intW3Sfp2 = " << intW3Sfp2 << endl;
    cout << "intW4Sfp2 = " << intW4Sfp2 << endl;
    cout << "intW5Sfp2 = " << intW5Sfp2 << endl;
    cout << "intW6Sfp2 = " << intW6Sfp2 << endl;
    cout << "intW7Sfp2 = " << intW7Sfp2 << endl;
    cout << "intW8Sfp2 = " << intW8Sfp2 << endl;

    cout << "W Sfp 2 interference: " << endl;
    cout << coupcombo1Wsfp2*intW1Sfp2 << endl;
    cout << coupcombo2Wsfp2*intW2Sfp2 << endl;
    cout << coupcombo3Wsfp2*intW3Sfp2 << endl;
    cout << coupcombo4Wsfp2*intW4Sfp2 << endl;
    cout << coupcombo5Wsfp2*intW5Sfp2 << endl;
    cout << coupcombo6Wsfp2*intW6Sfp2 << endl;
    cout << coupcombo7Wsfp2*intW7Sfp2 << endl;
    cout << coupcombo8Wsfp2*intW8Sfp2 << endl;

    GammaWSfp2 = coupcombo1Wsfp2*intW1Sfp2 + coupcombo2Wsfp2*intW2Sfp2 + coupcombo3Wsfp2*intW3Sfp2 + coupcombo4Wsfp2*intW4Sfp2 + coupcombo5Wsfp2*intW5Sfp2 + coupcombo6Wsfp2*intW6Sfp2 + coupcombo7Wsfp2*intW7Sfp2 + coupcombo8Wsfp2*intW8Sfp2;

    cout << scientific << "GammaWSfp2 = " << GammaWSfp2 << endl;


    ///W Sf1 interference
    double coupcombo1Wsf1 = 0, coupcombo2Wsf1 = 0, coupcombo3Wsf1 = 0, coupcombo4Wsf1 = 0, coupcombo5Wsf1 = 0, coupcombo6Wsf1 = 0, coupcombo7Wsf1 = 0, coupcombo8Wsf1 = 0;

    coupcombo6Wsf1 = 2*charneutWcoupR*sf1alpha1Zid*g/(pow(2,0.5))*alphasf1char*fabs(mneutralinoi)*fabs(mcharginoj)*-rc;
    coupcombo7Wsf1 = 2*charneutWcoupR*sf1beta1Zid*g/(pow(2,0.5))*betasf1char*mf*mfp*rc;
    coupcombo8Wsf1 = 8*charneutWcoupL*sf1beta1Zid*g/(pow(2,0.5))*betasf1char*fabs(mneutralinoi)*mf*mfp*fabs(mcharginoj)*rj*-ri*rc;
    if (norc == 'n') {
      coupcombo1Wsf1 = -2*charneutWcoupR*sf1alpha1Zid*-g/(pow(2,0.5))*betasf1char*fabs(mneutralinoi)*-mfp;
      coupcombo2Wsf1 = -2*charneutWcoupR*-sf1beta1Zid*g/(pow(2,0.5))*alphasf1char*mf*fabs(mcharginoj)*rj;
      coupcombo3Wsf1 = 2*charneutWcoupR*sf1alpha1Zid*g/(pow(2,0.5))*alphasf1char;
      coupcombo4Wsf1 = -ri*4*charneutWcoupL*sf1beta1Zid*g/(pow(2,0.5))*alphasf1char*fabs(mneutralinoi)*mf;
      coupcombo5Wsf1 = ri*4*charneutWcoupL*sf1alpha1Zid*g/(pow(2,0.5))*betasf1char*mfp*fabs(mcharginoj)*rj;
    }
    else if (norc == 'c') {
      coupcombo1Wsf1 = 2*charneutWcoupR*alphasf1char*-g/pow(2,0.5)*sf1beta1Zid*fabs(mneutralinoi)*-mfp*ri;
      coupcombo2Wsf1 = 2*charneutWcoupR*betasf1char*-g/pow(2,0.5)*sf1alpha1Zid*mf*fabs(mcharginoj);
      coupcombo3Wsf1 = 2*charneutWcoupL*alphasf1char*-g/pow(2,0.5)*sf1alpha1Zid*ri*rj;
      coupcombo4Wsf1 = -4*charneutWcoupL*betasf1char*-g/pow(2,0.5)*sf1alpha1Zid*fabs(mneutralinoi)*mf*ri*rj;
      coupcombo5Wsf1 = -4*charneutWcoupL*alphasf1char*g/pow(2,0.5)*sf1beta1Zid*mfp*fabs(mcharginoj)*rj;
    }
    

    cout << "Coupling combos for W Sf1 interference: " << endl;
    cout << coupcombo1Wsf1 << endl;
    cout << coupcombo2Wsf1 << endl;
    cout << coupcombo3Wsf1 << endl;
    cout << coupcombo4Wsf1 << endl;
    cout << coupcombo5Wsf1 << endl;
    cout << coupcombo6Wsf1 << endl;
    cout << coupcombo7Wsf1 << endl;
    cout << coupcombo8Wsf1 << endl;

    double intW1Sf1 = 0, intW2Sf1 = 0, intW3Sf1 = 0, intW4Sf1 = 0, intW5Sf1 = 0, intW6Sf1 = 0, intW7Sf1 = 0, intW8Sf1 = 0;
    m1 = mneutralinoi, m2 = mf, m3 = mfp, m4 = mcharginoj, m5 = mWboson, m6 = msf1;
    intW1Sf1 = 2*fabs(m1)*dgauss(gneuticharjffpW1Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW2Sf1 = 2*fabs(m1)*dgauss(gneuticharjffpW2Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW3Sf1 = 2*fabs(m1)*dgauss(gneuticharjffpW3Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW4Sf1 = 2*fabs(m1)*dgauss(gneuticharjffpW4Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW5Sf1 = 2*fabs(m1)*dgauss(gneuticharjffpW5Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW6Sf1 = 2*fabs(m1)*dgauss(gneuticharjffpW6Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW7Sf1 = 2*fabs(m1)*dgauss(gneuticharjffpW7Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW8Sf1 = 2*fabs(m1)*dgauss(gneuticharjffpW8Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);

    cout << "Integrals for W Sf1" << endl;
    cout << "intW1Sf1 = " << intW1Sf1 << endl;
    cout << "intW2Sf1 = " << intW2Sf1 << endl;
    cout << "intW3Sf1 = " << intW3Sf1 << endl;
    cout << "intW4Sf1 = " << intW4Sf1 << endl;
    cout << "intW5Sf1 = " << intW5Sf1 << endl;
    cout << "intW6Sf1 = " << intW6Sf1 << endl;
    cout << "intW7Sf1 = " << intW7Sf1 << endl;
    cout << "intW8Sf1 = " << intW8Sf1 << endl;

    cout << "W Sf 1 interference: " << endl;
    cout << coupcombo1Wsf1*intW1Sf1 << endl;
    cout << coupcombo2Wsf1*intW2Sf1 << endl;
    cout << coupcombo3Wsf1*intW3Sf1 << endl;
    cout << coupcombo4Wsf1*intW4Sf1 << endl;
    cout << coupcombo5Wsf1*intW5Sf1 << endl;
    cout << coupcombo6Wsf1*intW6Sf1 << endl;
    cout << coupcombo7Wsf1*intW7Sf1 << endl;
    cout << coupcombo8Wsf1*intW8Sf1 << endl;

    GammaWSf1 = coupcombo1Wsf1*intW1Sf1 + coupcombo2Wsf1*intW2Sf1 + coupcombo3Wsf1*intW3Sf1 + coupcombo4Wsf1*intW4Sf1 + coupcombo5Wsf1*intW5Sf1 + coupcombo6Wsf1*intW6Sf1 + coupcombo7Wsf1*intW7Sf1 + coupcombo8Wsf1*intW8Sf1;

    cout << scientific << "GammaWSf1 = " << GammaWSf1 << endl;

    ///W Sf2 interference
    double coupcombo1Wsf2 = 0, coupcombo2Wsf2 = 0, coupcombo3Wsf2 = 0, coupcombo4Wsf2 = 0, coupcombo5Wsf2 = 0, coupcombo6Wsf2 = 0, coupcombo7Wsf2 = 0, coupcombo8Wsf2 = 0;
    coupcombo6Wsf2 = 2*charneutWcoupR*sf2alpha1Zid*g/(pow(2,0.5))*alphasf2char*fabs(mneutralinoi)*fabs(mcharginoj)*-ri;
    coupcombo7Wsf2 = -2*charneutWcoupR*sf2beta1Zid*g/(pow(2,0.5))*betasf2char*mf*mfp*rj*-ri;
    coupcombo8Wsf2 = -8*charneutWcoupL*sf2beta1Zid*g/(pow(2,0.5))*betasf2char*fabs(mneutralinoi)*mf*mfp*fabs(mcharginoj);
    if (norc == 'n') {
      coupcombo1Wsf2 = 2*charneutWcoupR*sf2alpha1Zid*-g/(pow(2,0.5))*betasf2char*fabs(mneutralinoi)*-mfp*ri;
      coupcombo2Wsf2 = 2*charneutWcoupR*-sf2beta1Zid*g/(pow(2,0.5))*alphasf2char*mf*fabs(mcharginoj)*rj*ri;
      coupcombo3Wsf2 = 2*charneutWcoupR*sf2alpha1Zid*g/(pow(2,0.5))*alphasf2char*ri;
      coupcombo4Wsf2 = 4*charneutWcoupL*sf2beta1Zid*g/(pow(2,0.5))*alphasf2char*fabs(mneutralinoi)*mf;
      coupcombo5Wsf2 = -4*charneutWcoupL*sf2alpha1Zid*g/(pow(2,0.5))*betasf2char*mfp*fabs(mcharginoj)*rj;
    }
    else if (norc == 'c') {
      coupcombo1Wsf2 = 2*charneutWcoupR*alphasf2char*-g/pow(2,0.5)*sf2beta1Zid*fabs(mneutralinoi)*-mfp*ri;
      coupcombo2Wsf2 = 2*charneutWcoupR*betasf2char*-g/pow(2,0.5)*sf2alpha1Zid*mf*fabs(mcharginoj)*rj;
      coupcombo3Wsf2 = -2*charneutWcoupL*alphasf2char*-g/pow(2,0.5)*sf2alpha1Zid*ri*rj;
      coupcombo4Wsf2 = -4*charneutWcoupL*betasf2char*-g/pow(2,0.5)*sf2alpha1Zid*fabs(mneutralinoi)*mf*ri;
      coupcombo5Wsf2 = -4*charneutWcoupL*alphasf2char*g/pow(2,0.5)*sf2beta1Zid*mfp*fabs(mcharginoj)*rj;
    }

    cout << "Coupling combos for W Sf2 interference: " << endl;
    cout << coupcombo1Wsf2 << endl;
    cout << coupcombo2Wsf2 << endl;
    cout << coupcombo3Wsf2 << endl;
    cout << coupcombo4Wsf2 << endl;
    cout << coupcombo5Wsf2 << endl;
    cout << coupcombo6Wsf2 << endl;
    cout << coupcombo7Wsf2 << endl;
    cout << coupcombo8Wsf2 << endl;

    double intW1Sf2 = 0, intW2Sf2 = 0, intW3Sf2 = 0, intW4Sf2 = 0, intW5Sf2 = 0, intW6Sf2 = 0, intW7Sf2 = 0, intW8Sf2 = 0;
    m1 = mneutralinoi, m2 = mf, m3 = mfp, m4 = mcharginoj, m5 = mWboson, m6 = msf2;
    intW1Sf2 = 2*fabs(m1)*dgauss(gneuticharjffpW1Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW2Sf2 = 2*fabs(m1)*dgauss(gneuticharjffpW2Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW3Sf2 = 2*fabs(m1)*dgauss(gneuticharjffpW3Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW4Sf2 = 2*fabs(m1)*dgauss(gneuticharjffpW4Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW5Sf2 = 2*fabs(m1)*dgauss(gneuticharjffpW5Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW6Sf2 = 2*fabs(m1)*dgauss(gneuticharjffpW6Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW7Sf2 = 2*fabs(m1)*dgauss(gneuticharjffpW7Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    intW8Sf2 = 2*fabs(m1)*dgauss(gneuticharjffpW8Sfpdgauss,fabs(mcharginoj),Eupper3,accuracy);

    cout << "Integrals for W Sf2" << endl;
    cout << "intW1Sf2 = " << intW1Sf2 << endl;
    cout << "intW2Sf2 = " << intW2Sf2 << endl;
    cout << "intW3Sf2 = " << intW3Sf2 << endl;
    cout << "intW4Sf2 = " << intW4Sf2 << endl;
    cout << "intW5Sf2 = " << intW5Sf2 << endl;
    cout << "intW6Sf2 = " << intW6Sf2 << endl;
    cout << "intW7Sf2 = " << intW7Sf2 << endl;
    cout << "intW8Sf2 = " << intW8Sf2 << endl;

    cout << "W Sf 2 interference: " << endl;
    cout.precision(20);
    cout << coupcombo1Wsf2*intW1Sf2 << endl;
    cout << coupcombo2Wsf2*intW2Sf2 << endl;
    cout << coupcombo3Wsf2*intW3Sf2 << endl;
    cout << coupcombo4Wsf2*intW4Sf2 << endl;
    cout << coupcombo5Wsf2*intW5Sf2 << endl;
    cout << coupcombo6Wsf2*intW6Sf2 << endl;
    cout << coupcombo7Wsf2*intW7Sf2 << endl;
    cout << coupcombo8Wsf2*intW8Sf2 << endl;

    GammaWSf2 = coupcombo1Wsf2*intW1Sf2 + coupcombo2Wsf2*intW2Sf2 + coupcombo3Wsf2*intW3Sf2 + coupcombo4Wsf2*intW4Sf2 + coupcombo5Wsf2*intW5Sf2 + coupcombo6Wsf2*intW6Sf2 + coupcombo7Wsf2*intW7Sf2 + coupcombo8Wsf2*intW8Sf2;

    cout << scientific << "GammaWSf2 = " << GammaWSf2 << endl;


    ///H+ goldstone interference
    double coupcombo1Hg = 0, coupcombo2Hg = 0, coupcombo3Hg = 0, coupcombo4Hg = 0;
    coupcombo1Hg = coupHpm1charneutL*coupHpm2charneutL + coupHpm1charneutR*coupHpm2charneutR;
    coupcombo2Hg = (coupHpm1charneutR*coupHpm2charneutL + coupHpm1charneutL*coupHpm2charneutR)*ri*rj;
    coupcombo3Hg = coupHpm1ffpu*coupHpm2ffpu + coupHpm1ffpd*coupHpm2ffpd;
    coupcombo4Hg = coupHpm1ffpd*coupHpm2ffpu + coupHpm1ffpu*coupHpm2ffpd;

    /*    cout << "Coupling combos for H+ goldstone interference:" << endl;
    cout << "coupcombo1Hg = " << coupcombo1Hg << endl;
    cout << "first term = " << coupHpm1charneutL*coupHpm2charneutL << "second term = " << coupHpm1charneutR*coupHpm2charneutR << endl;
    cout << "coupcombo2Hg = " << coupcombo2Hg << endl;
    cout << "coupcombo3Hg = " << coupcombo3Hg << endl;
    cout << "coupcombo4Hg = " << coupcombo4Hg << endl;
    */
    double int1Hg = 0, int2Hg = 0, int3Hg = 0, int4Hg = 0;
    m1 = mneutralinoi, m2 = mcharginoj, m3 = mf, m4 = mfp, m5 = mWboson, m6 = mHP;
    int1Hg = 2*fabs(m1)*dgauss(gneuticharjffpHg1dgauss,fabs(mcharginoj),Eupper3,accuracy);
    int2Hg = 2*fabs(m1)*dgauss(gneuticharjffpHg2dgauss,fabs(mcharginoj),Eupper3,accuracy);
    int3Hg = 2*fabs(m1)*dgauss(gneuticharjffpHg3dgauss,fabs(mcharginoj),Eupper3,accuracy);
    int4Hg = 2*fabs(m1)*dgauss(gneuticharjffpHg4dgauss,fabs(mcharginoj),Eupper3,accuracy);

    cout << "Integrals for H+ goldstone interference: " << endl;
    cout << "int1Hg = " << int1Hg << endl;
    cout << "int2Hg = " << int2Hg << endl;
    cout << "int3Hg = " << int3Hg << endl;
    cout << "int4Hg = " << int4Hg << endl;

    cout << "term by term for H+ goldstone interference: " << endl;
    cout << coupcombo1Hg*coupcombo3Hg*int4Hg << endl;
    cout << -2*coupcombo1Hg*coupcombo4Hg*mf*mfp*int3Hg << endl;
    cout << 2*coupcombo2Hg*coupcombo3Hg*fabs(mneutralinoi)*fabs(mcharginoj)*int2Hg << endl;
    cout << -4*coupcombo2Hg*coupcombo4Hg*fabs(mneutralinoi)*fabs(mcharginoj)*mf*mfp*int1Hg << endl;

    GammaHgoldstone = coupcombo1Hg*coupcombo3Hg*int4Hg - 2*coupcombo1Hg*coupcombo4Hg*mf*mfp*int3Hg + 2*coupcombo2Hg*coupcombo3Hg*fabs(mneutralinoi)*fabs(mcharginoj)*int2Hg - 4*coupcombo2Hg*coupcombo4Hg*fabs(mneutralinoi)*fabs(mcharginoj)*mf*mfp*int1Hg*rj;

    cout << scientific << "GammaHgoldstone = " << GammaHgoldstone << endl;

    
    ///goldstone - sfp1 interference
    double coupcombo1gsfp1 = 0, coupcombo2gsfp1 = 0, coupcombo3gsfp1 = 0, coupcombo4gsfp1 = 0, coupcombo5gsfp1 = 0, coupcombo6gsfp1 = 0, coupcombo7gsfp1 = 0, coupcombo8gsfp1 = 0; 
    if (norc == 'n') {
      coupcombo1gsfp1 = -0.5*(coupHpm1charneutR*sf1alpha1Ziu*coupHpm1ffpd*betasfp1char + coupHpm1charneutL*sf1beta1Ziu*coupHpm1ffpu*alphasfp1char);
      coupcombo2gsfp1 = (coupHpm1charneutR*sf1beta1Ziu*coupHpm1ffpu*betasfp1char + coupHpm1charneutL*sf1alpha1Ziu*coupHpm1ffpd*alphasfp1char)*fabs(mneutralinoi)*-mf;
      coupcombo3gsfp1 = (coupHpm1charneutL*-sf1beta1Ziu*coupHpm1ffpd*betasfp1char - coupHpm1charneutR*sf1alpha1Ziu*coupHpm1ffpu*alphasfp1char)*mfp*fabs(mcharginoj)*-ri;
      coupcombo4gsfp1 = (coupHpm1charneutR*-sf1beta1Ziu*coupHpm1ffpd*betasfp1char + coupHpm1charneutL*sf1alpha1Ziu*coupHpm1ffpu*-alphasfp1char)*fabs(mneutralinoi)*-mfp;
      coupcombo5gsfp1 = -(coupHpm1charneutL*sf1beta1Ziu*coupHpm1ffpu*betasfp1char + ri*coupHpm1charneutR*sf1alpha1Ziu*coupHpm1ffpd*alphasfp1char)*mf*fabs(mcharginoj);
      coupcombo6gsfp1 = -ri*(coupHpm1charneutL*sf1alpha1Ziu*coupHpm1ffpd*betasfp1char + coupHpm1charneutR*sf1beta1Ziu*coupHpm1ffpu*alphasfp1char)*fabs(mneutralinoi)*fabs(mcharginoj);
      coupcombo7gsfp1 = (coupHpm1charneutR*sf1alpha1Ziu*coupHpm1ffpu*betasfp1char + coupHpm1charneutL*sf1beta1Ziu*coupHpm1ffpd*alphasfp1char)*mfp*mf;
      coupcombo8gsfp1 = 2*(coupHpm1charneutL*sf1alpha1Ziu*coupHpm1ffpu*betasfp1char + ri*coupHpm1charneutR*sf1beta1Ziu*coupHpm1ffpd*alphasfp1char)*fabs(mneutralinoi)*mfp*mf*fabs(mcharginoj);
    }
    else if (norc == 'c') {
      coupcombo1gsfp1 = 0.5*(coupHpm1charneutL*betasfp1char*coupHpm1ffpu*sf1alpha1Ziu + rj*coupHpm1charneutR*alphasfp1char*coupHpm1ffpd*sf1beta1Ziu);
      coupcombo2gsfp1 = (coupHpm1charneutL*alphasfp1char*coupHpm1ffpd*sf1alpha1Ziu + rj*coupHpm1charneutR*betasfp1char*coupHpm1ffpu*sf1beta1Ziu)*fabs(mneutralinoi)*mfp;
      coupcombo3gsfp1 = -(coupHpm1charneutR*alphasfp1char*coupHpm1ffpu*sf1alpha1Ziu + rj*coupHpm1charneutL*betasfp1char*coupHpm1ffpd*sf1beta1Ziu)*mf*fabs(mcharginoj)*rj;
      coupcombo4gsfp1 = -(coupHpm1charneutL*alphasfp1char*coupHpm1ffpu*sf1alpha1Ziu + rj*coupHpm1charneutR*betasfp1char*coupHpm1ffpd*sf1beta1Ziu)*fabs(mneutralinoi)*mf;
      coupcombo5gsfp1 = (rj*coupHpm1charneutR*alphasfp1char*coupHpm1ffpd*sf1alpha1Ziu + coupHpm1charneutL*betasfp1char*coupHpm1ffpu*sf1beta1Ziu)*mfp*fabs(mcharginoj);
      // cout << "combo5 terms: " << (rj*coupHpm1charneutR*alphasfp1char*coupHpm1ffpd*sf1alpha1Ziu)*mfp*fabs(mcharginoj) << " " <<  coupHpm1charneutL*betasfp1char*coupHpm1ffpu*sf1beta1Ziu*mfp*fabs(mcharginoj) << endl;
      coupcombo6gsfp1 = (rj*coupHpm1charneutR*betasfp1char*coupHpm1ffpu*sf1alpha1Ziu + coupHpm1charneutL*alphasfp1char*coupHpm1ffpd*sf1beta1Ziu)*fabs(mcharginoj)*fabs(mneutralinoi);
      coupcombo7gsfp1 = -(rj*coupHpm1charneutL*betasfp1char*coupHpm1ffpd*sf1alpha1Ziu + coupHpm1charneutR*alphasfp1char*coupHpm1ffpu*sf1beta1Ziu)*mf*mfp*rj;
      coupcombo8gsfp1 = -2*(rj*coupHpm1charneutR*betasfp1char*coupHpm1ffpd*sf1alpha1Ziu + coupHpm1charneutL*alphasfp1char*coupHpm1ffpu*sf1beta1Ziu)*mf*mfp*fabs(mcharginoj)*fabs(mneutralinoi);
    }


    

    cout << "Couplings g sfp1: " << endl;
    cout << coupcombo1gsfp1 << endl;
    cout << coupcombo2gsfp1 << endl;
    cout << coupcombo3gsfp1 << endl;
    cout << coupcombo4gsfp1 << endl;
    cout << coupcombo5gsfp1 << endl;
    cout << coupcombo6gsfp1 << endl;
    cout << coupcombo7gsfp1 << endl;
    cout << coupcombo8gsfp1 << endl;

    double int1gsfp1 = 0, int2gsfp1 = 0, int3gsfp1 = 0, int4gsfp1 = 0, int5gsfp1 = 0, int6gsfp1 = 0, int7gsfp1 = 0, int8gsfp1 = 0;
    m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp1;
    if (norc == 'n') {
      int1gsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp1gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int2gsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp2gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int3gsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp3gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int4gsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp4gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int5gsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp5gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int6gsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp6gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int7gsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp7gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int8gsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp8gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    }
    else if (norc == 'c') { ///swap which integral goes with which couplingcombo
      int1gsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp1gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int4gsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp2gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int5gsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp3gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int2gsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp4gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int3gsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp5gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int6gsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp6gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int7gsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp7gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int8gsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp8gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    }

    cout << "Integrals g sfp1: " << endl;
    cout << int1gsfp1 << endl;
    cout << int2gsfp1 << endl;
    cout << int3gsfp1 << endl;
    cout << int4gsfp1 << endl;
    cout << int5gsfp1 << endl;
    cout << int6gsfp1 << endl;
    cout << int7gsfp1 << endl;
    cout << int8gsfp1 << endl;

    cout << "term by term gsfp1: " << endl;
    cout << coupcombo1gsfp1*int1gsfp1 << endl;
    cout << coupcombo2gsfp1*int2gsfp1 << endl;
    cout << coupcombo3gsfp1*int3gsfp1 << endl;
    cout << coupcombo4gsfp1*int4gsfp1 << endl;
    cout << coupcombo5gsfp1*int5gsfp1 << endl;
    cout << coupcombo6gsfp1*int6gsfp1 << endl;
    cout << coupcombo7gsfp1*int7gsfp1 << endl;
    cout << coupcombo8gsfp1*int8gsfp1 << endl;

    Gammagsfp1 = coupcombo1gsfp1*int1gsfp1 + coupcombo2gsfp1*int2gsfp1 + coupcombo3gsfp1*int3gsfp1 + coupcombo4gsfp1*int4gsfp1 + coupcombo5gsfp1*int5gsfp1 + coupcombo6gsfp1*int6gsfp1 + coupcombo7gsfp1*int7gsfp1 + coupcombo8gsfp1*int8gsfp1;
    cout << scientific << "Gammagsfp1 = " << Gammagsfp1 << endl;


    ///goldstone - sfp2 interference
    double coupcombo1gsfp2 = 0, coupcombo2gsfp2 = 0, coupcombo3gsfp2 = 0, coupcombo4gsfp2 = 0, coupcombo5gsfp2 = 0, coupcombo6gsfp2 = 0, coupcombo7gsfp2 = 0, coupcombo8gsfp2 = 0; 
    if (norc == 'n') {
      coupcombo1gsfp2 = -ri*0.5*(ri*coupHpm1charneutR*sf2alpha1Ziu*coupHpm1ffpd*-betasfp2char + coupHpm1charneutL*sf2beta1Ziu*coupHpm1ffpu*alphasfp2char);
      coupcombo2gsfp2 = -(coupHpm1charneutR*sf2beta1Ziu*coupHpm1ffpu*-betasfp2char - coupHpm1charneutL*sf2alpha1Ziu*coupHpm1ffpd*alphasfp2char)*fabs(mneutralinoi)*mf;
      coupcombo3gsfp2 = (coupHpm1charneutL*-sf2beta1Ziu*coupHpm1ffpd*-betasfp2char - coupHpm1charneutR*sf2alpha1Ziu*coupHpm1ffpu*alphasfp2char)*mfp*fabs(mcharginoj)*rj*ri;
      coupcombo4gsfp2 = (coupHpm1charneutR*-sf2beta1Ziu*coupHpm1ffpd*-betasfp2char + ri*coupHpm1charneutL*sf2alpha1Ziu*coupHpm1ffpu*-alphasfp2char)*fabs(mneutralinoi)*mfp*ri;
      coupcombo5gsfp2 = -ri*(coupHpm1charneutL*sf2beta1Ziu*coupHpm1ffpu*-betasfp2char - coupHpm1charneutR*sf2alpha1Ziu*coupHpm1ffpd*alphasfp2char)*mf*fabs(mcharginoj)*rj;
      coupcombo6gsfp2 = -(ri*coupHpm1charneutL*sf2alpha1Ziu*coupHpm1ffpd*-betasfp2char + coupHpm1charneutR*sf2beta1Ziu*coupHpm1ffpu*alphasfp2char)*fabs(mneutralinoi)*fabs(mcharginoj);
      coupcombo7gsfp2 = ri*(ri*coupHpm1charneutR*sf2alpha1Ziu*coupHpm1ffpu*-betasfp2char + coupHpm1charneutL*sf2beta1Ziu*coupHpm1ffpd*alphasfp2char)*mfp*mf;
      coupcombo8gsfp2 = ri*2*(coupHpm1charneutL*sf2alpha1Ziu*coupHpm1ffpu*-betasfp2char + ri*coupHpm1charneutR*sf2beta1Ziu*coupHpm1ffpd*alphasfp2char)*fabs(mneutralinoi)*mfp*mf*fabs(mcharginoj);
    }
    else if (norc == 'c') {
      coupcombo1gsfp2 = 0.5*(coupHpm1charneutL*betasfp2char*coupHpm1ffpu*sf2alpha1Ziu*rj + coupHpm1charneutR*alphasfp2char*coupHpm1ffpd*sf2beta1Ziu);
      coupcombo2gsfp2 = -(coupHpm1charneutL*alphasfp2char*coupHpm1ffpd*sf2alpha1Ziu + rj*coupHpm1charneutR*betasfp2char*coupHpm1ffpu*sf2beta1Ziu)*fabs(mneutralinoi)*mfp*rj;
      coupcombo3gsfp2 = (coupHpm1charneutR*alphasfp2char*coupHpm1ffpu*sf2alpha1Ziu + rj*coupHpm1charneutL*betasfp2char*coupHpm1ffpd*sf2beta1Ziu)*mf*fabs(mcharginoj);
      coupcombo4gsfp2 = (coupHpm1charneutL*alphasfp2char*coupHpm1ffpu*sf2alpha1Ziu + rj*coupHpm1charneutR*betasfp2char*coupHpm1ffpd*sf2beta1Ziu)*fabs(mneutralinoi)*mf*rj;
      coupcombo5gsfp2 = -(coupHpm1charneutR*alphasfp2char*coupHpm1ffpd*sf2alpha1Ziu + rj*coupHpm1charneutL*betasfp2char*coupHpm1ffpu*sf2beta1Ziu)*mfp*fabs(mcharginoj);
      coupcombo6gsfp2 = (rj*coupHpm1charneutR*betasfp2char*coupHpm1ffpu*sf2alpha1Ziu + coupHpm1charneutL*alphasfp2char*coupHpm1ffpd*sf2beta1Ziu)*fabs(mcharginoj)*fabs(mneutralinoi)*rj;
      coupcombo7gsfp2 = -(rj*coupHpm1charneutL*betasfp2char*coupHpm1ffpd*sf2alpha1Ziu + coupHpm1charneutR*alphasfp2char*coupHpm1ffpu*sf2beta1Ziu)*mf*mfp;
      coupcombo8gsfp2 = -2*(rj*coupHpm1charneutR*betasfp2char*coupHpm1ffpd*sf2alpha1Ziu + coupHpm1charneutL*alphasfp2char*coupHpm1ffpu*sf2beta1Ziu)*mf*mfp*fabs(mcharginoj)*fabs(mneutralinoi)*rj;
    }


    cout << "Couplings g sfp2: " << endl;
    cout << coupcombo1gsfp2 << endl;
    cout << coupcombo2gsfp2 << endl;
    cout << coupcombo3gsfp2 << endl;
    cout << coupcombo4gsfp2 << endl;
    cout << coupcombo5gsfp2 << endl;
    cout << coupcombo6gsfp2 << endl;
    cout << coupcombo7gsfp2 << endl;
    cout << coupcombo8gsfp2 << endl;

    double int1gsfp2 = 0, int2gsfp2 = 0, int3gsfp2 = 0, int4gsfp2 = 0, int5gsfp2 = 0, int6gsfp2 = 0, int7gsfp2 = 0, int8gsfp2 = 0;
    m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mWboson, m6 = msfp2;
    if (norc == 'n') {
      int1gsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp1gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int2gsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp2gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int3gsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp3gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int4gsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp4gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int5gsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp5gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int6gsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp6gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int7gsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp7gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int8gsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp8gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    }
    else if (norc == 'c') {
      int1gsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp1gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int4gsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp2gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int5gsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp3gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int2gsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp4gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int3gsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp5gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int6gsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp6gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int7gsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp7gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int8gsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp8gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    }
    
    cout << "Integrals g sfp2: " << endl;
    cout << int1gsfp2 << endl;
    cout << int2gsfp2 << endl;
    cout << int3gsfp2 << endl;
    cout << int4gsfp2 << endl;
    cout << int5gsfp2 << endl;
    cout << int6gsfp2 << endl;
    cout << int7gsfp2 << endl;
    cout << int8gsfp2 << endl;

    cout << "term by term gsfp2: " << endl;
    cout << coupcombo1gsfp2*int1gsfp2 << endl;
    cout << coupcombo2gsfp2*int2gsfp2 << endl;
    cout << coupcombo3gsfp2*int3gsfp2 << endl;
    cout << coupcombo4gsfp2*int4gsfp2 << endl;
    cout << coupcombo5gsfp2*int5gsfp2 << endl;
    cout << coupcombo6gsfp2*int6gsfp2 << endl;
    cout << coupcombo7gsfp2*int7gsfp2 << endl;
    cout << coupcombo8gsfp2*int8gsfp2 << endl;

    Gammagsfp2 = coupcombo1gsfp2*int1gsfp2 + coupcombo2gsfp2*int2gsfp2 + coupcombo3gsfp2*int3gsfp2 + coupcombo4gsfp2*int4gsfp2 + coupcombo5gsfp2*int5gsfp2 + coupcombo6gsfp2*int6gsfp2 + coupcombo7gsfp2*int7gsfp2 + coupcombo8gsfp2*int8gsfp2;
    cout << scientific << "Gammagsfp2 = " << Gammagsfp2 << endl;


    ///H+ - sfp1 interference
    double coupcombo1Hpmsfp1 = 0, coupcombo2Hpmsfp1 = 0, coupcombo3Hpmsfp1 = 0, coupcombo4Hpmsfp1 = 0, coupcombo5Hpmsfp1 = 0, coupcombo6Hpmsfp1 = 0, coupcombo7Hpmsfp1 = 0, coupcombo8Hpmsfp1 = 0; 
    if (norc == 'n') {
      coupcombo1Hpmsfp1 = 0.5*(coupHpm2charneutR*sf1alpha1Ziu*coupHpm2ffpd*betasfp1char + ri*coupHpm2charneutL*sf1beta1Ziu*coupHpm2ffpu*alphasfp1char)*-ri;
      coupcombo2Hpmsfp1 = (coupHpm2charneutR*sf1beta1Ziu*coupHpm2ffpu*betasfp1char + coupHpm2charneutL*sf1alpha1Ziu*coupHpm2ffpd*alphasfp1char)*fabs(mneutralinoi)*-mf;
      coupcombo3Hpmsfp1 = (coupHpm2charneutL*-sf1beta1Ziu*coupHpm2ffpd*betasfp1char - coupHpm2charneutR*sf1alpha1Ziu*coupHpm2ffpu*alphasfp1char)*mfp*fabs(mcharginoj)*-ri;
      coupcombo4Hpmsfp1 = (ri*coupHpm2charneutR*-sf1beta1Ziu*coupHpm2ffpd*betasfp1char + coupHpm2charneutL*sf1alpha1Ziu*coupHpm2ffpu*-alphasfp1char)*fabs(mneutralinoi)*-mfp;
      coupcombo5Hpmsfp1 = (coupHpm2charneutL*sf1beta1Ziu*coupHpm2ffpu*betasfp1char + coupHpm2charneutR*sf1alpha1Ziu*coupHpm2ffpd*alphasfp1char)*mf*fabs(mcharginoj)*-ri;
      coupcombo6Hpmsfp1 = -ri*(coupHpm2charneutL*sf1alpha1Ziu*coupHpm2ffpd*betasfp1char + coupHpm2charneutR*sf1beta1Ziu*coupHpm2ffpu*alphasfp1char)*fabs(mneutralinoi)*fabs(mcharginoj);
      coupcombo7Hpmsfp1 = (coupHpm2charneutR*sf1alpha1Ziu*coupHpm2ffpu*betasfp1char + coupHpm2charneutL*sf1beta1Ziu*coupHpm2ffpd*alphasfp1char)*mfp*mf;
      coupcombo8Hpmsfp1 = 2*ri*(coupHpm2charneutL*sf1alpha1Ziu*coupHpm2ffpu*betasfp1char + coupHpm2charneutR*sf1beta1Ziu*coupHpm2ffpd*alphasfp1char)*fabs(mneutralinoi)*mfp*mf*fabs(mcharginoj);
    }
    else if (norc == 'c') {
      coupcombo1Hpmsfp1 = 0.5*(coupHpm2charneutL*betasfp1char*coupHpm2ffpu*sf1alpha1Ziu + rj*coupHpm2charneutR*alphasfp1char*coupHpm2ffpd*sf1beta1Ziu);
      coupcombo2Hpmsfp1 = (coupHpm2charneutL*alphasfp1char*coupHpm2ffpd*sf1alpha1Ziu + rj*coupHpm2charneutR*betasfp1char*coupHpm2ffpu*sf1beta1Ziu)*fabs(mneutralinoi)*mfp;
      coupcombo3Hpmsfp1 = -(rj*coupHpm2charneutR*alphasfp1char*coupHpm2ffpu*sf1alpha1Ziu + coupHpm2charneutL*betasfp1char*coupHpm2ffpd*sf1beta1Ziu)*mf*fabs(mcharginoj);
      coupcombo4Hpmsfp1 = -(coupHpm2charneutL*alphasfp1char*coupHpm2ffpu*sf1alpha1Ziu + rj*coupHpm2charneutR*betasfp1char*coupHpm2ffpd*sf1beta1Ziu)*fabs(mneutralinoi)*mf;
      coupcombo5Hpmsfp1 = (rj*coupHpm2charneutR*alphasfp1char*coupHpm2ffpd*sf1alpha1Ziu + coupHpm2charneutL*betasfp1char*coupHpm2ffpu*sf1beta1Ziu)*mfp*fabs(mcharginoj);
      coupcombo6Hpmsfp1 = (rj*coupHpm2charneutR*betasfp1char*coupHpm2ffpu*sf1alpha1Ziu + coupHpm2charneutL*alphasfp1char*coupHpm2ffpd*sf1beta1Ziu)*fabs(mcharginoj)*fabs(mneutralinoi);
      coupcombo7Hpmsfp1 = -(coupHpm2charneutL*betasfp1char*coupHpm2ffpd*sf1alpha1Ziu + rj*coupHpm2charneutR*alphasfp1char*coupHpm2ffpu*sf1beta1Ziu)*mf*mfp;
      coupcombo8Hpmsfp1 = -2*(rj*coupHpm2charneutR*betasfp1char*coupHpm2ffpd*sf1alpha1Ziu + coupHpm2charneutL*alphasfp1char*coupHpm2ffpu*sf1beta1Ziu)*mf*mfp*fabs(mcharginoj)*fabs(mneutralinoi);
    }

    cout << "Couplings Hpm sfp1: " << endl;
    cout << coupcombo1Hpmsfp1 << endl;
    cout << coupcombo2Hpmsfp1 << endl;
    cout << coupcombo3Hpmsfp1 << endl;
    cout << coupcombo4Hpmsfp1 << endl;
    cout << coupcombo5Hpmsfp1 << endl;
    cout << coupcombo6Hpmsfp1 << endl;
    cout << coupcombo7Hpmsfp1 << endl;
    cout << coupcombo8Hpmsfp1 << endl;

    double int1Hpmsfp1 = 0, int2Hpmsfp1 = 0, int3Hpmsfp1 = 0, int4Hpmsfp1 = 0, int5Hpmsfp1 = 0, int6Hpmsfp1 = 0, int7Hpmsfp1 = 0, int8Hpmsfp1 = 0;
    m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mHP, m6 = msfp1;
    if (norc == 'n') {
      int1Hpmsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp1gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int2Hpmsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp2gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int3Hpmsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp3gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int4Hpmsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp4gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int5Hpmsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp5gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int6Hpmsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp6gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int7Hpmsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp7gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int8Hpmsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp8gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    }
    else if (norc == 'c') {
      int1Hpmsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp1gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int4Hpmsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp2gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int5Hpmsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp3gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int2Hpmsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp4gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int3Hpmsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp5gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int6Hpmsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp6gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int7Hpmsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp7gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int8Hpmsfp1 = 2*fabs(m1)*dgauss(gneuticharjffp8gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    }
    cout << "Integrals Hpm sfp1: " << endl;
    cout << int1Hpmsfp1 << endl;
    cout << int2Hpmsfp1 << endl;
    cout << int3Hpmsfp1 << endl;
    cout << int4Hpmsfp1 << endl;
    cout << int5Hpmsfp1 << endl;
    cout << int6Hpmsfp1 << endl;
    cout << int7Hpmsfp1 << endl;
    cout << int8Hpmsfp1 << endl;

    cout << "term by term Hpmsfp1: " << endl;
    cout << coupcombo1Hpmsfp1*int1Hpmsfp1 << endl;
    cout << coupcombo2Hpmsfp1*int2Hpmsfp1 << endl;
    cout << coupcombo3Hpmsfp1*int3Hpmsfp1 << endl;
    cout << coupcombo4Hpmsfp1*int4Hpmsfp1 << endl;
    cout << coupcombo5Hpmsfp1*int5Hpmsfp1 << endl;
    cout << coupcombo6Hpmsfp1*int6Hpmsfp1 << endl;
    cout << coupcombo7Hpmsfp1*int7Hpmsfp1 << endl;
    cout << coupcombo8Hpmsfp1*int8Hpmsfp1 << endl;

    GammaHpmsfp1 = coupcombo1Hpmsfp1*int1Hpmsfp1 + coupcombo2Hpmsfp1*int2Hpmsfp1 + coupcombo3Hpmsfp1*int3Hpmsfp1 + coupcombo4Hpmsfp1*int4Hpmsfp1 + coupcombo5Hpmsfp1*int5Hpmsfp1 + coupcombo6Hpmsfp1*int6Hpmsfp1 + coupcombo7Hpmsfp1*int7Hpmsfp1 + coupcombo8Hpmsfp1*int8Hpmsfp1;
    cout << scientific << "GammaHpmsfp1 = " << GammaHpmsfp1 << endl;


    ///H+ - sfp2 interference
    double coupcombo1Hpmsfp2 = 0, coupcombo2Hpmsfp2 = 0, coupcombo3Hpmsfp2 = 0, coupcombo4Hpmsfp2 = 0, coupcombo5Hpmsfp2 = 0, coupcombo6Hpmsfp2 = 0, coupcombo7Hpmsfp2 = 0, coupcombo8Hpmsfp2 = 0; 
    if (norc == 'n') {
      coupcombo1Hpmsfp2 = -ri*0.5*(-coupHpm2charneutR*sf2alpha1Ziu*coupHpm2ffpd*-betasfp2char + coupHpm2charneutL*sf2beta1Ziu*coupHpm2ffpu*alphasfp2char);
      coupcombo2Hpmsfp2 = (coupHpm2charneutR*sf2beta1Ziu*coupHpm2ffpu*-betasfp2char - coupHpm2charneutL*sf2alpha1Ziu*coupHpm2ffpd*alphasfp2char)*fabs(mneutralinoi)*-mf;
      coupcombo3Hpmsfp2 = -(coupHpm2charneutL*-sf2beta1Ziu*coupHpm2ffpd*-betasfp2char + ri*coupHpm2charneutR*sf2alpha1Ziu*coupHpm2ffpu*alphasfp2char)*mfp*fabs(mcharginoj);
      coupcombo4Hpmsfp2 = -(coupHpm2charneutR*-sf2beta1Ziu*coupHpm2ffpd*-betasfp2char - coupHpm2charneutL*sf2alpha1Ziu*coupHpm2ffpu*-alphasfp2char)*fabs(mneutralinoi)*mfp;
      coupcombo5Hpmsfp2 = (coupHpm2charneutL*sf2beta1Ziu*coupHpm2ffpu*-betasfp2char + coupHpm2charneutR*sf2alpha1Ziu*coupHpm2ffpd*alphasfp2char)*mf*fabs(mcharginoj)*rj*ri;
      coupcombo6Hpmsfp2 = -(ri*coupHpm2charneutL*sf2alpha1Ziu*coupHpm2ffpd*-betasfp2char + coupHpm2charneutR*sf2beta1Ziu*coupHpm2ffpu*alphasfp2char)*fabs(mneutralinoi)*fabs(mcharginoj);
      coupcombo7Hpmsfp2 = ri*(ri*coupHpm2charneutR*sf2alpha1Ziu*coupHpm2ffpu*-betasfp2char + coupHpm2charneutL*sf2beta1Ziu*coupHpm2ffpd*alphasfp2char)*mfp*mf;
      coupcombo8Hpmsfp2 = 2*(coupHpm2charneutL*sf2alpha1Ziu*coupHpm2ffpu*-betasfp2char + coupHpm2charneutR*sf2beta1Ziu*coupHpm2ffpd*alphasfp2char)*fabs(mneutralinoi)*mfp*mf*fabs(mcharginoj);
    }
    else if (norc == 'c') {
      coupcombo1Hpmsfp2 = 0.5*(rj*coupHpm2charneutL*betasfp2char*coupHpm2ffpu*sf2alpha1Ziu + coupHpm2charneutR*alphasfp2char*coupHpm2ffpd*sf2beta1Ziu);
      coupcombo2Hpmsfp2 = -(rj*coupHpm2charneutL*alphasfp2char*coupHpm2ffpd*sf2alpha1Ziu + coupHpm2charneutR*betasfp2char*coupHpm2ffpu*sf2beta1Ziu)*fabs(mneutralinoi)*mfp;
      coupcombo3Hpmsfp2 = (coupHpm2charneutR*alphasfp2char*coupHpm2ffpu*sf2alpha1Ziu + rj*coupHpm2charneutL*betasfp2char*coupHpm2ffpd*sf2beta1Ziu)*mf*fabs(mcharginoj);
      coupcombo4Hpmsfp2 = (rj*coupHpm2charneutL*alphasfp2char*coupHpm2ffpu*sf2alpha1Ziu + coupHpm2charneutR*betasfp2char*coupHpm2ffpd*sf2beta1Ziu)*fabs(mneutralinoi)*mf;
      coupcombo5Hpmsfp2 = -(coupHpm2charneutR*alphasfp2char*coupHpm2ffpd*sf2alpha1Ziu + rj*coupHpm2charneutL*betasfp2char*coupHpm2ffpu*sf2beta1Ziu)*mfp*fabs(mcharginoj);
      coupcombo6Hpmsfp2 = (coupHpm2charneutR*betasfp2char*coupHpm2ffpu*sf2alpha1Ziu + rj*coupHpm2charneutL*alphasfp2char*coupHpm2ffpd*sf2beta1Ziu)*fabs(mcharginoj)*fabs(mneutralinoi);
      coupcombo7Hpmsfp2 = -(rj*coupHpm2charneutL*betasfp2char*coupHpm2ffpd*sf2alpha1Ziu + coupHpm2charneutR*alphasfp2char*coupHpm2ffpu*sf2beta1Ziu)*mf*mfp;
      coupcombo8Hpmsfp2 = -2*(coupHpm2charneutR*betasfp2char*coupHpm2ffpd*sf2alpha1Ziu + rj*coupHpm2charneutL*alphasfp2char*coupHpm2ffpu*sf2beta1Ziu)*mf*mfp*fabs(mcharginoj)*fabs(mneutralinoi);
    }



    cout << "Couplings Hpm sfp2: " << endl;
    cout << coupcombo1Hpmsfp2 << endl;
    cout << coupcombo2Hpmsfp2 << endl;
    cout << coupcombo3Hpmsfp2 << endl;
    cout << coupcombo4Hpmsfp2 << endl;
    cout << coupcombo5Hpmsfp2 << endl;
    cout << coupcombo6Hpmsfp2 << endl;
    cout << coupcombo7Hpmsfp2 << endl;
    cout << coupcombo8Hpmsfp2 << endl;

    double int1Hpmsfp2 = 0, int2Hpmsfp2 = 0, int3Hpmsfp2 = 0, int4Hpmsfp2 = 0, int5Hpmsfp2 = 0, int6Hpmsfp2 = 0, int7Hpmsfp2 = 0, int8Hpmsfp2 = 0;
    m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = mHP, m6 = msfp2;
    if (norc == 'n') {
      int1Hpmsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp1gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int2Hpmsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp2gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int3Hpmsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp3gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int4Hpmsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp4gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int5Hpmsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp5gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int6Hpmsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp6gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int7Hpmsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp7gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int8Hpmsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp8gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    }
    else if (norc == 'c') {
      int1Hpmsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp1gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int4Hpmsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp2gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int5Hpmsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp3gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int2Hpmsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp4gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int3Hpmsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp5gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int6Hpmsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp6gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int7Hpmsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp7gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int8Hpmsfp2 = 2*fabs(m1)*dgauss(gneuticharjffp8gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    }

    cout << "Integrals Hpm sfp2: " << endl;
    cout << int1Hpmsfp2 << endl;
    cout << int2Hpmsfp2 << endl;
    cout << int3Hpmsfp2 << endl;
    cout << int4Hpmsfp2 << endl;
    cout << int5Hpmsfp2 << endl;
    cout << int6Hpmsfp2 << endl;
    cout << int7Hpmsfp2 << endl;
    cout << int8Hpmsfp2 << endl;

    cout << "term by term Hpmsfp2: " << endl;
    cout << coupcombo1Hpmsfp2*int1Hpmsfp2 << endl;
    cout << coupcombo2Hpmsfp2*int2Hpmsfp2 << endl;
    cout << coupcombo3Hpmsfp2*int3Hpmsfp2 << endl;
    cout << coupcombo4Hpmsfp2*int4Hpmsfp2 << endl;
    cout << coupcombo5Hpmsfp2*int5Hpmsfp2 << endl;
    cout << coupcombo6Hpmsfp2*int6Hpmsfp2 << endl;
    cout << coupcombo7Hpmsfp2*int7Hpmsfp2 << endl;
    cout << coupcombo8Hpmsfp2*int8Hpmsfp2 << endl;

    GammaHpmsfp2 = coupcombo1Hpmsfp2*int1Hpmsfp2 + coupcombo2Hpmsfp2*int2Hpmsfp2 + coupcombo3Hpmsfp2*int3Hpmsfp2 + coupcombo4Hpmsfp2*int4Hpmsfp2 + coupcombo5Hpmsfp2*int5Hpmsfp2 + coupcombo6Hpmsfp2*int6Hpmsfp2 + coupcombo7Hpmsfp2*int7Hpmsfp2 + coupcombo8Hpmsfp2*int8Hpmsfp2;
    cout << scientific << "GammaHpmsfp2 = " << GammaHpmsfp2 << endl;

    ///goldstone - sf1 interference
    double coupcombo1gsf1 = 0, coupcombo2gsf1 = 0, coupcombo3gsf1 = 0, coupcombo4gsf1 = 0, coupcombo5gsf1 = 0, coupcombo6gsf1 = 0, coupcombo7gsf1 = 0, coupcombo8gsf1 = 0; 
    if (norc == 'n') {
      coupcombo1gsf1 = -ri*0.5*(ri*coupHpm1charneutR*-sf1beta1Zid*coupHpm1ffpd*-alphasf1char + coupHpm1charneutL*-sf1alpha1Zid*coupHpm1ffpu*-betasf1char);
      coupcombo2gsf1 = (coupHpm1charneutR*-sf1alpha1Zid*coupHpm1ffpu*-alphasf1char + ri*coupHpm1charneutL*-sf1beta1Zid*coupHpm1ffpd*-betasf1char)*fabs(mneutralinoi)*-mfp;
      coupcombo3gsf1 = (coupHpm1charneutL*sf1alpha1Zid*coupHpm1ffpd*-alphasf1char - ri*coupHpm1charneutR*-sf1beta1Zid*coupHpm1ffpu*-betasf1char)*mf*fabs(mcharginoj)*-ri;
      coupcombo4gsf1 = (coupHpm1charneutR*sf1alpha1Zid*coupHpm1ffpd*-alphasf1char + ri*coupHpm1charneutL*-sf1beta1Zid*coupHpm1ffpu*betasf1char)*fabs(mneutralinoi)*-mf;
      coupcombo5gsf1 = (coupHpm1charneutL*-sf1alpha1Zid*coupHpm1ffpu*-alphasf1char + ri*coupHpm1charneutR*-sf1beta1Zid*coupHpm1ffpd*-betasf1char)*mfp*fabs(mcharginoj)*-ri;
      coupcombo6gsf1 = (coupHpm1charneutL*-sf1beta1Zid*coupHpm1ffpd*-alphasf1char + ri*coupHpm1charneutR*-sf1alpha1Zid*coupHpm1ffpu*-betasf1char)*fabs(mneutralinoi)*fabs(mcharginoj)*-ri;
      coupcombo7gsf1 = (ri*coupHpm1charneutR*-sf1beta1Zid*coupHpm1ffpu*-alphasf1char + coupHpm1charneutL*-sf1alpha1Zid*coupHpm1ffpd*-betasf1char)*mfp*mf*ri;
      coupcombo8gsf1 = 2*(ri*coupHpm1charneutL*-sf1beta1Zid*coupHpm1ffpu*-alphasf1char + coupHpm1charneutR*-sf1alpha1Zid*coupHpm1ffpd*-betasf1char)*fabs(mneutralinoi)*mfp*mf*fabs(mcharginoj);
    }
    else if (norc == 'c') {
      coupcombo1gsf1 = 0.5*(rj*coupHpm1charneutL*betasf1char*coupHpm1ffpu*sf1alpha1Zid + coupHpm1charneutR*alphasf1char*coupHpm1ffpd*sf1beta1Zid);
      coupcombo2gsf1 = (rj*coupHpm1charneutL*alphasf1char*coupHpm1ffpd*sf1alpha1Zid + coupHpm1charneutR*betasf1char*coupHpm1ffpu*sf1beta1Zid)*fabs(mneutralinoi)*mf;
      coupcombo3gsf1 = -(coupHpm1charneutR*alphasf1char*coupHpm1ffpu*sf1alpha1Zid + rj*coupHpm1charneutL*betasf1char*coupHpm1ffpd*sf1beta1Zid)*mfp*fabs(mcharginoj);
      coupcombo4gsf1 = -(rj*coupHpm1charneutL*alphasf1char*coupHpm1ffpu*sf1alpha1Zid + coupHpm1charneutR*betasf1char*coupHpm1ffpd*sf1beta1Zid)*fabs(mneutralinoi)*mfp;
      coupcombo5gsf1 = (coupHpm1charneutR*alphasf1char*coupHpm1ffpd*sf1alpha1Zid + rj*coupHpm1charneutL*betasf1char*coupHpm1ffpu*sf1beta1Zid)*mf*fabs(mcharginoj);
      coupcombo6gsf1 = (coupHpm1charneutR*betasf1char*coupHpm1ffpu*sf1alpha1Zid + rj*coupHpm1charneutL*alphasf1char*coupHpm1ffpd*sf1beta1Zid)*fabs(mcharginoj)*fabs(mneutralinoi);
      coupcombo7gsf1 = -(rj*coupHpm1charneutL*betasf1char*coupHpm1ffpd*sf1alpha1Zid + coupHpm1charneutR*alphasf1char*coupHpm1ffpu*sf1beta1Zid)*mf*mfp;
      coupcombo8gsf1 = -2*(coupHpm1charneutR*betasf1char*coupHpm1ffpd*sf1alpha1Zid + rj*coupHpm1charneutL*alphasf1char*coupHpm1ffpu*sf1beta1Zid)*mf*mfp*fabs(mcharginoj)*fabs(mneutralinoi);
    }
    

    cout << "Couplings g sf1: " << endl;
    cout << coupcombo1gsf1 << endl;
    cout << coupcombo2gsf1 << endl;
    cout << coupcombo3gsf1 << endl;
    cout << coupcombo4gsf1 << endl;
    cout << coupcombo5gsf1 << endl;
    cout << coupcombo6gsf1 << endl;
    cout << coupcombo7gsf1 << endl;
    cout << coupcombo8gsf1 << endl;

    double int1gsf1 = 0, int2gsf1 = 0, int3gsf1 = 0, int4gsf1 = 0, int5gsf1 = 0, int6gsf1 = 0, int7gsf1 = 0, int8gsf1 = 0;
    m1 = mneutralinoi, m2 = mf, m3 = mfp, m4 = mcharginoj, m5 = mWboson, m6 = msf1;
    if (norc == 'n') {
      int1gsf1 = 2*fabs(m1)*dgauss(gneuticharjffp1gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int2gsf1 = 2*fabs(m1)*dgauss(gneuticharjffp2gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int3gsf1 = 2*fabs(m1)*dgauss(gneuticharjffp3gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int4gsf1 = 2*fabs(m1)*dgauss(gneuticharjffp4gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int5gsf1 = 2*fabs(m1)*dgauss(gneuticharjffp5gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int6gsf1 = 2*fabs(m1)*dgauss(gneuticharjffp6gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int7gsf1 = 2*fabs(m1)*dgauss(gneuticharjffp7gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int8gsf1 = 2*fabs(m1)*dgauss(gneuticharjffp8gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    }
    else if (norc == 'c') {
      int1gsf1 = 2*fabs(m1)*dgauss(gneuticharjffp1gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int4gsf1 = 2*fabs(m1)*dgauss(gneuticharjffp2gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int5gsf1 = 2*fabs(m1)*dgauss(gneuticharjffp3gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int2gsf1 = 2*fabs(m1)*dgauss(gneuticharjffp4gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int3gsf1 = 2*fabs(m1)*dgauss(gneuticharjffp5gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int6gsf1 = 2*fabs(m1)*dgauss(gneuticharjffp6gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int7gsf1 = 2*fabs(m1)*dgauss(gneuticharjffp7gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int8gsf1 = 2*fabs(m1)*dgauss(gneuticharjffp8gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    }

    cout << "Integrals g sf1: " << endl;
    cout << int1gsf1 << endl;
    cout << int2gsf1 << endl;
    cout << int3gsf1 << endl;
    cout << int4gsf1 << endl;
    cout << int5gsf1 << endl;
    cout << int6gsf1 << endl;
    cout << int7gsf1 << endl;
    cout << int8gsf1 << endl;

    cout << "term by term gsf1: " << endl;
    cout << coupcombo1gsf1*int1gsf1 << endl;
    cout << coupcombo2gsf1*int2gsf1 << endl;
    cout << coupcombo3gsf1*int3gsf1 << endl;
    cout << coupcombo4gsf1*int4gsf1 << endl;
    cout << coupcombo5gsf1*int5gsf1 << endl;
    cout << coupcombo6gsf1*int6gsf1 << endl;
    cout << coupcombo7gsf1*int7gsf1 << endl;
    cout << coupcombo8gsf1*int8gsf1 << endl;

    Gammagsf1 = coupcombo1gsf1*int1gsf1 + coupcombo2gsf1*int2gsf1 + coupcombo3gsf1*int3gsf1 + coupcombo4gsf1*int4gsf1 + coupcombo5gsf1*int5gsf1 + coupcombo6gsf1*int6gsf1 + coupcombo7gsf1*int7gsf1 + coupcombo8gsf1*int8gsf1;
    cout << scientific << "Gammagsf1 = " << Gammagsf1 << endl;

    ///goldstone - sf2 interference
    double coupcombo1gsf2 = 0, coupcombo2gsf2 = 0, coupcombo3gsf2 = 0, coupcombo4gsf2 = 0, coupcombo5gsf2 = 0, coupcombo6gsf2 = 0, coupcombo7gsf2 = 0, coupcombo8gsf2 = 0; 
    if (norc == 'n') {
      coupcombo1gsf2 = 0.5*(ri*coupHpm1charneutR*-sf2beta1Zid*coupHpm1ffpd*-alphasf2char + coupHpm1charneutL*-sf2alpha1Zid*coupHpm1ffpu*-betasf2char);
      coupcombo2gsf2 = (ri*coupHpm1charneutR*-sf2alpha1Zid*coupHpm1ffpu*-alphasf2char + coupHpm1charneutL*-sf2beta1Zid*coupHpm1ffpd*-betasf2char)*fabs(mneutralinoi)*-mfp;
      coupcombo3gsf2 = (ri*coupHpm1charneutL*sf2alpha1Zid*coupHpm1ffpd*-alphasf2char - coupHpm1charneutR*-sf2beta1Zid*coupHpm1ffpu*-betasf2char)*mf*fabs(mcharginoj)*-ri;
      coupcombo4gsf2 = (ri*coupHpm1charneutR*sf2alpha1Zid*coupHpm1ffpd*-alphasf2char + coupHpm1charneutL*-sf2beta1Zid*coupHpm1ffpu*betasf2char)*fabs(mneutralinoi)*-mf;
      coupcombo5gsf2 = (ri*coupHpm1charneutL*-sf2alpha1Zid*coupHpm1ffpu*-alphasf2char + coupHpm1charneutR*-sf2beta1Zid*coupHpm1ffpd*-betasf2char)*mfp*fabs(mcharginoj)*-ri;
      coupcombo6gsf2 = (coupHpm1charneutL*-sf2beta1Zid*coupHpm1ffpd*-alphasf2char + ri*coupHpm1charneutR*-sf2alpha1Zid*coupHpm1ffpu*-betasf2char)*fabs(mneutralinoi)*fabs(mcharginoj)*rj;
      coupcombo7gsf2 = -(ri*coupHpm1charneutR*-sf2beta1Zid*coupHpm1ffpu*-alphasf2char + coupHpm1charneutL*-sf2alpha1Zid*coupHpm1ffpd*-betasf2char)*mfp*mf;
      coupcombo8gsf2 = -2*(coupHpm1charneutL*-sf2beta1Zid*coupHpm1ffpu*-alphasf2char + ri*coupHpm1charneutR*-sf2alpha1Zid*coupHpm1ffpd*-betasf2char)*fabs(mneutralinoi)*mfp*mf*fabs(mcharginoj)*rj;
    }
    else if (norc == 'c') {
      coupcombo1gsf2 = 0.5*(coupHpm1charneutL*betasf2char*coupHpm1ffpu*sf2alpha1Zid - rj*coupHpm1charneutR*alphasf2char*coupHpm1ffpd*sf2beta1Zid);
      coupcombo2gsf2 = (coupHpm1charneutL*alphasf2char*coupHpm1ffpd*sf2alpha1Zid - rj*coupHpm1charneutR*betasf2char*coupHpm1ffpu*sf2beta1Zid)*fabs(mneutralinoi)*mf;
      coupcombo3gsf2 = (-rj*coupHpm1charneutR*alphasf2char*coupHpm1ffpu*sf2alpha1Zid + coupHpm1charneutL*betasf2char*coupHpm1ffpd*sf2beta1Zid)*mfp*fabs(mcharginoj);
      coupcombo4gsf2 = -(coupHpm1charneutL*alphasf2char*coupHpm1ffpu*sf2alpha1Zid + rj*coupHpm1charneutR*betasf2char*coupHpm1ffpd*sf2beta1Zid)*fabs(mneutralinoi)*mfp;
      coupcombo5gsf2 = -(-rj*coupHpm1charneutR*alphasf2char*coupHpm1ffpd*sf2alpha1Zid + coupHpm1charneutL*betasf2char*coupHpm1ffpu*sf2beta1Zid)*mf*fabs(mcharginoj);
      coupcombo6gsf2 = rj*(coupHpm1charneutR*betasf2char*coupHpm1ffpu*sf2alpha1Zid + coupHpm1charneutL*alphasf2char*coupHpm1ffpd*sf2beta1Zid)*fabs(mcharginoj)*fabs(mneutralinoi);
      coupcombo7gsf2 = rj*(coupHpm1charneutL*betasf2char*coupHpm1ffpd*sf2alpha1Zid + coupHpm1charneutR*alphasf2char*coupHpm1ffpu*sf2beta1Zid)*mf*mfp;
      coupcombo8gsf2 = 2*(rj*coupHpm1charneutR*betasf2char*coupHpm1ffpd*sf2alpha1Zid + coupHpm1charneutL*alphasf2char*coupHpm1ffpu*sf2beta1Zid)*mf*mfp*fabs(mcharginoj)*fabs(mneutralinoi);
    }


    cout << "Couplings g sf2: " << endl;
    cout << coupcombo1gsf2 << endl;
    cout << coupcombo2gsf2 << endl;
    cout << coupcombo3gsf2 << endl;
    cout << coupcombo4gsf2 << endl;
    cout << coupcombo5gsf2 << endl;
    cout << coupcombo6gsf2 << endl;
    cout << coupcombo7gsf2 << endl;
    cout << coupcombo8gsf2 << endl;

    double int1gsf2 = 0, int2gsf2 = 0, int3gsf2 = 0, int4gsf2 = 0, int5gsf2 = 0, int6gsf2 = 0, int7gsf2 = 0, int8gsf2 = 0;
    m1 = mneutralinoi, m2 = mf, m3 = mfp, m4 = mcharginoj, m5 = mWboson, m6 = msf2;
    if (norc == 'n') {
      int1gsf2 = 2*fabs(m1)*dgauss(gneuticharjffp1gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int2gsf2 = 2*fabs(m1)*dgauss(gneuticharjffp2gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int3gsf2 = 2*fabs(m1)*dgauss(gneuticharjffp3gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int4gsf2 = 2*fabs(m1)*dgauss(gneuticharjffp4gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int5gsf2 = 2*fabs(m1)*dgauss(gneuticharjffp5gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int6gsf2 = 2*fabs(m1)*dgauss(gneuticharjffp6gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int7gsf2 = 2*fabs(m1)*dgauss(gneuticharjffp7gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int8gsf2 = 2*fabs(m1)*dgauss(gneuticharjffp8gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    }
    else if (norc == 'c') {
      int1gsf2 = 2*fabs(m1)*dgauss(gneuticharjffp1gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int4gsf2 = 2*fabs(m1)*dgauss(gneuticharjffp2gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int5gsf2 = 2*fabs(m1)*dgauss(gneuticharjffp3gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int2gsf2 = 2*fabs(m1)*dgauss(gneuticharjffp4gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int3gsf2 = 2*fabs(m1)*dgauss(gneuticharjffp5gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int6gsf2 = 2*fabs(m1)*dgauss(gneuticharjffp6gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int7gsf2 = 2*fabs(m1)*dgauss(gneuticharjffp7gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int8gsf2 = 2*fabs(m1)*dgauss(gneuticharjffp8gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    }


    cout << "Integrals g sf2: " << endl;
    cout << int1gsf2 << endl;
    cout << int2gsf2 << endl;
    cout << int3gsf2 << endl;
    cout << int4gsf2 << endl;
    cout << int5gsf2 << endl;
    cout << int6gsf2 << endl;
    cout << int7gsf2 << endl;
    cout << int8gsf2 << endl;

    cout << "term by term gsf2: " << endl;
    cout << coupcombo1gsf2*int1gsf2 << endl;
    cout << coupcombo2gsf2*int2gsf2 << endl;
    cout << coupcombo3gsf2*int3gsf2 << endl;
    cout << coupcombo4gsf2*int4gsf2 << endl;
    cout << coupcombo5gsf2*int5gsf2 << endl;
    cout << coupcombo6gsf2*int6gsf2 << endl;
    cout << coupcombo7gsf2*int7gsf2 << endl;
    cout << coupcombo8gsf2*int8gsf2 << endl;

    Gammagsf2 = coupcombo1gsf2*int1gsf2 + coupcombo2gsf2*int2gsf2 + coupcombo3gsf2*int3gsf2 + coupcombo4gsf2*int4gsf2 + coupcombo5gsf2*int5gsf2 + coupcombo6gsf2*int6gsf2 + coupcombo7gsf2*int7gsf2 + coupcombo8gsf2*int8gsf2;
    cout << scientific << "Gammagsf2 = " << Gammagsf2 << endl;


    //Hpm - sf1 interference
    double coupcombo1Hpmsf1 = 0, coupcombo2Hpmsf1 = 0, coupcombo3Hpmsf1 = 0, coupcombo4Hpmsf1 = 0, coupcombo5Hpmsf1 = 0, coupcombo6Hpmsf1 = 0, coupcombo7Hpmsf1 = 0, coupcombo8Hpmsf1 = 0; 
    if (norc == 'n') {
      coupcombo1Hpmsf1 = -0.5*(coupHpm2charneutR*-sf1beta1Zid*coupHpm2ffpd*-alphasf1char + coupHpm2charneutL*-sf1alpha1Zid*coupHpm2ffpu*-betasf1char);
      coupcombo2Hpmsf1 = -(coupHpm2charneutR*-sf1alpha1Zid*coupHpm2ffpu*-alphasf1char + coupHpm2charneutL*-sf1beta1Zid*coupHpm2ffpd*-betasf1char)*fabs(mneutralinoi)*mfp;
      coupcombo3Hpmsf1 = (coupHpm2charneutL*sf1alpha1Zid*coupHpm2ffpd*-alphasf1char - coupHpm2charneutR*-sf1beta1Zid*coupHpm2ffpu*-betasf1char)*mf*fabs(mcharginoj)*-ri;
      coupcombo4Hpmsf1 = (coupHpm2charneutR*sf1alpha1Zid*coupHpm2ffpd*-alphasf1char + coupHpm2charneutL*-sf1beta1Zid*coupHpm2ffpu*betasf1char)*fabs(mneutralinoi)*-mf;
      coupcombo5Hpmsf1 = (coupHpm2charneutL*-sf1alpha1Zid*coupHpm2ffpu*-alphasf1char + ri*coupHpm2charneutR*-sf1beta1Zid*coupHpm2ffpd*-betasf1char)*mfp*fabs(mcharginoj)*-ri;
      coupcombo6Hpmsf1 = -(ri*coupHpm2charneutL*-sf1beta1Zid*coupHpm2ffpd*-alphasf1char + coupHpm2charneutR*-sf1alpha1Zid*coupHpm2ffpu*-betasf1char)*fabs(mneutralinoi)*fabs(mcharginoj);
      coupcombo7Hpmsf1 = ri*(ri*coupHpm2charneutR*-sf1beta1Zid*coupHpm2ffpu*-alphasf1char + coupHpm2charneutL*-sf1alpha1Zid*coupHpm2ffpd*-betasf1char)*mfp*mf;
      coupcombo8Hpmsf1 = 2*(ri*coupHpm2charneutL*-sf1beta1Zid*coupHpm2ffpu*-alphasf1char + coupHpm2charneutR*-sf1alpha1Zid*coupHpm2ffpd*-betasf1char)*fabs(mneutralinoi)*mfp*mf*fabs(mcharginoj);
    }
    else if (norc == 'c') {
      coupcombo1Hpmsf1 = 0.5*(rj*coupHpm2charneutL*betasf1char*coupHpm2ffpu*sf1alpha1Zid + coupHpm2charneutR*alphasf1char*coupHpm2ffpd*sf1beta1Zid);
      coupcombo2Hpmsf1 = (rj*coupHpm2charneutL*alphasf1char*coupHpm2ffpd*sf1alpha1Zid + coupHpm2charneutR*betasf1char*coupHpm2ffpu*sf1beta1Zid)*fabs(mneutralinoi)*mf;
      coupcombo3Hpmsf1 = -(coupHpm2charneutR*alphasf1char*coupHpm2ffpu*sf1alpha1Zid + rj*coupHpm2charneutL*betasf1char*coupHpm2ffpd*sf1beta1Zid)*mfp*fabs(mcharginoj);
      coupcombo4Hpmsf1 = -(rj*coupHpm2charneutL*alphasf1char*coupHpm2ffpu*sf1alpha1Zid + coupHpm2charneutR*betasf1char*coupHpm2ffpd*sf1beta1Zid)*fabs(mneutralinoi)*mfp;
      coupcombo5Hpmsf1 = (coupHpm2charneutR*alphasf1char*coupHpm2ffpd*sf1alpha1Zid + rj*coupHpm2charneutL*betasf1char*coupHpm2ffpu*sf1beta1Zid)*mf*fabs(mcharginoj);
      coupcombo6Hpmsf1 = (coupHpm2charneutR*betasf1char*coupHpm2ffpu*sf1alpha1Zid + rj*coupHpm2charneutL*alphasf1char*coupHpm2ffpd*sf1beta1Zid)*fabs(mcharginoj)*fabs(mneutralinoi);
      coupcombo7Hpmsf1 = -(rj*coupHpm2charneutL*betasf1char*coupHpm2ffpd*sf1alpha1Zid + coupHpm2charneutR*alphasf1char*coupHpm2ffpu*sf1beta1Zid)*mf*mfp;
      coupcombo8Hpmsf1 = -2*(coupHpm2charneutR*betasf1char*coupHpm2ffpd*sf1alpha1Zid + rj*coupHpm2charneutL*alphasf1char*coupHpm2ffpu*sf1beta1Zid)*mf*mfp*fabs(mcharginoj)*fabs(mneutralinoi);
    }

    cout << "Couplings Hpm sf1: " << endl;
    cout << coupcombo1Hpmsf1 << endl;
    cout << coupcombo2Hpmsf1 << endl;
    cout << coupcombo3Hpmsf1 << endl;
    cout << coupcombo4Hpmsf1 << endl;
    cout << coupcombo5Hpmsf1 << endl;
    cout << coupcombo6Hpmsf1 << endl;
    cout << coupcombo7Hpmsf1 << endl;
    cout << coupcombo8Hpmsf1 << endl;

    double int1Hpmsf1 = 0, int2Hpmsf1 = 0, int3Hpmsf1 = 0, int4Hpmsf1 = 0, int5Hpmsf1 = 0, int6Hpmsf1 = 0, int7Hpmsf1 = 0, int8Hpmsf1 = 0;
    m1 = mneutralinoi, m2 = mf, m3 = mfp, m4 = mcharginoj, m5 = mHP, m6 = msf1;
    if( norc == 'n') {
      int1Hpmsf1 = 2*fabs(m1)*dgauss(gneuticharjffp1gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int2Hpmsf1 = 2*fabs(m1)*dgauss(gneuticharjffp2gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int3Hpmsf1 = 2*fabs(m1)*dgauss(gneuticharjffp3gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int4Hpmsf1 = 2*fabs(m1)*dgauss(gneuticharjffp4gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int5Hpmsf1 = 2*fabs(m1)*dgauss(gneuticharjffp5gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int6Hpmsf1 = 2*fabs(m1)*dgauss(gneuticharjffp6gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int7Hpmsf1 = 2*fabs(m1)*dgauss(gneuticharjffp7gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int8Hpmsf1 = 2*fabs(m1)*dgauss(gneuticharjffp8gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    }
    else if (norc == 'c') {
      int1Hpmsf1 = 2*fabs(m1)*dgauss(gneuticharjffp1gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int4Hpmsf1 = 2*fabs(m1)*dgauss(gneuticharjffp2gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int5Hpmsf1 = 2*fabs(m1)*dgauss(gneuticharjffp3gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int2Hpmsf1 = 2*fabs(m1)*dgauss(gneuticharjffp4gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int3Hpmsf1 = 2*fabs(m1)*dgauss(gneuticharjffp5gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int6Hpmsf1 = 2*fabs(m1)*dgauss(gneuticharjffp6gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int7Hpmsf1 = 2*fabs(m1)*dgauss(gneuticharjffp7gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int8Hpmsf1 = 2*fabs(m1)*dgauss(gneuticharjffp8gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    }    

    cout << "Integrals Hpm sf1: " << endl;
    cout << int1Hpmsf1 << endl;
    cout << int2Hpmsf1 << endl;
    cout << int3Hpmsf1 << endl;
    cout << int4Hpmsf1 << endl;
    cout << int5Hpmsf1 << endl;
    cout << int6Hpmsf1 << endl;
    cout << int7Hpmsf1 << endl;
    cout << int8Hpmsf1 << endl;

    cout << "term by term Hpmsf1: " << endl;
    cout << coupcombo1Hpmsf1*int1Hpmsf1 << endl;
    cout << coupcombo2Hpmsf1*int2Hpmsf1 << endl;
    cout << coupcombo3Hpmsf1*int3Hpmsf1 << endl;
    cout << coupcombo4Hpmsf1*int4Hpmsf1 << endl;
    cout << coupcombo5Hpmsf1*int5Hpmsf1 << endl;
    cout << coupcombo6Hpmsf1*int6Hpmsf1 << endl;
    cout << coupcombo7Hpmsf1*int7Hpmsf1 << endl;
    cout << coupcombo8Hpmsf1*int8Hpmsf1 << endl;

    GammaHpmsf1 = coupcombo1Hpmsf1*int1Hpmsf1 + coupcombo2Hpmsf1*int2Hpmsf1 + coupcombo3Hpmsf1*int3Hpmsf1 + coupcombo4Hpmsf1*int4Hpmsf1 + coupcombo5Hpmsf1*int5Hpmsf1 + coupcombo6Hpmsf1*int6Hpmsf1 + coupcombo7Hpmsf1*int7Hpmsf1 + coupcombo8Hpmsf1*int8Hpmsf1;
    cout << scientific << "GammaHpmsf1 = " << GammaHpmsf1 << endl;


    ///Hpm - sf2 interference
    double coupcombo1Hpmsf2 = 0, coupcombo2Hpmsf2 = 0, coupcombo3Hpmsf2 = 0, coupcombo4Hpmsf2 = 0, coupcombo5Hpmsf2 = 0, coupcombo6Hpmsf2 = 0, coupcombo7Hpmsf2 = 0, coupcombo8Hpmsf2 = 0; 
    if (norc == 'n') {
      coupcombo1Hpmsf2 = 0.5*(coupHpm2charneutR*-sf2beta1Zid*coupHpm2ffpd*-alphasf2char + coupHpm2charneutL*-sf2alpha1Zid*coupHpm2ffpu*-betasf2char)*ri;
      coupcombo2Hpmsf2 = -ri*(coupHpm2charneutR*-sf2alpha1Zid*coupHpm2ffpu*-alphasf2char + coupHpm2charneutL*-sf2beta1Zid*coupHpm2ffpd*-betasf2char)*fabs(mneutralinoi)*mfp;
      coupcombo3Hpmsf2 = -(coupHpm2charneutL*sf2alpha1Zid*coupHpm2ffpd*-alphasf2char - coupHpm2charneutR*-sf2beta1Zid*coupHpm2ffpu*-betasf2char)*mf*fabs(mcharginoj);
      coupcombo4Hpmsf2 = (coupHpm2charneutR*sf2alpha1Zid*coupHpm2ffpd*-alphasf2char + coupHpm2charneutL*-sf2beta1Zid*coupHpm2ffpu*betasf2char)*fabs(mneutralinoi)*mf*-ri;
      coupcombo5Hpmsf2 = (ri*coupHpm2charneutL*-sf2alpha1Zid*coupHpm2ffpu*-alphasf2char + coupHpm2charneutR*-sf2beta1Zid*coupHpm2ffpd*-betasf2char)*mfp*fabs(mcharginoj)*-ri;
      coupcombo6Hpmsf2 = (coupHpm2charneutL*-sf2beta1Zid*coupHpm2ffpd*-alphasf2char + coupHpm2charneutR*-sf2alpha1Zid*coupHpm2ffpu*-betasf2char)*fabs(mneutralinoi)*fabs(mcharginoj)*rj;
      coupcombo7Hpmsf2 = -(coupHpm2charneutR*-sf2beta1Zid*coupHpm2ffpu*-alphasf2char + coupHpm2charneutL*-sf2alpha1Zid*coupHpm2ffpd*-betasf2char)*mfp*mf*ri;
      coupcombo8Hpmsf2 = -2*(ri*coupHpm2charneutL*-sf2beta1Zid*coupHpm2ffpu*-alphasf2char + coupHpm2charneutR*-sf2alpha1Zid*coupHpm2ffpd*-betasf2char)*fabs(mneutralinoi)*mfp*mf*fabs(mcharginoj)*ri*rj;
    }
    else if (norc == 'c') {
      coupcombo1Hpmsf2 = -0.5*(coupHpm2charneutL*betasf2char*coupHpm2ffpu*sf2alpha1Zid + rj*coupHpm2charneutR*alphasf2char*coupHpm2ffpd*sf2beta1Zid);
      coupcombo2Hpmsf2 = (coupHpm2charneutL*alphasf2char*coupHpm2ffpd*sf2alpha1Zid - rj*coupHpm2charneutR*betasf2char*coupHpm2ffpu*sf2beta1Zid)*fabs(mneutralinoi)*mf;
      coupcombo3Hpmsf2 = (-rj*coupHpm2charneutR*alphasf2char*coupHpm2ffpu*sf2alpha1Zid + coupHpm2charneutL*betasf2char*coupHpm2ffpd*sf2beta1Zid)*mfp*fabs(mcharginoj);
      coupcombo4Hpmsf2 = -(coupHpm2charneutL*alphasf2char*coupHpm2ffpu*sf2alpha1Zid - rj*coupHpm2charneutR*betasf2char*coupHpm2ffpd*sf2beta1Zid)*fabs(mneutralinoi)*mfp;
      coupcombo5Hpmsf2 = (rj*coupHpm2charneutR*alphasf2char*coupHpm2ffpd*sf2alpha1Zid + coupHpm2charneutL*betasf2char*coupHpm2ffpu*sf2beta1Zid)*mf*fabs(mcharginoj);
      coupcombo6Hpmsf2 = -(coupHpm2charneutR*betasf2char*coupHpm2ffpu*sf2alpha1Zid + coupHpm2charneutL*alphasf2char*coupHpm2ffpd*sf2beta1Zid)*fabs(mcharginoj)*fabs(mneutralinoi);
      coupcombo7Hpmsf2 = rj*(coupHpm2charneutL*betasf2char*coupHpm2ffpd*sf2alpha1Zid + coupHpm2charneutR*alphasf2char*coupHpm2ffpu*sf2beta1Zid)*mf*mfp;
      coupcombo8Hpmsf2 = 2*(-rj*coupHpm2charneutR*betasf2char*coupHpm2ffpd*sf2alpha1Zid + coupHpm2charneutL*alphasf2char*coupHpm2ffpu*sf2beta1Zid)*mf*mfp*fabs(mcharginoj)*fabs(mneutralinoi);
    }


    cout << "Couplings Hpm sf2: " << endl;
    cout << coupcombo1Hpmsf2 << endl;
    cout << coupcombo2Hpmsf2 << endl;
    cout << coupcombo3Hpmsf2 << endl;
    cout << coupcombo4Hpmsf2 << endl;
    cout << coupcombo5Hpmsf2 << endl;
    cout << coupcombo6Hpmsf2 << endl;
    cout << coupcombo7Hpmsf2 << endl;
    cout << coupcombo8Hpmsf2 << endl;

    double int1Hpmsf2 = 0, int2Hpmsf2 = 0, int3Hpmsf2 = 0, int4Hpmsf2 = 0, int5Hpmsf2 = 0, int6Hpmsf2 = 0, int7Hpmsf2 = 0, int8Hpmsf2 = 0;
    m1 = mneutralinoi, m2 = mf, m3 = mfp, m4 = mcharginoj, m5 = mHP, m6 = msf2;
    if(norc == 'n') {
      int1Hpmsf2 = 2*fabs(m1)*dgauss(gneuticharjffp1gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int2Hpmsf2 = 2*fabs(m1)*dgauss(gneuticharjffp2gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int3Hpmsf2 = 2*fabs(m1)*dgauss(gneuticharjffp3gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int4Hpmsf2 = 2*fabs(m1)*dgauss(gneuticharjffp4gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int5Hpmsf2 = 2*fabs(m1)*dgauss(gneuticharjffp5gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int6Hpmsf2 = 2*fabs(m1)*dgauss(gneuticharjffp6gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int7Hpmsf2 = 2*fabs(m1)*dgauss(gneuticharjffp7gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int8Hpmsf2 = 2*fabs(m1)*dgauss(gneuticharjffp8gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    }
    else if( norc == 'c') {
      int1Hpmsf2 = 2*fabs(m1)*dgauss(gneuticharjffp1gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int4Hpmsf2 = 2*fabs(m1)*dgauss(gneuticharjffp2gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int5Hpmsf2 = 2*fabs(m1)*dgauss(gneuticharjffp3gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int2Hpmsf2 = 2*fabs(m1)*dgauss(gneuticharjffp4gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int3Hpmsf2 = 2*fabs(m1)*dgauss(gneuticharjffp5gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int6Hpmsf2 = 2*fabs(m1)*dgauss(gneuticharjffp6gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int7Hpmsf2 = 2*fabs(m1)*dgauss(gneuticharjffp7gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
      int8Hpmsf2 = 2*fabs(m1)*dgauss(gneuticharjffp8gsfpdgauss,fabs(mcharginoj),Eupper3,accuracy);
    }  
  
    cout << "Integrals Hpm sf2: " << endl;
    cout << int1Hpmsf2 << endl;
    cout << int2Hpmsf2 << endl;
    cout << int3Hpmsf2 << endl;
    cout << int4Hpmsf2 << endl;
    cout << int5Hpmsf2 << endl;
    cout << int6Hpmsf2 << endl;
    cout << int7Hpmsf2 << endl;
    cout << int8Hpmsf2 << endl;

    cout << "term by term Hpm sf2: " << endl;
    cout.precision(25);
    cout << coupcombo1Hpmsf2*int1Hpmsf2 << endl;
    cout << coupcombo2Hpmsf2*int2Hpmsf2 << endl;
    cout << coupcombo3Hpmsf2*int3Hpmsf2 << endl;
    cout << coupcombo4Hpmsf2*int4Hpmsf2 << endl;
    cout << coupcombo5Hpmsf2*int5Hpmsf2 << endl;
    cout << coupcombo6Hpmsf2*int6Hpmsf2 << endl;
    cout << coupcombo7Hpmsf2*int7Hpmsf2 << endl;
    cout << coupcombo8Hpmsf2*int8Hpmsf2 << endl;

    GammaHpmsf2 = coupcombo1Hpmsf2*int1Hpmsf2 + coupcombo2Hpmsf2*int2Hpmsf2 + coupcombo3Hpmsf2*int3Hpmsf2 + coupcombo4Hpmsf2*int4Hpmsf2 + coupcombo5Hpmsf2*int5Hpmsf2 + coupcombo6Hpmsf2*int6Hpmsf2 + coupcombo7Hpmsf2*int7Hpmsf2 + coupcombo8Hpmsf2*int8Hpmsf2;
    cout << scientific << "GammaHpmsf2 = " << GammaHpmsf2 << endl;

    ///Sfp Sfp interference
    double coupcombo1sfpsfp = 0, coupcombo2sfpsfp = 0, coupcombo3sfpsfp = 0, coupcombo4sfpsfp = 0;
    if (norc == 'n') {
      coupcombo1sfpsfp = sf1beta1Ziu*sf2beta1Ziu + sf1alpha1Ziu*sf2alpha1Ziu;
      coupcombo2sfpsfp = (sf1alpha1Ziu*sf2beta1Ziu + sf1beta1Ziu*sf2alpha1Ziu)*ri;
      coupcombo3sfpsfp = -alphasfp1char*alphasfp2char + betasfp1char*betasfp2char;
      coupcombo4sfpsfp = (betasfp1char*alphasfp2char - alphasfp1char*betasfp2char)*rj;
    }
    else if (norc == 'c') {
      coupcombo1sfpsfp = -betasfp1char*betasfp2char + alphasfp1char*alphasfp2char;
      coupcombo2sfpsfp = alphasfp1char*betasfp2char - alphasfp2char*betasfp1char;
      coupcombo3sfpsfp = (-sf1alpha1Ziu*sf2alpha1Ziu + sf1beta1Ziu*sf2beta1Ziu)*rj;
      coupcombo4sfpsfp = (-sf1alpha1Ziu*sf2beta1Ziu + sf2alpha1Ziu*sf1beta1Ziu)*rj;
    }

    cout << "Coupling combos for Sfp Sfp interference: " << endl;
    cout << coupcombo1sfpsfp << endl;
    cout << coupcombo2sfpsfp << endl;
    cout << coupcombo3sfpsfp << endl;
    cout << coupcombo4sfpsfp << endl;

    double int1sfpsfp = 0, int2sfpsfp = 0, int3sfpsfp = 0, int4sfpsfp = 0;
    cout << "Eupper = " << Eupper << endl;
    m1 = mneutralinoi, m2 = mfp, m3 = mf, m4 = mcharginoj, m5 = msfp1, m6 = msfp2;
    if (norc == 'n') {
      int1sfpsfp = 2*fabs(m1)*dgauss(gneuticharjffp1sfpsfpdgauss,mfp,Eupper,accuracy);
      int2sfpsfp = 2*fabs(m1)*dgauss(gneuticharjffp2sfpsfpdgauss,mfp,Eupper,accuracy);
      int3sfpsfp = 2*fabs(m1)*dgauss(gneuticharjffp3sfpsfpdgauss,mfp,Eupper,accuracy);
      int4sfpsfp = 2*fabs(m1)*dgauss(gneuticharjffp4sfpsfpdgauss,mfp,Eupper,accuracy);
    }
    else if (norc == 'c') {
      int1sfpsfp = 2*fabs(m1)*dgauss(gneuticharjffp1sfpsfpdgauss,mfp,Eupper,accuracy);
      int3sfpsfp = 2*fabs(m1)*dgauss(gneuticharjffp2sfpsfpdgauss,mfp,Eupper,accuracy);
      int2sfpsfp = 2*fabs(m1)*dgauss(gneuticharjffp3sfpsfpdgauss,mfp,Eupper,accuracy);
      int4sfpsfp = 2*fabs(m1)*dgauss(gneuticharjffp4sfpsfpdgauss,mfp,Eupper,accuracy);
    } 

    cout << "Integrals for sfp sfp interference: " << endl;
    cout << int1sfpsfp << endl;
    cout << int2sfpsfp << endl;
    cout << int3sfpsfp << endl;
    cout << int4sfpsfp << endl;

    cout << "term by term for sfp sfp interference: " << endl;
    cout << 4*coupcombo2sfpsfp*coupcombo4sfpsfp*-fabs(mneutralinoi)*mfp*mf*fabs(mcharginoj)*int1sfpsfp << endl;
    if (norc == 'n') {
      cout << 2*coupcombo2sfpsfp*coupcombo3sfpsfp*fabs(mneutralinoi)*mfp*int2sfpsfp << endl;
      cout << 2*coupcombo1sfpsfp*coupcombo4sfpsfp*-mf*fabs(mcharginoj)*int3sfpsfp << endl;
    }
    else if (norc == 'c') {
      cout << 2*coupcombo2sfpsfp*coupcombo3sfpsfp*fabs(mneutralinoi)*mf*int2sfpsfp << endl;
      cout << 2*coupcombo1sfpsfp*coupcombo4sfpsfp*-mfp*fabs(mcharginoj)*int3sfpsfp << endl;
    }
    cout << coupcombo1sfpsfp*coupcombo3sfpsfp*int4sfpsfp << endl;

    if (norc == 'n') {
      Gammasfpsfp = 4*coupcombo2sfpsfp*coupcombo4sfpsfp*-fabs(mneutralinoi)*mfp*mf*fabs(mcharginoj)*int1sfpsfp + 2*coupcombo2sfpsfp*coupcombo3sfpsfp*fabs(mneutralinoi)*mfp*int2sfpsfp + 2*coupcombo1sfpsfp*coupcombo4sfpsfp*-mf*fabs(mcharginoj)*int3sfpsfp + coupcombo1sfpsfp*coupcombo3sfpsfp*int4sfpsfp;
    }
    else if (norc == 'c') {
      Gammasfpsfp = 4*coupcombo2sfpsfp*coupcombo4sfpsfp*-fabs(mneutralinoi)*mfp*mf*fabs(mcharginoj)*int1sfpsfp + 2*coupcombo2sfpsfp*coupcombo3sfpsfp*fabs(mneutralinoi)*mf*int2sfpsfp + 2*coupcombo1sfpsfp*coupcombo4sfpsfp*-mfp*fabs(mcharginoj)*int3sfpsfp + coupcombo1sfpsfp*coupcombo3sfpsfp*int4sfpsfp;
    } 
    cout << "Gammasfpsfp = " << Gammasfpsfp << endl;

    cout << endl;
    cout << "GammaW = " << GammaW << endl;
    cout << "Gammasf1 = " << Gammasf1 << endl;
    cout << "Gammasf2 = " << Gammasf2 << endl;
    cout << "Gammasfp1 = " << Gammasfp1 << endl;
    cout << "Gammasfp2 = " << Gammasfp2 << endl;
    cout << "Gammasfp1sf1 = " << -2*Gammasfp1sf1 << endl;
    cout << "Gammasfp1sf2 = " << -2*Gammasfp1sf2 << endl;
    cout << "Gammasfp2sf1 = " << -2*Gammasfp2sf1 << endl;
    cout << "Gammasfp2sf2 =  "<< -2*Gammasfp2sf2 << endl;
    cout << "GammaWHpm = " << -4*GammaWHpm << endl;
    cout << "GammaWgoldstone = " << -4*GammaWgoldstone << endl;
    cout << "GammaHpm = " << GammaHpm << endl;
    cout << "Gammagoldstone = " << Gammagoldstone << endl;
    cout << "GammaWSfp1 = " << -2*GammaWSfp1 << endl;
    cout << "GammaWSfp2 = " << -2*GammaWSfp2 << endl;
    cout << "GammaWSf1 = " << -2*GammaWSf1 << endl;
    cout << "GammaWSf2 = " << -2*GammaWSf2 << endl;
    cout << "GammaHgoldstone = " << 2*GammaHgoldstone << endl;
    cout << "Gammagsfp1 = "<< -2*Gammagsfp1 << endl;
    cout << "Gammagsfp2 = "<< -2*Gammagsfp2 << endl;
    cout << "Gammagsf1 = " << -2*Gammagsf1 << endl;
    cout << "Gammagsf2 = " << -2*Gammagsf2 << endl;
    cout << "GammaHpmsfp1 = " << -2*GammaHpmsfp1 << endl;
    cout << "GammaHpmsfp2 = " << -2*GammaHpmsfp2 << endl;
    cout << "GammaHpmsf1 = " << -2*GammaHpmsf1 << endl;
    cout << "GammaHpmsf2 = " << -2*GammaHpmsf2 << endl;
    cout << "Gammasfpsfp = " << 2*Gammasfpsfp << endl;

    cout << "Total = " << GammaW + Gammasf1 + Gammasf2 + Gammasfp1 + Gammasfp2 -2*Gammasfp1sf1 - 2*Gammasfp1sf2 - 2*Gammasfp2sf1 - 2*Gammasfp2sf2 - 4*GammaWHpm - 4*GammaWgoldstone + GammaHpm + Gammagoldstone + -2*GammaWSfp1 - 2*GammaWSfp2 - 2*GammaWSf1 - 2*GammaWSf2 + 2*GammaHgoldstone - 2*Gammagsfp1 - 2*Gammagsfp2 - 2*Gammagsf1 - 2*Gammagsf2 - 2*GammaHpmsfp1 - 2*GammaHpmsfp2 - 2*GammaHpmsf1 - 2*GammaHpmsf2 + 2*Gammasfpsfp << endl;

    cout << "Prefactor = " << Nc/(512*pow(PI,3)*pow(fabs(mneutralinoi),3)) << endl;

    amplitudeW = Nc/(512*pow(PI,3)*pow(fabs(mneutralinoi),3))*(GammaW + Gammasf1 + Gammasf2 + Gammasfp1 + Gammasfp2 -2*Gammasfp1sf1 - 2*Gammasfp1sf2 - 2*Gammasfp2sf1 - 2*Gammasfp2sf2 + 2*GammaWHpm + 2*GammaWgoldstone+ GammaHpm + Gammagoldstone + -2*GammaWSfp1 - 2*GammaWSfp2 - 2*GammaWSf1 - 2*GammaWSf2 + 2*GammaHgoldstone - 2*Gammagsfp1 - 2*Gammagsfp2 - 2*Gammagsf1 - 2*Gammagsf2 - 2*GammaHpmsfp1 - 2*GammaHpmsfp2 - 2*GammaHpmsf1 - 2*GammaHpmsf2 + 2*Gammasfpsfp);

    

  }

  return amplitudeW;
}
    
